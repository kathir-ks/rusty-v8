{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/source-positions.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 150, column 43",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/source-positions.cc\",\n        \"file_name\": \"source-positions.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Manages source file paths and IDs for the Torque language within V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and Torque-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/source-positions.h\"\n\n#include <fstream>\n#include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SourceId\",\n                \"about\": \"Represents a source file ID.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SourceId {\n                public:\n                    bool IsValid() const;\n                    int id_;\n                    SourceId(int id) : id_(id) {}\n                    static SourceId Invalid();\n                };\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"EXPORT_CONTEXTUAL_VARIABLE\",\n                \"about\": \"Defines a contextual variable (likely for Torque's compilation environment)\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define EXPORT_CONTEXTUAL_VARIABLE(var) // Placeholder\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StringStartsWith\",\n                \"about\": \"Checks if a string starts with a given prefix\"\n            }\n            </metadata>\n            <code><![CDATA[\n                bool StringStartsWith(const std::string& str, const std::string& prefix);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StringEndsWith\",\n                \"about\": \"Checks if a string ends with a given suffix\"\n            }\n            </metadata>\n            <code><![CDATA[\n                bool StringEndsWith(const std::string& str, const std::string& suffix);\n            ]]></code>\n        </func>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Error\",\n                \"about\": \"Represents an error in Torque\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Error {\n                public:\n                    Error& Throw();\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SourceFileMap\",\n            \"about\": \"Manages the mapping between SourceIds and file paths within the V8 root.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace torque {\nclass SourceFileMap {\n public:\n  static const std::string& PathFromV8Root(SourceId file);\n  static std::string AbsolutePath(SourceId file);\n  static std::string PathFromV8RootWithoutExtension(SourceId file);\n  static SourceId AddSource(std::string path);\n  static SourceId GetSourceId(const std::string& path);\n  static std::vector<SourceId> AllSources();\n  static bool FileRelativeToV8RootExists(const std::string& path);\n\n private:\n  static SourceFileMap& Get();\n  std::vector<std::string> sources_;\n  std::string v8_root_;\n};\n}\n}\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PathFromV8Root\",\n            \"parent\": \"SourceFileMap\",\n            \"about\": \"Returns the path relative to the V8 root for a given SourceId.\",\n            \"logic\": \"Retrieves the path from the internal `sources_` vector using the SourceId's `id_` as an index. Checks for validity of file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file\",\n                    \"type\": \"SourceId\",\n                    \"purpose\": \"The SourceId to look up.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const std::string&\",\n                \"description\": \"The file path relative to the V8 root.\"\n            },\n            \"dependencies\": [\n                \"SourceId\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nconst std::string& SourceFileMap::PathFromV8Root(SourceId file) {\n  CHECK(file.IsValid());\n  return Get().sources_[file.id_];\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AbsolutePath\",\n            \"parent\": \"SourceFileMap\",\n            \"about\": \"Returns the absolute path for a given SourceId.\",\n            \"logic\": \"If the path from V8 root starts with 'file://', it's considered absolute and returned directly. Otherwise, it prepends the V8 root path.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file\",\n                    \"type\": \"SourceId\",\n                    \"purpose\": \"The SourceId to look up.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The absolute file path.\"\n            },\n            \"dependencies\": [\n                \"SourceId\",\n                \"StringStartsWith\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string SourceFileMap::AbsolutePath(SourceId file) {\n  const std::string& root_path = PathFromV8Root(file);\n  if (StringStartsWith(root_path, \"file://\")) return root_path;\n  return Get().v8_root_ + \"/\" + PathFromV8Root(file);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PathFromV8RootWithoutExtension\",\n            \"parent\": \"SourceFileMap\",\n            \"about\": \"Returns the path relative to the V8 root for a given SourceId, without the '.tq' extension.\",\n            \"logic\": \"Retrieves the path, checks if it ends with '.tq', removes the extension, and returns the modified path. Throws an error if the path does not end with '.tq'.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file\",\n                    \"type\": \"SourceId\",\n                    \"purpose\": \"The SourceId to look up.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The file path relative to the V8 root, without the '.tq' extension.\"\n            },\n            \"dependencies\": [\n                \"SourceId\",\n                \"StringEndsWith\",\n                \"Error\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string SourceFileMap::PathFromV8RootWithoutExtension(SourceId file) {\n  std::string path_from_root = PathFromV8Root(file);\n  if (!StringEndsWith(path_from_root, \".tq\")) {\n    Error(\"Not a .tq file: \", path_from_root).Throw();\n  }\n  path_from_root.resize(path_from_root.size() - strlen(\".tq\"));\n  return path_from_root;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddSource\",\n            \"parent\": \"SourceFileMap\",\n            \"about\": \"Adds a new source path to the map and returns its SourceId.\",\n            \"logic\": \"Adds the path to the internal `sources_` vector and creates a new SourceId with the index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"path\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The path to add.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"SourceId\",\n                \"description\": \"The SourceId of the newly added path.\"\n            },\n            \"dependencies\": [\n                \"SourceId\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nSourceId SourceFileMap::AddSource(std::string path) {\n  Get().sources_.push_back(std::move(path));\n  return SourceId(static_cast<int>(Get().sources_.size()) - 1);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetSourceId\",\n            \"parent\": \"SourceFileMap\",\n            \"about\": \"Retrieves the SourceId for a given path.\",\n            \"logic\": \"Iterates through the `sources_` vector and compares each path with the given path. Returns the SourceId if found, otherwise returns an invalid SourceId.\",\n            \"parameters\": [\n                {\n                    \"name\": \"path\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The path to look up.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"SourceId\",\n                \"description\": \"The SourceId for the path, or an invalid SourceId if not found.\"\n            },\n            \"dependencies\": [\n                \"SourceId\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nSourceId SourceFileMap::GetSourceId(const std::string& path) {\n  for (size_t i = 0; i < Get().sources_.size(); ++i) {\n    if (Get().sources_[i] == path) {\n      return SourceId(static_cast<int>(i));\n    }\n  }\n  return SourceId::Invalid();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllSources\",\n            \"parent\": \"SourceFileMap\",\n            \"about\": \"Returns a vector containing all SourceIds.\",\n            \"logic\": \"Creates a vector and populates it with SourceIds corresponding to each path in the `sources_` vector.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::vector<SourceId>\",\n                \"description\": \"A vector of all SourceIds.\"\n            },\n            \"dependencies\": [\n                \"SourceId\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::vector<SourceId> SourceFileMap::AllSources() {\n  SourceFileMap& self = Get();\n  std::vector<SourceId> result;\n  result.reserve(static_cast<int>(self.sources_.size()));\n  for (int i = 0; i < static_cast<int>(self.sources_.size()); ++i) {\n    result.push_back(SourceId(i));\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FileRelativeToV8RootExists\",\n            \"parent\": \"SourceFileMap\",\n            \"about\": \"Checks if a file exists relative to the V8 root.\",\n            \"logic\": \"Combines the V8 root path with the given path, attempts to open the file, and returns whether the open operation was successful.\",\n            \"parameters\": [\n                {\n                    \"name\": \"path\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The path to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the file exists, false otherwise.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\nbool SourceFileMap::FileRelativeToV8RootExists(const std::string& path) {\n  const std::string file = Get().v8_root_ + \"/\" + path;\n  std::ifstream stream(file);\n  return stream.good();\n}\n        ]]></code>\n    </func>\n</file>\n```"
}