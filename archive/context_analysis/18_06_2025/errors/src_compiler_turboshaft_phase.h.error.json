{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/phase.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/phase.h\",\n            \"file_name\": \"phase.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the Turboshaft compiler phase infrastructure, including PipelineData and related concepts.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for compiler functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n#include <type_traits>\n\n#include \"src/base/contextual.h\"\n#include \"src/base/template-meta-programming/functional.h\"\n#include \"src/codegen/assembler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/access-info.h\"\n#include \"src/compiler/backend/instruction.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/node-origin-table.h\"\n#include \"src/compiler/osr.h\"\n#include \"src/compiler/phase.h\"\n#include \"src/compiler/turboshaft/builtin-compiler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/sidetable.h\"\n#include \"src/compiler/turboshaft/zone-with-name.h\"\n#include \"src/logging/runtime-call-stats.h\"\n#include \"src/zone/accounting-allocator.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"DECL_TURBOSHAFT_PHASE_CONSTANTS_IMPL\",\n                \"about\": \"Defines constants for a Turboshaft phase, including the phase name and assertions.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Name\",\n                        \"type\": \"string\",\n                        \"purpose\": \"The name of the phase.\"\n                    },\n                    {\n                        \"name\": \"CallStatsName\",\n                        \"type\": \"string\",\n                        \"purpose\": \"The name used for runtime call statistics.\"\n                    }\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define DECL_TURBOSHAFT_PHASE_CONSTANTS_IMPL(Name, CallStatsName)             \\\n  DECL_PIPELINE_PHASE_CONSTANTS_HELPER(CallStatsName, PhaseKind::kTurboshaft, \\\n                                       RuntimeCallStats::kThreadSpecific)     \\\n  static constexpr char kPhaseName[] = \"V8.TF\" #CallStatsName;                \\\n  static void AssertTurboshaftPhase() {                                       \\\n    static_assert(TurboshaftPhase<Name##Phase>);                              \\\n  }\n        ]]></code>\n    </macro>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"DECL_TURBOSHAFT_PHASE_CONSTANTS\",\n                \"about\": \"Defines constants for a Turboshaft phase, using Turboshaft##Name for call statistics.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Name\",\n                        \"type\": \"string\",\n                        \"purpose\": \"The name of the phase.\"\n                    }\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define DECL_TURBOSHAFT_PHASE_CONSTANTS(Name) \\\n  DECL_TURBOSHAFT_PHASE_CONSTANTS_IMPL(Name, Turboshaft##Name)\n        ]]></code>\n    </macro>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"DECL_TURBOSHAFT_PHASE_CONSTANTS_WITH_LEGACY_NAME\",\n                \"about\": \"Defines constants for a Turboshaft phase, using the given name for call statistics.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Name\",\n                        \"type\": \"string\",\n                        \"purpose\": \"The name of the phase.\"\n                    }\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define DECL_TURBOSHAFT_PHASE_CONSTANTS_WITH_LEGACY_NAME(Name) \\\n  DECL_TURBOSHAFT_PHASE_CONSTANTS_IMPL(Name, Name)\n        ]]></code>\n    </macro>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"DECL_TURBOSHAFT_MAIN_THREAD_PIPELINE_PHASE_CONSTANTS_WITH_LEGACY_NAME\",\n                \"about\": \"Defines constants for a Turboshaft main-thread pipeline phase, using the given name for call statistics.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Name\",\n                        \"type\": \"string\",\n                        \"purpose\": \"The name of the phase.\"\n                    }\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define DECL_TURBOSHAFT_MAIN_THREAD_PIPELINE_PHASE_CONSTANTS_WITH_LEGACY_NAME( \\\n    Name)                                                                      \\\n  DECL_PIPELINE_PHASE_CONSTANTS_HELPER(Name, PhaseKind::kTurboshaft,           \\\n                                       RuntimeCallStats::kExact)               \\\n  static constexpr char kPhaseName[] = \"V8.TF\" #Name;                          \\\n  static void AssertTurboshaftPhase() {                                        \\\n    static_assert(TurboshaftPhase<Name##Phase>);                               \\\n  }\n        ]]></code>\n    </macro>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PipelineData\",\n                \"about\": \"Central data structure for the Turboshaft pipeline, holding compilation state and components.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"detail::BuiltinComponent\",\n                    \"detail::GraphComponent\",\n                    \"detail::CodegenComponent\",\n                    \"detail::InstructionComponent\",\n                    \"detail::RegisterComponent\",\n                    \"ZoneStats\",\n                    \"TurboshaftPipelineKind\",\n                    \"Isolate\",\n                    \"OptimizedCompilationInfo\",\n                    \"AssemblerOptions\",\n                    \"JSHeapBroker\",\n                    \"CompilationDependencies\",\n                    \"CallDescriptor\",\n                    \"BytecodeHandlerData\",\n                    \"SourcePositionTable\",\n                    \"Graph\",\n                    \"NodeOriginTable\",\n                    \"OsrHelper\",\n                    \"JumpOptimizationInfo\",\n                    \"Linkage\",\n                    \"CodeGenerator\",\n                    \"InstructionSequence\",\n                    \"InstructionBlocks\",\n                    \"RegisterConfiguration\",\n                    \"RegisterAllocationData\",\n                    \"CodeTracer\",\n                    \"RuntimeCallStats\",\n                    \"TurbofanPipelineStatistics\",\n                    \"AccountingAllocator\",\n                    \"Frame\",\n                    \"wasm::FunctionSig\",\n                    \"wasm::CanonicalSig\",\n                    \"wasm::WasmModule\",\n                    \"WasmRevecAnalyzer\",\n                    \"WasmShuffleAnalyzer\",\n                    \"ZoneWithName\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE PipelineData {\n  using BuiltinComponent = detail::BuiltinComponent;\n  using GraphComponent = detail::GraphComponent;\n  using CodegenComponent = detail::CodegenComponent;\n  using InstructionComponent = detail::InstructionComponent;\n  using RegisterComponent = detail::RegisterComponent;\n\n public:\n  explicit PipelineData(ZoneStats* zone_stats,\n                        TurboshaftPipelineKind pipeline_kind, Isolate* isolate,\n                        OptimizedCompilationInfo* info,\n                        const AssemblerOptions& assembler_options,\n                        int start_source_position = kNoSourcePosition);\n\n  void InitializeBrokerAndDependencies(std::shared_ptr<JSHeapBroker> broker,\n                                       CompilationDependencies* dependencies);\n\n  void InitializeBuiltinComponent(\n      const CallDescriptor* call_descriptor,\n      std::optional<BytecodeHandlerData> bytecode_handler_data = {});\n\n  void InitializeGraphComponent(SourcePositionTable* source_positions);\n\n  void InitializeGraphComponentWithGraphZone(\n      ZoneWithName<kGraphZoneName> graph_zone,\n      ZoneWithNamePointer<SourcePositionTable, kGraphZoneName> source_positions,\n      ZoneWithNamePointer<NodeOriginTable, kGraphZoneName> node_origins);\n\n  void ClearGraphComponent();\n\n  void InitializeCodegenComponent(\n      std::shared_ptr<OsrHelper> osr_helper,\n      JumpOptimizationInfo* jump_optimization_info = nullptr);\n\n  void ClearCodegenComponent();\n\n  void InitializeCodeGenerator(Linkage* linkage);\n\n  void InitializeInstructionComponent(const CallDescriptor* call_descriptor);\n\n  void InitializeInstructionComponentWithSequence(\n      InstructionSequence* sequence);\n\n  void ClearInstructionComponent();\n\n  void InitializeRegisterComponent(const RegisterConfiguration* config,\n                                   CallDescriptor* call_descriptor);\n\n  void ClearRegisterComponent();\n\n  AccountingAllocator* allocator() const;\n  ZoneStats* zone_stats() const;\n  TurboshaftPipelineKind pipeline_kind() const;\n  Isolate* isolate() const;\n  OptimizedCompilationInfo* info() const;\n  const char* debug_name() const;\n  JSHeapBroker* broker() const;\n  CompilationDependencies* depedencies() const;\n  const AssemblerOptions& assembler_options() const;\n  JumpOptimizationInfo* jump_optimization_info();\n  const CallDescriptor* builtin_call_descriptor() const;\n  std::optional<BytecodeHandlerData>& bytecode_handler_data();\n\n  bool has_graph() const;\n  ZoneWithName<kGraphZoneName>& graph_zone();\n  turboshaft::Graph& graph() const;\n  GraphComponent::Pointer<SourcePositionTable> source_positions() const;\n  GraphComponent::Pointer<NodeOriginTable> node_origins() const;\n  RegisterAllocationData* register_allocation_data() const;\n  ZoneWithName<kRegisterAllocationZoneName>& register_allocation_zone();\n  CodeGenerator* code_generator() const;\n  void set_code(MaybeIndirectHandle<Code> code);\n  MaybeIndirectHandle<Code> code() const;\n  InstructionSequence* sequence() const;\n  Frame* frame() const;\n  CodeTracer* GetCodeTracer() const;\n  size_t& max_unoptimized_frame_height();\n  size_t& max_pushed_argument_count();\n  RuntimeCallStats* runtime_call_stats() const;\n  void set_runtime_call_stats(RuntimeCallStats* stats);\n\n  // The {compilation_zone} outlives the entire compilation pipeline. It is\n  // shared between all phases (including code gen where the graph zone is gone\n  // already).\n  ZoneWithName<kCompilationZoneName>& compilation_zone();\n\n  TurbofanPipelineStatistics* pipeline_statistics() const;\n  void set_pipeline_statistics(\n      TurbofanPipelineStatistics* pipeline_statistics);\n\n#if V8_ENABLE_WEBASSEMBLY\n  // Module-specific signature: type indices are only valid in the WasmModule*\n  // they belong to.\n  const wasm::FunctionSig* wasm_module_sig() const;\n\n  // Canonicalized (module-independent) signature.\n  const wasm::CanonicalSig* wasm_canonical_sig() const;\n\n  const wasm::WasmModule* wasm_module() const;\n\n  bool wasm_shared() const;\n\n  void SetIsWasmFunction(const wasm::WasmModule* module,\n                         const wasm::FunctionSig* sig, bool shared);\n\n  void SetIsWasmWrapper(const wasm::CanonicalSig* sig);\n\n#ifdef V8_ENABLE_WASM_SIMD256_REVEC\n  WasmRevecAnalyzer* wasm_revec_analyzer() const;\n\n  void set_wasm_revec_analyzer(WasmRevecAnalyzer* wasm_revec_analyzer);\n\n  void clear_wasm_revec_analyzer() { wasm_revec_analyzer_ = nullptr; }\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n\n  WasmShuffleAnalyzer* wasm_shuffle_analyzer() const;\n\n  void set_wasm_shuffle_analyzer(WasmShuffleAnalyzer* wasm_shuffle_analyzer);\n\n  void clear_wasm_shuffle_analyzer() { wasm_shuffle_analyzer_ = nullptr; }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  bool is_wasm() const;\n  bool is_js_to_wasm() const;\n\n  void InitializeFrameData(CallDescriptor* call_descriptor);\n\n  void set_source_position_output(std::string source_position_output);\n  std::string source_position_output() const { return source_position_output_; }\n\n  bool graph_has_special_rpo() const;\n  void set_graph_has_special_rpo() {\n    graph_component_->graph_has_special_rpo = true;\n  }\n  bool graph_has_lowered_fast_api_calls() const {\n    return graph_component_->graph_has_lowered_fast_api_calls;\n  }\n  void set_graph_has_lowered_fast_api_calls() {\n    graph_component_->graph_has_lowered_fast_api_calls = true;\n  }\n\n private:\n  ZoneStats* zone_stats_;\n  // The {compilation_zone_} outlives the entire compilation pipeline. It is\n  // shared between all phases (including code gen where the graph zone is gone\n  // already).\n  ZoneWithName<kCompilationZoneName> compilation_zone_;\n  TurboshaftPipelineKind pipeline_kind_;\n  Isolate* const isolate_ = nullptr;\n  OptimizedCompilationInfo* info_ = nullptr;\n  std::unique_ptr<char[]> debug_name_;\n  // TODO(nicohartmann): Use unique_ptr once TurboFan's pipeline data is gone.\n  std::shared_ptr<JSHeapBroker> broker_;\n  TurbofanPipelineStatistics* pipeline_statistics_ = nullptr;\n  CompilationDependencies* dependencies_ = nullptr;\n  int start_source_position_ = kNoSourcePosition;\n  const AssemblerOptions assembler_options_;\n  MaybeIndirectHandle<Code> code_;\n  std::string source_position_output_;\n  RuntimeCallStats* runtime_call_stats_ = nullptr;\n  // Components\n  std::optional<BuiltinComponent> builtin_component_;\n  std::optional<GraphComponent> graph_component_;\n  std::optional<CodegenComponent> codegen_component_;\n  std::optional<InstructionComponent> instruction_component_;\n  std::optional<RegisterComponent> register_component_;\n\n#if V8_ENABLE_WEBASSEMBLY\n  // TODO(14108): Consider splitting wasm members into its own WasmPipelineData\n  // if we need many of them.\n  const wasm::FunctionSig* wasm_module_sig_ = nullptr;\n  const wasm::CanonicalSig* wasm_canonical_sig_ = nullptr;\n  const wasm::WasmModule* wasm_module_ = nullptr;\n  bool wasm_shared_ = false;\n  WasmShuffleAnalyzer* wasm_shuffle_analyzer_ = nullptr;\n#ifdef V8_ENABLE_WASM_SIMD256_REVEC\n\n  WasmRevecAnalyzer* wasm_revec_analyzer_ = nullptr;\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif  // V8_ENABLE_WEBASSEMBLY\n};\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"TurboshaftPipelineKind\",\n                \"about\": \"Enumerates the different kinds of Turboshaft pipelines (JS, Wasm, CSA, TSABuiltin, JSToWasm).\",\n                \"values\": [\n                    \"kJS\",\n                    \"kWasm\",\n                    \"kCSA\",\n                    \"kTSABuiltin\",\n                    \"kJSToWasm\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nenum class TurboshaftPipelineKind { kJS, kWasm, kCSA, kTSABuiltin, kJSToWasm };\n        ]]></code>\n    </enum>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"HasProperRunMethod\",\n                \"about\": \"A trait to check if a Phase has a valid Run method signature (PipelineData*, Zone*).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Phase\",\n                        \"type\": \"typename\",\n                        \"purpose\": \"The type of the phase to check.\"\n                    }\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Phase>\nstruct HasProperRunMethod {\n  using parameters = base::tmp::call_parameters_t<decltype(&Phase::Run)>;\n  static_assert(\n      base::tmp::length_v<parameters> >= 2,\n      \"Phase::Run needs at least two parameters (PipelineData* and Zone*)\");\n  using parameter0 = base::tmp::element_t<parameters, 0>;\n  using parameter1 = base::tmp::element_t<parameters, 1>;\n  static constexpr bool value = std::is_same_v<parameter0, PipelineData*> &&\n                                std::is_same_v<parameter1, Zone*>;\n};\n        ]]></code>\n    </struct>\n    <concept>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"concept\",\n                \"name\": \"TurboshaftPhase\",\n                \"about\": \"Concept that checks if a type is a valid Turboshaft phase, inheriting from HasProperRunMethod and having the correct kKind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Phase\",\n                        \"type\": \"typename\",\n                        \"purpose\": \"The type to check.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"HasProperRunMethod\",\n                    \"PhaseKind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Phase, typename... Args>\nconcept TurboshaftPhase =\n    HasProperRunMethod<Phase>::value &&\n    requires(Phase p) { p.kKind == PhaseKind::kTurboshaft; };\n        ]]></code>\n    </concept>\n    <concept>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"concept\",\n                \"name\": \"TurbofanPhase\",\n                \"about\": \"Concept that checks if a type is a valid Turbofan phase, checking for the correct kKind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Phase\",\n                        \"type\": \"typename\",\n                        \"purpose\": \"The type to check.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"PhaseKind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Phase>\nconcept TurbofanPhase = requires(Phase p) { p.kKind == PhaseKind::kTurbofan; };\n        ]]></code>\n    </concept>\n    <concept>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"concept\",\n                \"name\": \"CompilerPhase\",\n                \"about\": \"Concept that checks if a type is either a TurboshaftPhase or a TurbofanPhase.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Phase\",\n                        \"type\": \"typename\",\n                        \"purpose\": \"The type to check.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TurboshaftPhase\",\n                    \"TurbofanPhase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Phase>\nconcept CompilerPhase = TurboshaftPhase<Phase> || TurbofanPhase<Phase>;\n        ]]></code>\n    </concept>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"detail\",\n                \"about\": \"Internal utilities for the phase system, including checking if a phase produces a printable graph and zone management components.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace detail {\ntemplate <typename, typename = void>\nstruct produces_printable_graph_impl : std::true_type {};\n\ntemplate <typename P>\nstruct produces_printable_graph_impl<\n    P, std::void_t<decltype(P::kOutputIsTraceableGraph)>>\n    : std::bool_constant<P::kOutputIsTraceableGraph> {};\n\n#ifdef HAS_CPP_CLASS_TYPES_AS_TEMPLATE_ARGS\ntemplate <base::tmp::StringLiteral ZoneName>\n#else\ntemplate <auto ZoneName>\n#endif\nstruct ComponentWithZone {\n  template <typename T>\n  using Pointer = ZoneWithNamePointer<T, ZoneName>;\n\n  explicit ComponentWithZone(ZoneStats* zone_stats)\n      : zone(zone_stats,\n#ifdef HAS_CPP_CLASS_TYPES_AS_TEMPLATE_ARGS\n             ZoneName.c_str()\n#else\n             ZONE_NAME\n#endif\n        ) {\n  }\n  explicit ComponentWithZone(ZoneWithName<ZoneName> existing_zone)\n      : zone(std::move(existing_zone)) {}\n\n  ZoneWithName<ZoneName> zone;\n};\n\nstruct BuiltinComponent {\n  const CallDescriptor* call_descriptor;\n  std::optional<BytecodeHandlerData> bytecode_handler_data;\n\n  BuiltinComponent(const CallDescriptor* call_descriptor,\n                   std::optional<BytecodeHandlerData> bytecode_handler_data)\n      : call_descriptor(call_descriptor),\n        bytecode_handler_data(std::move(bytecode_handler_data)) {}\n};\n\nstruct GraphComponent : public ComponentWithZone<kGraphZoneName> {\n  using ComponentWithZone::ComponentWithZone;\n\n  Pointer<Graph> graph = nullptr;\n  Pointer<SourcePositionTable> source_positions = nullptr;\n  Pointer<NodeOriginTable> node_origins = nullptr;\n  bool graph_has_special_rpo = false;\n  bool graph_has_lowered_fast_api_calls = false;\n};\n\nstruct CodegenComponent : public ComponentWithZone<kCodegenZoneName> {\n  using ComponentWithZone::ComponentWithZone;\n\n  Pointer<Frame> frame = nullptr;\n  std::unique_ptr<CodeGenerator> code_generator;\n  Pointer<CompilationDependency> dependencies = nullptr;\n  // TODO(nicohartmann): Make {osr_helper} an optional once TurboFan's\n  // PipelineData is gone.\n  std::shared_ptr<OsrHelper> osr_helper;\n  JumpOptimizationInfo* jump_optimization_info = nullptr;\n  size_t max_unoptimized_frame_height = 0;\n  size_t max_pushed_argument_count = 0;\n};\n\nstruct InstructionComponent : public ComponentWithZone<kInstructionZoneName> {\n  using ComponentWithZone::ComponentWithZone;\n\n  Pointer<InstructionSequence> sequence = nullptr;\n};\n\nstruct RegisterComponent\n    : public ComponentWithZone<kRegisterAllocationZoneName> {\n  using ComponentWithZone::ComponentWithZone;\n\n  Pointer<RegisterAllocationData> allocation_data = nullptr;\n};\n}  // namespace detail\n        ]]></code>\n    </namespace>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"produces_printable_graph\",\n                \"about\": \"Determines whether a phase produces a printable graph based on the kOutputIsTraceableGraph member.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"P\",\n                        \"type\": \"typename\",\n                        \"purpose\": \"The type of the phase.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"detail::produces_printable_graph_impl\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename P>\nstruct produces_printable_graph\n    : public detail::produces_printable_graph_impl<P> {};\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PrintTurboshaftGraph\",\n                \"about\": \"Prints the Turboshaft graph for debugging purposes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"data\",\n                        \"type\": \"PipelineData*\",\n                        \"purpose\": \"The pipeline data containing the graph.\"\n                    },\n                    {\n                        \"name\": \"temp_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"A temporary zone for allocation during printing.\"\n                    },\n                    {\n                        \"name\": \"code_tracer\",\n                        \"type\": \"CodeTracer*\",\n                        \"purpose\": \"The code tracer for output.\"\n                    },\n                    {\n                        \"name\": \"phase_name\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The name of the phase being printed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"PipelineData\",\n                    \"CodeTracer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid PrintTurboshaftGraph(PipelineData* data, Zone* temp_zone,\n                          CodeTracer* code_tracer, const char* phase_name);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PrintTurboshaftGraphForTurbolizer\",\n                \"about\": \"Prints the Turboshaft graph in a format suitable for the Turbolizer tool.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"stream\",\n                        \"type\": \"std::ofstream&\",\n                        \"purpose\": \"The output stream for the Turbolizer data.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const Graph&\",\n                        \"purpose\": \"The Turboshaft graph to print.\"\n                    },\n                    {\n                        \"name\": \"phase_name\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The name of the phase being printed.\"\n                    },\n                    {\n                        \"name\": \"node_origins\",\n                        \"type\": \"NodeOriginTable*\",\n                        \"purpose\": \"The table of node origins.\"\n                    },\n                    {\n                        \"name\": \"temp_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"A temporary zone for allocation during printing.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Graph\",\n                    \"NodeOriginTable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid PrintTurboshaftGraphForTurbolizer(std::ofstream& stream,\n                                       const Graph& graph,\n                                       const char* phase_name,\n                                       NodeOriginTable* node_origins,\n                                       Zone* temp_zone);\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneStats\",\n                    \"about\": \"Statistics for a Zone\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ZoneStats {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Isolate\",\n                    \"about\": \"V8 Isolate\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"OptimizedCompilationInfo\",\n                    \"about\": \"Information about an optimized compilation\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class OptimizedCompilationInfo {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"AssemblerOptions\",\n                    \"about\": \"Options for the assembler\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class AssemblerOptions {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CompilationDependencies\",\n                    \"about\": \"Dependencies for a compilation\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class CompilationDependencies {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSHeapBroker\",\n                    \"about\": \"Broker for accessing the JS heap\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class JSHeapBroker {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CallDescriptor\",\n                    \"about\": \"Describes the calling convention\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class CallDescriptor {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"BytecodeHandlerData\",\n                    \"about\": \"Data for bytecode handlers\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class BytecodeHandlerData {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SourcePositionTable\",\n                    \"about\": \"Table of source positions\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class SourcePositionTable {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Graph\",\n                    \"about\": \"The compilation graph\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Graph {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NodeOriginTable\",\n                    \"about\": \"Table of node origins\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class NodeOriginTable {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"OsrHelper\",\n                    \"about\": \"Helper for on-stack replacement\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class OsrHelper {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JumpOptimizationInfo\",\n                    \"about\": \"Information for jump optimizations\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class JumpOptimizationInfo {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Linkage\",\n                    \"about\": \"Describes the linkage between code units\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Linkage {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CodeGenerator\",\n                    \"about\": \"Generates machine code\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class CodeGenerator {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"InstructionSequence\",\n                    \"about\": \"Sequence of instructions\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class InstructionSequence {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"InstructionBlocks\",\n                    \"about\": \"Blocks of instructions\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class InstructionBlocks {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RegisterConfiguration\",\n                    \"about\": \"Configuration of registers\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class RegisterConfiguration {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RegisterAllocationData\",\n                    \"about\": \"Data for register allocation\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class RegisterAllocationData {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CodeTracer\",\n                    \"about\": \"Traces code execution\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class CodeTracer {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RuntimeCallStats\",\n                    \"about\":"
}