{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/isolate-inl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 141, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/isolate-inl.h\",\n            \"file_name\": \"isolate-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Inline implementations for the Isolate class, providing access to isolate-specific data and functionality.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for Isolate class definition and related objects.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/isolate.h\"\n// Include the non-inl header before the rest of the headers.\n\n#include \"src/objects/contexts-inl.h\"\n#include \"src/objects/js-function.h\"\n#include \"src/objects/lookup-inl.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/oddball.h\"\n#include \"src/objects/property-cell.h\"\n#include \"src/objects/regexp-match-info.h\"\n#include \"src/objects/shared-function-info.h\"\n#include \"src/objects/source-text-module-inl.h\"\n\n#ifdef DEBUG\n#include \"src/common/ptr-compr-inl.h\"\n#include \"src/runtime/runtime-utils.h\"\n#endif\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CurrentPerIsolateThreadData\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns a pointer to the current thread's PerIsolateThreadData.\",\n                \"logic\": \"Uses a global variable to store the pointer.  V8_INLINE suggests it should be inlined by the compiler.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Isolate::PerIsolateThreadData*\",\n                    \"description\": \"Pointer to the current thread's PerIsolateThreadData.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nV8_INLINE Isolate::PerIsolateThreadData*\nIsolate::CurrentPerIsolateThreadData() {\n  return g_current_per_isolate_thread_data_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Current\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns the current Isolate.\",\n                \"logic\": \"Calls TryGetCurrent and asserts the result is not null.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Isolate*\",\n                    \"description\": \"Pointer to the current Isolate.\"\n                },\n                \"dependencies\": [\n                    \"TryGetCurrent\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nV8_INLINE Isolate* Isolate::Current() {\n  Isolate* isolate = TryGetCurrent();\n  DCHECK_NOT_NULL(isolate);\n  return isolate;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsCurrent\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Checks if this Isolate is the current Isolate.\",\n                \"logic\": \"Compares 'this' pointer with the result of TryGetCurrent.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if this is the current Isolate, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"TryGetCurrent\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Isolate::IsCurrent() const { return this == TryGetCurrent(); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"set_context\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Sets the current context for the isolate.\",\n                \"logic\": \"Assigns the given context to the thread-local storage.  Includes a check to ensure the context is either null or a valid Context object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"context\",\n                        \"type\": \"Tagged<Context>\",\n                        \"purpose\": \"The context to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IsContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::set_context(Tagged<Context> context) {\n  DCHECK(context.is_null() || IsContext(context));\n  thread_local_top()->context_ = context;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"native_context\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns the native context of the current context.\",\n                \"logic\": \"Retrieves the native context from the current context. Wraps the raw pointer in a Handle.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Handle<NativeContext>\",\n                    \"description\": \"Handle to the native context.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nHandle<NativeContext> Isolate::native_context() {\n  DCHECK(!context().is_null());\n  return handle(context()->native_context(), this);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"raw_native_context\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns the raw native context of the current context.\",\n                \"logic\": \"Retrieves the raw native context from the current context.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Tagged<NativeContext>\",\n                    \"description\": \"Raw pointer to the native context.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nTagged<NativeContext> Isolate::raw_native_context() {\n  DCHECK(!context().is_null());\n  return context()->native_context();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"set_topmost_script_having_context\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Sets the topmost script having context for the isolate.\",\n                \"logic\": \"Assigns the given context to the thread-local storage. Includes a check to ensure the context is either null or a valid Context object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"context\",\n                        \"type\": \"Tagged<Context>\",\n                        \"purpose\": \"The context to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IsContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::set_topmost_script_having_context(Tagged<Context> context) {\n  DCHECK(context.is_null() || IsContext(context));\n  thread_local_top()->topmost_script_having_context_ = context;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"clear_topmost_script_having_context\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Clears the topmost script having context for the isolate.\",\n                \"logic\": \"Sets the thread-local storage to the default 'no context' value (which is 0).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::clear_topmost_script_having_context() {\n  static_assert(Context::kNoContext == 0);\n  thread_local_top()->topmost_script_having_context_ = Context();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetIncumbentContext\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns the incumbent context, which is the context of the currently executing script.\",\n                \"logic\": \"First checks if there's a topmost script having context. If so, it returns that context's native context. Otherwise, it calls GetIncumbentContextSlow(). Includes a DCHECK to ensure consistency between the fast and slow paths.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"DirectHandle<NativeContext>\",\n                    \"description\": \"Direct handle to the incumbent context.\"\n                },\n                \"dependencies\": [\n                    \"GetIncumbentContextSlow\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<NativeContext> Isolate::GetIncumbentContext() {\n  Tagged<Context> maybe_topmost_script_having_context =\n      topmost_script_having_context();\n  if (V8_LIKELY(!maybe_topmost_script_having_context.is_null())) {\n    // The topmost script-having context value is guaranteed to be valid only\n    // inside the Api callback however direct calls of Api callbacks from\n    // builtins or optimized code do not change the current VM state, so we\n    // allow JS VM state too.\n    DCHECK(current_vm_state() == EXTERNAL ||  // called from C++ code\n           current_vm_state() == JS);         // called from JS code directly\n\n    Tagged<NativeContext> incumbent_context =\n        maybe_topmost_script_having_context->native_context();\n    DCHECK_EQ(incumbent_context, *GetIncumbentContextSlow());\n    return direct_handle(incumbent_context, this);\n  }\n  return GetIncumbentContextSlow();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"set_pending_message\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Sets the pending message object.\",\n                \"logic\": \"Stores the message object in thread-local storage. Includes a check to ensure the message object is either 'the hole' or a valid JSMessageObject.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"message_obj\",\n                        \"type\": \"Tagged<Object>\",\n                        \"purpose\": \"The message object to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IsTheHole\",\n                    \"IsJSMessageObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::set_pending_message(Tagged<Object> message_obj) {\n  DCHECK(IsTheHole(message_obj, this) || IsJSMessageObject(message_obj));\n  thread_local_top()->pending_message_ = message_obj;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"pending_message\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns the pending message object.\",\n                \"logic\": \"Retrieves the message object from thread-local storage.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Tagged<Object>\",\n                    \"description\": \"The pending message object.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nTagged<Object> Isolate::pending_message() {\n  return thread_local_top()->pending_message_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"clear_pending_message\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Clears the pending message object.\",\n                \"logic\": \"Sets the pending message object to 'the hole'.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ReadOnlyRoots\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::clear_pending_message() {\n  set_pending_message(ReadOnlyRoots(this).the_hole_value());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"has_pending_message\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Checks if there is a pending message.\",\n                \"logic\": \"Checks if the pending message object is not 'the hole'.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if there is a pending message, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"IsTheHole\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Isolate::has_pending_message() {\n  return !IsTheHole(pending_message(), this);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"exception\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns the current exception object.\",\n                \"logic\": \"Retrieves the exception object from thread-local storage. Includes a CHECK to ensure an exception exists and a DCHECK to ensure it is not an exception *marker* itself.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Tagged<Object>\",\n                    \"description\": \"The current exception object.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nTagged<Object> Isolate::exception() {\n  CHECK(has_exception());\n  DCHECK(!IsException(thread_local_top()->exception_, this));\n  return thread_local_top()->exception_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"set_exception\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Sets the current exception object.\",\n                \"logic\": \"Stores the exception object in thread-local storage. Includes a DCHECK to ensure it is not an exception marker itself.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"exception_obj\",\n                        \"type\": \"Tagged<Object>\",\n                        \"purpose\": \"The exception object to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::set_exception(Tagged<Object> exception_obj) {\n  DCHECK(!IsException(exception_obj, this));\n  thread_local_top()->exception_ = exception_obj;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"clear_internal_exception\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Clears the internal exception object.\",\n                \"logic\": \"Sets the exception object in thread-local storage to 'the hole'. Includes a DCHECK to ensure it is not an exception marker itself.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ReadOnlyRoots\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::clear_internal_exception() {\n  DCHECK(!IsException(thread_local_top()->exception_, this));\n  thread_local_top()->exception_ = ReadOnlyRoots(this).the_hole_value();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"clear_exception\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Clears the exception object and resets the try-catch handler if one exists.\",\n                \"logic\": \"Calls clear_internal_exception() and then resets the try_catch_handler.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"clear_internal_exception\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::clear_exception() {\n  clear_internal_exception();\n  if (try_catch_handler()) try_catch_handler()->Reset();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"has_exception\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Checks if there is an exception.\",\n                \"logic\": \"Checks if the exception object in thread-local storage is not 'the hole'. Includes a DCHECK to ensure it is not an exception marker itself.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if there is an exception, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"IsTheHole\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Isolate::has_exception() {\n  ThreadLocalTop* top = thread_local_top();\n  DCHECK(!IsException(top->exception_, this));\n  return !IsTheHole(top->exception_, this);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"is_execution_terminating\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Checks if execution is terminating due to a termination exception.\",\n                \"logic\": \"Compares the exception in thread-local storage with the termination exception.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if execution is terminating, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ReadOnlyRoots\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Isolate::is_execution_terminating() {\n  return thread_local_top()->exception_ ==\n         i::ReadOnlyRoots(this).termination_exception();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VerifyBuiltinsResult\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Verifies the result returned from a builtin function (Debug build only).\",\n                \"logic\": \"In debug mode, it checks for termination exceptions and compares the result with the exception marker to ensure exceptions are handled properly. It also checks that the result pointer belongs to the current isolate or shared isolate if pointer compression is enabled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"result\",\n                        \"type\": \"Tagged<Object>\",\n                        \"purpose\": \"The result to verify.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Tagged<Object>\",\n                    \"description\": \"The verified result.\"\n                },\n                \"dependencies\": [\n                    \"ReadOnlyRoots\",\n                    \"GetIsolateFromHeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nTagged<Object> Isolate::VerifyBuiltinsResult(Tagged<Object> result) {\n  if (is_execution_terminating() && !v8_flags.strict_termination_checks) {\n    // We may be missing places where termination checks are handled properly.\n    // If that's the case, it's likely that we'll have one sitting around when\n    // we return from a builtin. If we're not looking to find such bugs\n    // (strict_termination_checks is false), simply return the exception marker.\n    return ReadOnlyRoots(this).exception();\n  }\n\n  // Here we use full pointer comparison as the result might be an object\n  // outside of the main pointer compression heap (e.g. in trusted space).\n  DCHECK_EQ(has_exception(),\n            result.SafeEquals(ReadOnlyRoots(this).exception()));\n\n#ifdef V8_COMPRESS_POINTERS\n  // Check that the returned pointer is actually part of the current isolate (or\n  // the shared isolate), because that's the assumption in generated code (which\n  // might call this builtin).\n  Isolate* isolate;\n  if (!IsSmi(result) &&\n      GetIsolateFromHeapObject(Cast<HeapObject>(result), &isolate)) {\n    DCHECK(isolate == this || isolate == shared_space_isolate());\n  }\n#endif\n\n  return result;\n}\n#endif  // DEBUG\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VerifyBuiltinsResult\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Verifies the result pair returned from a builtin function (Debug build only, 64-bit host architecture only).\",\n                \"logic\": \"In debug mode, it checks for termination exceptions and compares the first object in pair with the exception marker to ensure exceptions are handled properly. It also checks that both objects in the pair pointers belongs to the current isolate or shared isolate if pointer compression is enabled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pair\",\n                        \"type\": \"ObjectPair\",\n                        \"purpose\": \"The pair of results to verify.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ObjectPair\",\n                    \"description\": \"The verified result pair.\"\n                },\n                \"dependencies\": [\n                    \"ReadOnlyRoots\",\n                    \"GetIsolateFromHeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nObjectPair Isolate::VerifyBuiltinsResult(ObjectPair pair) {\n#ifdef V8_HOST_ARCH_64_BIT\n  Tagged<Object> x(pair.x), y(pair.y);\n\n  // Here we use full pointer comparison as the result might be an object\n  // outside of the main pointer compression heap (e.g. in trusted space).\n  DCHECK_EQ(has_exception(), x.SafeEquals(ReadOnlyRoots(this).exception()));\n\n#ifdef V8_COMPRESS_POINTERS\n  // Check that the returned pointer is actually part of the current isolate (or\n  // the shared isolate), because that's the assumption in generated code (which\n  // might call this builtin).\n  Isolate* isolate;\n  if (!IsSmi(x) && GetIsolateFromHeapObject(Cast<HeapObject>(x), &isolate)) {\n    DCHECK(isolate == this || isolate == shared_space_isolate());\n  }\n  if (!IsSmi(y) && GetIsolateFromHeapObject(Cast<HeapObject>(y), &isolate)) {\n    DCHECK(isolate == this || isolate == shared_space_isolate());\n  }\n#endif\n#endif  // V8_HOST_ARCH_64_BIT\n  return pair;\n}\n#endif  // DEBUG\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"is_catchable_by_javascript\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Checks if an exception is catchable by JavaScript code.\",\n                \"logic\": \"An exception is catchable if it's not the termination exception.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"exception\",\n                        \"type\": \"Tagged<Object>\",\n                        \"purpose\": \"The exception to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the exception is catchable, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ReadOnlyRoots\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Isolate::is_catchable_by_javascript(Tagged<Object> exception) {\n  return exception != ReadOnlyRoots(heap()).termination_exception();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InFastCCall\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Determines if the isolate is currently inside a fast C call.\",\n                \"logic\": \"Checks if the fast_c_call_caller_fp is not kNullAddress.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"Returns true if in a FastCCall, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool Isolate::InFastCCall() const {\n  return isolate_data()->fast_c_call_caller_fp() != kNullAddress;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"is_catchable_by_wasm\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Checks if an exception is catchable by WebAssembly code.\",\n                \"logic\": \"First checks if it's catchable by JavaScript. If not a JSObject, then catchable. If JSObject, consults wasm_uncatchable_symbol\",\n                \"parameters\": [\n                    {\n                        \"name\": \"exception\",\n                        \"type\": \"Tagged<Object>\",\n                        \"purpose\": \"The exception to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the exception is catchable, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"is_catchable_by_javascript\",\n                    \"IsJSObject\",\n                    \"LookupIterator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Isolate::is_catchable_by_wasm(Tagged<Object> exception) {\n  if (!is_catchable_by_javascript(exception)) return false;\n  if (!IsJSObject(exception)) return true;\n  return !LookupIterator::HasInternalMarkerProperty(\n      this, Cast<JSReceiver>(exception), factory()->wasm_uncatchable_symbol());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FireBeforeCallEnteredCallback\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Fires the 'before call entered' callbacks.\",\n                \"logic\": \"Iterates through the list of callbacks and calls each one with the current isolate.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Isolate::FireBeforeCallEnteredCallback() {\n  for (auto& callback : before_call_entered_callbacks_) {\n    callback(reinterpret_cast<v8::Isolate*>(this));\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"global_object\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns a handle to the global object.\",\n                \"logic\": \"Gets the global object from the context and wraps it in a handle.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Handle<JSGlobalObject>\",\n                    \"description\": \"Handle to the global object.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nHandle<JSGlobalObject> Isolate::global_object() {\n  return handle(context()->global_object(), this);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"global_proxy\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Returns a handle to the global proxy object.\",\n                \"logic\": \"Gets the global proxy from the context and wraps it in a handle.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Handle<JSGlobalProxy>\",\n                    \"description\": \"Handle to the global proxy object.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nHandle<JSGlobalProxy> Isolate::global_proxy() {\n  return handle(context()->global_proxy(), this);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ExceptionScope\",\n                \"about\": \"A helper class for managing exceptions within a scope.  Clears exceptions at construction and restores them at destruction.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the isolate.\"\n                    },\n                    {\n                        \"name\": \"exception_\",\n                        \"type\": \"Handle<Object>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the exception.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nIsolate::ExceptionScope::ExceptionScope(Isolate* isolate)\n    : isolate_(isolate), exception_(isolate_->exception(), isolate_) {\n  isolate_->clear_internal_exception();\n}\n\nIsolate::ExceptionScope::~ExceptionScope() {\n  isolate_->set_exception(*exception_);\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsInitialArrayPrototype\",\n                \"parent\": \"Isolate\",\n                \"about\": \"Checks if a JSArray is the initial array prototype.\",\n                \"logic\": \"Checks if the array is in the creation context for the initial array prototype.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"array\",\n                        \"type\": \"Tagged<JSArray>\",\n                        \"purpose\": \"The array to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the array is the initial array prototype, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool Isolate::IsInitialArrayPrototype(Tagged<JSArray> array) {\n  DisallowGarbageCollection no_gc;\n  return IsInCreationContext(array, Context::INITIAL_ARRAY_PROTOTYPE_INDEX);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"NATIVE_CONTEXT_FIELD_ACCESSOR\",\n                \"about\": \"Macro to generate accessor methods for native context fields.\",\n                \"logic\": \"Defines two methods: one to get a Handle to the field, and another to check if a value is equal to the field.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"N/A\",\n                    \"description\": \"Macro definition.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#define NATIVE_CONTEXT_FIELD_ACCESSOR(index, type, name)              \\\n  Handle<UNPAREN(type)> Isolate::name() {                             \\\n    return Handle<UNPAREN(type)>(raw_native_context()->name(), this); \\\n  }                                                                   \\\n  bool Isolate::is_##name(Tagged<UNPAREN(type)> value) {              \\\n    return raw_native_context()->is_##name(value);                    \\\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"NATIVE_CONTEXT_FIELDS\",\n                \"about\": \"Macro to expand native context fields.\",\n                \"logic\": \"Expands to a list of fields to be used in a native context.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"N/A\",\n                    \"description\": \"Macro definition.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nNATIVE_CONTEXT_FIELDS(NATIVE_CONTEXT_FIELD_ACCESSOR)\n#undef NATIVE_CONTEXT_FIELD_ACCESSOR\n        ]]></code>\n    </func>\n</file>\n```"
}