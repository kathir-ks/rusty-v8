{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/strings/string-builder.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 66, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/strings/string-builder.cc\",\n            \"file_name\": \"string-builder.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements string building utilities, including fixed-array-based and incremental string builders.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for string manipulation, execution context, object representation, and string builder functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/strings.h\"\n#include \"src/execution/isolate-inl.h\"\n#include \"src/objects/fixed-array-inl.h\"\n#include \"src/objects/js-array-inl.h\"\n#include \"src/strings/string-builder-inl.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StringBuilderConcatHelper\",\n                \"about\": \"Concatenates strings from a fixed array into a destination buffer.\",\n                \"logic\": \"Iterates through a fixed array, handling both direct string references and Smi-encoded substring references. Writes the string content to the provided sink buffer, accounting for one-byte or two-byte encodings.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"special\",\n                        \"type\": \"Tagged<String>\",\n                        \"purpose\": \"The base string for substring operations.\"\n                    },\n                    {\n                        \"name\": \"sink\",\n                        \"type\": \"sinkchar*\",\n                        \"purpose\": \"The destination buffer to write the concatenated string to.\"\n                    },\n                    {\n                        \"name\": \"fixed_array\",\n                        \"type\": \"Tagged<FixedArray>\",\n                        \"purpose\": \"The fixed array containing strings and Smi-encoded substring information.\"\n                    },\n                    {\n                        \"name\": \"array_length\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The length of the fixed array.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"String\",\n                    \"FixedArray\",\n                    \"StringBuilderSubstringPosition\",\n                    \"StringBuilderSubstringLength\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename sinkchar>\nvoid StringBuilderConcatHelper(Tagged<String> special, sinkchar* sink,\n                               Tagged<FixedArray> fixed_array,\n                               int array_length) {\n  DisallowGarbageCollection no_gc;\n  int position = 0;\n  for (int i = 0; i < array_length; i++) {\n    Tagged<Object> element = fixed_array->get(i);\n    if (IsSmi(element)) {\n      // Smi encoding of position and length.\n      int encoded_slice = Smi::ToInt(element);\n      int pos;\n      int len;\n      if (encoded_slice > 0) {\n        // Position and length encoded in one smi.\n        pos = StringBuilderSubstringPosition::decode(encoded_slice);\n        len = StringBuilderSubstringLength::decode(encoded_slice);\n      } else {\n        // Position and length encoded in two smis.\n        Tagged<Object> obj = fixed_array->get(++i);\n        DCHECK(IsSmi(obj));\n        pos = Smi::ToInt(obj);\n        len = -encoded_slice;\n      }\n      String::WriteToFlat(special, sink + position, pos, len);\n      position += len;\n    } else {\n      Tagged<String> string = Cast<String>(element);\n      int element_length = string->length();\n      String::WriteToFlat(string, sink + position, 0, element_length);\n      position += element_length;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StringBuilderConcatLength\",\n                \"about\": \"Calculates the total length of the concatenated string from a fixed array.\",\n                \"logic\": \"Iterates through a fixed array, summing the lengths of strings and substrings (encoded as Smis). Handles potential errors like out-of-bounds substring references and string length overflows. Determines if the resulting string can be represented as a one-byte string.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"special_length\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The length of the base string for substring operations.\"\n                    },\n                    {\n                        \"name\": \"fixed_array\",\n                        \"type\": \"Tagged<FixedArray>\",\n                        \"purpose\": \"The fixed array containing strings and Smi-encoded substring information.\"\n                    },\n                    {\n                        \"name\": \"array_length\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The length of the fixed array.\"\n                    },\n                    {\n                        \"name\": \"one_byte\",\n                        \"type\": \"bool*\",\n                        \"purpose\": \"A pointer to a boolean value indicating whether the resulting string can be represented as a one-byte string.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The total length of the concatenated string, or -1 if an error occurs, or kMaxInt if the length exceeds the maximum string length.\"\n                },\n                \"dependencies\": [\n                    \"String\",\n                    \"FixedArray\",\n                    \"StringBuilderSubstringPosition\",\n                    \"StringBuilderSubstringLength\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nint StringBuilderConcatLength(int special_length,\n                              Tagged<FixedArray> fixed_array, int array_length,\n                              bool* one_byte) {\n  DisallowGarbageCollection no_gc;\n  int position = 0;\n  for (int i = 0; i < array_length; i++) {\n    uint32_t increment = 0;\n    Tagged<Object> elt = fixed_array->get(i);\n    if (IsSmi(elt)) {\n      // Smi encoding of position and length.\n      int smi_value = Smi::ToInt(elt);\n      int pos;\n      int len;\n      if (smi_value > 0) {\n        // Position and length encoded in one smi.\n        pos = StringBuilderSubstringPosition::decode(smi_value);\n        len = StringBuilderSubstringLength::decode(smi_value);\n      } else {\n        // Position and length encoded in two smis.\n        len = -smi_value;\n        // Get the position and check that it is a positive smi.\n        i++;\n        if (i >= array_length) return -1;\n        Tagged<Object> next_smi = fixed_array->get(i);\n        if (!IsSmi(next_smi)) return -1;\n        pos = Smi::ToInt(next_smi);\n        if (pos < 0) return -1;\n      }\n      DCHECK_GE(pos, 0);\n      DCHECK_GE(len, 0);\n      if (pos > special_length || len > special_length - pos) return -1;\n      increment = len;\n    } else if (IsString(elt)) {\n      Tagged<String> element = Cast<String>(elt);\n      int element_length = element->length();\n      increment = element_length;\n      if (*one_byte && !element->IsOneByteRepresentation()) {\n        *one_byte = false;\n      }\n    } else {\n      return -1;\n    }\n    if (increment > String::kMaxLength - position) {\n      return kMaxInt;  // Provoke throw on allocation.\n    }\n    position += increment;\n  }\n  return position;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FixedArrayBuilder\",\n                \"about\": \"A utility class for building fixed arrays efficiently.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"array_\",\n                        \"type\": \"DirectHandle<FixedArray>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The underlying fixed array being built.\"\n                    },\n                    {\n                        \"name\": \"length_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current number of elements in the array.\"\n                    },\n                    {\n                        \"name\": \"has_non_smi_elements_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the array contains non-Smi elements.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"FixedArray\",\n                    \"Isolate\",\n                    \"Factory\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nFixedArrayBuilder::FixedArrayBuilder(Isolate* isolate, int initial_capacity)\n    : array_(isolate->factory()->NewFixedArrayWithHoles(initial_capacity)),\n      length_(0),\n      has_non_smi_elements_(false) {\n  // Require a non-zero initial size. Ensures that doubling the size to\n  // extend the array will work.\n  DCHECK_GT(initial_capacity, 0);\n}\n\nFixedArrayBuilder::FixedArrayBuilder(DirectHandle<FixedArray> backing_store)\n    : array_(backing_store), length_(0), has_non_smi_elements_(false) {\n  // Require a non-zero initial size. Ensures that doubling the size to\n  // extend the array will work.\n  DCHECK_GT(backing_store->length(), 0);\n}\n\nFixedArrayBuilder::FixedArrayBuilder(Isolate* isolate)\n    : array_(isolate->factory()->empty_fixed_array()),\n      length_(0),\n      has_non_smi_elements_(false) {}\n\n// static\nFixedArrayBuilder FixedArrayBuilder::Lazy(Isolate* isolate) {\n  return FixedArrayBuilder(isolate);\n}\n\nbool FixedArrayBuilder::HasCapacity(int elements) {\n  int length = array_->length();\n  int required_length = length_ + elements;\n  return (length >= required_length);\n}\n\nvoid FixedArrayBuilder::EnsureCapacity(Isolate* isolate, int elements) {\n  int length = array_->length();\n  int required_length = length_ + elements;\n  if (length < required_length) {\n    if (length == 0) {\n      constexpr int kInitialCapacityForLazy = 16;\n      array_ = isolate->factory()->NewFixedArrayWithHoles(\n          std::max(kInitialCapacityForLazy, elements));\n      return;\n    }\n\n    int new_length = length;\n    do {\n      new_length *= 2;\n    } while (new_length < required_length);\n    DirectHandle<FixedArray> extended_array =\n        isolate->factory()->NewFixedArrayWithHoles(new_length);\n    FixedArray::CopyElements(isolate, *extended_array, 0, *array_, 0, length_);\n    array_ = extended_array;\n  }\n}\n\nvoid FixedArrayBuilder::Add(Tagged<Object> value) {\n  DCHECK(!IsSmi(value));\n  array_->set(length_, value);\n  length_++;\n  has_non_smi_elements_ = true;\n}\n\nvoid FixedArrayBuilder::Add(Tagged<Smi> value) {\n  DCHECK(IsSmi(value));\n  array_->set(length_, value);\n  length_++;\n}\n\nint FixedArrayBuilder::capacity() { return array_->length(); }\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReplacementStringBuilder\",\n                \"about\": \"A utility class for building strings by replacing parts of a subject string.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"heap_\",\n                        \"type\": \"Heap*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The heap used for memory allocation.\"\n                    },\n                    {\n                        \"name\": \"array_builder_\",\n                        \"type\": \"FixedArrayBuilder\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The fixed array builder used to store the string parts.\"\n                    },\n                    {\n                        \"name\": \"subject_\",\n                        \"type\": \"DirectHandle<String>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The subject string being replaced.\"\n                    },\n                    {\n                        \"name\": \"character_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The total number of characters in the resulting string.\"\n                    },\n                    {\n                        \"name\": \"is_one_byte_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the resulting string can be represented as a one-byte string.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"FixedArrayBuilder\",\n                    \"String\",\n                    \"Isolate\",\n                    \"Heap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReplacementStringBuilder::ReplacementStringBuilder(Heap* heap,\n                                                   DirectHandle<String> subject,\n                                                   int estimated_part_count)\n    : heap_(heap),\n      array_builder_(Isolate::FromHeap(heap), estimated_part_count),\n      subject_(subject),\n      character_count_(0),\n      is_one_byte_(subject->IsOneByteRepresentation()) {\n  // Require a non-zero initial size. Ensures that doubling the size to\n  // extend the array will work.\n  DCHECK_GT(estimated_part_count, 0);\n}\n\nvoid ReplacementStringBuilder::EnsureCapacity(int elements) {\n  array_builder_.EnsureCapacity(Isolate::FromHeap(heap_), elements);\n}\n\nvoid ReplacementStringBuilder::AddString(DirectHandle<String> string) {\n  uint32_t length = string->length();\n  AddElement(string);\n  if (!string->IsOneByteRepresentation()) {\n    is_one_byte_ = false;\n  }\n  IncrementCharacterCount(length);\n}\n\nMaybeDirectHandle<String> ReplacementStringBuilder::ToString() {\n  Isolate* isolate = Isolate::FromHeap(heap_);\n  if (array_builder_.length() == 0) {\n    return isolate->factory()->empty_string();\n  }\n\n  DirectHandle<String> joined_string;\n  if (is_one_byte_) {\n    DirectHandle<SeqOneByteString> seq;\n    ASSIGN_RETURN_ON_EXCEPTION(\n        isolate, seq,\n        isolate->factory()->NewRawOneByteString(character_count_));\n\n    DisallowGarbageCollection no_gc;\n    uint8_t* char_buffer = seq->GetChars(no_gc);\n    StringBuilderConcatHelper(*subject_, char_buffer, *array_builder_.array(),\n                              array_builder_.length());\n    joined_string = Cast<String>(seq);\n  } else {\n    // Two-byte.\n    DirectHandle<SeqTwoByteString> seq;\n    ASSIGN_RETURN_ON_EXCEPTION(\n        isolate, seq,\n        isolate->factory()->NewRawTwoByteString(character_count_));\n\n    DisallowGarbageCollection no_gc;\n    base::uc16* char_buffer = seq->GetChars(no_gc);\n    StringBuilderConcatHelper(*subject_, char_buffer, *array_builder_.array(),\n                              array_builder_.length());\n    joined_string = Cast<String>(seq);\n  }\n  return joined_string;\n}\n\nvoid ReplacementStringBuilder::AddElement(DirectHandle<Object> element) {\n  DCHECK(IsSmi(*element) || IsString(*element));\n  EnsureCapacity(1);\n  DisallowGarbageCollection no_gc;\n  array_builder_.Add(*element);\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IncrementalStringBuilder\",\n                \"about\": \"A utility class for building strings incrementally.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The isolate used for memory allocation.\"\n                    },\n                    {\n                        \"name\": \"encoding_\",\n                        \"type\": \"String::Encoding\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The encoding of the string (one-byte or two-byte).\"\n                    },\n                    {\n                        \"name\": \"overflowed_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the string length has exceeded the maximum allowed length.\"\n                    },\n                    {\n                        \"name\": \"part_length_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The length of the current string part.\"\n                    },\n                    {\n                        \"name\": \"current_index_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current index within the current string part.\"\n                    },\n                    {\n                        \"name\": \"accumulator_\",\n                        \"type\": \"DirectHandle<String>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The accumulated string so far.\"\n                    },\n                    {\n                        \"name\": \"current_part_\",\n                        \"type\": \"DirectHandle<String>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current string part being built.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"String\",\n                    \"Isolate\",\n                    \"Factory\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nIncrementalStringBuilder::IncrementalStringBuilder(Isolate* isolate)\n    : isolate_(isolate),\n      encoding_(String::ONE_BYTE_ENCODING),\n      overflowed_(false),\n      part_length_(kInitialPartLength),\n      current_index_(0) {\n  // Create an accumulator handle starting with the empty string.\n  accumulator_ =\n      DirectHandle<String>::New(ReadOnlyRoots(isolate).empty_string(), isolate);\n  current_part_ =\n      factory()->NewRawOneByteString(part_length_).ToHandleChecked();\n}\n\nint IncrementalStringBuilder::Length() const {\n  return accumulator_->length() + current_index_;\n}\n\nbool IncrementalStringBuilder::HasValidCurrentIndex() const {\n  return current_index_ < part_length_;\n}\n\nvoid IncrementalStringBuilder::Accumulate(DirectHandle<String> new_part) {\n  DirectHandle<String> new_accumulator;\n  if (accumulator()->length() + new_part->length() > String::kMaxLength) {\n    // Set the flag and carry on. Delay throwing the exception till the end.\n    new_accumulator = factory()->empty_string();\n    overflowed_ = true;\n  } else {\n    new_accumulator =\n        factory()\n            ->NewConsString(indirect_handle(accumulator(), isolate_),\n                            indirect_handle(new_part, isolate_))\n            .ToHandleChecked();\n  }\n  set_accumulator(new_accumulator);\n}\n\nvoid IncrementalStringBuilder::Extend() {\n  DCHECK_EQ(current_index_, current_part()->length());\n  Accumulate(current_part());\n  if (part_length_ <= kMaxPartLength / kPartLengthGrowthFactor) {\n    part_length_ *= kPartLengthGrowthFactor;\n  }\n  DirectHandle<String> new_part;\n  if (encoding_ == String::ONE_BYTE_ENCODING) {\n    new_part = factory()->NewRawOneByteString(part_length_).ToHandleChecked();\n  } else {\n    new_part = factory()->NewRawTwoByteString(part_length_).ToHandleChecked();\n  }\n  // Reuse the same handle to avoid being invalidated when exiting handle scope.\n  set_current_part(new_part);\n  current_index_ = 0;\n}\n\nMaybeDirectHandle<String> IncrementalStringBuilder::Finish() {\n  ShrinkCurrentPart();\n  Accumulate(current_part());\n  if (overflowed_) {\n    THROW_NEW_ERROR(isolate_, NewInvalidStringLengthError());\n  }\n  if (isolate()->serializer_enabled()) {\n    return factory()->InternalizeString(\n        indirect_handle(accumulator(), isolate_));\n  }\n  return accumulator();\n}\n\n// Short strings can be copied directly to {current_part_}.\n// Requires the IncrementalStringBuilder to either have two byte encoding or\n// the incoming string to have one byte representation \"underneath\" (The\n// one byte check requires the string to be flat).\nbool IncrementalStringBuilder::CanAppendByCopy(DirectHandle<String> string) {\n  const bool representation_ok =\n      encoding_ == String::TWO_BYTE_ENCODING ||\n      (string->IsFlat() && String::IsOneByteRepresentationUnderneath(*string));\n\n  return representation_ok && CurrentPartCanFit(string->length());\n}\n\nvoid IncrementalStringBuilder::AppendStringByCopy(DirectHandle<String> string) {\n  DCHECK(CanAppendByCopy(string));\n\n  {\n    DisallowGarbageCollection no_gc;\n    if (encoding_ == String::ONE_BYTE_ENCODING) {\n      String::WriteToFlat(\n          *string,\n          Cast<SeqOneByteString>(current_part())->GetChars(no_gc) +\n              current_index_,\n          0, string->length());\n    } else {\n      String::WriteToFlat(\n          *string,\n          Cast<SeqTwoByteString>(current_part())->GetChars(no_gc) +\n              current_index_,\n          0, string->length());\n    }\n  }\n  current_index_ += string->length();\n  DCHECK(current_index_ <= part_length_);\n  if (current_index_ == part_length_) Extend();\n}\n\nvoid IncrementalStringBuilder::AppendString(DirectHandle<String> string) {\n  if (CanAppendByCopy(string)) {\n    AppendStringByCopy(string);\n    return;\n  }\n\n  ShrinkCurrentPart();\n  part_length_ = kInitialPartLength;  // Allocate conservatively.\n  Extend();  // Attach current part and allocate new part.\n  Accumulate(string);\n}\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"String\",\n                    \"about\": \"Represents a string object in V8.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class String {\n                public:\n                    int length() const;\n                    bool IsOneByteRepresentation() const;\n                    static void WriteToFlat(Tagged<String> string, uint8_t* sink, int position, int length);\n                    static void WriteToFlat(Tagged<String> string, base::uc16* sink, int position, int length);\n                    bool IsFlat() const;\n                    static bool IsOneByteRepresentationUnderneath(const String& str);\n                    enum Encoding {\n                        ONE_BYTE_ENCODING,\n                        TWO_BYTE_ENCODING\n                    };\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"FixedArray\",\n                    \"about\": \"Represents a fixed-size array of objects in V8.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class FixedArray {\n                public:\n                    Tagged<Object> get(int index) const;\n                    void set(int index, Tagged<Object> value);\n                    int length() const;\n                    static void CopyElements(Isolate* isolate, FixedArray target, int target_start_index, FixedArray source, int source_start_index, int length);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Smi\",\n                    \"about\": \"Represents a small integer in V8.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Smi {\n                public:\n                    static int ToInt(Tagged<Object> smi);\n                    static bool IsSmi(Tagged<Object> object);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Isolate\",\n                    \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {\n                public:\n                    Factory* factory();\n                    static Isolate* FromHeap(Heap* heap);\n                    bool serializer_enabled();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Factory\",\n                    \"about\": \"A factory for creating V8 objects.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Factory {\n                public:\n                    DirectHandle<FixedArray> NewFixedArrayWithHoles(int size);\n                    DirectHandle<String> empty_string();\n                    DirectHandle<String> NewRawOneByteString(int length);\n                    DirectHandle<String> NewRawTwoByteString(int length);\n                    MaybeHandle<String> NewConsString(Handle<String> left, Handle<String> right);\n                    MaybeHandle<String> InternalizeString(Handle<String> string);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Heap\",\n                    \"about\": \"Represents the V8 heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Heap {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}