{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-scanner.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-scanner.cc\",\n            \"file_name\": \"asm-scanner.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the Asm.js scanner for tokenizing and identifying keywords, numbers, and identifiers in Asm.js code.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for asm.js scanning, standard integer types, base iterators, flags, number conversions, parsing scanner, and string character predicates.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/asmjs/asm-scanner.h\"\n\n#include <cinttypes>\n\n#include \"src/base/iterator.h\"\n#include \"src/flags/flags.h\"\n#include \"src/numbers/conversions.h\"\n#include \"src/parsing/scanner.h\"\n#include \"src/strings/char-predicates-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AsmJsScanner\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"The AsmJsScanner class is responsible for scanning and tokenizing Asm.js source code.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"stream_\",\n                        \"type\": \"Utf16CharacterStream*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The input stream of characters to be scanned.\"\n                    },\n                    {\n                        \"name\": \"token_\",\n                        \"type\": \"token_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current token being processed.\"\n                    },\n                    {\n                        \"name\": \"preceding_token_\",\n                        \"type\": \"token_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The token that was processed before the current token.\"\n                    },\n                    {\n                        \"name\": \"next_token_\",\n                        \"type\": \"token_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The next token in the stream (used for rewinding).\"\n                    },\n                    {\n                        \"name\": \"position_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current position in the input stream.\"\n                    },\n                    {\n                        \"name\": \"preceding_position_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The position of the preceding token.\"\n                    },\n                    {\n                        \"name\": \"next_position_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The position of the next token.\"\n                    },\n                    {\n                        \"name\": \"rewind_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the scanner has been rewound.\"\n                    },\n                    {\n                        \"name\": \"in_local_scope_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the scanner is currently within a local scope.\"\n                    },\n                    {\n                        \"name\": \"global_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A counter for the number of global identifiers encountered.\"\n                    },\n                    {\n                        \"name\": \"double_value_\",\n                        \"type\": \"double\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The value of the current token if it is a double.\"\n                    },\n                    {\n                        \"name\": \"unsigned_value_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The value of the current token if it is an unsigned integer.\"\n                    },\n                    {\n                        \"name\": \"preceded_by_newline_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the current token was preceded by a newline character.\"\n                    },\n                    {\n                        \"name\": \"property_names_\",\n                        \"type\": \"std::unordered_map<std::string, token_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map of property names to token types.\"\n                    },\n                    {\n                        \"name\": \"global_names_\",\n                        \"type\": \"std::unordered_map<std::string, token_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map of global names to token types.\"\n                    },\n                    {\n                        \"name\": \"local_names_\",\n                        \"type\": \"std::unordered_map<std::string, token_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map of local names to token types.\"\n                    },\n                    {\n                        \"name\": \"identifier_string_\",\n                        \"type\": \"std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A string buffer to hold the current identifier.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Utf16CharacterStream\",\n                    \"token_t\",\n                    \"base::uc32\",\n                    \"std::unordered_map\",\n                    \"std::string\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nnamespace {\n// Cap number of identifiers to ensure we can assign both global and\n// local ones a token id in the range of an int32_t.\nstatic const int kMaxIdentifierCount = 0xF000000;\n}  // namespace\n\nAsmJsScanner::AsmJsScanner(Utf16CharacterStream* stream)\n    : stream_(stream),\n      token_(kUninitialized),\n      preceding_token_(kUninitialized),\n      next_token_(kUninitialized),\n      position_(0),\n      preceding_position_(0),\n      next_position_(0),\n      rewind_(false),\n      in_local_scope_(false),\n      global_count_(0),\n      double_value_(0.0),\n      unsigned_value_(0),\n      preceded_by_newline_(false) {\n#define V(name, _junk1, _junk2, _junk3) property_names_[#name] = kToken_##name;\n  STDLIB_MATH_FUNCTION_LIST(V)\n  STDLIB_ARRAY_TYPE_LIST(V)\n#undef V\n#define V(name, _junk1) property_names_[#name] = kToken_##name;\n  STDLIB_MATH_VALUE_LIST(V)\n#undef V\n#define V(name) property_names_[#name] = kToken_##name;\n  STDLIB_OTHER_LIST(V)\n#undef V\n#define V(name) global_names_[#name] = kToken_##name;\n  KEYWORD_NAME_LIST(V)\n#undef V\n  Next();\n}\n\nvoid AsmJsScanner::Next() {\n  if (rewind_) {\n    preceding_token_ = token_;\n    preceding_position_ = position_;\n    token_ = next_token_;\n    position_ = next_position_;\n    next_token_ = kUninitialized;\n    next_position_ = 0;\n    rewind_ = false;\n    return;\n  }\n\n  if (token_ == kEndOfInput || token_ == kParseError) {\n    return;\n  }\n\n#if DEBUG\n  if (v8_flags.trace_asm_scanner) {\n    if (Token() == kDouble) {\n      PrintF(\"%lf \", AsDouble());\n    } else if (Token() == kUnsigned) {\n      PrintF(\"%\" PRIu32 \" \", AsUnsigned());\n    } else {\n      std::string name = Name(Token());\n      PrintF(\"%s \", name.c_str());\n    }\n  }\n#endif\n\n  preceded_by_newline_ = false;\n  preceding_token_ = token_;\n  preceding_position_ = position_;\n\n  for (;;) {\n    position_ = stream_->pos();\n    base::uc32 ch = stream_->Advance();\n    switch (ch) {\n      case ' ':\n      case '\\t':\n      case '\\r':\n        // Ignore whitespace.\n        break;\n\n      case '\\n':\n        // Track when we've passed a newline for optional semicolon support,\n        // but keep scanning.\n        preceded_by_newline_ = true;\n        break;\n\n      case kEndOfInputU:\n        token_ = kEndOfInput;\n        return;\n\n      case '\\'':\n      case '\"':\n        ConsumeString(ch);\n        return;\n\n      case '/':\n        ch = stream_->Advance();\n        if (ch == '/') {\n          ConsumeCPPComment();\n        } else if (ch == '*') {\n          if (!ConsumeCComment()) {\n            token_ = kParseError;\n            return;\n          }\n        } else {\n          stream_->Back();\n          token_ = '/';\n          return;\n        }\n        // Breaks out of switch, but loops again (i.e. the case when we parsed\n        // a comment, but need to continue to look for the next token).\n        break;\n\n      case '<':\n      case '>':\n      case '=':\n      case '!':\n        ConsumeCompareOrShift(ch);\n        return;\n\n#define V(single_char_token) case single_char_token:\n        SIMPLE_SINGLE_TOKEN_LIST(V)\n#undef V\n        // Use fixed token IDs for ASCII.\n        token_ = ch;\n        return;\n\n      default:\n        if (IsIdentifierStart(ch)) {\n          ConsumeIdentifier(ch);\n        } else if (IsNumberStart(ch)) {\n          ConsumeNumber(ch);\n        } else {\n          // TODO(bradnelson): Support unicode (probably via UnicodeCache).\n          token_ = kParseError;\n        }\n        return;\n    }\n  }\n}\n\nvoid AsmJsScanner::Rewind() {\n  DCHECK_NE(kUninitialized, preceding_token_);\n  // TODO(bradnelson): Currently rewinding needs to leave in place the\n  // preceding newline state (in case a |0 ends a line).\n  // This is weird and stateful, fix me.\n  DCHECK(!rewind_);\n  next_token_ = token_;\n  next_position_ = position_;\n  token_ = preceding_token_;\n  position_ = preceding_position_;\n  preceding_token_ = kUninitialized;\n  preceding_position_ = 0;\n  rewind_ = true;\n  identifier_string_.clear();\n}\n\nvoid AsmJsScanner::ResetLocals() { local_names_.clear(); }\n\n#if DEBUG\n// Only used for debugging.\nstd::string AsmJsScanner::Name(token_t token) const {\n  if (token >= 32 && token < 127) {\n    return std::string(1, static_cast<char>(token));\n  }\n  for (auto& i : local_names_) {\n    if (i.second == token) {\n      return i.first;\n    }\n  }\n  for (auto& i : global_names_) {\n    if (i.second == token) {\n      return i.first;\n    }\n  }\n  for (auto& i : property_names_) {\n    if (i.second == token) {\n      return i.first;\n    }\n  }\n  switch (token) {\n#define V(rawname, name) \\\n  case kToken_##name:    \\\n    return rawname;\n    LONG_SYMBOL_NAME_LIST(V)\n#undef V\n#define V(name, value, string_name) \\\n  case name:                        \\\n    return string_name;\n    SPECIAL_TOKEN_LIST(V)\n    default:\n      break;\n#undef V\n  }\n  UNREACHABLE();\n}\n#endif\n\nvoid AsmJsScanner::Seek(size_t pos) {\n  stream_->Seek(pos);\n  preceding_token_ = kUninitialized;\n  token_ = kUninitialized;\n  next_token_ = kUninitialized;\n  preceding_position_ = 0;\n  position_ = 0;\n  next_position_ = 0;\n  rewind_ = false;\n  Next();\n}\n\nvoid AsmJsScanner::ConsumeIdentifier(base::uc32 ch) {\n  // Consume characters while still part of the identifier.\n  identifier_string_.clear();\n  while (IsIdentifierPart(ch)) {\n    identifier_string_ += ch;\n    ch = stream_->Advance();\n  }\n  // Go back one for next time.\n  stream_->Back();\n\n  // Decode what the identifier means.\n  if (preceding_token_ == '.') {\n    auto i = property_names_.find(identifier_string_);\n    if (i != property_names_.end()) {\n      token_ = i->second;\n      return;\n    }\n  } else {\n    {\n      auto i = local_names_.find(identifier_string_);\n      if (i != local_names_.end()) {\n        token_ = i->second;\n        return;\n      }\n    }\n    if (!in_local_scope_) {\n      auto i = global_names_.find(identifier_string_);\n      if (i != global_names_.end()) {\n        token_ = i->second;\n        return;\n      }\n    }\n  }\n  if (preceding_token_ == '.') {\n    CHECK_LT(global_count_, kMaxIdentifierCount);\n    token_ = kGlobalsStart + global_count_++;\n    property_names_[identifier_string_] = token_;\n  } else if (in_local_scope_) {\n    CHECK_LT(local_names_.size(), kMaxIdentifierCount);\n    token_ = kLocalsStart - static_cast<token_t>(local_names_.size());\n    local_names_[identifier_string_] = token_;\n  } else {\n    CHECK_LT(global_count_, kMaxIdentifierCount);\n    token_ = kGlobalsStart + global_count_++;\n    global_names_[identifier_string_] = token_;\n  }\n}\n\nnamespace {\nbool IsValidImplicitOctal(std::string_view number) {\n  DCHECK_EQ(number[0], '0');\n  return std::all_of(number.begin() + 1, number.end(), IsOctalDigit);\n}\n}  // namespace\n\nvoid AsmJsScanner::ConsumeNumber(base::uc32 ch) {\n  std::string number;\n  number.assign(1, ch);\n  bool has_dot = ch == '.';\n  bool has_prefix = false;\n  for (;;) {\n    ch = stream_->Advance();\n    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n        (ch >= 'A' && ch <= 'F') || ch == '.' || ch == 'b' || ch == 'o' ||\n        ch == 'x' ||\n        ((ch == '-' || ch == '+') && !has_prefix &&\n         (number[number.size() - 1] == 'e' ||\n          number[number.size() - 1] == 'E'))) {\n      // TODO(bradnelson): Test weird cases ending in -.\n      if (ch == '.') {\n        has_dot = true;\n      }\n      if (ch == 'b' || ch == 'o' || ch == 'x') {\n        has_prefix = true;\n      }\n      number.push_back(ch);\n    } else {\n      break;\n    }\n  }\n  stream_->Back();\n  // Special case the most common number.\n  if (number.size() == 1 && number[0] == '0') {\n    unsigned_value_ = 0;\n    token_ = kUnsigned;\n    return;\n  }\n  // Pick out dot.\n  if (number.size() == 1 && number[0] == '.') {\n    token_ = '.';\n    return;\n  }\n  // Decode numbers, with seperate paths for prefixes and implicit octals.\n  if (has_prefix && number[0] == '0') {\n    // \"0[xob]\" by itself is a parse error.\n    if (number.size() <= 2) {\n      token_ = kParseError;\n      return;\n    }\n    switch (number[1]) {\n      case 'b':\n        double_value_ = BinaryStringToDouble(\n            base::Vector<const uint8_t>::cast(base::VectorOf(number)));\n        break;\n      case 'o':\n        double_value_ = OctalStringToDouble(\n            base::Vector<const uint8_t>::cast(base::VectorOf(number)));\n        break;\n      case 'x':\n        double_value_ = HexStringToDouble(\n            base::Vector<const uint8_t>::cast(base::VectorOf(number)));\n        break;\n      default:\n        // If there is a prefix character, but it's not the second character,\n        // then there's a parse error somewhere.\n        token_ = kParseError;\n        break;\n    }\n  } else if (number[0] == '0' && !has_prefix && IsValidImplicitOctal(number)) {\n    double_value_ = ImplicitOctalStringToDouble(\n        base::Vector<const uint8_t>::cast(base::VectorOf(number)));\n  } else {\n    double_value_ = StringToDouble(\n        base::Vector<const uint8_t>::cast(base::VectorOf(number)),\n        NO_CONVERSION_FLAG);\n  }\n  if (std::isnan(double_value_)) {\n    // Check if string to number conversion didn't consume all the characters.\n    // This happens if the character filter let through something invalid\n    // like: 0123ef for example.\n    // TODO(bradnelson): Check if this happens often enough to be a perf\n    // problem.\n    if (number[0] == '.') {\n      for (size_t k = 1; k < number.size(); ++k) {\n        stream_->Back();\n      }\n      token_ = '.';\n      return;\n    }\n    // Anything else that doesn't parse is an error.\n    token_ = kParseError;\n    return;\n  }\n  if (has_dot || trunc(double_value_) != double_value_) {\n    token_ = kDouble;\n  } else {\n    // Exceeding safe integer range is an error.\n    if (double_value_ > static_cast<double>(kMaxUInt32)) {\n      token_ = kParseError;\n      return;\n    }\n    unsigned_value_ = static_cast<uint32_t>(double_value_);\n    token_ = kUnsigned;\n  }\n}\n\nbool AsmJsScanner::ConsumeCComment() {\n  for (;;) {\n    base::uc32 ch = stream_->Advance();\n    while (ch == '*') {\n      ch = stream_->Advance();\n      if (ch == '/') {\n        return true;\n      }\n    }\n    if (ch == '\\n') {\n      preceded_by_newline_ = true;\n    }\n    if (ch == kEndOfInputU) {\n      return false;\n    }\n  }\n}\n\nvoid AsmJsScanner::ConsumeCPPComment() {\n  for (;;) {\n    base::uc32 ch = stream_->Advance();\n    if (ch == '\\n') {\n      preceded_by_newline_ = true;\n      return;\n    }\n    if (ch == kEndOfInputU) {\n      return;\n    }\n  }\n}\n\nvoid AsmJsScanner::ConsumeString(base::uc32 quote) {\n  // Only string allowed is 'use asm' / \"use asm\".\n  const char* expected = \"use asm\";\n  for (; *expected != '\\0'; ++expected) {\n    if (stream_->Advance() != static_cast<base::uc32>(*expected)) {\n      token_ = kParseError;\n      return;\n    }\n  }\n  if (stream_->Advance() != quote) {\n    token_ = kParseError;\n    return;\n  }\n  token_ = kToken_UseAsm;\n}\n\nvoid AsmJsScanner::ConsumeCompareOrShift(base::uc32 ch) {\n  base::uc32 next_ch = stream_->Advance();\n  if (next_ch == '=') {\n    switch (ch) {\n      case '<':\n        token_ = kToken_LE;\n        break;\n      case '>':\n        token_ = kToken_GE;\n        break;\n      case '=':\n        token_ = kToken_EQ;\n        break;\n      case '!':\n        token_ = kToken_NE;\n        break;\n      default:\n        UNREACHABLE();\n    }\n  } else if (ch == '<' && next_ch == '<') {\n    token_ = kToken_SHL;\n  } else if (ch == '>' && next_ch == '>') {\n    if (stream_->Advance() == '>') {\n      token_ = kToken_SHR;\n    } else {\n      token_ = kToken_SAR;\n      stream_->Back();\n    }\n  } else {\n    stream_->Back();\n    token_ = ch;\n  }\n}\n\nbool AsmJsScanner::IsIdentifierStart(base::uc32 ch) {\n  return base::IsInRange(AsciiAlphaToLower(ch), 'a', 'z') || ch == '_' ||\n         ch == '$';\n}\n\nbool AsmJsScanner::IsIdentifierPart(base::uc32 ch) {\n  return IsAsciiIdentifier(ch);\n}\n\nbool AsmJsScanner::IsNumberStart(base::uc32 ch) {\n  return ch == '.' || IsDecimalDigit(ch);\n}\n\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Next\",\n                \"parent\": \"AsmJsScanner\",\n                \"about\": \"Advances the scanner to the next token in the input stream.\",\n                \"logic\": \"Handles rewinding, skips whitespace and comments, identifies different token types (strings, operators, identifiers, numbers), and sets the current token accordingly.  It also keeps track of newline characters for optional semicolon support. Uses a state machine pattern in the main loop.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Utf16CharacterStream\",\n                    \"token_t\",\n                    \"ConsumeString\",\n                    \"ConsumeCPPComment\",\n                    \"ConsumeCComment\",\n                    \"ConsumeCompareOrShift\",\n                    \"ConsumeIdentifier\",\n                    \"ConsumeNumber\",\n                    \"IsIdentifierStart\",\n                    \"IsNumberStart\",\n                    \"PrintF\",\n                    \"AsDouble\",\n                    \"AsUnsigned\",\n                    \"Name\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AsmJsScanner::Next() {\n  if (rewind_) {\n    preceding_token_ = token_;\n    preceding_position_ = position_;\n    token_ = next_token_;\n    position_ = next_position_;\n    next_token_ = kUninitialized;\n    next_position_ = 0;\n    rewind_ = false;\n    return;\n  }\n\n  if (token_ == kEndOfInput || token_ == kParseError) {\n    return;\n  }\n\n#if DEBUG\n  if (v8_flags.trace_asm_scanner) {\n    if (Token() == kDouble) {\n      PrintF(\"%lf \", AsDouble());\n    } else if (Token() == kUnsigned) {\n      PrintF(\"%\" PRIu32 \" \", AsUnsigned());\n    } else {\n      std::string name = Name(Token());\n      PrintF(\"%s \", name.c_str());\n    }\n  }\n#endif\n\n  preceded_by_newline_ = false;\n  preceding_token_ = token_;\n  preceding_position_ = position_;\n\n  for (;;) {\n    position_ = stream_->pos();\n    base::uc32 ch = stream_->Advance();\n    switch (ch) {\n      case ' ':\n      case '\\t':\n      case '\\r':\n        // Ignore whitespace.\n        break;\n\n      case '\\n':\n        // Track when we've passed a newline for optional semicolon support,\n        // but keep scanning.\n        preceded_by_newline_ = true;\n        break;\n\n      case kEndOfInputU:\n        token_ = kEndOfInput;\n        return;\n\n      case '\\'':\n      case '\"':\n        ConsumeString(ch);\n        return;\n\n      case '/':\n        ch = stream_->Advance();\n        if (ch == '/') {\n          ConsumeCPPComment();\n        } else if (ch == '*') {\n          if (!ConsumeCComment()) {\n            token_ = kParseError;\n            return;\n          }\n        } else {\n          stream_->Back();\n          token_ = '/';\n          return;\n        }\n        // Breaks out of switch, but loops again (i.e. the case when we parsed\n        // a comment, but need to continue to look for the next token).\n        break;\n\n      case '<':\n      case '>':\n      case '=':\n      case '!':\n        ConsumeCompareOrShift(ch);\n        return;\n\n#define V(single_char_token) case single_char_token:\n        SIMPLE_SINGLE_TOKEN_LIST(V)\n#undef V\n        // Use fixed token IDs for ASCII.\n        token_ = ch;\n        return;\n\n      default:\n        if (IsIdentifierStart(ch)) {\n          ConsumeIdentifier(ch);\n        } else if (IsNumberStart(ch)) {\n          ConsumeNumber(ch);\n        } else {\n          // TODO(bradnelson): Support unicode (probably via UnicodeCache).\n          token_ = kParseError;\n        }\n        return;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Rewind\",\n                \"parent\": \"AsmJsScanner\",\n                \"about\": \"Rewinds the scanner to the previously scanned token.\",\n                \"logic\": \"Stores the current token and position in the 'next' fields and restores the preceding token and position.  Clears the identifier string. Used for lookahead and backtracking.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"token_t\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AsmJsScanner::Rewind() {\n  DCHECK_NE(kUninitialized, preceding_token_);\n  // TODO(bradnelson): Currently rewinding needs to leave in place the\n  // preceding newline state (in case a |0 ends a line).\n  // This is weird and stateful, fix me.\n  DCHECK(!rewind_);\n  next_token_ = token_;\n  next_position_ = position_;\n  token_ = preceding_token_;\n  position_ = preceding_position_;\n  preceding_token_ = kUninitialized;\n  preceding_position_ = 0;\n  rewind_ = true;\n  identifier_string_.clear();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ResetLocals\",\n                \"parent\": \"AsmJsScanner\",\n                \"about\": \"Clears the local names map.\",\n                \"logic\": \"Empties the local_names_ map, effectively resetting the local scope.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"local_names_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AsmJsScanner::ResetLocals() { local_names_.clear(); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Name\",\n                \"parent\": \"AsmJsScanner\",\n                \"about\": \"Returns the name of a given token (only used for debugging).\",\n                \"logic\": \"Looks up the token in the local, global, and property name maps and returns the corresponding string. If the token is an ASCII character, it returns a string containing that character. Otherwise, it looks up tokens in various lists and returns the string name.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"token\",\n                        \"type\": \"token_t\",\n                        \"purpose\": \"The token to look up.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"The name of the token.\"\n                },\n                \"dependencies\": [\n                    \"token_t\",\n                    \"local_names_\",\n                    \"global_names_\",\n                    \"property_names_\",\n                    \"LONG_SYMBOL_NAME_LIST\",\n                    \"SPECIAL_TOKEN_LIST\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if DEBUG\n// Only used for debugging.\nstd::string AsmJsScanner::Name(token_t token) const {\n  if (token >= 32 && token < 127) {\n    return std::string(1, static_cast<char>(token));\n  }\n  for (auto& i : local_names_) {\n    if (i.second == token) {\n      return i.first;\n    }\n  }\n  for (auto& i : global_names_) {\n    if (i.second == token) {\n      return i.first;\n    }\n  }\n  for (auto& i : property_names_) {\n    if (i.second == token) {\n      return i.first;\n    }\n  }\n  switch (token) {\n#define V(rawname, name) \\\n  case kToken_##name:    \\\n    return rawname;\n    LONG_SYMBOL_NAME_LIST(V)\n#undef V\n#define V(name, value, string_name) \\\n  case name:                        \\\n    return string_name;\n    SPECIAL_TOKEN_LIST(V)\n    default:\n      break;\n#undef V\n  }\n  UNREACHABLE();\n}\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Seek\",\n                \"parent\": \"AsmJsScanner\",\n                \"about\": \"Seeks to a specific position in the input stream and resets the scanner's state.\",\n                \"logic\": \"Sets the stream position, resets token-related variables, and advances to the next token.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The position to seek to in the input stream.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Utf16CharacterStream\",\n                    \"token_t\",\n                    \"Next\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AsmJsScanner::Seek(size_t pos) {\n  stream_->Seek(pos);\n  preceding_token_ = kUninitialized;\n  token_ = kUninitialized;\n  next_token_ = kUninitialized;\n  preceding_position_ = 0;\n  position_ = 0;\n  next_position_ = 0;\n  rewind_ = false;\n  Next();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ConsumeIdentifier\",\n                \"parent\": \"AsmJsScanner\",\n                \"about\": \"Consumes an identifier from the input stream and determines its token type.\",\n                \"logic\": \"Reads characters until an identifier part is no longer found. Checks if the identifier is a property name, local name, or global name. If not found, it adds the identifier to the appropriate name map (property, local, or global) and assigns it a new token.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ch\",\n                        \"type\": \"base::uc32\",\n                        \"purpose\": \"The first character of the identifier.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Utf16CharacterStream\",\n                    \"token_t\",\n                    \"IsIdentifierPart\",\n                    \"property_names_\",\n                    \"local_names_\",\n                    \"global_names_\",\n                    \"kMaxIdentifierCount\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AsmJsScanner::ConsumeIdentifier(base::uc32 ch) {\n  // Consume characters while still part of the identifier.\n  identifier_string_.clear();\n  while (IsIdentifierPart(ch)) {\n    identifier_string_ += ch;\n    ch = stream_->Advance();\n  }\n  // Go back one for next time.\n  stream_->Back();\n\n  // Decode what the identifier means.\n  if (preceding_token_ == '.') {\n    auto i = property_names_.find(identifier_string_);\n    if (i != property_names_.end()) {\n      token_ = i->second;\n      return;\n    }\n  } else {\n    {\n      auto i = local_names_.find(identifier_string_);\n      if (i != local_names_.end()) {\n        token_ = i->second;\n        return;\n      }\n    }\n    if (!in_local_scope_) {\n      auto i = global_names_."
}