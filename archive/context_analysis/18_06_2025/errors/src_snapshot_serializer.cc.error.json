{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/serializer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/serializer.cc\",\n            \"file_name\": \"serializer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the Serializer class for creating snapshots of the V8 heap.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for snapshot serialization, heap management, object manipulation, and other V8 internals.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/serializer.h\"\n\n#include \"include/v8-internal.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/common/globals.h\"\n#include \"src/handles/global-handles-inl.h\"\n#include \"src/heap/heap-inl.h\"  // For Space::identity().\n#include \"src/heap/mutable-page-metadata-inl.h\"\n#include \"src/heap/read-only-heap.h\"\n#include \"src/heap/visit-object.h\"\n#include \"src/objects/code.h\"\n#include \"src/objects/descriptor-array.h\"\n#include \"src/objects/instance-type-checker.h\"\n#include \"src/objects/instance-type.h\"\n#include \"src/objects/js-array-buffer-inl.h\"\n#include \"src/objects/map.h\"\n#include \"src/objects/objects-body-descriptors-inl.h\"\n#include \"src/objects/slots-inl.h\"\n#include \"src/objects/slots.h\"\n#include \"src/objects/smi.h\"\n#include \"src/sandbox/js-dispatch-table-inl.h\"\n#include \"src/snapshot/embedded/embedded-data.h\"\n#include \"src/snapshot/serializer-deserializer.h\"\n#include \"src/snapshot/serializer-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Serializer\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Serializes the V8 heap into a snapshot.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"cage_base_\",\n                        \"type\": \"PtrComprCageBase\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Cage base for pointer compression.\"\n                    },\n                    {\n                        \"name\": \"hot_objects_\",\n                        \"type\": \"HotObjectsList\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of frequently referenced objects.\"\n                    },\n                    {\n                        \"name\": \"reference_map_\",\n                        \"type\": \"ObjectCacheIndexMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps objects to their back-reference indices.\"\n                    },\n                    {\n                        \"name\": \"external_reference_encoder_\",\n                        \"type\": \"ExternalReferenceEncoder\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Encodes external references.\"\n                    },\n                    {\n                        \"name\": \"root_index_map_\",\n                        \"type\": \"ObjectCacheIndexMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps root objects to their indices.\"\n                    },\n                    {\n                        \"name\": \"deferred_objects_\",\n                        \"type\": \"std::queue<HeapObject>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Queue of objects to be serialized later.\"\n                    },\n                    {\n                        \"name\": \"forward_refs_per_pending_object_\",\n                        \"type\": \"IdentityMap<HeapObject, PendingObjectReferences*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps pending objects to their forward references.\"\n                    },\n                    {\n                        \"name\": \"flags_\",\n                        \"type\": \"Snapshot::SerializerFlags\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flags controlling serialization behavior.\"\n                    },\n                    {\n                        \"name\": \"back_refs_\",\n                        \"type\": \"std::vector<HeapObject>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of back references.\"\n                    },\n                    {\n                        \"name\": \"stack_\",\n                        \"type\": \"std::vector<HeapObject>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stack for recursion tracking.\"\n                    },\n                    {\n                        \"name\": \"instance_type_count_\",\n                        \"type\": \"std::unique_ptr<int[]>[]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counts of instance types for serialization statistics.\"\n                    },\n                    {\n                        \"name\": \"instance_type_size_\",\n                        \"type\": \"std::unique_ptr<size_t[]>[]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Sizes of instance types for serialization statistics.\"\n                    },\n                    {\n                        \"name\": \"allocation_size_\",\n                        \"type\": \"int[]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks allocation sizes for each snapshot space.\"\n                    },\n                    {\n                        \"name\": \"num_back_refs_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counts the number of back references created.\"\n                    },\n                    {\n                        \"name\": \"sink_\",\n                        \"type\": \"SnapshotByteSink\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Byte sink where the serialized data is written.\"\n                    },\n                    {\n                        \"name\": \"seen_backing_stores_index_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Index for off-heap backing stores.\"\n                    },\n                    {\n                        \"name\": \"unresolved_forward_refs_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counts unresolved forward references.\"\n                    },\n                    {\n                        \"name\": \"next_forward_ref_id_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"ID for next forward reference.\"\n                    },\n                    {\n                        \"name\": \"code_address_map_\",\n                        \"type\": \"std::unique_ptr<CodeAddressMap>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps code addresses to names for logging.\"\n                    },\n                    {\n                        \"name\": \"code_buffer_\",\n                        \"type\": \"std::vector<uint8_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Buffer to hold copied code during serialization.\"\n                    },\n                    {\n                        \"name\": \"dispatch_handle_map_\",\n                        \"type\": \"std::unordered_map<JSDispatchHandle, uint32_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps js dispatch handles to their assigned id\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"PtrComprCageBase\",\n                    \"HotObjectsList\",\n                    \"ObjectCacheIndexMap\",\n                    \"ExternalReferenceEncoder\",\n                    \"HeapObject\",\n                    \"Snapshot\",\n                    \"RootIndex\",\n                    \"SerializerReference\",\n                    \"SnapshotByteSink\",\n                    \"CodeAddressMap\",\n                    \"InstructionStream\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nSerializer::Serializer(Isolate* isolate, Snapshot::SerializerFlags flags)\n    : isolate_(isolate),\n#if V8_COMPRESS_POINTERS\n      cage_base_(isolate),\n#endif  // V8_COMPRESS_POINTERS\n      hot_objects_(isolate->heap()),\n      reference_map_(isolate),\n      external_reference_encoder_(isolate),\n      root_index_map_(isolate),\n      deferred_objects_(isolate->heap()),\n      forward_refs_per_pending_object_(isolate->heap()),\n      flags_(flags)\n#ifdef DEBUG\n      ,\n      back_refs_(isolate->heap()),\n      stack_(isolate->heap())\n#endif\n{\n#ifdef VERBOSE_SERIALIZATION_STATISTICS\n  if (v8_flags.serialization_statistics) {\n    for (int space = 0; space < kNumberOfSnapshotSpaces; ++space) {\n      // Value-initialized to 0.\n      instance_type_count_[space] = std::make_unique<int[]>(kInstanceTypes);\n      instance_type_size_[space] = std::make_unique<size_t[]>(kInstanceTypes);\n    }\n  }\n#endif  // VERBOSE_SERIALIZATION_STATISTICS\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PopStack\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Pops an element from the stack for debugging purposes.\",\n                \"logic\": \"Removes the top element from the internal stack.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nvoid Serializer::PopStack() { stack_.Pop(); }\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CountAllocation\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Counts the allocation size for serialization statistics.\",\n                \"logic\": \"Updates the allocation size and instance type counts/sizes based on the allocated object's map and size.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Tagged<Map>\",\n                        \"purpose\": \"Map of the allocated object.\"\n                    },\n                    {\n                        \"name\": \"size\",\n                        \"type\": \"int\",\n                        \"purpose\": \"Size of the allocated object.\"\n                    },\n                    {\n                        \"name\": \"space\",\n                        \"type\": \"SnapshotSpace\",\n                        \"purpose\": \"Memory space where the object was allocated.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Map\",\n                    \"SnapshotSpace\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Serializer::CountAllocation(Tagged<Map> map, int size,\n                                 SnapshotSpace space) {\n  DCHECK(v8_flags.serialization_statistics);\n\n  const int space_number = static_cast<int>(space);\n  allocation_size_[space_number] += size;\n#ifdef VERBOSE_SERIALIZATION_STATISTICS\n  int instance_type = map->instance_type();\n  instance_type_count_[space_number][instance_type]++;\n  instance_type_size_[space_number][instance_type] += size;\n#endif  // VERBOSE_SERIALIZATION_STATISTICS\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TotalAllocationSize\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Calculates the total allocation size across all spaces.\",\n                \"logic\": \"Iterates through all snapshot spaces and sums their allocation sizes.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Total allocation size in bytes.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nint Serializer::TotalAllocationSize() const {\n  int sum = 0;\n  for (int space = 0; space < kNumberOfSnapshotSpaces; space++) {\n    sum += allocation_size_[space];\n  }\n  return sum;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ToString\",\n                \"parent\": null,\n                \"about\": \"Converts a SnapshotSpace enum to a string.\",\n                \"logic\": \"Uses a switch statement to map the SnapshotSpace enum to its corresponding string representation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"space\",\n                        \"type\": \"SnapshotSpace\",\n                        \"purpose\": \"The SnapshotSpace enum to convert.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const char*\",\n                    \"description\": \"String representation of the SnapshotSpace.\"\n                },\n                \"dependencies\": [\n                    \"SnapshotSpace\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nconst char* ToString(SnapshotSpace space) {\n  switch (space) {\n    case SnapshotSpace::kReadOnlyHeap:\n      return \"ReadOnlyHeap\";\n    case SnapshotSpace::kOld:\n      return \"Old\";\n    case SnapshotSpace::kCode:\n      return \"Code\";\n    case SnapshotSpace::kTrusted:\n      return \"Trusted\";\n  }\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"OutputStatistics\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Prints serialization statistics to the console.\",\n                \"logic\": \"Prints the allocation sizes for each snapshot space and, if verbose statistics are enabled, prints the count and size of each instance type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"Name to identify the statistics output.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"SnapshotSpace\",\n                    \"ToString\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Serializer::OutputStatistics(const char* name) {\n  if (!v8_flags.serialization_statistics) return;\n\n  PrintF(\"%s:\\n\", name);\n  if (!serializer_tracks_serialization_statistics()) {\n    PrintF(\"  <serialization statistics are not tracked>\\n\");\n    return;\n  }\n\n  PrintF(\"  Spaces (bytes):\\n\");\n\n  static constexpr SnapshotSpace kAllSnapshotSpaces[] = {\n      SnapshotSpace::kReadOnlyHeap,\n      SnapshotSpace::kOld,\n      SnapshotSpace::kCode,\n  };\n\n  for (SnapshotSpace space : kAllSnapshotSpaces) {\n    PrintF(\"%16s\", ToString(space));\n  }\n  PrintF(\"\\n\");\n\n  for (SnapshotSpace space : kAllSnapshotSpaces) {\n    PrintF(\"%16zu\", allocation_size_[static_cast<int>(space)]);\n  }\n  PrintF(\"\\n\");\n\n#ifdef VERBOSE_SERIALIZATION_STATISTICS\n  PrintF(\"  Instance types (count and bytes):\\n\");\n#define PRINT_INSTANCE_TYPE(Name)                                           \\\n  for (SnapshotSpace space : kAllSnapshotSpaces) {                          \\\n    const int space_i = static_cast<int>(space);                            \\\n    if (instance_type_count_[space_i][Name]) {                              \\\n      PrintF(\"%10d %10zu  %-10s %s\\n\", instance_type_count_[space_i][Name], \\\n             instance_type_size_[space_i][Name], ToString(space), #Name);   \\\n    }                                                                       \\\n  }\n  INSTANCE_TYPE_LIST(PRINT_INSTANCE_TYPE)\n#undef PRINT_INSTANCE_TYPE\n  PrintF(\"\\n\");\n#endif  // VERBOSE_SERIALIZATION_STATISTICS\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeDeferredObjects\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Serializes objects that were deferred during the initial serialization pass.\",\n                \"logic\": \"Iterates through the queue of deferred objects, serializing each one using an ObjectSerializer.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\",\n                    \"ObjectSerializer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Serializer::SerializeDeferredObjects() {\n  if (v8_flags.trace_serializer) {\n    PrintF(\"Serializing deferred objects\\n\");\n  }\n  WHILE_WITH_HANDLE_SCOPE(isolate(), !deferred_objects_.empty(), {\n    Handle<HeapObject> obj = handle(deferred_objects_.Pop(), isolate());\n\n    ObjectSerializer obj_serializer(this, obj, &sink_);\n    obj_serializer.SerializeDeferred();\n  });\n  sink_.Put(kSynchronize, \"Finished with deferred objects\");\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeObject\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Serializes a HeapObject, handling special cases like ThinStrings and Code objects.\",\n                \"logic\": \"If the object is a ThinString, it serializes the underlying actual string. If the object is baseline Code, it serializes the BytecodeArray instead. Otherwise, it calls SerializeObjectImpl.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"purpose\": \"The object to serialize.\"\n                    },\n                    {\n                        \"name\": \"slot_type\",\n                        \"type\": \"SlotType\",\n                        \"purpose\": \"Type of the slot containing the object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\",\n                    \"ThinString\",\n                    \"Code\",\n                    \"BytecodeArray\",\n                    \"SerializeObjectImpl\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Serializer::SerializeObject(Handle<HeapObject> obj, SlotType slot_type) {\n  // ThinStrings are just an indirection to an internalized string, so elide the\n  // indirection and serialize the actual string directly.\n  if (IsThinString(*obj, isolate())) {\n    obj = handle(Cast<ThinString>(*obj)->actual(), isolate());\n  } else if (IsCode(*obj, isolate())) {\n    Tagged<Code> code = Cast<Code>(*obj);\n    // The only expected Code objects here are baseline code and builtins.\n    if (code->kind() == CodeKind::BASELINE) {\n      // For now just serialize the BytecodeArray instead of baseline code.\n      // TODO(v8:11429,pthier): Handle Baseline code in cases we want to\n      // serialize it.\n      obj = handle(code->bytecode_or_interpreter_data(), isolate());\n    } else {\n      CHECK(code->is_builtin());\n    }\n  }\n  SerializeObjectImpl(obj, slot_type);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MustBeDeferred\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Determines if an object must be deferred for serialization.\",\n                \"logic\": \"Always returns false in this base class implementation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The object to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"False, indicating the object does not need to be deferred.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Serializer::MustBeDeferred(Tagged<HeapObject> object) { return false; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitRootPointers\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Serializes root objects within a given range.\",\n                \"logic\": \"Iterates through the specified root slots, serializing each one.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"root\",\n                        \"type\": \"Root\",\n                        \"purpose\": \"The root being visited.\"\n                    },\n                    {\n                        \"name\": \"description\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"Description of the root.\"\n                    },\n                    {\n                        \"name\": \"start\",\n                        \"type\": \"FullObjectSlot\",\n                        \"purpose\": \"Starting slot.\"\n                    },\n                    {\n                        \"name\": \"end\",\n                        \"type\": \"FullObjectSlot\",\n                        \"purpose\": \"Ending slot.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"FullObjectSlot\",\n                    \"SerializeRootObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Serializer::VisitRootPointers(Root root, const char* description,\n                                   FullObjectSlot start, FullObjectSlot end) {\n  for (FullObjectSlot current = start; current < end; ++current) {\n    SerializeRootObject(current);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeRootObject\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Serializes a single root object.\",\n                \"logic\": \"If the root is a Smi, it calls PutSmiRoot. Otherwise, it serializes the object using SerializeObject.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"slot\",\n                        \"type\": \"FullObjectSlot\",\n                        \"purpose\": \"The slot containing the root object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"FullObjectSlot\",\n                    \"Smi\",\n                    \"HeapObject\",\n                    \"PutSmiRoot\",\n                    \"SerializeObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Serializer::SerializeRootObject(FullObjectSlot slot) {\n  Tagged<Object> o = *slot;\n  if (IsSmi(o)) {\n    PutSmiRoot(slot);\n  } else {\n    SerializeObject(Handle<HeapObject>(slot.location()), SlotType::kAnySlot);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PrintStack\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Prints the contents of the stack (for debugging).\",\n                \"logic\": \"Iterates through the stack and prints each object.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nvoid Serializer::PrintStack() { PrintStack(std::cout); }\n\nvoid Serializer::PrintStack(std::ostream& out) {\n  for (const auto o : stack_) {\n    Print(*o, out);\n    out << \"\\n\";\n  }\n}\n#endif  // DEBUG\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeRoot\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Serializes a root object by its RootIndex.\",\n                \"logic\": \"Looks up the root in the root_index_map_ and serializes it, otherwise returns false\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The root object to serialize.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if root was serialized, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\",\n                    \"RootIndex\",\n                    \"PutRoot\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Serializer::SerializeRoot(Tagged<HeapObject> obj) {\n  RootIndex root_index;\n  // Derived serializers are responsible for determining if the root has\n  // actually been serialized before calling this.\n  if (root_index_map()->Lookup(obj, &root_index)) {\n    PutRoot(root_index);\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeHotObject\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Serializes a 'hot' object (frequently referenced) by its index.\",\n                \"logic\": \"Looks up the object in the hot_objects_ list and serializes it if found.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The object to serialize.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object was serialized as a hot object, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Serializer::SerializeHotObject(Tagged<HeapObject> obj) {\n  DisallowGarbageCollection no_gc;\n  // Encode a reference to a hot object by its index in the working set.\n  int index = hot_objects_.Find(obj);\n  if (index == HotObjectsList::kNotFound) return false;\n  DCHECK(index >= 0 && index < kHotObjectCount);\n  if (v8_flags.trace_serializer) {\n    PrintF(\" Encoding hot object %d:\", index);\n    ShortPrint(obj);\n    PrintF(\"\\n\");\n  }\n  sink_.Put(HotObject::Encode(index), \"HotObject\");\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeBackReference\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Serializes a back reference to an already serialized object.\",\n                \"logic\": \"Looks up the object in the reference_map_ and serializes its back reference index.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The object to serialize a back reference to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object was serialized as a back reference, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\",\n                    \"SerializerReference\",\n                    \"PutBackReference\",\n                    \"PutAttachedReference\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Serializer::SerializeBackReference(Tagged<HeapObject> obj) {\n  DisallowGarbageCollection no_gc;\n  const SerializerReference* reference = reference_map_.LookupReference(obj);\n  if (reference == nullptr) return false;\n  // Encode the location of an already deserialized object in order to write\n  // its location into a later object.  We can encode the location as an\n  // offset from the start of the deserialized objects or as an offset\n  // backwards from the current allocation pointer.\n  if (reference->is_attached_reference()) {\n    if (v8_flags.trace_serializer) {\n      PrintF(\" Encoding attached reference %d\\n\",\n             reference->attached_reference_index());\n    }\n    PutAttachedReference(*reference);\n  } else {\n    DCHECK(reference->is_back_reference());\n    if (v8_flags.trace_serializer) {\n      PrintF(\" Encoding back reference to: \");\n      ShortPrint(obj);\n      PrintF(\"\\n\");\n    }\n\n    sink_.Put(kBackref, \"Backref\");\n    PutBackReference(obj, *reference);\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializePendingObject\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Serializes a reference to an object that is pending serialization.\",\n                \"logic\": \"Looks up the object in the forward_refs_per_pending_object_ map and serializes the forward reference.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The pending object to serialize a reference to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object was serialized as a pending object reference, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\",\n                    \"PutPendingForwardReference\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Serializer::SerializePendingObject(Tagged<HeapObject> obj) {\n  PendingObjectReferences* refs_to_object =\n      forward_refs_per_pending_object_.Find(obj);\n  if (refs_to_object == nullptr) {\n    return false;\n  }\n  PutPendingForwardReference(*refs_to_object);\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ObjectIsBytecodeHandler\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Checks if a HeapObject is a bytecode handler.\",\n                \"logic\": \"Checks if the object is Code and its kind is BYTECODE_HANDLER.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The object to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object is a bytecode handler, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\",\n                    \"Code\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Serializer::ObjectIsBytecodeHandler(Tagged<HeapObject> obj) const {\n  if (!IsCode(obj)) return false;\n  return (Cast<Code>(obj)->kind() == CodeKind::BYTECODE_HANDLER);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PutRoot\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Writes a root object reference to the snapshot.\",\n                \"logic\": \"Serializes a root object using either a short or long encoding based on the root index and object location.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"root\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The root index of the object to serialize.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"HeapObject\",\n                    \"RootIndex\",\n                    \"HotObjectsList\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Serializer::PutRoot(RootIndex root) {\n  DisallowGarbageCollection no_gc;\n  int root_index = static_cast<int>(root);\n  Tagged<HeapObject> object = Cast<HeapObject>(isolate()->root(root));\n  if (v8_flags.trace_serializer) {\n    PrintF(\" Encoding root %d:\", root_index);\n    ShortPrint(object);\n    PrintF(\"\\n\");\n  }\n\n  // Assert that the first 32 root array items are a conscious choice. They are\n  // chosen so that the most common ones can be encoded more efficiently.\n  static_assert(static_cast<int>(RootIndex::kArgumentsMarker) ==\n                kRootArrayConstantsCount - 1);\n\n  // TODO(ulan): Check that it works with young large objects.\n  if (root_index < kRootArrayConstantsCount &&\n      !HeapLayout::InYoungGeneration(object)) {\n    sink_.Put(RootArrayConstant::Encode(root), \"RootConstant\");\n  } else {\n    sink_.Put(kRootArray, \"RootSerialization\");\n    sink_.PutUint30(root_index, \"root_index\");\n    hot_objects_.Add(object);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PutSmiRoot\",\n                \"parent\": \"Serializer\",\n                \"about\": \"Writes a Smi root object reference to the snapshot.\",\n                \"logic\": \"Serializes a Smi root by outputting its raw value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"slot\",\n                        \"type\": \"FullObjectSlot\",\n                        \"purpose\": \"The slot containing the Smi root object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"FullObjectSlot\",\n                    \"Smi\"\n                "
}