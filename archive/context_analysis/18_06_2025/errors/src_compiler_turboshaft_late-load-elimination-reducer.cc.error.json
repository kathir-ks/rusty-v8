{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/late-load-elimination-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/late-load-elimination-reducer.cc\",\n        \"file_name\": \"late-load-elimination-reducer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements a late load elimination optimization pass for the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for compiler, backend, and object representations.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/late-load-elimination-reducer.h\"\n\n#include \"src/compiler/backend/instruction.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/turboshaft/operation-matcher.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/objects/code-inl.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the output stream operator for MemoryAddress to provide a human-readable representation.\",\n            \"logic\": \"Outputs the members of the MemoryAddress structure to the provided output stream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to write to.\"\n                },\n                {\n                    \"name\": \"mem\",\n                    \"type\": \"const MemoryAddress&\",\n                    \"purpose\": \"The MemoryAddress object to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const MemoryAddress& mem) {\n  return os << \"MemoryAddress{base=\" << mem.base << \", index=\" << mem.index\n            << \", offset=\" << mem.offset << \", elem_size_log2=\"\n            << static_cast<uint32_t>(mem.element_size_log2)\n            << \", size=\" << static_cast<uint32_t>(mem.size) << \"}\";\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Run\",\n            \"parent\": \"LateLoadEliminationAnalyzer\",\n            \"about\": \"The main entry point for the late load elimination analysis.\",\n            \"logic\": \"Iterates through the graph, analyzes each block, and identifies loads that can be eliminated based on memory state and alias analysis.  It also handles loop reprocessing and int32 truncation optimizations.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"LoopFinder\",\n                \"AnalyzerIterator\",\n                \"ProcessBlock\",\n                \"GotoOp\",\n                \"FixedOpIndexSidetable\",\n                \"GetReplacement\",\n                \"IsLoadElimination\",\n                \"Replacement\",\n                \"SaturatedUint8\",\n                \"DCHECK\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LateLoadEliminationAnalyzer::Run() {\n  TRACE(\"LateLoadElimination: Starting analysis\");\n  LoopFinder loop_finder(phase_zone_, &graph_);\n  AnalyzerIterator iterator(phase_zone_, graph_, loop_finder);\n\n  bool compute_start_snapshot = true;\n  while (iterator.HasNext()) {\n    const Block* block = iterator.Next();\n\n    ProcessBlock(*block, compute_start_snapshot);\n    compute_start_snapshot = true;\n\n    // Consider re-processing for loops.\n    if (const GotoOp* last = block->LastOperation(graph_).TryCast<GotoOp>()) {\n      if (last->destination->IsLoop() &&\n          last->destination->LastPredecessor() == block) {\n        TRACE(\"> Considering reprocessing loop header \" << last->destination);\n        const Block* loop_header = last->destination;\n        // {block} is the backedge of a loop. We recompute the loop header's\n        // initial snapshots, and if they differ from its original snapshot,\n        // then we revisit the loop.\n        if (BeginBlock<true>(loop_header)) {\n          TRACE(\">> Will need to revisit loop\");\n          // We set the snapshot of the loop's 1st predecessor to the newly\n          // computed snapshot. It's not quite correct, but this predecessor\n          // is guaranteed to end with a Goto, and we are now visiting the\n          // loop, which means that we don't really care about this\n          // predecessor anymore.\n          // The reason for saving this snapshot is to prevent infinite\n          // looping, since the next time we reach this point, the backedge\n          // snapshot could still invalidate things from the forward edge\n          // snapshot. By restricting the forward edge snapshot, we prevent\n          // this.\n          const Block* loop_1st_pred =\n              loop_header->LastPredecessor()->NeighboringPredecessor();\n          FinishBlock(loop_1st_pred);\n          // And we start a new fresh snapshot from this predecessor.\n          auto pred_snapshots =\n              block_to_snapshot_mapping_[loop_1st_pred->index()];\n          non_aliasing_objects_.StartNewSnapshot(\n              pred_snapshots->alias_snapshot);\n          object_maps_.StartNewSnapshot(pred_snapshots->maps_snapshot);\n          memory_.StartNewSnapshot(pred_snapshots->memory_snapshot);\n\n          iterator.MarkLoopForRevisit();\n          compute_start_snapshot = false;\n        } else {\n          TRACE(\">> No need to revisit loop\");\n          SealAndDiscard();\n        }\n      }\n    }\n  }\n\n  FixedOpIndexSidetable<SaturatedUint8> total_use_counts(graph_.op_id_count(),\n                                                         phase_zone_, &graph_);\n  // Incorpoare load elimination decisions into int32-truncation data.\n  for (auto it = int32_truncated_loads_.begin();\n       it != int32_truncated_loads_.end();) {\n    OpIndex load_idx = it->first;\n    auto& truncations = it->second;\n    Replacement replacement = GetReplacement(load_idx);\n    // We distinguish a few different cases.\n    if (!replacement.IsLoadElimination()) {\n      // Case 1: This load is not going to be eliminated.\n      total_use_counts[load_idx] += graph_.Get(load_idx).saturated_use_count;\n      // Check if all uses we know so far, are all truncating uses.\n      if (total_use_counts[load_idx].IsSaturated() ||\n          total_use_counts[load_idx].Get() > truncations.size()) {\n        // We do know that we cannot int32-truncate this load, so eliminate\n        // it from the candidates.\n        int32_truncated_loads_.erase(it++);\n        continue;\n      }\n      // Otherwise, keep this candidate.\n      ++it;\n      continue;\n    } else {\n      OpIndex replaced_by_idx = replacement.replacement();\n      const Operation& replaced_by = graph_.Get(replaced_by_idx);\n      if (!replaced_by.Is<LoadOp>()) {\n        // Case 2: This load is replaced by a non-load (e.g. by the value\n        // stored that the load would read). This load cannot be truncated\n        // (because we are not going to have a load anymore), so eliminate it\n        // from the candidates.\n        int32_truncated_loads_.erase(it++);\n        continue;\n      } else {\n        // Case 3: This load is replaced by another load, so the truncating\n        // and the total uses have to be merged into the replacing use.\n        auto it2 = int32_truncated_loads_.find(replaced_by_idx);\n        if (it2 == int32_truncated_loads_.end()) {\n          // Case 3a: The replacing load is not tracked, so we assume it has\n          // non-truncating uses, so we can also ignore this load.\n          int32_truncated_loads_.erase(it++);\n          continue;\n        } else {\n          // Case 3b: The replacing load might have be a candidate for int32\n          // truncation, we merge the information into that load.\n          total_use_counts[replaced_by_idx] +=\n              graph_.Get(load_idx).saturated_use_count;\n          it2->second.insert(truncations.begin(), truncations.end());\n          int32_truncated_loads_.erase(it++);\n          continue;\n        }\n      }\n    }\n  }\n\n  // We have prepared everything and now extract the necessary replacement\n  // information.\n  for (const auto& [load_idx, int32_truncations] : int32_truncated_loads_) {\n    if (int32_truncations.empty()) continue;\n    if (!total_use_counts[load_idx].IsSaturated() &&\n        total_use_counts[load_idx].Get() == int32_truncations.size()) {\n      // All uses of this load are int32-truncating loads, so we replace them.\n      DCHECK(GetReplacement(load_idx).IsNone() ||\n             GetReplacement(load_idx).IsTaggedLoadToInt32Load());\n      for (const auto [change_idx, bitcast_idx] : int32_truncations) {\n        replacements_[change_idx] =\n            Replacement::Int32TruncationElimination(load_idx);\n        replacements_[bitcast_idx] = Replacement::TaggedBitcastElimination();\n        replacements_[load_idx] = Replacement::TaggedLoadToInt32Load();\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessBlock\",\n            \"parent\": \"LateLoadEliminationAnalyzer\",\n            \"about\": \"Processes a single block in the graph, iterating through its operations and applying load elimination logic.\",\n            \"logic\": \"Handles different operation types like Load, Store, Allocate, Call, AssumeMap, and Change to either eliminate loads or update the analysis state.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const Block&\",\n                    \"purpose\": \"The block to process.\"\n                },\n                {\n                    \"name\": \"compute_start_snapshot\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether to compute the initial snapshot for the block.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"BeginBlock\",\n                \"ShouldSkipOptimizationStep\",\n                \"ShouldSkipOperation\",\n                \"ProcessLoad\",\n                \"ProcessStore\",\n                \"ProcessAllocate\",\n                \"ProcessCall\",\n                \"ProcessAssumeMap\",\n                \"ProcessChange\",\n                \"DcheckWordBinop\",\n                \"InvalidateAllNonAliasingInputs\",\n                \"FinishBlock\",\n                \"LoadOp\",\n                \"StoreOp\",\n                \"AllocateOp\",\n                \"CallOp\",\n                \"AssumeMapOp\",\n                \"ChangeOp\",\n                \"SuccessorBlocks\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LateLoadEliminationAnalyzer::ProcessBlock(const Block& block,\n                                               bool compute_start_snapshot) {\n  TRACE(\"> ProcessBlock(\" << block.index() << \")\");\n  if (compute_start_snapshot) {\n    BeginBlock(&block);\n  }\n  if (block.IsLoop() && BackedgeHasSnapshot(block)) {\n    // Update the associated snapshot for the forward edge with the merged\n    // snapshot information from the forward- and backward edge.\n    // This will make sure that when evaluating whether a loop needs to be\n    // revisited, the inner loop compares the merged state with the backedge\n    // preventing us from exponential revisits for loops where the backedge\n    // invalidates loads which are eliminatable on the forward edge.\n    StoreLoopSnapshotInForwardPredecessor(block);\n  }\n\n  for (OpIndex op_idx : graph_.OperationIndices(block)) {\n    Operation& op = graph_.Get(op_idx);\n    if (ShouldSkipOptimizationStep()) continue;\n    if (ShouldSkipOperation(op)) continue;\n    switch (op.opcode) {\n      case Opcode::kLoad:\n        // Eliminate load or update state\n        ProcessLoad(op_idx, op.Cast<LoadOp>());\n        break;\n      case Opcode::kStore:\n        // Update state (+ maybe invalidate aliases)\n        ProcessStore(op_idx, op.Cast<StoreOp>());\n        break;\n      case Opcode::kAllocate:\n        // Create new non-alias\n        ProcessAllocate(op_idx, op.Cast<AllocateOp>());\n        break;\n      case Opcode::kCall:\n        // Invalidate state (+ maybe invalidate aliases)\n        ProcessCall(op_idx, op.Cast<CallOp>());\n        break;\n      case Opcode::kAssumeMap:\n        // Update known maps\n        ProcessAssumeMap(op_idx, op.Cast<AssumeMapOp>());\n        break;\n      case Opcode::kChange:\n        // Check for tagged -> word32 load replacement\n        ProcessChange(op_idx, op.Cast<ChangeOp>());\n        break;\n\n      case Opcode::kWordBinop:\n        // A WordBinop should never invalidate aliases (since the only time when\n        // it should take a non-aliasing object as input is for Smi checks).\n        DcheckWordBinop(op_idx, op.Cast<WordBinopOp>());\n        break;\n\n      case Opcode::kFrameState:\n      case Opcode::kDeoptimizeIf:\n      case Opcode::kComparison:\n#ifdef V8_ENABLE_WEBASSEMBLY\n      case Opcode::kTrapIf:\n#endif\n        // We explicitly break for these opcodes so that we don't call\n        // InvalidateAllNonAliasingInputs on their inputs, since they don't\n        // really create aliases. (and also, they don't write so it's\n        // fine to break)\n        DCHECK(!op.Effects().can_write());\n        break;\n\n      case Opcode::kDeoptimize:\n      case Opcode::kReturn:\n        // We explicitly break for these opcodes so that we don't call\n        // InvalidateAllNonAliasingInputs on their inputs, since they are block\n        // terminators without successors, meaning that it's not useful for the\n        // rest of the analysis to invalidate anything here.\n        DCHECK(op.IsBlockTerminator() && SuccessorBlocks(op).empty());\n        break;\n\n      case Opcode::kCatchBlockBegin:\n      case Opcode::kRetain:\n      case Opcode::kDidntThrow:\n      case Opcode::kCheckException:\n      case Opcode::kAtomicRMW:\n      case Opcode::kAtomicWord32Pair:\n      case Opcode::kMemoryBarrier:\n      case Opcode::kParameter:\n      case Opcode::kDebugBreak:\n      case Opcode::kJSStackCheck:\n#ifdef V8_ENABLE_WEBASSEMBLY\n      case Opcode::kWasmStackCheck:\n      case Opcode::kSimd128LaneMemory:\n      case Opcode::kGlobalSet:\n      case Opcode::kArraySet:\n      case Opcode::kStructSet:\n      case Opcode::kSetStackPointer:\n#endif  // V8_ENABLE_WEBASSEMBLY\n        // We explicitly break for those operations that have can_write effects\n        // but don't actually write, or cannot interfere with load elimination.\n        break;\n      default:\n        // Operations that `can_write` should invalidate the state. All such\n        // operations should be already handled above, which means that we don't\n        // need a `if (can_write) { Invalidate(); }` here.\n        CHECK(!op.Effects().can_write());\n\n        // Even if the operation doesn't write, it could create an alias to its\n        // input by returning it. This happens for instance in Phis and in\n        // Change (although ChangeOp is already handled earlier by calling\n        // ProcessChange). We are conservative here by calling\n        // InvalidateAllNonAliasingInputs for all operations even though only\n        // few can actually create aliases to fresh allocations, the reason\n        // being that missing such a case would be a security issue, and it\n        // should be rare for fresh allocations to be used outside of\n        // Call/Store/Load/Change anyways.\n        TRACE(\"> Process other op (id=\" << op_idx << \")\");\n        InvalidateAllNonAliasingInputs(op);\n\n        break;\n    }\n  }\n\n  FinishBlock(&block);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"RepIsCompatible\",\n            \"about\": \"Checks if replacing a load with a register representation {expected_reg_rep} and memory representation {expected_loaded_repr} with an operation with register representation {actual} is valid.\",\n            \"logic\": \"Compares sizes and register representations to ensure compatibility between the load and the replacement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"actual\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The actual register representation.\"\n                },\n                {\n                    \"name\": \"expected_reg_rep\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The expected register representation.\"\n                },\n                {\n                    \"name\": \"expected_loaded_repr\",\n                    \"type\": \"MemoryRepresentation\",\n                    \"purpose\": \"The expected memory representation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the replacement is compatible, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\n// Returns true if replacing a Load with a RegisterRepresentation\n// {expected_reg_rep} and MemoryRepresentation of {expected_loaded_repr} with an\n// operation with RegisterRepresentation {actual} is valid. For instance,\n// replacing an operation that returns a Float64 by one that returns a Word64 is\n// not valid. Similarly, replacing a Tagged with an untagged value is probably\n// not valid because of the GC.\nbool RepIsCompatible(RegisterRepresentation actual,\n                     RegisterRepresentation expected_reg_rep,\n                     MemoryRepresentation expected_loaded_repr) {\n  if (expected_loaded_repr.SizeInBytes() !=\n      MemoryRepresentation::FromRegisterRepresentation(actual, true)\n          .SizeInBytes()) {\n    // The replacement was truncated when being stored or should be truncated\n    // (or sign-extended) during the load. Since we don't have enough\n    // truncations operators in Turboshaft (eg, we don't have Int32 to Int8\n    // truncation), we just prevent load elimination in this case.\n\n    // TODO(dmercadier): add more truncations operators to Turboshaft, and\n    // insert the correct truncation when there is a mismatch between\n    // {expected_loaded_repr} and {actual}.\n\n    return false;\n  }\n\n  return expected_reg_rep == actual;\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessLoad\",\n            \"parent\": \"LateLoadEliminationAnalyzer\",\n            \"about\": \"Processes a Load operation, attempting to eliminate it or updating the analysis state.\",\n            \"logic\": \"Checks if the load is eliminable, atomic, or from an external constant. If a suitable replacement exists in memory_, it attempts to eliminate the load. Otherwise, the load is inserted into memory_.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the Load operation.\"\n                },\n                {\n                    \"name\": \"load\",\n                    \"type\": \"const LoadOp&\",\n                    \"purpose\": \"The Load operation to process.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"memory_\",\n                \"RepIsCompatible\",\n                \"ConstantOp\",\n                \"GetReplacement\",\n                \"Replacement\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LateLoadEliminationAnalyzer::ProcessLoad(OpIndex op_idx,\n                                              const LoadOp& load) {\n  TRACE(\"> ProcessLoad(\" << op_idx << \")\");\n\n  if (!load.kind.load_eliminable) {\n    // We don't optimize Loads/Stores to addresses that could be accessed\n    // non-canonically.\n    TRACE(\">> Not load-eliminable; skipping\");\n    return;\n  }\n  if (load.kind.is_atomic) {\n    // Atomic loads cannot be eliminated away, but potential concurrency\n    // invalidates known stored values.\n    TRACE(\">> Atomic load, invalidating related memory\");\n    memory_.Invalidate(load.base(), load.index(), load.offset);\n    return;\n  }\n\n  // We need to insert the load into the truncation mapping as a key, because\n  // all loads need to be revisited during processing.\n  int32_truncated_loads_[op_idx];\n\n  if (OpIndex existing = memory_.Find(load); existing.valid()) {\n    const Operation& replacement = graph_.Get(existing);\n    // We need to make sure that {load} and {replacement} have the same output\n    // representation. In particular, in unreachable code, it's possible that\n    // the two of them have incompatible representations (like one could be\n    // Tagged and the other one Float64).\n    DCHECK_EQ(replacement.outputs_rep().size(), 1);\n    DCHECK_EQ(load.outputs_rep().size(), 1);\n    TRACE(\">> Found potential replacement at offset \" << existing);\n    if (RepIsCompatible(replacement.outputs_rep()[0], load.outputs_rep()[0],\n                        load.loaded_rep)) {\n      TRACE(\">>> Confirming replacement\");\n      replacements_[op_idx] = Replacement::LoadElimination(existing);\n      return;\n    } else {\n      TRACE(\">>> Replacement has wrong representation: \"\n            << replacement.outputs_rep()[0] << \" instead of \"\n            << load.outputs_rep()[0]);\n    }\n  }\n  // Reset the replacement of {op_idx} to Invalid, in case a previous visit of a\n  // loop has set it to something else.\n  replacements_[op_idx] = Replacement::None();\n\n  // TODO(dmercadier): if we precisely track maps, then we could know from the\n  // map what we are loading in some cases. For instance, if the elements_kind\n  // of the map is *_DOUBLE_ELEMENTS, then a load at offset\n  // JSObject::kElementsOffset always load a FixedDoubleArray, with map\n  // fixed_double_array_map.\n\n  if (const ConstantOp* base = graph_.Get(load.base()).TryCast<ConstantOp>();\n      base != nullptr && base->kind == ConstantOp::Kind::kExternal) {\n    // External constants can be written by other threads, so we don't\n    // load-eliminate them, in order to always reload them.\n    TRACE(\">> Ignoring load from External constant\");\n    return;\n  }\n\n  memory_.Insert(load, op_idx);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessStore\",\n            \"parent\": \"LateLoadEliminationAnalyzer\",\n            \"about\": \"Processes a Store operation, updating the analysis state and potentially invalidating aliases.\",\n            \"logic\": \"Invalidates relevant memory locations and inserts the store into memory_ to update known stored values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the Store operation.\"\n                },\n                {\n                    \"name\": \"store\",\n                    \"type\": \"const StoreOp&\",\n                    \"purpose\": \"The Store operation to process.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"memory_\",\n                \"non_aliasing_objects_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LateLoadEliminationAnalyzer::ProcessStore(OpIndex op_idx,\n                                               const StoreOp& store) {\n  TRACE(\"> ProcessStore(\" << op_idx << \")\");\n  // If we have a raw base and we allow those to be inner pointers, we can\n  // overwrite arbitrary values and need to invalidate anything that is\n  // potentially aliasing.\n  const bool invalidate_maybe_aliasing =\n      !store.kind.tagged_base &&\n      raw_base_assumption_ == RawBaseAssumption::kMaybeInnerPointer;\n\n  if (invalidate_maybe_aliasing) {\n    TRACE(\n        \">> Raw base or maybe inner pointer ==> Invalidating whole \"\n        \"maybe-aliasing memory\");\n    memory_.InvalidateMaybeAliasing();\n  }\n\n  if (!store.kind.load_eliminable) {\n    // We don't optimize Loads/Stores to addresses that could be accessed\n    // non-canonically.\n    TRACE(\">> Not load-eliminable; skipping\");\n    return;\n  }\n\n  // Updating the known stored values.\n  if (!invalidate_maybe_aliasing) memory_.Invalidate(store);\n  memory_.Insert(store);\n\n  // Updating aliases if the value stored was known as non-aliasing.\n  OpIndex value = store.value();\n  if (non_aliasing_objects_.HasKeyFor(value)) {\n    TRACE(\">> Invalidate non-alias for value=\" << value);\n    non_aliasing_objects_.Set(value, false);\n  }\n\n  // If we just stored a map, invalidate the maps for this base.\n  if (store.offset == HeapObject::kMapOffset && !store.index().valid()) {\n    if (object_maps_.HasKeyFor(store.base())) {\n      TRACE(\">> Wiping map\\n\");\n      object_maps_.Set(store.base(), MapMaskAndOr{});\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessCall\",\n            \"parent\": \"LateLoadEliminationAnalyzer\",\n            \"about\": \"Processes a Call operation, invalidating relevant memory locations and tracking non-aliasing return values.\",\n            \"logic\": \"Checks if the call has side effects that invalidate memory or create aliases. Invalidates memory and updates alias information accordingly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the Call operation.\"\n                },\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const CallOp&\",\n                    \"purpose\": \"The Call operation to process.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"non_aliasing_objects_\",\n                \"memory_\",\n                \"InvalidateAllNonAliasingInputs\",\n                \"TryGetBuiltinId\",\n                \"broker_\",\n                \"ExternalReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Since we only loosely keep track of what can or can't alias, we assume that\n// anything that was guaranteed to not alias with anything (because it's in\n// {non_aliasing_objects_}) can alias with anything when coming back from the\n// call if it was an argument of the call.\nvoid LateLoadEliminationAnalyzer::ProcessCall(OpIndex op_idx,\n                                              const CallOp& op) {\n  TRACE(\"> ProcessCall(\" << op_idx << \")\");\n  const Operation& callee = graph_.Get(op.callee());\n#ifdef DEBUG\n  if (const ConstantOp* external_constant =\n          callee.template TryCast<Opmask::kExternalConstant>()) {\n    if (external_constant->external_reference() ==\n        ExternalReference::check_object_type()) {\n      return;\n    }\n  }\n#endif\n\n  // Some builtins do not create aliases and do not invalidate existing\n  // memory, and some even return fresh objects. For such cases, we don't\n  // invalidate the state, and record the non-alias if any.\n  if (!op.Effects().can_write()) {\n    TRACE(\">> Call doesn't write, skipping\");\n    return;\n  }\n  // Note: This does not detect wasm stack checks, but those are detected by the\n  // check just above.\n  if (op.IsStackCheck(graph_, broker_, StackCheckKind::kJSIterationBody)) {\n    // This is a stack check that cannot write heap memory.\n    TRACE(\">> Call is loop stack check, skipping\");\n    return;\n  }\n\n  auto builtin_id = TryGetBuiltinId(callee.TryCast<ConstantOp>(), broker_);\n\n  if (builtin_id) {\n    switch (*builtin_id) {\n      // TODO(dmercadier): extend this list.\n      case Builtin::kCopyFastSmiOrObjectElements:\n        // This function just replaces the Elements array of an object.\n        // It doesn't invalidate any alias or any other memory than this\n        // Elements array.\n        TRACE(\n            \">> Call is CopyFastSmiOrObjectElements, invalidating only \"\n            \"Elements for \"\n            << op.arguments()[0]);\n        memory_.Invalidate(op.arguments()[0], OpIndex::Invalid(),\n                           JSObject::kElementsOffset);\n        return;\n      default:\n        break;\n    }\n  }\n\n  // Not a builtin call, or not a builtin that we know doesn't invalidate\n  // memory.\n  InvalidateAllNonAliasingInputs(op);\n\n  if (builtin_id) {\n    switch (*builtin_id) {\n      case Builtin::kCreateShallowObjectLiteral:\n        // This builtin creates a fresh non-aliasing object.\n        non_aliasing_objects_.Set(op_idx, true);\n        break;\n      default:\n        break;\n    }\n  }\n\n  // The call could modify arbitrary memory, so we invalidate every\n  // potentially-aliasing object.\n  memory_.InvalidateMaybeAliasing();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DcheckWordBinop\",\n            \"parent\": \"LateLoadEliminationAnalyzer\",\n            \"about\": \"Performs a debug check on WordBinop operations involving non-aliasing objects.\",\n            \"logic\": \"Ensures that WordBinop operations on non-aliasing objects are only used for Smi checks.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the WordBinop operation.\"\n                },\n                {\n                    \"name\": \"binop\",\n                    \"type\": \"const WordBinopOp&\",\n                    \"purpose\": \"The WordBinop operation to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"non_aliasing_objects_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// The only time an Allocate should flow into a WordBinop is for Smi checks\n// (which, by the way, should be removed by MachineOptimizationReducer (since\n// Allocate never returns a Smi), but there is no guarantee that this happens\n// before load elimination). So, there is no need to invalidate non-aliases, and\n// we just DCHECK in this function that indeed, nothing else than a Smi check\n// happens on non-aliasing objects.\nvoid LateLoadEliminationAnalyzer::DcheckWordBinop(OpIndex op_idx,\n                                                  const WordBinopOp& binop) {\n#ifdef DEBUG\n  auto check = [&](V<Word> left, V<Word> right) {\n    if (auto key = non_aliasing_objects_.TryGetKeyFor(left);\n        key.has_value() && non_aliasing_objects_.Get(*key)) {\n      int64_t cst;\n      DCHECK_EQ(binop.kind, WordBinopOp::Kind::kBitwiseAnd);\n      DCHECK(OperationMatcher(graph_).MatchSignedIntegralConstant(right, &cst));\n      DCHECK_EQ(cst, kSmiTagMask);\n    }\n  };\n  check(binop.left(), binop.right());\n  check(binop.right(), binop.left());\n#endif\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InvalidateAllNonAliasingInputs\",\n            \"parent\": \"LateLoadEliminationAnalyzer\",\n            \"about\": \"Invalidates non-aliasing inputs of an operation to account for potential aliasing.\",\n            \"logic\": \"Iterates through the inputs of an operation and invalidates any non-aliasing objects to conservatively handle potential aliasing caused by the operation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const Operation&\",\n                    \"purpose\": \"The operation whose inputs should be invalidated.\"\n                }\n            ],\n            \"return\": {\n                \"type\":"
}