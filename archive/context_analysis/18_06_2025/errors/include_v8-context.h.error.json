{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-context.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-context.h\",\n        \"file_name\": \"v8-context.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the v8::Context class, which represents a sandboxed execution context in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers and V8 specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <stdint.h>\n\n#include <vector>\n\n#include \"v8-data.h\"          // NOLINT(build/include_directory)\n#include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n#include \"v8-maybe.h\"         // NOLINT(build/include_directory)\n#include \"v8-snapshot.h\"      // NOLINT(build/include_directory)\n#include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExtensionConfiguration\",\n            \"about\": \"A container for extension names used when creating a context.\",\n            \"attributes\": [\n                {\n                    \"name\": \"name_count_\",\n                    \"type\": \"const int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of extension names.\"\n                },\n                {\n                    \"name\": \"names_\",\n                    \"type\": \"const char**\",\n                    \"access\": \"private\",\n                    \"purpose\": \"An array of extension names.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT ExtensionConfiguration {\n public:\n  ExtensionConfiguration() : name_count_(0), names_(nullptr) {}\n  ExtensionConfiguration(int name_count, const char* names[])\n      : name_count_(name_count), names_(names) {}\n\n  const char** begin() const { return &names_[0]; }\n  const char** end() const { return &names_[name_count_]; }\n\n private:\n  const int name_count_;\n  const char** names_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Context\",\n            \"extends\": \"Data\",\n            \"about\": \"A sandboxed execution context with its own set of built-in objects and functions.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Object\",\n                \"Value\",\n                \"Isolate\",\n                \"ObjectTemplate\",\n                \"ExtensionConfiguration\",\n                \"MicrotaskQueue\",\n                \"String\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT Context : public Data {\n public:\n  /**\n   * Returns the global proxy object.\n   *\n   * Global proxy object is a thin wrapper whose prototype points to actual\n   * context's global object with the properties like Object, etc. This is done\n   * that way for security reasons (for more details see\n   * https://wiki.mozilla.org/Gecko:SplitWindow).\n   *\n   * Please note that changes to global proxy object prototype most probably\n   * would break VM---v8 expects only global object as a prototype of global\n   * proxy object.\n   */\n  Local<Object> Global();\n\n  /**\n   * Detaches the global object from its context before\n   * the global object can be reused to create a new context.\n   */\n  void DetachGlobal();\n\n  /**\n   * Creates a new context and returns a handle to the newly allocated\n   * context.\n   *\n   * \\param isolate The isolate in which to create the context.\n   *\n   * \\param extensions An optional extension configuration containing\n   * the extensions to be installed in the newly created context.\n   *\n   * \\param global_template An optional object template from which the\n   * global object for the newly created context will be created.\n   *\n   * \\param global_object An optional global object to be reused for\n   * the newly created context. This global object must have been\n   * created by a previous call to Context::New with the same global\n   * template. The state of the global object will be completely reset\n   * and only object identify will remain.\n   *\n   * \\param internal_fields_deserializer An optional callback used\n   * to deserialize fields set by\n   * v8::Object::SetAlignedPointerInInternalField() in wrapper objects\n   * from the default context snapshot. It should match the\n   * SerializeInternalFieldsCallback() used by\n   * v8::SnapshotCreator::SetDefaultContext() when the default context\n   * snapshot is created. It does not need to be configured if the default\n   * context snapshot contains no wrapper objects with pointer internal\n   * fields, or if no custom startup snapshot is configured\n   * in the v8::CreateParams used to create the isolate.\n   *\n   * \\param microtask_queue An optional microtask queue used to manage\n   * the microtasks created in this context. If not set the per-isolate\n   * default microtask queue would be used.\n   *\n   * \\param context_data_deserializer An optional callback used\n   * to deserialize embedder data set by\n   * v8::Context::SetAlignedPointerInEmbedderData() in the default\n   * context from the default context snapshot. It does not need to be\n   * configured if the default context snapshot contains no pointer embedder\n   * data, or if no custom startup snapshot is configured in the\n   * v8::CreateParams used to create the isolate.\n   *\n   * \\param api_wrapper_deserializer An optional callback used to deserialize\n   * API wrapper objects that was initially set with v8::Object::Wrap() and then\n   * serialized using SerializeAPIWrapperCallback.\n   */\n  static Local<Context> New(\n      Isolate* isolate, ExtensionConfiguration* extensions = nullptr,\n      MaybeLocal<ObjectTemplate> global_template = MaybeLocal<ObjectTemplate>(),\n      MaybeLocal<Value> global_object = MaybeLocal<Value>(),\n      DeserializeInternalFieldsCallback internal_fields_deserializer =\n          DeserializeInternalFieldsCallback(),\n      MicrotaskQueue* microtask_queue = nullptr,\n      DeserializeContextDataCallback context_data_deserializer =\n          DeserializeContextDataCallback(),\n      DeserializeAPIWrapperCallback api_wrapper_deserializer =\n          DeserializeAPIWrapperCallback());\n\n  /**\n   * Create a new context from a (non-default) context snapshot. There\n   * is no way to provide a global object template since we do not create\n   * a new global object from template, but we can reuse a global object.\n   *\n   * \\param isolate See v8::Context::New().\n   *\n   * \\param context_snapshot_index The index of the context snapshot to\n   * deserialize from. Use v8::Context::New() for the default snapshot.\n   *\n   * \\param internal_fields_deserializer An optional callback used\n   * to deserialize fields set by\n   * v8::Object::SetAlignedPointerInInternalField() in wrapper objects\n   * from the default context snapshot. It does not need to be\n   * configured if there are no wrapper objects with no internal\n   * pointer fields in the default context snapshot or if no startup\n   * snapshot is configured when the isolate is created.\n   *\n   * \\param extensions See v8::Context::New().\n   *\n   * \\param global_object See v8::Context::New().\n   *\n   * \\param internal_fields_deserializer Similar to\n   * internal_fields_deserializer in v8::Context::New() but applies to\n   * the context specified by the context_snapshot_index.\n   *\n   * \\param microtask_queue  See v8::Context::New().\n   *\n   * \\param context_data_deserializer  Similar to\n   * context_data_deserializer in v8::Context::New() but applies to\n   * the context specified by the context_snapshot_index.\n   *\n   *\\param api_wrapper_deserializer Similar to api_wrapper_deserializer in\n   * v8::Context::New() but applies to the context specified by the\n   * context_snapshot_index.\n   */\n  static MaybeLocal<Context> FromSnapshot(\n      Isolate* isolate, size_t context_snapshot_index,\n      DeserializeInternalFieldsCallback internal_fields_deserializer =\n          DeserializeInternalFieldsCallback(),\n      ExtensionConfiguration* extensions = nullptr,\n      MaybeLocal<Value> global_object = MaybeLocal<Value>(),\n      MicrotaskQueue* microtask_queue = nullptr,\n      DeserializeContextDataCallback context_data_deserializer =\n          DeserializeContextDataCallback(),\n      DeserializeAPIWrapperCallback api_wrapper_deserializer =\n          DeserializeAPIWrapperCallback());\n\n  /**\n   * Returns an global object that isn't backed by an actual context.\n   *\n   * The global template needs to have access checks with handlers installed.\n   * If an existing global object is passed in, the global object is detached\n   * from its context.\n   *\n   * Note that this is different from a detached context where all accesses to\n   * the global proxy will fail. Instead, the access check handlers are invoked.\n   *\n   * It is also not possible to detach an object returned by this method.\n   * Instead, the access check handlers need to return nothing to achieve the\n   * same effect.\n   *\n   * It is possible, however, to create a new context from the global object\n   * returned by this method.\n   */\n  static MaybeLocal<Object> NewRemoteContext(\n      Isolate* isolate, Local<ObjectTemplate> global_template,\n      MaybeLocal<Value> global_object = MaybeLocal<Value>());\n\n  /**\n   * Sets the security token for the context.  To access an object in\n   * another context, the security tokens must match.\n   */\n  void SetSecurityToken(Local<Value> token);\n\n  /** Restores the security token to the default value. */\n  void UseDefaultSecurityToken();\n\n  /** Returns the security token of this context.*/\n  Local<Value> GetSecurityToken();\n\n  /**\n   * Enter this context.  After entering a context, all code compiled\n   * and run is compiled and run in this context.  If another context\n   * is already entered, this old context is saved so it can be\n   * restored when the new context is exited.\n   */\n  void Enter();\n\n  /**\n   * Exit this context.  Exiting the current context restores the\n   * context that was in place when entering the current context.\n   */\n  void Exit();\n\n  /**\n   * Delegate to help with Deep freezing embedder-specific objects (such as\n   * JSApiObjects) that can not be frozen natively.\n   */\n  class DeepFreezeDelegate {\n   public:\n    /**\n     * Performs embedder-specific operations to freeze the provided embedder\n     * object. The provided object *will* be frozen by DeepFreeze after this\n     * function returns, so only embedder-specific objects need to be frozen.\n     * This function *may not* create new JS objects or perform JS allocations.\n     * Any v8 objects reachable from the provided embedder object that should\n     * also be considered for freezing should be added to the children_out\n     * parameter. Returns true if the operation completed successfully.\n     */\n    virtual bool FreezeEmbedderObjectAndGetChildren(\n        Local<Object> obj, LocalVector<Object>& children_out) = 0;\n  };\n\n  /**\n   * Attempts to recursively freeze all objects reachable from this context.\n   * Some objects (generators, iterators, non-const closures) can not be frozen\n   * and will cause this method to throw an error. An optional delegate can be\n   * provided to help freeze embedder-specific objects.\n   *\n   * Freezing occurs in two steps:\n   * 1. \"Marking\" where we iterate through all objects reachable by this\n   *    context, accumulating a list of objects that need to be frozen and\n   *    looking for objects that can't be frozen. This step is separated because\n   *    it is more efficient when we can assume there is no garbage collection.\n   * 2. \"Freezing\" where we go through the list of objects and freezing them.\n   *    This effectively requires copying them so it may trigger garbage\n   *    collection.\n   */\n  Maybe<void> DeepFreeze(DeepFreezeDelegate* delegate = nullptr);\n\n  /** Returns the isolate associated with a current context. */\n  Isolate* GetIsolate();\n\n  /** Returns the microtask queue associated with a current context. */\n  MicrotaskQueue* GetMicrotaskQueue();\n\n  /** Sets the microtask queue associated with the current context. */\n  void SetMicrotaskQueue(MicrotaskQueue* queue);\n\n  /**\n   * The field at kDebugIdIndex used to be reserved for the inspector.\n   * It now serves no purpose.\n   */\n  enum EmbedderDataFields { kDebugIdIndex = 0 };\n\n  /**\n   * Return the number of fields allocated for embedder data.\n   */\n  uint32_t GetNumberOfEmbedderDataFields();\n\n  /**\n   * Gets the embedder data with the given index, which must have been set by a\n   * previous call to SetEmbedderData with the same index.\n   */\n  V8_INLINE Local<Value> GetEmbedderData(int index);\n\n  /**\n   * Gets the binding object used by V8 extras. Extra natives get a reference\n   * to this object and can use it to \"export\" functionality by adding\n   * properties. Extra natives can also \"import\" functionality by accessing\n   * properties added by the embedder using the V8 API.\n   */\n  Local<Object> GetExtrasBindingObject();\n\n  /**\n   * Sets the embedder data with the given index, growing the data as\n   * needed. Note that index 0 currently has a special meaning for Chrome's\n   * debugger.\n   */\n  void SetEmbedderData(int index, Local<Value> value);\n\n  /**\n   * Gets a 2-byte-aligned native pointer from the embedder data with the given\n   * index, which must have been set by a previous call to\n   * SetAlignedPointerInEmbedderData with the same index. Note that index 0\n   * currently has a special meaning for Chrome's debugger.\n   */\n  V8_INLINE void* GetAlignedPointerFromEmbedderData(Isolate* isolate,\n                                                    int index);\n  V8_INLINE void* GetAlignedPointerFromEmbedderData(int index);\n\n  /**\n   * Sets a 2-byte-aligned native pointer in the embedder data with the given\n   * index, growing the data as needed. Note that index 0 currently has a\n   * special meaning for Chrome's debugger.\n   */\n  void SetAlignedPointerInEmbedderData(int index, void* value);\n\n  /**\n   * Control whether code generation from strings is allowed. Calling\n   * this method with false will disable 'eval' and the 'Function'\n   * constructor for code running in this context. If 'eval' or the\n   * 'Function' constructor are used an exception will be thrown.\n   *\n   * If code generation from strings is not allowed the\n   * V8::ModifyCodeGenerationFromStringsCallback callback will be invoked if\n   * set before blocking the call to 'eval' or the 'Function'\n   * constructor. If that callback returns true, the call will be\n   * allowed, otherwise an exception will be thrown. If no callback is\n   * set an exception will be thrown.\n   */\n  void AllowCodeGenerationFromStrings(bool allow);\n\n  /**\n   * Returns true if code generation from strings is allowed for the context.\n   * For more details see AllowCodeGenerationFromStrings(bool) documentation.\n   */\n  bool IsCodeGenerationFromStringsAllowed() const;\n\n  /**\n   * Sets the error description for the exception that is thrown when\n   * code generation from strings is not allowed and 'eval' or the 'Function'\n   * constructor are called.\n   */\n  void SetErrorMessageForCodeGenerationFromStrings(Local<String> message);\n\n  /**\n   * Sets the error description for the exception that is thrown when\n   * wasm code generation is not allowed.\n   */\n  void SetErrorMessageForWasmCodeGeneration(Local<String> message);\n\n  /**\n   * Return data that was previously attached to the context snapshot via\n   * SnapshotCreator, and removes the reference to it.\n   * Repeated call with the same index returns an empty MaybeLocal.\n   */\n  template <class T>\n  V8_INLINE MaybeLocal<T> GetDataFromSnapshotOnce(size_t index);\n\n  /**\n   * If callback is set, abort any attempt to execute JavaScript in this\n   * context, call the specified callback, and throw an exception.\n   * To unset abort, pass nullptr as callback.\n   */\n  using AbortScriptExecutionCallback = void (*)(Isolate* isolate,\n                                                Local<Context> context);\n  void SetAbortScriptExecution(AbortScriptExecutionCallback callback);\n\n  /**\n   * Set or clear hooks to be invoked for promise lifecycle operations.\n   * To clear a hook, set it to an empty v8::Function. Each function will\n   * receive the observed promise as the first argument. If a chaining\n   * operation is used on a promise, the init will additionally receive\n   * the parent promise as the second argument.\n   */\n  void SetPromiseHooks(Local<Function> init_hook, Local<Function> before_hook,\n                       Local<Function> after_hook,\n                       Local<Function> resolve_hook);\n\n  bool HasTemplateLiteralObject(Local<Value> object);\n  /**\n   * Stack-allocated class which sets the execution context for all\n   * operations executed within a local scope.\n   */\n  class V8_NODISCARD Scope {\n   public:\n    explicit V8_INLINE Scope(Local<Context> context) : context_(context) {\n      context_->Enter();\n    }\n    V8_INLINE ~Scope() { context_->Exit(); }\n\n   private:\n    Local<Context> context_;\n  };\n\n  /**\n   * Stack-allocated class to support the backup incumbent settings object\n   * stack.\n   * https://html.spec.whatwg.org/multipage/webappapis.html#backup-incumbent-settings-object-stack\n   */\n  class V8_EXPORT V8_NODISCARD BackupIncumbentScope final {\n   public:\n    /**\n     * |backup_incumbent_context| is pushed onto the backup incumbent settings\n     * object stack.\n     */\n    explicit BackupIncumbentScope(Local<Context> backup_incumbent_context);\n    ~BackupIncumbentScope();\n\n   private:\n    friend class internal::Isolate;\n\n    uintptr_t JSStackComparableAddressPrivate() const {\n      return js_stack_comparable_address_;\n    }\n\n    Local<Context> backup_incumbent_context_;\n    uintptr_t js_stack_comparable_address_ = 0;\n    const BackupIncumbentScope* prev_ = nullptr;\n  };\n\n  V8_INLINE static Context* Cast(Data* data);\n\n private:\n  friend class Value;\n  friend class Script;\n  friend class Object;\n  friend class Function;\n\n  static void CheckCast(Data* obj);\n\n  internal::ValueHelper::InternalRepresentationType GetDataFromSnapshotOnce(\n      size_t index);\n  Local<Value> SlowGetEmbedderData(int index);\n  void* SlowGetAlignedPointerFromEmbedderData(int index);\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Global\",\n            \"parent\": \"Context\",\n            \"about\": \"Returns the global proxy object.\",\n            \"return\": {\n                \"type\": \"Local<Object>\",\n                \"description\": \"The global proxy object.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n  Local<Object> Global();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DetachGlobal\",\n            \"parent\": \"Context\",\n            \"about\": \"Detaches the global object from its context.\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n  void DetachGlobal();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"New\",\n            \"parent\": \"Context\",\n            \"about\": \"Creates a new context.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate in which to create the context.\"\n                },\n                {\n                    \"name\": \"extensions\",\n                    \"type\": \"ExtensionConfiguration*\",\n                    \"purpose\": \"An optional extension configuration.\"\n                },\n                {\n                    \"name\": \"global_template\",\n                    \"type\": \"MaybeLocal<ObjectTemplate>\",\n                    \"purpose\": \"An optional object template for the global object.\"\n                },\n                {\n                    \"name\": \"global_object\",\n                    \"type\": \"MaybeLocal<Value>\",\n                    \"purpose\": \"An optional global object to reuse.\"\n                },\n                {\n                    \"name\": \"internal_fields_deserializer\",\n                    \"type\": \"DeserializeInternalFieldsCallback\",\n                    \"purpose\": \"Optional callback to deserialize internal fields.\"\n                },\n                {\n                    \"name\": \"microtask_queue\",\n                    \"type\": \"MicrotaskQueue*\",\n                    \"purpose\": \"Optional microtask queue.\"\n                },\n                {\n                    \"name\": \"context_data_deserializer\",\n                    \"type\": \"DeserializeContextDataCallback\",\n                    \"purpose\": \"Optional callback for context data deserialization.\"\n                },\n                {\n                    \"name\": \"api_wrapper_deserializer\",\n                    \"type\": \"DeserializeAPIWrapperCallback\",\n                    \"purpose\": \"Optional callback for API wrapper deserialization.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Local<Context>\",\n                \"description\": \"A handle to the newly allocated context.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"ExtensionConfiguration\",\n                \"ObjectTemplate\",\n                \"Value\",\n                \"DeserializeInternalFieldsCallback\",\n                \"MicrotaskQueue\",\n                \"DeserializeContextDataCallback\",\n                \"DeserializeAPIWrapperCallback\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static Local<Context> New(\n      Isolate* isolate, ExtensionConfiguration* extensions = nullptr,\n      MaybeLocal<ObjectTemplate> global_template = MaybeLocal<ObjectTemplate>(),\n      MaybeLocal<Value> global_object = MaybeLocal<Value>(),\n      DeserializeInternalFieldsCallback internal_fields_deserializer =\n          DeserializeInternalFieldsCallback(),\n      MicrotaskQueue* microtask_queue = nullptr,\n      DeserializeContextDataCallback context_data_deserializer =\n          DeserializeContextDataCallback(),\n      DeserializeAPIWrapperCallback api_wrapper_deserializer =\n          DeserializeAPIWrapperCallback());\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FromSnapshot\",\n            \"parent\": \"Context\",\n            \"about\": \"Creates a new context from a snapshot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate in which to create the context.\"\n                },\n                {\n                    \"name\": \"context_snapshot_index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the context snapshot.\"\n                },\n                {\n                    \"name\": \"internal_fields_deserializer\",\n                    \"type\": \"DeserializeInternalFieldsCallback\",\n                    \"purpose\": \"Optional callback to deserialize internal fields.\"\n                },\n                {\n                    \"name\": \"extensions\",\n                    \"type\": \"ExtensionConfiguration*\",\n                    \"purpose\": \"An optional extension configuration.\"\n                },\n                {\n                    \"name\": \"global_object\",\n                    \"type\": \"MaybeLocal<Value>\",\n                    \"purpose\": \"An optional global object to reuse.\"\n                },\n                {\n                    \"name\": \"microtask_queue\",\n                    \"type\": \"MicrotaskQueue*\",\n                    \"purpose\": \"Optional microtask queue.\"\n                },\n                {\n                    \"name\": \"context_data_deserializer\",\n                    \"type\": \"DeserializeContextDataCallback\",\n                    \"purpose\": \"Optional callback for context data deserialization.\"\n                },\n                {\n                    \"name\": \"api_wrapper_deserializer\",\n                    \"type\": \"DeserializeAPIWrapperCallback\",\n                    \"purpose\": \"Optional callback for API wrapper deserialization.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeLocal<Context>\",\n                \"description\": \"A handle to the newly allocated context.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"DeserializeInternalFieldsCallback\",\n                \"ExtensionConfiguration\",\n                \"Value\",\n                \"MicrotaskQueue\",\n                \"DeserializeContextDataCallback\",\n                \"DeserializeAPIWrapperCallback\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static MaybeLocal<Context> FromSnapshot(\n      Isolate* isolate, size_t context_snapshot_index,\n      DeserializeInternalFieldsCallback internal_fields_deserializer =\n          DeserializeInternalFieldsCallback(),\n      ExtensionConfiguration* extensions = nullptr,\n      MaybeLocal<Value> global_object = MaybeLocal<Value>(),\n      MicrotaskQueue* microtask_queue = nullptr,\n      DeserializeContextDataCallback context_data_deserializer =\n          DeserializeContextDataCallback(),\n      DeserializeAPIWrapperCallback api_wrapper_deserializer =\n          DeserializeAPIWrapperCallback());\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NewRemoteContext\",\n            \"parent\": \"Context\",\n            \"about\": \"Returns a global object that isn't backed by an actual context.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate in which to create the context.\"\n                },\n                {\n                    \"name\": \"global_template\",\n                    \"type\": \"Local<ObjectTemplate>\",\n                    \"purpose\": \"The global template.\"\n                },\n                {\n                    \"name\": \"global_object\",\n                    \"type\": \"MaybeLocal<Value>\",\n                    \"purpose\": \"An optional global object to reuse.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeLocal<Object>\",\n                \"description\": \"The detached global object.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"ObjectTemplate\",\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static MaybeLocal<Object> NewRemoteContext(\n      Isolate* isolate, Local<ObjectTemplate> global_template,\n      MaybeLocal<Value> global_object = MaybeLocal<Value>());\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetSecurityToken\",\n            \"parent\": \"Context\",\n            \"about\": \"Sets the security token for the context.\",\n            \"parameters\": [\n                {\n                    \"name\": \"token\",\n                    \"type\": \"Local<Value>\",\n                    \"purpose\": \"The security token.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetSecurityToken(Local<Value> token);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UseDefaultSecurityToken\",\n            \"parent\": \"Context\",\n            \"about\": \"Restores the security token to the default value.\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n  void UseDefaultSecurityToken();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetSecurityToken\",\n            \"parent\": \"Context\",\n            \"about\": \"Returns the security token of this context.\",\n            \"return\": {\n                \"type\": \"Local<Value>\",\n                \"description\": \"The security token.\"\n            },\n            \"dependencies\": [\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Local<Value> GetSecurityToken();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Enter\",\n            \"parent\": \"Context\",\n            \"about\": \"Enters this context.\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n  void Enter();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Exit\",\n            \"parent\": \"Context\",\n            \"about\": \"Exits this context.\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n  void Exit();\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DeepFreezeDelegate\",\n            \"parent\": \"Context\",\n            \"about\": \"Delegate to help with Deep freezing embedder-specific objects that can not be frozen natively.\",\n            \"attributes\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  class DeepFreezeDelegate {\n   public:\n    /**\n     * Performs embedder-specific operations to freeze the provided embedder\n     * object. The provided object *will* be frozen by DeepFreeze after this\n     * function returns, so only embedder-specific objects need to be frozen.\n     * This function *may not* create new JS objects or perform JS allocations.\n     * Any v8 objects reachable from the provided embedder object that should\n     * also be considered for freezing should be added to the children_out\n     * parameter. Returns true if the operation completed successfully.\n     */\n    virtual bool FreezeEmbedderObjectAndGetChildren(\n        Local<Object> obj, LocalVector<Object>& children_out) = 0;\n  };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeepFreeze\",\n            \"parent\": \"Context\",\n            \"about\": \"Attempts to recursively freeze all objects reachable from this context.\",\n            \"parameters\": [\n                {\n                    \"name\": \"delegate\",\n                    \"type\": \"DeepFreezeDelegate*\",\n                    \"purpose\": \"Optional delegate to help freeze embedder-specific objects.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Maybe<void>\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DeepFreezeDelegate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Maybe<void> DeepFreeze(DeepFreezeDelegate* delegate = nullptr);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetIsolate\",\n            \"parent\": \"Context\",\n            \"about\": \"Returns the isolate associated with a current context.\",\n            \"return\": {\n                \"type\": \"Isolate*\",\n                \"description\": \"The isolate.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n  Isolate* GetIsolate();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetMicrotaskQueue\",\n            \"parent\": \"Context\",\n            \"about\": \"Returns the microtask queue associated with a current context.\",\n            \"return\": {\n                \"type\": \"MicrotaskQueue*\",\n                \"description\": \"The microtask queue.\"\n            },\n            \"dependencies\": [\n                \"MicrotaskQueue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  MicrotaskQueue* GetMicrotaskQueue();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetMicrotaskQueue\",\n            \"parent\": \"Context\",\n            \"about\": \"Sets the microtask queue associated with the current context.\",\n            \"parameters\": [\n                {\n                    \"name\": \"queue\",\n                    \"type\": \"MicrotaskQueue*\",\n                    \"purpose\": \"The microtask queue.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"MicrotaskQueue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetMicrotaskQueue(MicrotaskQueue* queue);\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"EmbedderDataFields\",\n            \"parent\": \"Context\",\n            \"about\": \"Enum describing fields allocated for embedder data.\",\n            \"attributes\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  /**\n   * The field at kDebugIdIndex used to be reserved for the inspector.\n   * It now serves no purpose.\n   */\n  enum EmbedderDataFields {"
}