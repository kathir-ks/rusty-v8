{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-native-context-specialization.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-native-context-specialization.cc\",\n      \"file_name\": \"js-native-context-specialization.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Performs native context specialization optimizations in the Turbofan compiler for JavaScript.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes necessary headers for compiler, base utilities, builtins, code generation, common data structures, flags, handles, heap management, and object representation.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/compiler/js-native-context-specialization.h\"\n\n#include <optional>\n\n#include \"src/base/logging.h\"\n#include \"src/builtins/accessors.h\"\n#include \"src/codegen/code-factory.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/access-info.h\"\n#include \"src/compiler/allocation-builder-inl.h\"\n#include \"src/compiler/allocation-builder.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/fast-api-calls.h\"\n#include \"src/compiler/frame-states.h\"\n#include \"src/compiler/graph-assembler.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/js-operator.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/map-inference.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/property-access-builder.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/type-cache.h\"\n#include \"src/flags/flags.h\"\n#include \"src/handles/handles.h\"\n#include \"src/heap/factory.h\"\n#include \"src/heap/heap-layout-inl.h\"\n#include \"src/heap/heap-write-barrier-inl.h\"\n#include \"src/objects/elements-kind.h\"\n#include \"src/objects/feedback-vector.h\"\n#include \"src/objects/heap-number.h\"\n#include \"src/objects/string.h\"\n]]></code>\n  </imports>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"JSNativeContextSpecialization\",\n        \"about\": \"Performs native context-specific optimizations within the Turbofan compiler.\",\n        \"attributes\": [\n          {\n            \"name\": \"jsgraph_\",\n            \"type\": \"JSGraph*\",\n            \"access\": \"private\",\n            \"purpose\": \"Provides access to the JavaScript graph.\"\n          },\n          {\n            \"name\": \"broker_\",\n            \"type\": \"JSHeapBroker*\",\n            \"access\": \"private\",\n            \"purpose\": \"Provides access to the JS heap and object properties.\"\n          },\n          {\n            \"name\": \"flags_\",\n            \"type\": \"Flags\",\n            \"access\": \"private\",\n            \"purpose\": \"Stores compiler flags.\"\n          },\n          {\n            \"name\": \"global_object_\",\n            \"type\": \"Object\",\n            \"access\": \"private\",\n            \"purpose\": \"Represents the global object of the target native context.\"\n          },\n          {\n            \"name\": \"global_proxy_\",\n            \"type\": \"Object\",\n            \"access\": \"private\",\n            \"purpose\": \"Represents the global proxy object of the target native context.\"\n          },\n          {\n            \"name\": \"zone_\",\n            \"type\": \"Zone*\",\n            \"access\": \"private\",\n            \"purpose\": \"Allocator for temporary data structures.\"\n          },\n          {\n            \"name\": \"shared_zone_\",\n            \"type\": \"Zone*\",\n            \"access\": \"private\",\n            \"purpose\": \"Shared allocator for data structures shared between threads.\"\n          },\n          {\n            \"name\": \"type_cache_\",\n            \"type\": \"TypeCache&\",\n            \"access\": \"private\",\n            \"purpose\": \"Provides access to commonly used types.\"\n          },\n          {\n            \"name\": \"created_strings_\",\n            \"type\": \"ZoneSet<Handle<String>>\",\n            \"access\": \"private\",\n            \"purpose\": \"Stores string handles created during specialization, used for thread safety checks.\"\n          }\n        ],\n        \"dependencies\": [\n          \"AdvancedReducer\",\n          \"JSGraph\",\n          \"JSHeapBroker\",\n          \"Flags\",\n          \"Zone\",\n          \"TypeCache\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nclass JSNativeContextSpecialization final : public AdvancedReducer {\n public:\n  JSNativeContextSpecialization(Editor* editor, JSGraph* jsgraph,\n                                  JSHeapBroker* broker, Flags flags, Zone* zone,\n                                  Zone* shared_zone);\n\n  Reduction Reduce(Node* node) final;\n\n private:\n  static std::optional<size_t> GetMaxStringLength(JSHeapBroker* broker,\n                                                    Node* node);\n  Reduction ReduceJSToString(Node* node);\n  Handle<String> CreateStringConstant(Node* node);\n  Handle<String> Concatenate(Handle<String> left, Handle<String> right);\n  bool StringCanSafelyBeRead(Node* const node, Handle<String> str);\n  Reduction ReduceJSAdd(Node* node);\n  Reduction ReduceJSGetSuperConstructor(Node* node);\n  Reduction ReduceJSFindNonDefaultConstructorOrConstruct(Node* node);\n  Reduction ReduceJSInstanceOf(Node* node);\n  Reduction ReduceJSHasInPrototypeChain(Node* node);\n  Reduction ReduceJSOrdinaryHasInstance(Node* node);\n  Reduction ReduceJSPromiseResolve(Node* node);\n  Reduction ReduceJSResolvePromise(Node* node);\n  Reduction ReduceJSLoadGlobal(Node* node);\n  Reduction ReduceJSStoreGlobal(Node* node);\n  Reduction ReduceJSLoadNamed(Node* node);\n  Reduction ReduceJSLoadNamedFromSuper(Node* node);\n  Reduction ReduceJSSetNamedProperty(Node* node);\n  Reduction ReduceJSHasProperty(Node* node);\n  Reduction ReduceJSLoadProperty(Node* node);\n  Reduction ReduceJSSetKeyedProperty(Node* node);\n  Reduction ReduceJSDefineKeyedOwnProperty(Node* node);\n  Reduction ReduceJSDefineNamedOwnProperty(Node* node);\n  Reduction ReduceJSDefineKeyedOwnPropertyInLiteral(Node* node);\n  Reduction ReduceJSStoreInArrayLiteral(Node* node);\n  Reduction ReduceJSAsyncFunctionEnter(Node* node);\n  Reduction ReduceJSAsyncFunctionReject(Node* node);\n  Reduction ReduceJSAsyncFunctionResolve(Node* node);\n  Reduction ReduceMegaDOMPropertyAccess(\n      Node* node, Node* value, MegaDOMPropertyAccessFeedback const& feedback,\n      FeedbackSource const& source);\n\n  Reduction ReduceNamedAccess(Node* node, Node* value,\n                              NamedAccessFeedback const& feedback,\n                              AccessMode access_mode, Node* key);\n  Reduction ReduceElementAccess(Node* node, Node* index, Node* value,\n                                ElementAccessFeedback const& feedback);\n\n  void RemoveImpossibleMaps(Node* object, ZoneVector<MapRef>* maps) const;\n\n  // Helper functions\n  Node* BuildCheckEqualsName(NameRef name, Node* key, Node* effect,\n                             Node* control);\n  std::optional<ValueEffectControl> BuildPropertyAccess(\n      Node* lookup_start_object, Node* receiver, Node* value, Node* context,\n      FrameState frame_state, Effect effect, Control control, NameRef name,\n      ZoneVector<Node*>* if_exceptions, PropertyAccessInfo access_info,\n      AccessMode access_mode);\n  Effect BuildCheckString(Node* node, Effect effect, Control control);\n  Effect BuildCheckNumber(Node* node, Effect effect, Control control);\n  Effect BuildCheckHeapObject(Node* node, Effect effect, Control control);\n  Effect BuildCheckValue(Node* value, Effect effect, Control control,\n                         ObjectRef object);\n  Effect BuildCheckMaps(Node* node, Effect effect, Control control,\n                       ZoneRefSet<Map> const& maps,\n                       bool has_deprecated_maps_without_migration_target);\n  Node* BuildLoadPrototypeFromObject(Node* object, Effect effect,\n                                     Control control);\n  Node* BuildIndexedStringLoad(Node* receiver, Node* index, Node* length,\n                               Effect* effect, Control* control,\n                               LoadMode load_mode);\n\n  OptionalMapRef InferRootMap(Node* object) const;\n  bool InferMaps(Node* object, Effect effect, ZoneVector<MapRef>* maps) const;\n  OptionalMapRef GetPropertyCellMap() const;\n  NativeContextRef native_context() const { return broker_->target_native_context(); }\n\n  Isolate* isolate() const { return broker_->local_isolate_or_isolate(); }\n\n  CommonOperatorBuilder* common() const { return jsgraph_->common(); }\n  JSOperatorBuilder* javascript() const { return jsgraph_->javascript(); }\n  SimplifiedOperatorBuilder* simplified() const {\n    return jsgraph_->simplified();\n  }\n  Graph* graph() const { return jsgraph_->graph(); }\n  CompilationDependencies* dependencies() const {\n    return broker_->dependencies();\n  }\n  JSHeapBroker* broker() const { return broker_; }\n\n  enum InferHasInPrototypeChainResult {\n    kIsInPrototypeChain,\n    kIsNotInPrototypeChain,\n    kMayBeInPrototypeChain\n  };\n  InferHasInPrototypeChainResult InferHasInPrototypeChain(\n      Node* receiver, Effect effect, HeapObjectRef prototype);\n\n  Reduction ReducePropertyAccess(Node* node, NameRef name,\n                                 const AccessFeedback& feedback,\n                                 const KeyedAccessMode& keyed_mode);\n\n  Reduction ReducePropertyAccess(Node* node, Node* key, NameRef name,\n                                 Node* value, FeedbackSource const& source,\n                                 AccessMode access_mode);\n\n  Reduction ReducePropertyAccessOnString(Node* node, Node* key, Node* value,\n                                          FeedbackSource const& source,\n                                          AccessMode access_mode);\n\n  bool HasOnlyStringMaps(JSHeapBroker* broker,\n                         ZoneVector<MapRef> const& maps) const;\n  bool HasOnlyStringWrapperMaps(JSHeapBroker* broker,\n                                ZoneVector<MapRef> const& maps) const;\n  bool HasOnlyNonResizableTypedArrayMaps(JSHeapBroker* broker,\n                                         ZoneVector<MapRef> const& maps) const;\n\n  JSNativeContextSpecialization::InferHasInPrototypeChainResult\n  InferHasInPrototypeChain(Node* receiver, Effect effect,\n                           HeapObjectRef prototype);\n  ElementAccessFeedback const& TryRefineElementAccessFeedback(\n      ElementAccessFeedback const& feedback, Node* receiver,\n      Effect effect) const;\n  Reduction ReduceElementAccessOnString(\n      Node* node, Node* index, Node* value,\n      KeyedAccessMode const& keyed_mode);\n\n private:\n  JSGraph* jsgraph_;\n  JSHeapBroker* broker_;\n  Flags flags_;\n  Object global_object_;\n  Object global_proxy_;\n  Zone* zone_;\n  Zone* shared_zone_;\n  TypeCache& type_cache_;\n  ZoneSet<Handle<String>> created_strings_;\n};\n]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"HasNumberMaps\",\n        \"about\": \"Checks if a vector of maps contains at least one HeapNumberMap.\",\n        \"logic\": \"Iterates through the map vector and returns true if any map is a HeapNumberMap.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"Provides access to the JS heap and object properties.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"Vector of maps to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the map vector contains a HeapNumberMap; otherwise, false.\"\n        },\n        \"dependencies\": [\n          \"MapRef\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nnamespace {\n\nbool HasNumberMaps(JSHeapBroker* broker, ZoneVector<MapRef> const& maps) {\n  for (MapRef map : maps) {\n    if (map.IsHeapNumberMap()) return true;\n  }\n  return false;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"HasOnlyJSArrayMaps\",\n        \"about\": \"Checks if a vector of maps contains only JSArrayMaps.\",\n        \"logic\": \"Iterates through the map vector and returns false if any map is not a JSArrayMap.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"Provides access to the JS heap and object properties.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"Vector of maps to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the map vector contains only JSArrayMaps; otherwise, false.\"\n        },\n        \"dependencies\": [\n          \"MapRef\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool HasOnlyJSArrayMaps(JSHeapBroker* broker, ZoneVector<MapRef> const& maps) {\n  for (MapRef map : maps) {\n    if (!map.IsJSArrayMap()) return false;\n  }\n  return true;\n}\n\n}  // namespace\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JSNativeContextSpecialization\",\n        \"parent\": \"JSNativeContextSpecialization\",\n        \"about\": \"Constructor for the JSNativeContextSpecialization class.\",\n        \"logic\": \"Initializes the members of the class.\",\n        \"parameters\": [\n          {\n            \"name\": \"editor\",\n            \"type\": \"Editor*\",\n            \"purpose\": \"The editor for modifying the graph.\"\n          },\n          {\n            \"name\": \"jsgraph\",\n            \"type\": \"JSGraph*\",\n            \"purpose\": \"Provides access to the JavaScript graph.\"\n          },\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"Provides access to the JS heap and object properties.\"\n          },\n          {\n            \"name\": \"flags\",\n            \"type\": \"Flags\",\n            \"purpose\": \"Compiler flags.\"\n          },\n          {\n            \"name\": \"zone\",\n            \"type\": \"Zone*\",\n            \"purpose\": \"Allocator for temporary data structures.\"\n          },\n          {\n            \"name\": \"shared_zone\",\n            \"type\": \"Zone*\",\n            \"purpose\": \"Shared allocator for data structures shared between threads.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"N/A\"\n        },\n        \"dependencies\": [\n          \"JSGraph\",\n          \"JSHeapBroker\",\n          \"Flags\",\n          \"Zone\",\n          \"TypeCache\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nJSNativeContextSpecialization::JSNativeContextSpecialization(\n    Editor* editor, JSGraph* jsgraph, JSHeapBroker* broker, Flags flags,\n    Zone* zone, Zone* shared_zone)\n    : AdvancedReducer(editor),\n      jsgraph_(jsgraph),\n      broker_(broker),\n      flags_(flags),\n      global_object_(\n          broker->target_native_context().global_object(broker).object()),\n      global_proxy_(\n          broker->target_native_context().global_proxy_object(broker).object()),\n      zone_(zone),\n      shared_zone_(shared_zone),\n      type_cache_(TypeCache::Get()),\n      created_strings_(zone) {}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Reduce\",\n        \"parent\": \"JSNativeContextSpecialization\",\n        \"about\": \"Reduces a node in the JavaScript graph.\",\n        \"logic\": \"Switches on the node's opcode and calls the appropriate reduction function.\",\n        \"parameters\": [\n          {\n            \"name\": \"node\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The node to reduce.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Reduction\",\n          \"description\": \"The result of the reduction.\"\n        },\n        \"dependencies\": [\n          \"IrOpcode\",\n          \"ReduceJSAdd\",\n          \"ReduceJSGetSuperConstructor\",\n          \"ReduceJSInstanceOf\",\n          \"ReduceJSLoadGlobal\",\n          \"ReduceJSStoreGlobal\",\n          \"ReduceJSLoadNamed\",\n          \"ReduceJSSetNamedProperty\",\n          \"ReduceJSHasProperty\",\n          \"ReduceJSLoadProperty\",\n          \"ReduceJSSetKeyedProperty\",\n          \"ReduceJSToObject\",\n          \"ReduceJSToString\",\n          \"ReduceJSOrdinaryHasInstance\",\n          \"ReduceJSPromiseResolve\",\n          \"ReduceJSResolvePromise\",\n          \"ReduceJSDefineKeyedOwnProperty\",\n          \"ReduceJSDefineNamedOwnProperty\",\n          \"ReduceJSDefineKeyedOwnPropertyInLiteral\",\n          \"ReduceJSStoreInArrayLiteral\",\n          \"ReduceJSFindNonDefaultConstructorOrConstruct\",\n          \"ReduceJSHasInPrototypeChain\",\n          \"ReduceJSLoadNamedFromSuper\",\n          \"ReduceJSAsyncFunctionEnter\",\n          \"ReduceJSAsyncFunctionReject\",\n          \"ReduceJSAsyncFunctionResolve\",\n          \"ReduceJSGetIterator\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nReduction JSNativeContextSpecialization::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kJSAdd:\n      return ReduceJSAdd(node);\n    case IrOpcode::kJSAsyncFunctionEnter:\n      return ReduceJSAsyncFunctionEnter(node);\n    case IrOpcode::kJSAsyncFunctionReject:\n      return ReduceJSAsyncFunctionReject(node);\n    case IrOpcode::kJSAsyncFunctionResolve:\n      return ReduceJSAsyncFunctionResolve(node);\n    case IrOpcode::kJSGetSuperConstructor:\n      return ReduceJSGetSuperConstructor(node);\n    case IrOpcode::kJSFindNonDefaultConstructorOrConstruct:\n      return ReduceJSFindNonDefaultConstructorOrConstruct(node);\n    case IrOpcode::kJSInstanceOf:\n      return ReduceJSInstanceOf(node);\n    case IrOpcode::kJSHasInPrototypeChain:\n      return ReduceJSHasInPrototypeChain(node);\n    case IrOpcode::kJSOrdinaryHasInstance:\n      return ReduceJSOrdinaryHasInstance(node);\n    case IrOpcode::kJSPromiseResolve:\n      return ReduceJSPromiseResolve(node);\n    case IrOpcode::kJSResolvePromise:\n      return ReduceJSResolvePromise(node);\n    case IrOpcode::kJSLoadGlobal:\n      return ReduceJSLoadGlobal(node);\n    case IrOpcode::kJSStoreGlobal:\n      return ReduceJSStoreGlobal(node);\n    case IrOpcode::kJSLoadNamed:\n      return ReduceJSLoadNamed(node);\n    case IrOpcode::kJSLoadNamedFromSuper:\n      return ReduceJSLoadNamedFromSuper(node);\n    case IrOpcode::kJSSetNamedProperty:\n      return ReduceJSSetNamedProperty(node);\n    case IrOpcode::kJSHasProperty:\n      return ReduceJSHasProperty(node);\n    case IrOpcode::kJSLoadProperty:\n      return ReduceJSLoadProperty(node);\n    case IrOpcode::kJSSetKeyedProperty:\n      return ReduceJSSetKeyedProperty(node);\n    case IrOpcode::kJSDefineKeyedOwnProperty:\n      return ReduceJSDefineKeyedOwnProperty(node);\n    case IrOpcode::kJSDefineNamedOwnProperty:\n      return ReduceJSDefineNamedOwnProperty(node);\n    case IrOpcode::kJSDefineKeyedOwnPropertyInLiteral:\n      return ReduceJSDefineKeyedOwnPropertyInLiteral(node);\n    case IrOpcode::kJSStoreInArrayLiteral:\n      return ReduceJSStoreInArrayLiteral(node);\n    case IrOpcode::kJSToObject:\n      return ReduceJSToObject(node);\n    case IrOpcode::kJSToString:\n      return ReduceJSToString(node);\n    case IrOpcode::kJSGetIterator:\n      return ReduceJSGetIterator(node);\n    default:\n      break;\n  }\n  return NoChange();\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"GetMaxStringLength\",\n        \"parent\": \"JSNativeContextSpecialization\",\n        \"about\": \"Determines the maximum length of a string representation of a given node.\",\n        \"logic\": \"Checks if the node is a HeapConstant<String> or a number. If a string, returns its length. If a number, returns the maximum possible length of its string representation. Otherwise, returns nullopt.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"Provides access to the JS heap and object properties.\"\n          },\n          {\n            \"name\": \"node\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The node to analyze.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"std::optional<size_t>\",\n          \"description\": \"The maximum string length or nullopt if the node cannot be easily converted to a string.\"\n        },\n        \"dependencies\": [\n          \"HeapObjectMatcher\",\n          \"StringRef\",\n          \"NumberMatcher\",\n          \"kMaxDoubleStringLength\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// If {node} is a HeapConstant<String>, return the String's length. If {node} is\n// a number, return the maximum size that a stringified number can have.\n// Otherwise, we can't easily convert {node} into a String, and we return\n// nullopt.\n// static\nstd::optional<size_t> JSNativeContextSpecialization::GetMaxStringLength(\n    JSHeapBroker* broker, Node* node) {\n  HeapObjectMatcher matcher(node);\n  if (matcher.HasResolvedValue() && matcher.Ref(broker).IsString()) {\n    StringRef input = matcher.Ref(broker).AsString();\n    return input.length();\n  }\n\n  NumberMatcher number_matcher(node);\n  if (number_matcher.HasResolvedValue()) {\n    return kMaxDoubleStringLength;\n  }\n\n  // We don't support objects with possibly monkey-patched prototype.toString\n  // as it might have side-effects, so we shouldn't attempt lowering them.\n  return std::nullopt;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"ReduceJSToString\",\n        \"parent\": \"JSNativeContextSpecialization\",\n        \"about\": \"Reduces a JSToString node.\",\n        \"logic\": \"If the input is a string constant, replace the node with the string. If the input is a number constant, convert it to a string and replace the node.\",\n        \"parameters\": [\n          {\n            \"name\": \"node\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The JSToString node to reduce.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Reduction\",\n          \"description\": \"The result of the reduction.\"\n        },\n        \"dependencies\": [\n          \"HeapObjectMatcher\",\n          \"StringRef\",\n          \"NumberMatcher\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nReduction JSNativeContextSpecialization::ReduceJSToString(Node* node) {\n  DCHECK_EQ(IrOpcode::kJSToString, node->opcode());\n  Node* const input = node->InputAt(0);\n\n  HeapObjectMatcher matcher(input);\n  if (matcher.HasResolvedValue() && matcher.Ref(broker()).IsString()) {\n    Reduction reduction = Changed(input);  // JSToString(x:string) => x\n    ReplaceWithValue(node, reduction.replacement());\n    return reduction;\n  }\n\n  // TODO(turbofan): This optimization is weaker than what we used to have\n  // in js-typed-lowering for OrderedNumbers. We don't have types here though,\n  // so alternative approach should be designed if this causes performance\n  // regressions and the stronger optimization should be re-implemented.\n  NumberMatcher number_matcher(input);\n  if (number_matcher.HasResolvedValue()) {\n    DirectHandle<Object> num_obj =\n        broker()\n            ->local_isolate_or_isolate()\n            ->factory()\n            ->NewNumber<AllocationType::kOld>(number_matcher.ResolvedValue());\n    Handle<String> num_str =\n        broker()->local_isolate_or_isolate()->factory()->NumberToString(\n            num_obj);\n    Node* reduced = graph()->NewNode(\n        common()->HeapConstant(broker()->CanonicalPersistentHandle(num_str)));\n\n    ReplaceWithValue(node, reduced);\n    return Replace(reduced);\n  }\n\n  return NoChange();\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"CreateStringConstant\",\n        \"parent\": \"JSNativeContextSpecialization\",\n        \"about\": \"Creates a String handle from a constant node (HeapConstant<String> or a number).\",\n        \"logic\": \"If the node is a number, converts it to a string. If the node is a HeapConstant<String>, returns the string. Otherwise, it's unreachable.\",\n        \"parameters\": [\n          {\n            \"name\": \"node\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The constant node.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Handle<String>\",\n          \"description\": \"The String handle.\"\n        },\n        \"dependencies\": [\n          \"NumberMatcher\",\n          \"HeapObjectMatcher\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// Return a String from {node}, which should be either a HeapConstant<String>\n// (in which case we return the String), or a number (in which case we convert\n// it to a String).\nHandle<String> JSNativeContextSpecialization::CreateStringConstant(Node* node) {\n  DCHECK(IrOpcode::IsConstantOpcode(node->opcode()));\n  NumberMatcher number_matcher(node);\n  if (number_matcher.HasResolvedValue()) {\n    DirectHandle<Object> num_obj =\n        broker()\n            ->local_isolate_or_isolate()\n            ->factory()\n            ->NewNumber<AllocationType::kOld>(number_matcher.ResolvedValue());\n    // Note that we do not store the result of NumberToString in\n    // {created_strings_}, because the latter is used to know if strings are\n    // safe to be used in the background, but we always have as additional\n    // information the node from which the string was created ({node} is that\n    // case), and if this node is a kHeapNumber, then we know that we must have\n    // created the string, and that there it is safe to read. So, we don't need\n    // {created_strings_} in that case.\n    return broker()->local_isolate_or_isolate()->factory()->NumberToString(\n        num_obj);\n  } else {\n    HeapObjectMatcher matcher(node);\n    if (matcher.HasResolvedValue() && matcher.Ref(broker()).IsString()) {\n      return matcher.Ref(broker()).AsString().object();\n    } else {\n      UNREACHABLE();\n    }\n  }\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"IsStringConstant\",\n        \"about\": \"Checks if a node is a HeapConstant<String>.\",\n        \"logic\": \"Uses HeapObjectMatcher to check if the node is a string.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"Provides access to the JS heap and object properties.\"\n          },\n          {\n            \"name\": \"node\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The node to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the node is a string constant; otherwise, false.\"\n        },\n        \"dependencies\": [\n          \"HeapObjectMatcher\",\n          \"StringRef\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nnamespace {\nbool IsStringConstant(JSHeapBroker* broker, Node* node) {\n  HeapObjectMatcher matcher(node);\n  return matcher.HasResolvedValue() && matcher.Ref(broker).IsString();\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"IsStringWithNonAccessibleContent\",\n        \"about\": \"Checks if a node is a HeapConstant<String> and its content is not accessible.\",\n        \"logic\": \"Uses HeapObjectMatcher to check if the node is a string and then checks StringRef::IsContentAccessible.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"Provides access to the JS heap and object properties.\"\n          },\n          {\n            \"name\": \"node\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The node to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the node is a string with non-accessible content; otherwise, false.\"\n        },\n        \"dependencies\": [\n          \"HeapObjectMatcher\",\n          \"StringRef\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool IsStringWithNonAccessibleContent(JSHeapBroker* broker, Node* node) {\n  HeapObjectMatcher matcher(node);\n  if (matcher.HasResolvedValue() && matcher.Ref(broker).IsString()) {\n    StringRef input = matcher.Ref(broker).AsString();\n    return !input.IsContentAccessible();\n  }\n  return false;\n}\n}  // namespace\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"ReduceJSAsyncFunctionEnter\",\n        \"parent\": \"JSNativeContextSpecialization\",\n        \"about\": \"Reduces a JSAsyncFunctionEnter node.\",\n        \"logic\": \"Creates a promise and a JSAsyncFunctionObject for the async function.\",\n        \"parameters\": [\n          {\n            \"name\": \"node\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The JSAsyncFunctionEnter node to reduce.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Reduction\",\n          \"description\": \"The result of the reduction.\"\n        },\n        \"dependencies\": [\n          \"NodeProperties\",\n          \"SharedFunctionInfoRef\",\n          \"MapRef\",\n          \"AllocationBuilder\",\n          \"javascript()->CreatePromise\",\n          \"javascript()->CreateAsyncFunctionObject\",\n          \"flags()->trace_turbo_reduction\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nReduction JSNativeContextSpecialization::ReduceJSAsyncFunctionEnter(\n    Node* node) {\n  DCHECK_EQ(IrOpcode::kJSAsyncFunctionEnter, node->opcode());\n  Node* closure = NodeProperties::GetValueInput(node, 0);\n  Node* receiver = NodeProperties::GetValueInput(node, 1);\n  Node* context = NodeProperties::GetContextInput(node);\n  Node* frame_state = NodeProperties::GetFrameStateInput(node);\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* control = NodeProperties::GetControlInput(node);\n\n  if (!dependencies()->DependOnPromiseHookProtector()) return NoChange();\n\n  // Create the promise for the async function.\n  Node* promise = effect =\n      graph()->NewNode(javascript()->CreatePromise(), context, effect);\n\n  // Create the JSAsyncFunctionObject based on the SharedFunctionInfo\n  // extracted from the top-most frame in {frame_state}.\n  SharedFunctionInfoRef shared = MakeRef(\n      broker(),\n      FrameStateInfoOf(frame_state->op()).shared_info().ToHandleChecked());\n  DCHECK(shared.is_compiled());\n  int register_count =\n      shared.internal_formal_parameter_count_without_receiver() +\n      shared.GetBytecodeArray(broker()).register_count();\n  MapRef fixed_array_map = broker()->fixed_array_map();\n  AllocationBuilder ab(jsgraph(), broker(), effect, control);\n  if (!ab.CanAllocateArray(register_count, fixed_array_map)) {\n    return NoChange();\n  }\n  Node* value = effect =\n      graph()->NewNode(javascript()->CreateAsyncFunctionObject(register_count),\n                       closure, receiver, promise, context, effect, control);\n  ReplaceWithValue(node, value, effect, control);\n  return Replace(value);\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"ReduceJSAsyncFunctionReject\",\n        \"parent\": \"J"
}