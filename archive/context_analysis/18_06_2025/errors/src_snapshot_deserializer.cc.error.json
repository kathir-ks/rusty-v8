{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/deserializer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/deserializer.cc\",\n        \"file_name\": \"deserializer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the deserializer for V8 snapshots, responsible for recreating the heap from serialized data.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for deserialization, memory management, object manipulation, and logging.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/snapshot/deserializer.h\"\n\n            #include <inttypes.h>\n\n            #include \"src/base/logging.h\"\n            #include \"src/codegen/assembler-inl.h\"\n            #include \"src/codegen/reloc-info-inl.h\"\n            #include \"src/common/assert-scope.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/execution/isolate.h\"\n            #include \"src/handles/global-handles-inl.h\"\n            #include \"src/heap/heap-inl.h\"\n            #include \"src/heap/heap-write-barrier-inl.h\"\n            #include \"src/heap/heap-write-barrier.h\"\n            #include \"src/heap/heap.h\"\n            #include \"src/heap/local-heap-inl.h\"\n            #include \"src/logging/local-logger.h\"\n            #include \"src/logging/log.h\"\n            #include \"src/objects/backing-store.h\"\n            #include \"src/objects/js-array-buffer-inl.h\"\n            #include \"src/objects/maybe-object.h\"\n            #include \"src/objects/objects-body-descriptors-inl.h\"\n            #include \"src/objects/objects.h\"\n            #include \"src/objects/slots.h\"\n            #include \"src/objects/string.h\"\n            #include \"src/roots/roots.h\"\n            #include \"src/sandbox/js-dispatch-table-inl.h\"\n            #include \"src/snapshot/embedded/embedded-data-inl.h\"\n            #include \"src/snapshot/references.h\"\n            #include \"src/snapshot/serializer-deserializer.h\"\n            #include \"src/snapshot/shared-heap-serializer.h\"\n            #include \"src/snapshot/snapshot-data.h\"\n            #include \"src/utils/memcopy.h\"\n\n            // Has to be the last include (doesn't have include guards)\n            #include \"src/objects/object-macros.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SlotAccessorForHeapObject\",\n            \"about\": \"Provides GC-safe access to slots within a HeapObject using a Handle.  Handles object movement during GC.\",\n            \"attributes\": [\n                {\n                    \"name\": \"object_\",\n                    \"type\": \"Handle<HeapObject>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Handle to the HeapObject containing the slot.\"\n                },\n                {\n                    \"name\": \"offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Byte offset of the slot within the HeapObject.\"\n                }\n            ],\n            \"dependencies\": [\n                \"HeapObject\",\n                \"Handle\",\n                \"MaybeObjectSlot\",\n                \"ExternalPointerSlot\",\n                \"Tagged\",\n                \"WriteBarrier\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SlotAccessorForHeapObject {\n            public:\n            static SlotAccessorForHeapObject ForSlotIndex(Handle<HeapObject> object,\n                                                        int index) {\n                return SlotAccessorForHeapObject(object, index * kTaggedSize);\n            }\n            static SlotAccessorForHeapObject ForSlotOffset(Handle<HeapObject> object,\n                                                            int offset) {\n                return SlotAccessorForHeapObject(object, offset);\n            }\n\n            MaybeObjectSlot slot() const { return object_->RawMaybeWeakField(offset_); }\n            ExternalPointerSlot external_pointer_slot(ExternalPointerTag tag) const {\n                return object_->RawExternalPointerField(offset_, tag);\n            }\n            Handle<HeapObject> object() const { return object_; }\n            int offset() const { return offset_; }\n\n            // Writes the given value to this slot, with an offset (e.g. for repeat\n            // writes). Returns the number of slots written (which is one).\n            int Write(Tagged<MaybeObject> value, int slot_offset, WriteBarrierMode mode) {\n                MaybeObjectSlot current_slot = slot() + slot_offset;\n                current_slot.Relaxed_Store(value);\n            #ifdef V8_STATIC_ROOTS_BOOL\n                if (mode != SKIP_WRITE_BARRIER && FastInReadOnlySpaceOrSmallSmi(value)) {\n                // TODO(jgruber): Remove this once WriteBarrier::ForValue() contains the\n                // same check.\n                mode = SKIP_WRITE_BARRIER;\n                }\n            #endif  // V8_STATIC_ROOTS_BOOL\n                WriteBarrier::ForValue(*object_, current_slot, value, mode);\n                return 1;\n            }\n            int Write(Tagged<HeapObject> value, HeapObjectReferenceType ref_type,\n                        int slot_offset, WriteBarrierMode mode) {\n                return Write(Tagged<HeapObjectReference>(value, ref_type), slot_offset,\n                            mode);\n            }\n            int Write(DirectHandle<HeapObject> value, HeapObjectReferenceType ref_type,\n                        int slot_offset, WriteBarrierMode mode) {\n                return Write(*value, ref_type, slot_offset, mode);\n            }\n\n            int WriteIndirectPointerTo(Tagged<HeapObject> value, WriteBarrierMode mode) {\n                // Only ExposedTrustedObjects can be referenced via indirect pointers, so\n                // we must have one of these objects here. See the comments in\n                // trusted-object.h for more details.\n                DCHECK(IsExposedTrustedObject(value));\n                Tagged<ExposedTrustedObject> object = Cast<ExposedTrustedObject>(value);\n\n                InstanceType instance_type = value->map()->instance_type();\n                IndirectPointerTag tag = IndirectPointerTagFromInstanceType(instance_type);\n                IndirectPointerSlot dest = object_->RawIndirectPointerField(offset_, tag);\n                dest.store(object);\n\n                WriteBarrier::ForIndirectPointer(*object_, dest, value, mode);\n                return 1;\n            }\n\n            int WriteProtectedPointerTo(Tagged<TrustedObject> value,\n                                        WriteBarrierMode mode) {\n                DCHECK(IsTrustedObject(*object_));\n                Tagged<TrustedObject> host = Cast<TrustedObject>(*object_);\n                ProtectedPointerSlot dest = host->RawProtectedPointerField(offset_);\n                dest.store(value);\n                WriteBarrier::ForProtectedPointer(host, dest, value, mode);\n                return 1;\n            }\n\n            private:\n            SlotAccessorForHeapObject(Handle<HeapObject> object, int offset)\n                : object_(object), offset_(offset) {}\n\n            const Handle<HeapObject> object_;\n            const int offset_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SlotAccessorForRootSlots\",\n            \"about\": \"Provides access to slots at absolute memory addresses, suitable for roots. It does not handle GC movement, as roots are fixed.\",\n            \"attributes\": [\n                {\n                    \"name\": \"slot_\",\n                    \"type\": \"FullMaybeObjectSlot\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The absolute memory address of the slot.\"\n                }\n            ],\n            \"dependencies\": [\n                \"FullMaybeObjectSlot\",\n                \"Tagged\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SlotAccessorForRootSlots {\n            public:\n            explicit SlotAccessorForRootSlots(FullMaybeObjectSlot slot) : slot_(slot) {}\n\n            FullMaybeObjectSlot slot() const { return slot_; }\n            ExternalPointerSlot external_pointer_slot(ExternalPointerTag tag) const {\n                UNREACHABLE();\n            }\n            Handle<HeapObject> object() const { UNREACHABLE(); }\n            int offset() const { UNREACHABLE(); }\n\n            // Writes the given value to this slot, with an offset (e.g. for repeat\n            // writes). Returns the number of slots written (which is one).\n            int Write(Tagged<MaybeObject> value, int slot_offset, WriteBarrierMode mode) {\n                FullMaybeObjectSlot current_slot = slot() + slot_offset;\n                current_slot.Relaxed_Store(value);\n                return 1;\n            }\n            int Write(Tagged<HeapObject> value, HeapObjectReferenceType ref_type,\n                        int slot_offset, WriteBarrierMode mode) {\n                return Write(Tagged<HeapObjectReference>(value, ref_type), slot_offset,\n                            mode);\n            }\n            int Write(DirectHandle<HeapObject> value, HeapObjectReferenceType ref_type,\n                        int slot_offset, WriteBarrierMode mode) {\n                return Write(*value, ref_type, slot_offset, mode);\n            }\n            int WriteIndirectPointerTo(Tagged<HeapObject> value, WriteBarrierMode mode) {\n                UNREACHABLE();\n            }\n            int WriteProtectedPointerTo(Tagged<TrustedObject> value,\n                                        WriteBarrierMode mode) {\n                UNREACHABLE();\n            }\n\n            private:\n            const FullMaybeObjectSlot slot_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SlotAccessorForHandle\",\n            \"about\": \"Provides a SlotAccessor for creating a Handle, which saves a Handle allocation when a Handle already exists.\",\n            \"attributes\": [\n                {\n                    \"name\": \"handle_\",\n                    \"type\": \"DirectHandle<HeapObject>*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the existing Handle to be updated.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"IsolateT*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the isolate.\"\n                }\n            ],\n            \"dependencies\": [\n                \"DirectHandle\",\n                \"HeapObject\",\n                \"IsolateT\",\n                \"Tagged\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename IsolateT>\n            class SlotAccessorForHandle {\n            public:\n            SlotAccessorForHandle(DirectHandle<HeapObject>* handle, IsolateT* isolate)\n                : handle_(handle), isolate_(isolate) {}\n\n            MaybeObjectSlot slot() const { UNREACHABLE(); }\n            ExternalPointerSlot external_pointer_slot(ExternalPointerTag tag) const {\n                UNREACHABLE();\n            }\n            Handle<HeapObject> object() const { UNREACHABLE(); }\n            int offset() const { UNREACHABLE(); }\n\n            int Write(Tagged<MaybeObject> value, int slot_offset, WriteBarrierMode mode) {\n                UNREACHABLE();\n            }\n            int Write(Tagged<HeapObject> value, HeapObjectReferenceType ref_type,\n                        int slot_offset, WriteBarrierMode mode) {\n                DCHECK_EQ(slot_offset, 0);\n                DCHECK_EQ(ref_type, HeapObjectReferenceType::STRONG);\n                *handle_ = direct_handle(value, isolate_);\n                return 1;\n            }\n            int Write(DirectHandle<HeapObject> value, HeapObjectReferenceType ref_type,\n                        int slot_offset, WriteBarrierMode mode) {\n                DCHECK_EQ(slot_offset, 0);\n                DCHECK_EQ(ref_type, HeapObjectReferenceType::STRONG);\n                *handle_ = value;\n                return 1;\n            }\n            int WriteIndirectPointerTo(Tagged<HeapObject> value, WriteBarrierMode mode) {\n                UNREACHABLE();\n            }\n            int WriteProtectedPointerTo(Tagged<TrustedObject> value,\n                                        WriteBarrierMode mode) {\n                UNREACHABLE();\n            }\n\n            private:\n            DirectHandle<HeapObject>* handle_;\n            IsolateT* isolate_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteHeapPointer\",\n            \"parent\": \"Deserializer\",\n            \"about\": \"Writes a HeapObject pointer to a slot, handling indirect pointers and write barriers.\",\n            \"logic\": \"Overloaded template method to handle writing HeapObject pointers. If the reference is an indirect pointer, it calls WriteIndirectPointerTo. Otherwise, it uses the standard Write method. It also handles protected pointers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"slot_accessor\",\n                    \"type\": \"SlotAccessor\",\n                    \"purpose\": \"Accessor for the memory slot to write to.\"\n                },\n                {\n                    \"name\": \"heap_object\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The HeapObject to write.\"\n                },\n                {\n                    \"name\": \"descr\",\n                    \"type\": \"ReferenceDescriptor\",\n                    \"purpose\": \"Describes the reference type (weak/strong/indirect).\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"WriteBarrierMode\",\n                    \"purpose\": \"Specifies whether to perform a write barrier.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The number of slots written (always 1).\"\n            },\n            \"dependencies\": [\n                \"ExposedTrustedObject\",\n                \"HeapObject\",\n                \"ReferenceDescriptor\",\n                \"WriteBarrierMode\",\n                \"WriteBarrier\",\n                \"SlotAccessor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename IsolateT>\n            template <typename SlotAccessor>\n            int Deserializer<IsolateT>::WriteHeapPointer(SlotAccessor slot_accessor,\n                                                        Tagged<HeapObject> heap_object,\n                                                        ReferenceDescriptor descr,\n                                                        WriteBarrierMode mode) {\n            if (descr.is_indirect_pointer) {\n                return slot_accessor.WriteIndirectPointerTo(heap_object, mode);\n            } else {\n                return slot_accessor.Write(heap_object, descr.type, 0, mode);\n            }\n            }\n\n            template <typename IsolateT>\n            template <typename SlotAccessor>\n            int Deserializer<IsolateT>::WriteHeapPointer(\n                SlotAccessor slot_accessor, DirectHandle<HeapObject> heap_object,\n                ReferenceDescriptor descr, WriteBarrierMode mode) {\n            if (descr.is_indirect_pointer) {\n                return slot_accessor.WriteIndirectPointerTo(*heap_object, mode);\n            } else if (descr.is_protected_pointer) {\n                DCHECK(IsTrustedObject(*heap_object));\n                return slot_accessor.WriteProtectedPointerTo(\n                    Cast<TrustedObject>(*heap_object), mode);\n            } else {\n                return slot_accessor.Write(heap_object, descr.type, 0, mode);\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteExternalPointer\",\n            \"parent\": \"Deserializer\",\n            \"about\": \"Writes an external pointer to a slot in a HeapObject, handling sandbox-related checks.\",\n            \"logic\": \"Initializes an ExternalPointerSlot with the given address and tag, updating the host object and performing necessary sandbox checks.  It also takes into account snapshot stress mode where resources are temporarily saved and restored.\",\n            \"parameters\": [\n                {\n                    \"name\": \"host\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The HeapObject containing the external pointer slot.\"\n                },\n                {\n                    \"name\": \"dest\",\n                    \"type\": \"ExternalPointerSlot\",\n                    \"purpose\": \"The ExternalPointerSlot to write to.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The address of the external resource.\"\n                },\n                {\n                    \"name\": \"tag\",\n                    \"type\": \"ExternalPointerTag\",\n                    \"purpose\": \"The tag associated with the external pointer.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The number of slots covered by the external pointer (kExternalPointerSlotSize / kTaggedSize).\"\n            },\n            \"dependencies\": [\n                \"ExternalPointerSlot\",\n                \"HeapObject\",\n                \"ExternalPointerTag\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename IsolateT>\n            int Deserializer<IsolateT>::WriteExternalPointer(Tagged<HeapObject> host,\n                                                        ExternalPointerSlot dest,\n                                                        Address value,\n                                                        ExternalPointerTag tag) {\n            DCHECK(!next_reference_is_weak_ && !next_reference_is_indirect_pointer_ &&\n                !next_reference_is_protected_pointer);\n\n            #ifdef V8_ENABLE_SANDBOX\n            ExternalPointerTable::ManagedResource* managed_resource = nullptr;\n            ExternalPointerTable* owning_table = nullptr;\n            ExternalPointerHandle original_handle = kNullExternalPointerHandle;\n            if (IsManagedExternalPointerType(tag)) {\n                // This can currently only happen during snapshot stress mode as we cannot\n                // normally serialized managed resources. In snapshot stress mode, the new\n                // isolate will be destroyed and the old isolate (really, the old isolate's\n                // external pointer table) therefore effectively retains ownership of the\n                // resource. As such, we need to save and restore the relevant fields of\n                // the external resource. Once the external pointer table itself destroys\n                // the managed resource when freeing the corresponding table entry, this\n                // workaround can be removed again.\n                DCHECK(v8_flags.stress_snapshot);\n                managed_resource =\n                    reinterpret_cast<ExternalPointerTable::ManagedResource*>(value);\n                owning_table = managed_resource->owning_table_;\n                original_handle = managed_resource->ept_entry_;\n                managed_resource->owning_table_ = nullptr;\n                managed_resource->ept_entry_ = kNullExternalPointerHandle;\n            }\n            #endif  // V8_ENABLE_SANDBOX\n\n            dest.init(main_thread_isolate(), host, value, tag);\n\n            #ifdef V8_ENABLE_SANDBOX\n            if (managed_resource) {\n                managed_resource->owning_table_ = owning_table;\n                managed_resource->ept_entry_ = original_handle;\n            }\n            #endif  // V8_ENABLE_SANDBOX\n\n            // ExternalPointers can only be written into HeapObject fields, therefore they\n            // cover (kExternalPointerSlotSize / kTaggedSize) slots.\n            return (kExternalPointerSlotSize / kTaggedSize);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetNumApiReferences\",\n            \"about\": \"Returns the number of external references registered through the API.\",\n            \"logic\": \"Iterates through the api_external_references array of the isolate and counts the number of non-null entries.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate whose external references are to be counted.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The number of external references registered through the API.\"\n            },\n            \"dependencies\": [\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n            #ifdef DEBUG\n            int GetNumApiReferences(Isolate* isolate) {\n            int num_api_references = 0;\n            // The read-only deserializer is run by read-only heap set-up before the\n            // heap is fully set up. External reference table relies on a few parts of\n            // this set-up (like old-space), so it may be uninitialized at this point.\n            if (isolate->isolate_data()->external_reference_table()->is_initialized()) {\n                // Count the number of external references registered through the API.\n                if (isolate->api_external_references() != nullptr) {\n                while (isolate->api_external_references()[num_api_references] != 0) {\n                    num_api_references++;\n                }\n                }\n            }\n            return num_api_references;\n            }\n            int GetNumApiReferences(LocalIsolate* isolate) { return 0; }\n            #endif\n            }  // namespace\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Deserializer\",\n            \"about\": \"Deserializes V8 snapshots to recreate the heap.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"IsolateT*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The isolate being deserialized into.\"\n                },\n                {\n                    \"name\": \"attached_objects_\",\n                    \"type\": \"FixedArray\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of objects attached to the snapshot.\"\n                },\n                {\n                    \"name\": \"source_\",\n                    \"type\": \"SerializedData::Payload\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The source of the serialized data.\"\n                },\n                {\n                    \"name\": \"magic_number_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Magic number to verify snapshot integrity.\"\n                },\n                {\n                    \"name\": \"new_maps_\",\n                    \"type\": \"std::vector<Handle<Map>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of newly created Maps (for logging).\"\n                },\n                {\n                    \"name\": \"new_allocation_sites_\",\n                    \"type\": \"std::vector<Handle<AllocationSite>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of allocation sites to link later.\"\n                },\n                {\n                    \"name\": \"new_code_objects_\",\n                    \"type\": \"std::vector<Handle<InstructionStream>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of newly created code objects.\"\n                },\n                {\n                    \"name\": \"accessor_infos_\",\n                    \"type\": \"std::vector<Handle<AccessorInfo>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of accessor infos.\"\n                },\n                {\n                    \"name\": \"function_template_infos_\",\n                    \"type\": \"std::vector<Handle<FunctionTemplateInfo>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of function template infos.\"\n                },\n                {\n                    \"name\": \"new_scripts_\",\n                    \"type\": \"std::vector<Handle<Script>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of newly created Scripts.\"\n                },\n                {\n                    \"name\": \"new_descriptor_arrays_\",\n                    \"type\": \"DescriptorArrayRefList\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of descriptor arrays.\"\n                },\n                {\n                    \"name\": \"deserializing_user_code_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating if user code is being deserialized.\"\n                },\n                {\n                    \"name\": \"should_rehash_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating if rehashing is necessary.\"\n                },\n                {\n                    \"name\": \"to_rehash_\",\n                    \"type\": \"std::vector<Handle<HeapObject>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Objects that need to be rehashed.\"\n                },\n                {\n                    \"name\": \"backing_stores_\",\n                    \"type\": \"std::vector<std::unique_ptr<BackingStore>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Backing stores for TypedArrays and ArrayBuffers.\"\n                },\n                {\n                    \"name\": \"back_refs_\",\n                    \"type\": \"std::vector<Handle<HeapObject>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Objects that have been deserialized (for back references).\"\n                },\n                {\n                    \"name\": \"num_api_references_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of API external references.\"\n                },\n                {\n                    \"name\": \"next_reference_is_weak_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the next reference is a weak reference\"\n                },\n                {\n                    \"name\": \"next_reference_is_indirect_pointer_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the next reference is an indirect pointer\"\n                },\n                {\n                    \"name\": \"next_reference_is_protected_pointer\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the next reference is a protected pointer\"\n                },\n                {\n                    \"name\": \"unresolved_forward_refs_\",\n                    \"type\": \"std::vector<ForwardRef>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A list of forward references to resolve later. Used for indirect pointers.\"\n                },\n                {\n                    \"name\": \"num_unresolved_forward_refs_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Keeps track of the total number of unresolved forward references. Used for assertions.\"\n                },\n                {\n                    \"name\": \"js_dispatch_entries_\",\n                    \"type\": \"std::vector<JSDispatchHandle>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of JS dispatch entries.\"\n                },\n                {\n                    \"name\": \"hot_objects_\",\n                    \"type\": \"HotObjects\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of hot objects used during deserialization.\"\n                }\n            ],\n            \"dependencies\": [\n                \"IsolateT\",\n                \"FixedArray\",\n                \"SerializedData\",\n                \"Handle\",\n                \"Map\",\n                \"AllocationSite\",\n                \"InstructionStream\",\n                \"AccessorInfo\",\n                \"FunctionTemplateInfo\",\n                \"Script\",\n                \"Heap\",\n                \"BackingStore\",\n                \"HeapObject\",\n                \"StringTable\",\n                \"JSReceiver\",\n                \"SharedFunctionInfo\",\n                \"AllocationType\",\n                \"RootsTable\",\n                \"SnapshotSpace\",\n                \"Code\",\n                \"DescriptorArray\",\n                \"NativeContext\",\n                \"ReadOnlySpace\",\n                \"ExternalPointerTable\",\n                \"BytecodeArray\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename IsolateT>\n            class Deserializer {\n            public:\n            Deserializer(IsolateT* isolate,\n                                        base::Vector<const uint8_t> payload,\n                                        uint32_t magic_number,\n                                        bool deserializing_user_code,\n                                        bool can_rehash);\n            ~Deserializer();\n\n            void VisitRootPointers(Root root, const char* description, FullObjectSlot start,\n                                    FullObjectSlot end);\n            void Synchronize(VisitorSynchronization::SyncTag tag);\n            void DeserializeDeferredObjects();\n            void LogNewMapEvents();\n            void WeakenDescriptorArrays();\n            Tagged<HeapObject> Allocate(AllocationType allocation, int size, AllocationAlignment alignment);\n\n            // Should be called only on the main thread (not thread safe).\n            void PostProcessNewJSReceiver(Tagged<Map> map, DirectHandle<JSReceiver> obj,\n                                            InstanceType instance_type, SnapshotSpace space);\n            void PostProcessNewObject(DirectHandle<Map> map, Handle<HeapObject> obj,\n                                        SnapshotSpace space);\n\n            void Rehash();\n\n            IsolateT* isolate() const { return isolate_; }\n            Isolate* main_thread_isolate() const { return isolate_; }\n            SerializedData::Payload* source() { return &source_; }\n\n            bool deserializing_user_code() const { return deserializing_user_code_; }\n            bool should_rehash() const { return should_rehash_; }\n\n            class ReferenceDescriptor {\n            public:\n                HeapObjectReferenceType type;\n                bool is_indirect_pointer = false;\n                bool is_protected_pointer = false;\n            };\n            ReferenceDescriptor GetAndResetNextReferenceDescriptor();\n            DirectHandle<HeapObject> ReadObject();\n            Handle<HeapObject> ReadObject(SnapshotSpace space);\n\n            private:\n            static constexpr int kRootArrayConstantsCount = 32;\n\n            Handle<HeapObject> GetBackReferencedObject();\n            Handle<HeapObject> GetBackReferencedObject(uint32_t index);\n\n            // For debugging, we track objects to make sure we allocate enough.\n            #ifdef DEBUG\n            DirectHandle<HeapObject> previous_allocation_obj_ = DirectHandle<HeapObject>();\n            int previous_allocation_size_ = 0;\n            #endif\n\n            Handle<HeapObject> ReadMetaMap(SnapshotSpace space);\n            template <typename SlotAccessor>\n            int ReadRepeatedRoot(SlotAccessor slot_accessor, int repeat_count);\n\n            template <typename SlotAccessor>\n            int ReadSingleBytecodeData(uint8_t data, SlotAccessor slot_accessor);\n            void ReadData(Handle<HeapObject> object, int start_slot_index,\n                            int end_slot_index);\n            void ReadData(FullMaybeObjectSlot start, FullMaybeObjectSlot end);\n\n            template <typename SlotAccessor>\n            int ReadNewObject(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadBackref(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadReadOnlyHeapRef(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadRootArray(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadStartupObjectCache(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadSharedHeapObjectCache(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadNewMetaMap(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadExternalReference(uint8_t data, SlotAccessor slot_accessor);\n            Address ReadExternalReferenceCase();\n            ExternalPointerTag ReadExternalPointerTag();\n            template <typename SlotAccessor>\n            int ReadRawExternalReference(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadAttachedReference(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadRegisterPendingForwardRef(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadResolvePendingForwardRef(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadVariableRawData(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadVariableRepeatRoot(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadOffHeapBackingStore(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadApiReference(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadClearedWeakReference(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadWeakPrefix(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadIndirectPointerPrefix(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadInitializeSelfIndirectPointer(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadAllocateJSDispatchEntry(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadJSDispatchEntry(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadProtectedPointerPrefix(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadRootArrayConstants(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadHotObject(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadFixedRawData(uint8_t data, SlotAccessor slot_accessor);\n            template <typename SlotAccessor>\n            int ReadFixedRepeatRoot(uint8_t data, SlotAccessor slot_accessor);\n\n            template <typename SlotAccessor>\n            int WriteHeapPointer(SlotAccessor slot_accessor, Tagged<HeapObject> heap_object,\n                                ReferenceDescriptor descr, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);\n            template <typename SlotAccessor>\n            int WriteHeapPointer(SlotAccessor slot_accessor, DirectHandle<HeapObject> heap_object,\n                                ReferenceDescriptor descr, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);\n            int WriteExternalPointer(Tagged<HeapObject> host, ExternalPointerSlot dest,\n                                    Address value, ExternalPointerTag tag);\n\n            void PushObjectToRehash(Handle<HeapObject> object) { to_rehash_.push_back(object); }\n            BackingStore* backing_store(uint32_t store_index) {\n                return backing_stores_[store_index].get();\n            }\n\n            IsolateT* isolate_;\n            FixedArray attached_objects_;\n            SerializedData::Payload source_;\n            uint32_t magic_number_;\n\n            // Keep track of all seen Maps to log them later since they might be only\n            // partially initialized at"
}