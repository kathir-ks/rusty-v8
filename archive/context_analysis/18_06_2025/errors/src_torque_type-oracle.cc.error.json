{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/type-oracle.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 38, column 47",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/type-oracle.cc\",\n        \"file_name\": \"type-oracle.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Manages and provides access to types defined in the Torque language, including aggregate types, bitfield struct types, and generic type instances.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for type definitions, data structures, and error reporting in the Torque compiler.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/type-oracle.h\"\n\n#include <optional>\n\n#include \"src/torque/type-visitor.h\"\n#include \"src/torque/types.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetAggregateTypes\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves a vector of unique pointers to all aggregate types.\",\n            \"logic\": \"Returns the aggregate_types_ member of the singleton TypeOracle instance.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"const std::vector<std::unique_ptr<AggregateType>>&\",\n                \"description\": \"A constant reference to the vector of aggregate type unique pointers.\"\n            },\n            \"dependencies\": [\n                \"TypeOracle\",\n                \"AggregateType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nconst std::vector<std::unique_ptr<AggregateType>>&\nTypeOracle::GetAggregateTypes() {\n  return Get().aggregate_types_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetBitFieldStructTypes\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves a vector of unique pointers to all bitfield struct types.\",\n            \"logic\": \"Returns the bit_field_struct_types_ member of the singleton TypeOracle instance.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"const std::vector<std::unique_ptr<BitFieldStructType>>&\",\n                \"description\": \"A constant reference to the vector of bitfield struct type unique pointers.\"\n            },\n            \"dependencies\": [\n                \"TypeOracle\",\n                \"BitFieldStructType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nconst std::vector<std::unique_ptr<BitFieldStructType>>&\nTypeOracle::GetBitFieldStructTypes() {\n  return Get().bit_field_struct_types_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FinalizeAggregateTypes\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Finalizes all aggregate types, ensuring their internal structures are fully resolved.\",\n            \"logic\": \"Iterates through the aggregate_types_ vector and calls the Finalize() method on each AggregateType. This might resolve forward declarations or perform other finalization steps.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"TypeOracle\",\n                \"AggregateType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TypeOracle::FinalizeAggregateTypes() {\n  size_t current = 0;\n  while (current != Get().aggregate_types_.size()) {\n    auto& p = Get().aggregate_types_[current++];\n    p->Finalize();\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetGenericTypeInstance\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves a specific instance of a generic type, based on the provided type arguments.\",\n            \"logic\": \"Checks if a specialization for the given generic type and arguments already exists. If so, returns the existing specialization. Otherwise, computes the type using TypeVisitor::ComputeType, adds it as a specialization, and returns the new type. Includes error handling for incorrect number of type arguments.\",\n            \"parameters\": [\n                {\n                    \"name\": \"generic_type\",\n                    \"type\": \"GenericType*\",\n                    \"purpose\": \"The generic type to instantiate.\"\n                },\n                {\n                    \"name\": \"arg_types\",\n                    \"type\": \"TypeVector\",\n                    \"purpose\": \"The type arguments to use for instantiation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const Type*\",\n                \"description\": \"The specialized type instance.\"\n            },\n            \"dependencies\": [\n                \"TypeOracle\",\n                \"GenericType\",\n                \"TypeVector\",\n                \"TypeVisitor\",\n                \"CurrentScope\",\n                \"Scope\",\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nconst Type* TypeOracle::GetGenericTypeInstance(GenericType* generic_type,\n                                               TypeVector arg_types) {\n  auto& params = generic_type->generic_parameters();\n\n  if (params.size() != arg_types.size()) {\n    ReportError(\"Generic struct takes \", params.size(), \" parameters, but \",\n                arg_types.size(), \" were given\");\n  }\n\n  if (auto specialization = generic_type->GetSpecialization(arg_types)) {\n    return *specialization;\n  } else {\n    const Type* type = nullptr;\n    // AddSpecialization can raise an error, which should be reported in the\n    // scope of the code requesting the specialization, not the generic type's\n    // parent scope, hence the following block.\n    {\n      v8::internal::torque::Scope* requester_scope = CurrentScope::Get();\n      CurrentScope::Scope generic_scope(generic_type->ParentScope());\n      type = TypeVisitor::ComputeType(generic_type->declaration(),\n                                      {{generic_type, arg_types}},\n                                      requester_scope);\n    }\n    generic_type->AddSpecialization(arg_types, type);\n    return type;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CreateGenericTypeInstantiationNamespace\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Creates a new namespace for generic type instantiations.\",\n            \"logic\": \"Creates a new Namespace with the name GENERIC_TYPE_INSTANTIATION_NAMESPACE_STRING and adds it to the generic_type_instantiation_namespaces_ vector. Returns a pointer to the newly created namespace.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Namespace*\",\n                \"description\": \"A pointer to the newly created namespace.\"\n            },\n            \"dependencies\": [\n                \"TypeOracle\",\n                \"Namespace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNamespace* TypeOracle::CreateGenericTypeInstantiationNamespace() {\n  Get().generic_type_instantiation_namespaces_.push_back(\n      std::make_unique<Namespace>(GENERIC_TYPE_INSTANTIATION_NAMESPACE_STRING));\n  return Get().generic_type_instantiation_namespaces_.back().get();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetClasses\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves a vector of all ClassType instances.\",\n            \"logic\": \"Iterates through the aggregate_types_ vector. If an AggregateType can be dynamically cast to a ClassType, it's added to the result vector.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::vector<const ClassType*>\",\n                \"description\": \"A vector containing pointers to all ClassType instances.\"\n            },\n            \"dependencies\": [\n                \"TypeOracle\",\n                \"ClassType\",\n                \"AggregateType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::vector<const ClassType*> TypeOracle::GetClasses() {\n  std::vector<const ClassType*> result;\n  for (const std::unique_ptr<AggregateType>& t : Get().aggregate_types_) {\n    if (auto* class_type = ClassType::DynamicCast(t.get())) {\n      result.push_back(class_type);\n    }\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MatchReferenceGeneric\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Matches a type against the MutableReferenceGeneric and ConstReferenceGeneric, returning the underlying type if a match is found.\",\n            \"logic\": \"Tries to match the input reference_type against MutableReferenceGeneric and ConstReferenceGeneric using Type::MatchUnaryGeneric. If a match is found, it sets the is_const pointer (if provided) accordingly and returns the underlying type. Returns std::nullopt if no match is found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"reference_type\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The type to match against the reference generics.\"\n                },\n                {\n                    \"name\": \"is_const\",\n                    \"type\": \"bool*\",\n                    \"purpose\": \"Optional pointer to a boolean that will be set to true if the match is with ConstReferenceGeneric, false if with MutableReferenceGeneric. Can be nullptr.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<const Type*>\",\n                \"description\": \"The underlying type if a match is found, std::nullopt otherwise.\"\n            },\n            \"dependencies\": [\n                \"TypeOracle\",\n                \"Type\",\n                \"MutableReferenceGeneric\",\n                \"ConstReferenceGeneric\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<const Type*> TypeOracle::MatchReferenceGeneric(\n    const Type* reference_type, bool* is_const) {\n  if (auto type = Type::MatchUnaryGeneric(reference_type,\n                                          GetMutableReferenceGeneric())) {\n    if (is_const) *is_const = false;\n    return type;\n  }\n  if (auto type =\n          Type::MatchUnaryGeneric(reference_type, GetConstReferenceGeneric())) {\n    if (is_const) *is_const = true;\n    return type;\n  }\n  return std::nullopt;\n}\n        ]]></code>\n    </func>\n</file>\n```"
}