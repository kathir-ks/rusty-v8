{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/logging/metrics.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 44, column 48",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/logging/metrics.h\",\n        \"file_name\": \"metrics.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines classes and utilities for recording metrics within the V8 JavaScript engine. It allows for tracking events on the main thread and in a thread-safe manner, as well as timing code execution.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for memory management, data structures, platform utilities, and metrics definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <memory>\n            #include <queue>\n\n            #include \"include/v8-metrics.h\"\n            #include \"src/base/platform/mutex.h\"\n            #include \"src/base/platform/time.h\"\n            #include \"src/init/v8.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Recorder\",\n            \"extends\": \"std::enable_shared_from_this<Recorder>\",\n            \"about\": \"A class for recording metrics events, both on the main thread and in a thread-safe manner. It supports delaying events to be processed on the main thread.\",\n            \"attributes\": [\n                {\n                    \"name\": \"lock_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Protects access to shared resources, such as the queue of delayed events.\"\n                },\n                {\n                    \"name\": \"foreground_task_runner_\",\n                    \"type\": \"std::shared_ptr<v8::TaskRunner>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A task runner for executing tasks on the main thread.\"\n                },\n                {\n                    \"name\": \"embedder_recorder_\",\n                    \"type\": \"std::shared_ptr<v8::metrics::Recorder>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"An optional recorder provided by the embedder of V8, used to forward events.\"\n                },\n                {\n                    \"name\": \"delayed_events_\",\n                    \"type\": \"std::queue<std::unique_ptr<DelayedEventBase>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A queue of events that are delayed to be processed on the main thread.\"\n                }\n            ],\n            \"dependencies\": [\n                \"v8::metrics::Recorder\",\n                \"Isolate\",\n                \"TaskRunner\",\n                \"DelayedEventBase\",\n                \"DelayedEvent\",\n                \"base::Mutex\",\n                \"base::TimeDelta\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Recorder : public std::enable_shared_from_this<Recorder> {\n            public:\n            V8_EXPORT_PRIVATE void SetEmbedderRecorder(\n                Isolate* isolate,\n                const std::shared_ptr<v8::metrics::Recorder>& embedder_recorder);\n\n            V8_EXPORT_PRIVATE bool HasEmbedderRecorder() const;\n\n            V8_EXPORT_PRIVATE void NotifyIsolateDisposal();\n\n            template <class T>\n            void AddMainThreadEvent(const T& event,\n                                    v8::metrics::Recorder::ContextId id) {\n                if (embedder_recorder_)\n                embedder_recorder_->AddMainThreadEvent(event, id);\n            }\n\n            template <class T>\n            void DelayMainThreadEvent(const T& event,\n                                        v8::metrics::Recorder::ContextId id) {\n                if (!embedder_recorder_) return;\n                Delay(std::make_unique<DelayedEvent<T>>(event, id));\n            }\n\n            template <class T>\n            void AddThreadSafeEvent(const T& event) {\n                if (embedder_recorder_) embedder_recorder_->AddThreadSafeEvent(event);\n            }\n\n            private:\n            class DelayedEventBase {\n            public:\n                virtual ~DelayedEventBase() = default;\n\n                virtual void Run(const std::shared_ptr<Recorder>& recorder) = 0;\n            };\n\n            template <class T>\n            class DelayedEvent : public DelayedEventBase {\n            public:\n                DelayedEvent(const T& event, v8::metrics::Recorder::ContextId id)\n                    : event_(event), id_(id) {}\n\n                void Run(const std::shared_ptr<Recorder>& recorder) override {\n                recorder->AddMainThreadEvent(event_, id_);\n                }\n\n            protected:\n                T event_;\n                v8::metrics::Recorder::ContextId id_;\n            };\n\n            class Task;\n\n            V8_EXPORT_PRIVATE void Delay(\n                std::unique_ptr<Recorder::DelayedEventBase>&& event);\n\n            base::Mutex lock_;\n            std::shared_ptr<v8::TaskRunner> foreground_task_runner_;\n            std::shared_ptr<v8::metrics::Recorder> embedder_recorder_;\n            std::queue<std::unique_ptr<DelayedEventBase>> delayed_events_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TimedScope\",\n            \"about\": \"A class for measuring the execution time of a code block.  It uses RAII to start and stop timing automatically.\",\n            \"attributes\": [\n                {\n                    \"name\": \"event_\",\n                    \"type\": \"T*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A pointer to the event to record timing information to.\"\n                },\n                {\n                    \"name\": \"start_time_\",\n                    \"type\": \"base::TimeTicks\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The time when the scope started.\"\n                }\n            ],\n            \"dependencies\": [\n                \"base::TimeTicks\",\n                \"base::TimeDelta\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T, int64_t (base::TimeDelta::*precision)() const =\n                        &base::TimeDelta::InMicroseconds>\n            class V8_NODISCARD TimedScope {\n            public:\n            explicit TimedScope(T* event) : event_(event) { Start(); }\n            ~TimedScope() { Stop(); }\n\n            void Start() { start_time_ = base::TimeTicks::Now(); }\n\n            void Stop() {\n                if (start_time_.IsMin()) return;\n                base::TimeDelta duration = base::TimeTicks::Now() - start_time_;\n                event_->wall_clock_duration_in_us = (duration.*precision)();\n                start_time_ = base::TimeTicks::Min();\n            }\n\n            private:\n            T* event_;\n            base::TimeTicks start_time_;\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TaskRunner\",\n                \"about\": \"An interface for running tasks on a specific thread or context.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TaskRunner {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"v8::metrics::Recorder\",\n                \"about\": \"Abstract base class for metrics recorders.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 { namespace metrics { class Recorder {}; } }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"base::Mutex\",\n                \"about\": \"A mutex for thread synchronization.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { class Mutex {}; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"base::TimeTicks\",\n                \"about\": \"Represents a point in time with high resolution.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { class TimeTicks { public: static TimeTicks Now(); bool IsMin(); }; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"base::TimeDelta\",\n                \"about\": \"Represents a duration of time.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { class TimeDelta { public: int64_t InMicroseconds() const; }; }\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}