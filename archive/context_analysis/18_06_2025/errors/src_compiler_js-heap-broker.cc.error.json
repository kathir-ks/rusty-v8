{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-heap-broker.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-heap-broker.cc\",\n            \"file_name\": \"js-heap-broker.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides a broker for accessing the JavaScript heap during compilation.  It allows the compiler to safely access heap objects and their properties, and it caches information to improve performance.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for JSHeapBroker functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/js-heap-broker.h\"\n\n#include <optional>\n\n#ifdef ENABLE_SLOW_DCHECKS\n#include <algorithm>\n#endif\n\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/js-heap-broker-inl.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/heap/heap-inl.h\"\n#include \"src/objects/allocation-site-inl.h\"\n#include \"src/objects/js-array-inl.h\"\n#include \"src/objects/literal-objects-inl.h\"\n#include \"src/objects/map-updater.h\"\n#include \"src/objects/megadom-handler-inl.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/property-cell.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IncrementTracingIndentation\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Increments the tracing indentation level.\",\n                \"logic\": \"Increases the trace_indentation_ counter.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JSHeapBroker::IncrementTracingIndentation() { ++trace_indentation_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DecrementTracingIndentation\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Decrements the tracing indentation level.\",\n                \"logic\": \"Decreases the trace_indentation_ counter.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JSHeapBroker::DecrementTracingIndentation() { --trace_indentation_; }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSHeapBroker\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Provides a safe and efficient way for the compiler to access the JavaScript heap.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Isolate.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating broker data.\"\n                    },\n                    {\n                        \"name\": \"refs_\",\n                        \"type\": \"RefsMap*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map of references to heap objects.\"\n                    },\n                    {\n                        \"name\": \"root_index_map_\",\n                        \"type\": \"RootIndexMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mapping of root indices.\"\n                    },\n                    {\n                        \"name\": \"array_and_object_prototypes_\",\n                        \"type\": \"ZoneSet<CanonicalPersistentHandle<JSObject>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Cache of array and object prototypes.\"\n                    },\n                    {\n                        \"name\": \"tracing_enabled_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether tracing is enabled.\"\n                    },\n                    {\n                        \"name\": \"code_kind_\",\n                        \"type\": \"CodeKind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The kind of code being compiled.\"\n                    },\n                    {\n                        \"name\": \"feedback_\",\n                        \"type\": \"FeedbackMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores processed feedback for various operations.\"\n                    },\n                    {\n                        \"name\": \"property_access_infos_\",\n                        \"type\": \"PropertyAccessInfoMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores information about property accesses.\"\n                    },\n                     {\n                        \"name\": \"trace_indentation_\",\n                        \"type\": \"unsigned\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indentation level for tracing output.\"\n                    },\n                    {\n                        \"name\": \"mode_\",\n                        \"type\": \"Mode\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Current mode of the broker (serializing, serialized, retired).\"\n                    },\n                      {\n                        \"name\": \"local_isolate_\",\n                        \"type\": \"LocalIsolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A local isolate for the broker.\"\n                    },\n                     {\n                        \"name\": \"ph_\",\n                        \"type\": \"std::unique_ptr<PersistentHandles>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Persistent handles for local isolate.\"\n                    },\n                     {\n                        \"name\": \"target_native_context_\",\n                        \"type\": \"std::optional<NativeContextRef>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Target native context.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Zone\",\n                    \"RefsMap\",\n                    \"AddressMatcher\",\n                    \"CodeKind\",\n                    \"OptimizedCompilationInfo\",\n                    \"LocalIsolate\",\n                    \"PersistentHandles\",\n                    \"NativeContext\",\n                    \"ObjectData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nJSHeapBroker::JSHeapBroker(Isolate* isolate, Zone* broker_zone,\n                           bool tracing_enabled, CodeKind code_kind)\n    : isolate_(isolate),\n#if V8_COMPRESS_POINTERS\n      cage_base_(isolate),\n#endif  // V8_COMPRESS_POINTERS\n      zone_(broker_zone),\n      // Note that this initialization of {refs_} with the minimal initial\n      // capacity is redundant in the normal use case (concurrent compilation\n      // enabled, standard objects to be serialized), as the map is going to be\n      // replaced immediately with a larger-capacity one.  It doesn't seem to\n      // affect the performance in a noticeable way though.\n      refs_(zone()->New<RefsMap>(kMinimalRefsBucketCount, AddressMatcher(),\n                                 zone())),\n      root_index_map_(isolate),\n      array_and_object_prototypes_(zone()),\n      tracing_enabled_(tracing_enabled),\n      code_kind_(code_kind),\n      feedback_(zone()),\n      property_access_infos_(zone()) {\n  TRACE(this, \"Constructing heap broker\");\n}\n\nJSHeapBroker::~JSHeapBroker() { DCHECK_NULL(local_isolate_); }\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Trace\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Returns a string representing the current tracing indentation.\",\n                \"logic\": \"Creates an ostringstream and adds spaces based on the trace_indentation_ level.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"The tracing string.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::string JSHeapBroker::Trace() const {\n  std::ostringstream oss;\n  oss << \"[\" << this << \"] \";\n  for (unsigned i = 0; i < trace_indentation_ * 2; ++i) oss.put(' ');\n  return oss.str();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CurrentHeapBrokerScope\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"A helper class to set the current heap broker for a scope.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"prev_broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the previous broker.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nstatic thread_local JSHeapBroker* current_broker = nullptr;\n\nCurrentHeapBrokerScope::CurrentHeapBrokerScope(JSHeapBroker* broker)\n    : prev_broker_(current_broker) {\n  current_broker = broker;\n}\nCurrentHeapBrokerScope::~CurrentHeapBrokerScope() {\n  current_broker = prev_broker_;\n}\n\n// static\nJSHeapBroker* JSHeapBroker::Current() {\n  DCHECK_NOT_NULL(current_broker);\n  return current_broker;\n}\n#endif\n        ]]></code>\n    </class>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AttachLocalIsolate\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Attaches a LocalIsolate to the JSHeapBroker.\",\n                \"logic\": \"Sets the local_isolate_ field and attaches persistent handles from the OptimizedCompilationInfo to the local isolate's heap.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"info\",\n                        \"type\": \"OptimizedCompilationInfo*\",\n                        \"purpose\": \"The OptimizedCompilationInfo containing persistent handles.\"\n                    },\n                    {\n                        \"name\": \"local_isolate\",\n                        \"type\": \"LocalIsolate*\",\n                        \"purpose\": \"The LocalIsolate to attach.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"OptimizedCompilationInfo\",\n                    \"LocalIsolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JSHeapBroker::AttachLocalIsolate(OptimizedCompilationInfo* info,\n                                      LocalIsolate* local_isolate) {\n  DCHECK_NULL(local_isolate_);\n  local_isolate_ = local_isolate;\n  DCHECK_NOT_NULL(local_isolate_);\n  local_isolate_->heap()->AttachPersistentHandles(\n      info->DetachPersistentHandles());\n}\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DetachLocalIsolate\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Detaches the LocalIsolate from the JSHeapBroker.\",\n                \"logic\": \"Detaches the persistent handles from the local isolate's heap and sets the local_isolate_ field to nullptr.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"info\",\n                        \"type\": \"OptimizedCompilationInfo*\",\n                        \"purpose\": \"The OptimizedCompilationInfo to which to attach the persistent handles.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"OptimizedCompilationInfo\",\n                    \"LocalIsolate\",\n                    \"PersistentHandles\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JSHeapBroker::DetachLocalIsolate(OptimizedCompilationInfo* info) {\n  DCHECK_NULL(ph_);\n  DCHECK_NOT_NULL(local_isolate_);\n  std::unique_ptr<PersistentHandles> ph =\n      local_isolate_->heap()->DetachPersistentHandles();\n  local_isolate_ = nullptr;\n  info->set_persistent_handles(std::move(ph));\n}\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StopSerializing\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Stops the serialization process.\",\n                \"logic\": \"Changes the mode_ to kSerialized.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JSHeapBroker::StopSerializing() {\n  CHECK_EQ(mode_, kSerializing);\n  TRACE(this, \"Stopping serialization\");\n  mode_ = kSerialized;\n}\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Retire\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Retires the JSHeapBroker.\",\n                \"logic\": \"Changes the mode_ to kRetired.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JSHeapBroker::Retire() {\n  CHECK_EQ(mode_, kSerialized);\n  TRACE(this, \"Retiring\");\n  mode_ = kRetired;\n}\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetTargetNativeContextRef\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Sets the target native context reference.\",\n                \"logic\": \"Creates a reference to the provided NativeContext and stores it in target_native_context_.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"native_context\",\n                        \"type\": \"DirectHandle<NativeContext>\",\n                        \"purpose\": \"The NativeContext to set as the target.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NativeContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JSHeapBroker::SetTargetNativeContextRef(\n    DirectHandle<NativeContext> native_context) {\n  DCHECK(!target_native_context_.has_value());\n  target_native_context_ = MakeRef(this, *native_context);\n}\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CollectArrayAndObjectPrototypes\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Collects the Array and Object prototypes from all NativeContexts.\",\n                \"logic\": \"Iterates through all NativeContexts, retrieves the Array and Object prototypes and stores them in array_and_object_prototypes_.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Context\",\n                    \"JSObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JSHeapBroker::CollectArrayAndObjectPrototypes() {\n  DisallowGarbageCollection no_gc;\n  CHECK_EQ(mode(), kSerializing);\n  CHECK(array_and_object_prototypes_.empty());\n\n  Tagged<Object> maybe_context = isolate()->heap()->native_contexts_list();\n  while (!IsUndefined(maybe_context, isolate())) {\n    Tagged<Context> context = Cast<Context>(maybe_context);\n    Tagged<Object> array_prot =\n        context->get(Context::INITIAL_ARRAY_PROTOTYPE_INDEX);\n    Tagged<Object> object_prot =\n        context->get(Context::INITIAL_OBJECT_PROTOTYPE_INDEX);\n    array_and_object_prototypes_.emplace(\n        CanonicalPersistentHandle(Cast<JSObject>(array_prot)));\n    array_and_object_prototypes_.emplace(\n        CanonicalPersistentHandle(Cast<JSObject>(object_prot)));\n    maybe_context = context->next_context_link();\n  }\n\n  CHECK(!array_and_object_prototypes_.empty());\n}\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetTypedArrayStringTag\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Returns the string tag for a given TypedArray ElementsKind.\",\n                \"logic\": \"A switch statement returns the correct string based on the provided ElementsKind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"ElementsKind\",\n                        \"purpose\": \"The ElementsKind of the TypedArray.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"StringRef\",\n                    \"description\": \"The StringRef representing the TypedArray.\"\n                },\n                \"dependencies\": [\n                    \"ElementsKind\",\n                    \"StringRef\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nStringRef JSHeapBroker::GetTypedArrayStringTag(ElementsKind kind) {\n  DCHECK(IsTypedArrayOrRabGsabTypedArrayElementsKind(kind));\n  switch (kind) {\n#define TYPED_ARRAY_STRING_TAG(Type, type, TYPE, ctype) \\\n  case ElementsKind::TYPE##_ELEMENTS:                   \\\n    return Type##Array_string();\n    TYPED_ARRAYS(TYPED_ARRAY_STRING_TAG)\n    RAB_GSAB_TYPED_ARRAYS_WITH_TYPED_ARRAY_TYPE(TYPED_ARRAY_STRING_TAG)\n#undef TYPED_ARRAY_STRING_TAG\n    default:\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsArrayOrObjectPrototype\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Checks if a given JSObjectRef is either the Array or Object prototype.\",\n                \"logic\": \"Uses the cached array_and_object_prototypes_ or checks the Isolate if the broker is disabled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"JSObjectRef\",\n                        \"purpose\": \"The JSObjectRef to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object is an Array or Object prototype, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"JSObjectRef\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool JSHeapBroker::IsArrayOrObjectPrototype(JSObjectRef object) const {\n  return IsArrayOrObjectPrototype(object.object());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsArrayOrObjectPrototype\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Checks if a given Handle<JSObject> is either the Array or Object prototype.\",\n                \"logic\": \"Uses the cached array_and_object_prototypes_ or checks the Isolate if the broker is disabled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Handle<JSObject>\",\n                        \"purpose\": \"The Handle<JSObject> to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object is an Array or Object prototype, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Handle<JSObject>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool JSHeapBroker::IsArrayOrObjectPrototype(Handle<JSObject> object) const {\n  if (mode() == kDisabled) {\n    return isolate()->IsInCreationContext(\n               *object, Context::INITIAL_ARRAY_PROTOTYPE_INDEX) ||\n           object->map(isolate_)->instance_type() == JS_OBJECT_PROTOTYPE_TYPE;\n  }\n  CHECK(!array_and_object_prototypes_.empty());\n  return array_and_object_prototypes_.find(object) !=\n         array_and_object_prototypes_.end();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TryGetOrCreateData\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Tries to get or create ObjectData for a given Tagged<Object>.\",\n                \"logic\": \"Calls the overloaded function using CanonicalPersistentHandle.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Tagged<Object>\",\n                        \"purpose\": \"The Tagged<Object> to get or create ObjectData for.\"\n                    },\n                    {\n                        \"name\": \"flags\",\n                        \"type\": \"GetOrCreateDataFlags\",\n                        \"purpose\": \"Flags to control the creation of ObjectData.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ObjectData*\",\n                    \"description\": \"The ObjectData, or nullptr if not found and kCrashOnError is not set.\"\n                },\n                \"dependencies\": [\n                    \"ObjectData\",\n                    \"CanonicalPersistentHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nObjectData* JSHeapBroker::TryGetOrCreateData(Tagged<Object> object,\n                                             GetOrCreateDataFlags flags) {\n  return TryGetOrCreateData(CanonicalPersistentHandle(object), flags);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetOrCreateData\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Gets or creates ObjectData for a given Handle<Object>.\",\n                \"logic\": \"Calls TryGetOrCreateData with kCrashOnError flag.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Handle<Object>\",\n                        \"purpose\": \"The Handle<Object> to get or create ObjectData for.\"\n                    },\n                    {\n                        \"name\": \"flags\",\n                        \"type\": \"GetOrCreateDataFlags\",\n                        \"purpose\": \"Flags to control the creation of ObjectData.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ObjectData*\",\n                    \"description\": \"The ObjectData.\"\n                },\n                \"dependencies\": [\n                    \"ObjectData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nObjectData* JSHeapBroker::GetOrCreateData(Handle<Object> object,\n                                          GetOrCreateDataFlags flags) {\n  ObjectData* return_value = TryGetOrCreateData(object, flags | kCrashOnError);\n  DCHECK_NOT_NULL(return_value);\n  return return_value;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetOrCreateData\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Gets or creates ObjectData for a given Tagged<Object>.\",\n                \"logic\": \"Calls the overloaded function using CanonicalPersistentHandle.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Tagged<Object>\",\n                        \"purpose\": \"The Tagged<Object> to get or create ObjectData for.\"\n                    },\n                    {\n                        \"name\": \"flags\",\n                        \"type\": \"GetOrCreateDataFlags\",\n                        \"purpose\": \"Flags to control the creation of ObjectData.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ObjectData*\",\n                    \"description\": \"The ObjectData.\"\n                },\n                \"dependencies\": [\n                    \"ObjectData\",\n                    \"CanonicalPersistentHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nObjectData* JSHeapBroker::GetOrCreateData(Tagged<Object> object,\n                                          GetOrCreateDataFlags flags) {\n  return GetOrCreateData(CanonicalPersistentHandle(object), flags);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StackHasOverflowed\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Checks if the stack has overflowed.\",\n                \"logic\": \"Uses StackLimitCheck to check if the stack has overflowed. If using a local isolate, it will check against the local isolate; otherwise, it will use the main isolate.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the stack has overflowed, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"StackLimitCheck\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool JSHeapBroker::StackHasOverflowed() const {\n  DCHECK_IMPLIES(local_isolate_ == nullptr,\n                 ThreadId::Current() == isolate_->thread_id());\n  return (local_isolate_ != nullptr)\n             ? StackLimitCheck::HasOverflowed(local_isolate_)\n             : StackLimitCheck(isolate_).HasOverflowed();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ObjectMayBeUninitialized\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Checks if an object may be uninitialized.\",\n                \"logic\": \"Calls the overloaded function using *object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The object to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object may be uninitialized, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool JSHeapBroker::ObjectMayBeUninitialized(DirectHandle<Object> object) const {\n  return ObjectMayBeUninitialized(*object);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ObjectMayBeUninitialized\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Checks if an object may be uninitialized.\",\n                \"logic\": \"Calls the overloaded function using Cast<HeapObject>(object).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Tagged<Object>\",\n                        \"purpose\": \"The object to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object may be uninitialized, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool JSHeapBroker::ObjectMayBeUninitialized(Tagged<Object> object) const {\n  if (!IsHeapObject(object)) return false;\n  return ObjectMayBeUninitialized(Cast<HeapObject>(object));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ObjectMayBeUninitialized\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Checks if a HeapObject may be uninitialized.\",\n                \"logic\": \"Checks if the object is a pending allocation and is not on the main thread.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The HeapObject to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object may be uninitialized, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool JSHeapBroker::ObjectMayBeUninitialized(Tagged<HeapObject> object) const {\n  return !IsMainThread() && isolate()->heap()->IsPendingAllocation(object);\n}\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InitReadOnlyRoots\",\n                \"parent\": \"JSHeapBroker\",\n                \"about\": \"Initializes the read-only roots.\",\n                \"logic\": \"Creates MakeRefAssumeMemoryFence for a read-only root if not initialized already.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#define V(Type, name, Name)                                                 \\\n  void JSHeapBroker::Init##Name() {                                         \\\n    DCHECK(!name##_);                                                       \\\n    name##_ = MakeRefAssumeMemoryFence(this, isolate()->factory()->name()); \\\n  }\nREAD_ONLY_ROOT_LIST(V)\n#undef V\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ProcessedFeedback\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Base class for representing processed feedback.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind_\",\n                        \"type\": \"Kind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The kind of feedback.\"\n                    },\n                    {\n                        \"name\": \"slot_kind_\",\n                        \"type\": \"FeedbackSlotKind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The kind of feedback slot.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"FeedbackSlotKind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nProcessedFeedback::ProcessedFeedback(Kind kind, FeedbackSlotKind slot_kind)\n    : kind_(kind), slot_kind_(slot_kind) {}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ElementAccessFeedback\",\n                \"extends\": \"ProcessedFeedback\",\n                \"implements\": [],\n                \"about\": \"Represents feedback for element access operations.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"keyed_mode_\",\n                        \"type\": \"KeyedAccessMode\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The access mode (load/store) for the element access.\"\n                    },\n                    {\n                        \"name\": \"transition_groups_\",\n                        \"type\": \"ZoneVector<TransitionGroup>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Groups of maps representing transitions during element access.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ProcessedFeedback\",\n                    \"KeyedAccessMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nKeyedAccessMode ElementAccessFeedback::keyed_mode() const {\n  return keyed_mode_;\n}\n\nZoneVector<ElementAccessFeedback::TransitionGroup> const&\nElementAccessFeedback::transition_groups() const {\n  return transition_groups_;\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Refine\",\n                \"parent\": \"ElementAccessFeedback\",\n                \"about\": \"Refines element access feedback based on inferred maps.\",\n                \"logic\": \"Creates a new ElementAccessFeedback based on provided inferred maps. If no maps are provided returns a simple feedback.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker.\"\n                    },\n                    {\n                        \"name\": \"inferred_maps\",\n                        \"type\": \"ZoneVector<MapRef> const&\",\n                        \"purpose\": \"A vector of inferred maps.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ElementAccessFeedback const&\",\n                    \"description\": \"The refined ElementAccessFeedback.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"MapRef\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nElementAccessFeedback const& ElementAccessFeedback::Refine(\n    JSHeapBroker* broker, ZoneVector<MapRef> const& inferred_maps) const {\n  if (inferred_maps.empty()) {\n    return *broker->zone()->New<ElementAccessFeedback>(\n        broker->zone(), keyed_mode(), slot_kind());\n  }\n\n  ZoneRefSet<Map> inferred(inferred_maps.begin(), inferred_maps.end(),\n                           broker->zone());\n  return Refine(broker, inferred, false);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Refine\",\n                \"parent\": \"ElementAccessFeedback\",\n                \"about\": \"Refines element access feedback to a named access"
}