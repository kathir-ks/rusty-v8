{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/platform.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 223, column 47",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/platform.h\",\n        \"file_name\": \"platform.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Platform interface for cppgc, providing abstractions for allocators, task runners, and tracing controllers.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard memory management and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <memory>\n\n            #include \"cppgc/source-location.h\"\n            #include \"v8-platform.h\"  // NOLINT(build/include_directory)\n            #include \"v8config.h\"     // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Platform\",\n            \"about\": \"Abstract interface for platform-specific services used by cppgc, including memory allocation, task scheduling, and tracing.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"PageAllocator\",\n                \"TaskRunner\",\n                \"TaskPriority\",\n                \"JobHandle\",\n                \"JobTask\",\n                \"TracingController\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Platform {\n            public:\n              virtual ~Platform() = default;\n\n              /**\n               * \\returns the allocator used by cppgc to allocate its heap and various\n               * support structures. Returning nullptr results in using the `PageAllocator`\n               * provided by `cppgc::InitializeProcess()` instead.\n               */\n              virtual PageAllocator* GetPageAllocator() = 0;\n\n              /**\n               * Monotonically increasing time in seconds from an arbitrary fixed point in\n               * the past. This function is expected to return at least\n               * millisecond-precision values. For this reason,\n               * it is recommended that the fixed point be no further in the past than\n               * the epoch.\n               **/\n              virtual double MonotonicallyIncreasingTime() = 0;\n\n              /**\n               * Foreground task runner that should be used by a Heap.\n               */\n              virtual std::shared_ptr<TaskRunner> GetForegroundTaskRunner() {\n                return GetForegroundTaskRunner(TaskPriority::kUserBlocking);\n              }\n\n              /**\n               * Returns a TaskRunner with a specific |priority| which can be used to post a\n               * task on the foreground thread.\n               */\n              virtual std::shared_ptr<TaskRunner> GetForegroundTaskRunner(\n                  TaskPriority priority) {\n                return nullptr;\n              }\n\n              /**\n               * Posts `job_task` to run in parallel. Returns a `JobHandle` associated with\n               * the `Job`, which can be joined or canceled.\n               * This avoids degenerate cases:\n               * - Calling `CallOnWorkerThread()` for each work item, causing significant\n               *   overhead.\n               * - Fixed number of `CallOnWorkerThread()` calls that split the work and\n               *   might run for a long time. This is problematic when many components post\n               *   \"num cores\" tasks and all expect to use all the cores. In these cases,\n               *   the scheduler lacks context to be fair to multiple same-priority requests\n               *   and/or ability to request lower priority work to yield when high priority\n               *   work comes in.\n               * A canonical implementation of `job_task` looks like:\n               * \\code\n               * class MyJobTask : public JobTask {\n               *  public:\n               *   MyJobTask(...) : worker_queue_(...) {}\n               *   // JobTask implementation.\n               *   void Run(JobDelegate* delegate) override {\n               *     while (!delegate->ShouldYield()) {\n               *       // Smallest unit of work.\n               *       auto work_item = worker_queue_.TakeWorkItem(); // Thread safe.\n               *       if (!work_item) return;\n               *       ProcessWork(work_item);\n               *     }\n               *   }\n               *\n               *   size_t GetMaxConcurrency() const override {\n               *     return worker_queue_.GetSize(); // Thread safe.\n               *   }\n               * };\n               *\n               * // ...\n               * auto handle = PostJob(TaskPriority::kUserVisible,\n               *                       std::make_unique<MyJobTask>(...));\n               * handle->Join();\n               * \\endcode\n               *\n               * `PostJob()` and methods of the returned JobHandle/JobDelegate, must never\n               * be called while holding a lock that could be acquired by `JobTask::Run()`\n               * or `JobTask::GetMaxConcurrency()` -- that could result in a deadlock. This\n               * is because (1) `JobTask::GetMaxConcurrency()` may be invoked while holding\n               * internal lock (A), hence `JobTask::GetMaxConcurrency()` can only use a lock\n               * (B) if that lock is *never* held while calling back into `JobHandle` from\n               * any thread (A=>B/B=>A deadlock) and (2) `JobTask::Run()` or\n               * `JobTask::GetMaxConcurrency()` may be invoked synchronously from\n               * `JobHandle` (B=>JobHandle::foo=>B deadlock).\n               *\n               * A sufficient `PostJob()` implementation that uses the default Job provided\n               * in libplatform looks like:\n               * \\code\n               * std::unique_ptr<JobHandle> PostJob(\n               *     TaskPriority priority, std::unique_ptr<JobTask> job_task) override {\n               *   return std::make_unique<DefaultJobHandle>(\n               *       std::make_shared<DefaultJobState>(\n               *           this, std::move(job_task), kNumThreads));\n               * }\n               * \\endcode\n               */\n              virtual std::unique_ptr<JobHandle> PostJob(\n                  TaskPriority priority, std::unique_ptr<JobTask> job_task) {\n                return nullptr;\n              }\n\n              /**\n               * Returns an instance of a `TracingController`. This must be non-nullptr. The\n               * default implementation returns an empty `TracingController` that consumes\n               * trace data without effect.\n               */\n              virtual TracingController* GetTracingController();\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"InitializeProcess\",\n            \"about\": \"Initializes the garbage collector process-wide. Must be called before creating a Heap.\",\n            \"logic\": \"Performs global initialization of the garbage collector, including setting up the page allocator and reserving virtual address space.\",\n            \"parameters\": [\n                {\n                    \"name\": \"page_allocator\",\n                    \"type\": \"PageAllocator*\",\n                    \"purpose\": \"The allocator used for maintaining meta data.  If no allocator is provided, a default internal version will be used.\"\n                },\n                {\n                    \"name\": \"desired_heap_size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"Desired amount of virtual address space to reserve for the heap, in bytes. If this parameter is zero, a default value will be used.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"PageAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT void InitializeProcess(PageAllocator* page_allocator = nullptr,\n                                             size_t desired_heap_size = 0);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ShutdownProcess\",\n            \"about\": \"Shuts down the garbage collector process-wide. Must be called after destroying the last used heap.\",\n            \"logic\": \"Releases resources allocated during InitializeProcess.  Some process-global metadata may not be returned and reused upon a subsequent InitializeProcess() call.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT void ShutdownProcess();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Fatal\",\n            \"parent\": \"internal\",\n            \"about\": \"A fatal error reporting function\",\n            \"logic\": \"Reports a fatal error and terminates execution. Uses SourceLocation for more detailed error reporting.\",\n            \"parameters\": [\n                {\n                    \"name\": \"reason\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The reason for the fatal error.\"\n                },\n                {\n                    \"name\": \"\",\n                    \"type\": \"const SourceLocation&\",\n                    \"purpose\": \"The source location where the error occurred.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"SourceLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT void Fatal(const std::string& reason = std::string(),\n                                 const SourceLocation& = SourceLocation::Current());\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PageAllocator\",\n                \"about\": \"Abstracts memory allocation at the page level.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class PageAllocator {};\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TaskRunner\",\n                \"about\": \"Abstracts the execution of tasks.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TaskRunner {};\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JobHandle\",\n                \"about\": \"Handle to control a running job.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class JobHandle {};\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JobTask\",\n                \"about\": \"Abstracts a task that can be run as a job.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class JobTask {};\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TracingController\",\n                \"about\": \"Interface for controlling tracing.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TracingController {};\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SourceLocation\",\n                \"about\": \"Represents a location in the source code.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SourceLocation {\n                public:\n                    static SourceLocation Current();\n                };\n            ]]></code>\n        </class>\n\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"TaskPriority\",\n                \"about\": \"Enumerates the priority of tasks\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum class TaskPriority {\n                  kUserBlocking,\n                };\n            ]]></code>\n        </enum>\n    </dependencies>\n</file>\n```"
}