{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/linear-scheduler.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 44, column 54",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/linear-scheduler.cc\",\n            \"file_name\": \"linear-scheduler.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements a linear scheduler for the Turbofan compiler, determining the order in which nodes are executed.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for compiler nodes, graphs, node properties, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/linear-scheduler.h\"\n\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LinearScheduler\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Schedules nodes in a linear order for execution within the Turbofan compiler.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The Turbofan graph being scheduled.\"\n                    },\n                    {\n                        \"name\": \"control_level_\",\n                        \"type\": \"ZoneUnorderedMap<Node*, int>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps control nodes to their control level in the graph.\"\n                    },\n                    {\n                        \"name\": \"early_schedule_position_\",\n                        \"type\": \"ZoneUnorderedMap<Node*, Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps nodes to their early schedule position (a control node).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"Node\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass LinearScheduler {\n public:\n  LinearScheduler(Zone* zone, TFGraph* graph);\n\n  Node* GetEarlySchedulePosition(Node* node);\n  bool SameBasicBlock(Node* node0, Node* node1);\n\n private:\n  void ComputeControlLevel();\n  int GetControlLevel(Node* node) { return control_level_[node]; }\n  void SetControlLevel(Node* node, int level) { control_level_[node] = level; }\n  void SetEarlySchedulePosition(Node* node, Node* position) {\n    early_schedule_position_[node] = position;\n  }\n\n  TFGraph* graph_;\n  ZoneUnorderedMap<Node*, int> control_level_;\n  ZoneUnorderedMap<Node*, Node*> early_schedule_position_;\n\n  struct NodeState {\n    Node* node;\n    Node* early_schedule_position;\n    size_t input_index;\n  };\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"LinearScheduler::LinearScheduler\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Constructor for the LinearScheduler class.\",\n                \"logic\": \"Initializes the graph, control level map, and early schedule position map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone for allocating data structures.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The Turbofan graph to schedule.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TFGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nLinearScheduler::LinearScheduler(Zone* zone, TFGraph* graph)\n    : graph_(graph), control_level_(zone), early_schedule_position_(zone) {\n  ComputeControlLevel();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LinearScheduler::ComputeControlLevel\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Computes the control level for each control node in the graph.\",\n                \"logic\": \"Performs a breadth-first search (BFS) starting from the start node to determine the control level of each control node.  The level represents the relative depth of control flow.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"Node\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LinearScheduler::ComputeControlLevel() {\n  Node* start = graph_->start();\n  SetControlLevel(start, 0);\n\n  // Do BFS from the start node and compute the level of\n  // each control node.\n  std::queue<Node*> queue({start});\n  while (!queue.empty()) {\n    Node* node = queue.front();\n    int level = GetControlLevel(node);\n    queue.pop();\n    for (Edge const edge : node->use_edges()) {\n      if (!NodeProperties::IsControlEdge(edge)) continue;\n      Node* use = edge.from();\n      if (use->opcode() == IrOpcode::kLoopExit &&\n          node->opcode() == IrOpcode::kLoop)\n        continue;\n      if (control_level_.find(use) == control_level_.end() &&\n          use->opcode() != IrOpcode::kEnd) {\n        SetControlLevel(use, level + 1);\n        queue.push(use);\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LinearScheduler::GetEarlySchedulePosition\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Determines the early schedule position (a control node) for a given node.\",\n                \"logic\": \"Uses a depth-first search (DFS) to traverse the graph and find the control node where the given node can be scheduled earliest.  For phi nodes, it's the control input.  For others, it's the input with the maximal control level.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node for which to find the early schedule position.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The early schedule position (a control node) for the given node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"NodeProperties\",\n                    \"TFGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* LinearScheduler::GetEarlySchedulePosition(Node* node) {\n  DCHECK(!NodeProperties::IsControl(node));\n\n  auto it = early_schedule_position_.find(node);\n  if (it != early_schedule_position_.end()) return it->second;\n\n  std::stack<NodeState> stack;\n  stack.push({node, nullptr, 0});\n  Node* early_schedule_position = nullptr;\n  while (!stack.empty()) {\n    NodeState& top = stack.top();\n    if (NodeProperties::IsPhi(top.node)) {\n      // For phi node, the early schedule position is its control node.\n      early_schedule_position = NodeProperties::GetControlInput(top.node);\n    } else if (top.node->InputCount() == 0) {\n      // For node without inputs, the early schedule position is start node.\n      early_schedule_position = graph_->start();\n    } else {\n      // For others, the early schedule position is one of its inputs' early\n      // schedule position with maximal level.\n      if (top.input_index == top.node->InputCount()) {\n        // All inputs are visited, set early schedule position.\n        early_schedule_position = top.early_schedule_position;\n      } else {\n        // Visit top's input and find its early schedule position.\n        Node* input = top.node->InputAt(top.input_index);\n        Node* input_early_schedule_position = nullptr;\n        if (NodeProperties::IsControl(input)) {\n          input_early_schedule_position = input;\n        } else {\n          auto early_pos_it = early_schedule_position_.find(input);\n          if (early_pos_it != early_schedule_position_.end()) {\n            input_early_schedule_position = early_pos_it->second;\n          }\n        }\n        if (input_early_schedule_position != nullptr) {\n          if (top.early_schedule_position == nullptr ||\n              GetControlLevel(top.early_schedule_position) <\n                  GetControlLevel(input_early_schedule_position)) {\n            top.early_schedule_position = input_early_schedule_position;\n          }\n          top.input_index += 1;\n        } else {\n          top.input_index += 1;\n          stack.push({input, nullptr, 0});\n        }\n        continue;\n      }\n    }\n\n    // Found top's early schedule position, set it to the cache and pop it out\n    // of the stack.\n    SetEarlySchedulePosition(top.node, early_schedule_position);\n    stack.pop();\n    // Update early schedule position of top's use.\n    if (!stack.empty()) {\n      NodeState& use = stack.top();\n      if (use.early_schedule_position == nullptr ||\n          GetControlLevel(use.early_schedule_position) <\n              GetControlLevel(early_schedule_position)) {\n        use.early_schedule_position = early_schedule_position;\n      }\n    }\n  }\n\n  DCHECK(early_schedule_position != nullptr);\n  return early_schedule_position;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LinearScheduler::SameBasicBlock\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Checks if two nodes belong to the same basic block.\",\n                \"logic\": \"Compares the early schedule positions of the two nodes. If they are the same, the nodes are considered to be in the same basic block.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node0\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The first node.\"\n                    },\n                    {\n                        \"name\": \"node1\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The second node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the nodes are in the same basic block, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool LinearScheduler::SameBasicBlock(Node* node0, Node* node1) {\n  Node* early_schedule_position0 = NodeProperties::IsControl(node0)\n                                       ? node0\n                                       : GetEarlySchedulePosition(node0);\n  Node* early_schedule_position1 = NodeProperties::IsControl(node1)\n                                       ? node1\n                                       : GetEarlySchedulePosition(node1);\n  return early_schedule_position0 == early_schedule_position1;\n}\n        ]]></code>\n    </func>\n</file>\n```"
}