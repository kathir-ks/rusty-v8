{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/messages.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 71, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/messages.h\",\n            \"file_name\": \"messages.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the infrastructure for localized message reporting in V8, including message formatting and handling.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary standard library and V8-specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <memory>\n\n#include \"include/v8-local-handle.h\"\n#include \"src/base/vector.h\"\n#include \"src/common/message-template.h\"\n#include \"src/handles/handles.h\"\n#include \"src/handles/maybe-handles.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MessageLocation\",\n                \"about\": \"Represents the location of a message in the source code.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"script_\",\n                        \"type\": \"Handle<Script>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The script where the message originates.\"\n                    },\n                    {\n                        \"name\": \"start_pos_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The starting position of the message in the script.\"\n                    },\n                    {\n                        \"name\": \"end_pos_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ending position of the message in the script.\"\n                    },\n                    {\n                        \"name\": \"bytecode_offset_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The bytecode offset of the message (if applicable).\"\n                    },\n                    {\n                        \"name\": \"shared_\",\n                        \"type\": \"Handle<SharedFunctionInfo>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Shared function info associated with the message.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Script\",\n                    \"SharedFunctionInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE MessageLocation {\n public:\n  // Constructors for when source positions are already known.\n  // TODO(delphick): Collapse to a single constructor with a default parameter\n  // when we stop using the GCC that requires this separation.\n  MessageLocation(Handle<Script> script, int start_pos, int end_pos);\n  MessageLocation(Handle<Script> script, int start_pos, int end_pos,\n                  Handle<SharedFunctionInfo> shared);\n  // Constructor for when source positions were not collected but which can be\n  // reconstructed from the SharedFunctionInfo and bytecode offset.\n  MessageLocation(Handle<Script> script, Handle<SharedFunctionInfo> shared,\n                  int bytecode_offset);\n  MessageLocation();\n\n  Handle<Script> script() const { return script_; }\n  int start_pos() const { return start_pos_; }\n  int end_pos() const { return end_pos_; }\n  int bytecode_offset() const { return bytecode_offset_; }\n  Handle<SharedFunctionInfo> shared() const { return shared_; }\n\n private:\n  Handle<Script> script_;\n  int start_pos_;\n  int end_pos_;\n  int bytecode_offset_;\n  Handle<SharedFunctionInfo> shared_;\n};\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"FrameSkipMode\",\n                \"about\": \"Determines how stack trace collection skips frames.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum FrameSkipMode {\n  // Unconditionally skips the first frame. Used e.g. when the Error constructor\n  // is called, in which case the first frame is always a BUILTIN_EXIT frame.\n  SKIP_FIRST,\n  // Skip all frames until a specified caller function is seen.\n  SKIP_UNTIL_SEEN,\n  SKIP_NONE,\n};\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ErrorUtils\",\n                \"about\": \"Provides utility functions for constructing and formatting JavaScript errors.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"JSObject\",\n                    \"JSFunction\",\n                    \"Object\",\n                    \"String\",\n                    \"MessageTemplate\",\n                    \"StackTraceInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass ErrorUtils : public AllStatic {\n public:\n  // |kDisabled| is useful when you don't need the stack information at all, for\n  // example when creating a deserialized error.\n  enum class StackTraceCollection { kEnabled, kDisabled };\n  static MaybeDirectHandle<JSObject> Construct(Isolate* isolate,\n                                               DirectHandle<JSFunction> target,\n                                               DirectHandle<Object> new_target,\n                                               DirectHandle<Object> message,\n                                               DirectHandle<Object> options);\n  static MaybeHandle<JSObject> Construct(\n      Isolate* isolate, DirectHandle<JSFunction> target,\n      DirectHandle<Object> new_target, DirectHandle<Object> message,\n      DirectHandle<Object> options, FrameSkipMode mode,\n      DirectHandle<Object> caller, StackTraceCollection stack_trace_collection);\n\n  enum class ToStringMessageSource {\n    kPreferOriginalMessage,\n    kCurrentMessageProperty\n  };\n  V8_EXPORT_PRIVATE static MaybeHandle<String> ToString(\n      Isolate* isolate, DirectHandle<Object> recv,\n      ToStringMessageSource message_source =\n          ToStringMessageSource::kCurrentMessageProperty);\n\n  static Handle<JSObject> MakeGenericError(\n      Isolate* isolate, DirectHandle<JSFunction> constructor,\n      MessageTemplate index, base::Vector<const DirectHandle<Object>> args,\n      FrameSkipMode mode);\n\n  static DirectHandle<JSObject> ShadowRealmConstructTypeErrorCopy(\n      Isolate* isolate, DirectHandle<Object> original, MessageTemplate index,\n      base::Vector<const DirectHandle<Object>> args);\n\n  // Formats a textual stack trace from the given structured stack trace.\n  // Note that this can call arbitrary JS code through Error.prepareStackTrace.\n  static MaybeDirectHandle<Object> FormatStackTrace(\n      Isolate* isolate, DirectHandle<JSObject> error,\n      DirectHandle<Object> stack_trace);\n\n  static DirectHandle<JSObject> NewIteratorError(Isolate* isolate,\n                                                 DirectHandle<Object> source);\n  static DirectHandle<JSObject> NewCalledNonCallableError(\n      Isolate* isolate, DirectHandle<Object> source);\n  static DirectHandle<JSObject> NewConstructedNonConstructable(\n      Isolate* isolate, DirectHandle<Object> source);\n  // Returns the Exception sentinel.\n  static Tagged<Object> ThrowSpreadArgError(Isolate* isolate,\n                                            MessageTemplate id,\n                                            DirectHandle<Object> object);\n  // Returns the Exception sentinel.\n  static Tagged<Object> ThrowLoadFromNullOrUndefined(\n      Isolate* isolate, DirectHandle<Object> object,\n      MaybeDirectHandle<Object> key);\n\n  // Returns true if given object has own |error_stack_symbol| property.\n  static bool HasErrorStackSymbolOwnProperty(Isolate* isolate,\n                                             DirectHandle<JSObject> object);\n\n  struct StackPropertyLookupResult {\n    // The holder of the |error_stack_symbol| or empty handle.\n    MaybeDirectHandle<JSObject> error_stack_symbol_holder;\n    // The value of the |error_stack_symbol| property or |undefined_value|.\n    Handle<Object> error_stack;\n  };\n  // Gets |error_stack_symbol| property value by looking up the prototype chain.\n  static StackPropertyLookupResult GetErrorStackProperty(\n      Isolate* isolate, DirectHandle<JSReceiver> maybe_error_object);\n\n  static MaybeDirectHandle<Object> GetFormattedStack(\n      Isolate* isolate, DirectHandle<JSObject> maybe_error_object);\n  static void SetFormattedStack(Isolate* isolate,\n                                DirectHandle<JSObject> maybe_error_object,\n                                DirectHandle<Object> formatted_stack);\n\n  // Collects the stack trace and installs the stack property accessors.\n  static MaybeHandle<Object> CaptureStackTrace(Isolate* isolate,\n                                               DirectHandle<JSObject> object,\n                                               FrameSkipMode mode,\n                                               Handle<Object> caller);\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MessageFormatter\",\n                \"about\": \"Provides static methods for formatting messages using message templates and arguments.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"String\",\n                    \"MessageTemplate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass MessageFormatter {\n public:\n  V8_EXPORT_PRIVATE static const char* TemplateString(MessageTemplate index);\n\n  V8_EXPORT_PRIVATE static MaybeHandle<String> TryFormat(\n      Isolate* isolate, MessageTemplate index,\n      base::Vector<const DirectHandle<String>> args);\n\n  static DirectHandle<String> Format(\n      Isolate* isolate, MessageTemplate index,\n      base::Vector<const DirectHandle<Object>> args);\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MessageHandler\",\n                \"about\": \"Provides an interface for accessing and reporting messages.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"JSMessageObject\",\n                    \"MessageTemplate\",\n                    \"MessageLocation\",\n                    \"StackTraceInfo\",\n                    \"String\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// A message handler is a convenience interface for accessing the list\n// of message listeners registered in an environment\nclass MessageHandler {\n public:\n  // Returns a message object for the API to use.\n  V8_EXPORT_PRIVATE static Handle<JSMessageObject> MakeMessageObject(\n      Isolate* isolate, MessageTemplate type, const MessageLocation* location,\n      DirectHandle<Object> argument,\n      DirectHandle<StackTraceInfo> stack_trace =\n          DirectHandle<StackTraceInfo>::null());\n\n  // Report a formatted message (needs JS allocation).\n  V8_EXPORT_PRIVATE static void ReportMessage(\n      Isolate* isolate, const MessageLocation* loc,\n      DirectHandle<JSMessageObject> message);\n\n  static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\n                                   DirectHandle<Object> message_obj);\n  static DirectHandle<String> GetMessage(Isolate* isolate,\n                                         DirectHandle<Object> data);\n  static std::unique_ptr<char[]> GetLocalizedMessage(Isolate* isolate,\n                                                     DirectHandle<Object> data);\n\n private:\n  static void ReportMessageNoExceptions(Isolate* isolate,\n                                        const MessageLocation* loc,\n                                        DirectHandle<Object> message_obj,\n                                        Local<Value> api_exception_obj);\n};\n        ]]></code>\n    </class>\n</file>\n```"
}