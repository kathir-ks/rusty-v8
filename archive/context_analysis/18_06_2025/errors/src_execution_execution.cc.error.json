{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/execution.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/execution.cc\",\n            \"file_name\": \"execution.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides functions for executing JavaScript code within the V8 engine, including calling functions, constructing objects, and handling microtasks.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary header files for execution-related functionalities and V8 API.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/execution.h\"\n\n#include \"src/api/api-inl.h\"\n#include \"src/debug/debug.h\"\n#include \"src/execution/frames.h\"\n#include \"src/execution/isolate-inl.h\"\n#include \"src/execution/vm-state-inl.h\"\n#include \"src/logging/runtime-call-stats-scope.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/compiler/wasm-compiler.h\"  // Only for static asserts.\n#include \"src/wasm/code-space-access.h\"\n#include \"src/wasm/wasm-engine.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"NormalizeReceiver\",\n                \"about\": \"Normalizes the receiver object for function calls.  If the receiver is a JSGlobalObject, it's replaced with its global proxy.\",\n                \"logic\": \"Checks if the receiver is a JSGlobalObject and if so, returns its global proxy; otherwise, returns the original receiver.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"receiver\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The receiver object of the function call.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"DirectHandle<Object>\",\n                    \"description\": \"The normalized receiver object.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"JSGlobalObject\",\n                    \"Cast\",\n                    \"direct_handle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<Object> NormalizeReceiver(Isolate* isolate,\n                                       DirectHandle<Object> receiver) {\n  // Convert calls on global objects to be calls on the global\n  // receiver instead to avoid having a 'this' pointer which refers\n  // directly to a global object.\n  if (IsJSGlobalObject(*receiver)) {\n    return direct_handle(Cast<JSGlobalObject>(receiver)->global_proxy(),\n                         isolate);\n  }\n  return receiver;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"InvokeParams\",\n                \"about\": \"A structure to hold parameters for invoking JavaScript functions, including the target function, receiver, arguments, and execution flags.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The target object to be invoked (function or constructor).\"\n                    },\n                    {\n                        \"name\": \"receiver\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The receiver object for the function call (the 'this' value).\"\n                    },\n                    {\n                        \"name\": \"args\",\n                        \"type\": \"base::Vector<const DirectHandle<Object>>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The arguments passed to the function call.\"\n                    },\n                    {\n                        \"name\": \"new_target\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The 'new.target' value for constructor calls.\"\n                    },\n                    {\n                        \"name\": \"microtask_queue\",\n                        \"type\": \"MicrotaskQueue*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The microtask queue to run (for running microtasks).\"\n                    },\n                    {\n                        \"name\": \"message_handling\",\n                        \"type\": \"Execution::MessageHandling\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Specifies how messages (e.g., exceptions) are handled.\"\n                    },\n                    {\n                        \"name\": \"exception_out\",\n                        \"type\": \"MaybeDirectHandle<Object>*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"A pointer to store the exception object, if any (used in TryCall).\"\n                    },\n                    {\n                        \"name\": \"is_construct\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether the invocation is a constructor call (new).\"\n                    },\n                    {\n                        \"name\": \"execution_target\",\n                        \"type\": \"Execution::Target\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Specifies the type of execution target (callable, run microtasks).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"Object\",\n                    \"base::Vector\",\n                    \"Execution::MessageHandling\",\n                    \"MaybeDirectHandle\",\n                    \"MicrotaskQueue\",\n                    \"JSFunction\",\n                    \"FixedArray\",\n                    \"Cast\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct InvokeParams {\n  static InvokeParams SetUpForNew(\n      Isolate* isolate, DirectHandle<Object> constructor,\n      DirectHandle<Object> new_target,\n      base::Vector<const DirectHandle<Object>> args);\n\n  static InvokeParams SetUpForCall(\n      Isolate* isolate, DirectHandle<Object> callable,\n      DirectHandle<Object> receiver,\n      base::Vector<const DirectHandle<Object>> args);\n\n  static InvokeParams SetUpForTryCall(\n      Isolate* isolate, DirectHandle<Object> callable,\n      DirectHandle<Object> receiver,\n      base::Vector<const DirectHandle<Object>> args,\n      Execution::MessageHandling message_handling,\n      MaybeDirectHandle<Object>* exception_out);\n\n  static InvokeParams SetUpForRunMicrotasks(Isolate* isolate,\n                                            MicrotaskQueue* microtask_queue);\n\n  bool IsScript() const {\n    if (!IsJSFunction(*target)) return false;\n    auto function = Cast<JSFunction>(target);\n    return function->shared()->is_script();\n  }\n\n  DirectHandle<FixedArray> GetAndResetHostDefinedOptions() {\n    DCHECK(IsScript());\n    DCHECK_EQ(args.size(), 1);\n    auto options = Cast<FixedArray>(args[0]);\n    args = {};\n    return options;\n  }\n\n  DirectHandle<Object> target;\n  DirectHandle<Object> receiver;\n  base::Vector<const DirectHandle<Object>> args;\n  DirectHandle<Object> new_target;\n\n  MicrotaskQueue* microtask_queue;\n\n  Execution::MessageHandling message_handling;\n  MaybeDirectHandle<Object>* exception_out;\n\n  bool is_construct;\n  Execution::Target execution_target;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SetUpForNew\",\n                \"parent\": \"InvokeParams\",\n                \"about\": \"Sets up the InvokeParams structure for a 'new' (constructor) call.\",\n                \"logic\": \"Initializes the InvokeParams structure with the constructor, new_target, arguments, and flags appropriate for a constructor call.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"constructor\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The constructor function.\"\n                    },\n                    {\n                        \"name\": \"new_target\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The 'new.target' value.\"\n                    },\n                    {\n                        \"name\": \"args\",\n                        \"type\": \"base::Vector<const DirectHandle<Object>>\",\n                        \"purpose\": \"The arguments passed to the constructor.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"InvokeParams\",\n                    \"description\": \"The initialized InvokeParams structure.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"Object\",\n                    \"base::Vector\",\n                    \"InvokeParams\",\n                    \"isolate->factory()->undefined_value()\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nInvokeParams InvokeParams::SetUpForNew(\n    Isolate* isolate, DirectHandle<Object> constructor,\n    DirectHandle<Object> new_target,\n    base::Vector<const DirectHandle<Object>> args) {\n  InvokeParams params;\n  params.target = constructor;\n  params.receiver = isolate->factory()->undefined_value();\n  DCHECK(!params.IsScript());\n  params.args = args;\n  params.new_target = new_target;\n  params.microtask_queue = nullptr;\n  params.message_handling = Execution::MessageHandling::kReport;\n  params.exception_out = nullptr;\n  params.is_construct = true;\n  params.execution_target = Execution::Target::kCallable;\n  return params;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SetUpForCall\",\n                \"parent\": \"InvokeParams\",\n                \"about\": \"Sets up the InvokeParams structure for a regular function call.\",\n                \"logic\": \"Initializes the InvokeParams structure with the callable, receiver, arguments, and flags appropriate for a function call.  It also normalizes the receiver.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"callable\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The function to be called.\"\n                    },\n                    {\n                        \"name\": \"receiver\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The receiver object (the 'this' value).\"\n                    },\n                    {\n                        \"name\": \"args\",\n                        \"type\": \"base::Vector<const DirectHandle<Object>>\",\n                        \"purpose\": \"The arguments passed to the function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"InvokeParams\",\n                    \"description\": \"The initialized InvokeParams structure.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"Object\",\n                    \"base::Vector\",\n                    \"InvokeParams\",\n                    \"NormalizeReceiver\",\n                    \"isolate->factory()->undefined_value()\",\n                    \"IsScript\",\n                    \"IsFixedArray\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nInvokeParams InvokeParams::SetUpForCall(\n    Isolate* isolate, DirectHandle<Object> callable,\n    DirectHandle<Object> receiver,\n    base::Vector<const DirectHandle<Object>> args) {\n  InvokeParams params;\n  params.target = callable;\n  params.receiver = NormalizeReceiver(isolate, receiver);\n  // Check for host-defined options argument for scripts.\n  DCHECK_IMPLIES(params.IsScript(), args.size() == 1);\n  DCHECK_IMPLIES(params.IsScript(), IsFixedArray(*args[0]));\n  params.args = args;\n  params.new_target = isolate->factory()->undefined_value();\n  params.microtask_queue = nullptr;\n  params.message_handling = Execution::MessageHandling::kReport;\n  params.exception_out = nullptr;\n  params.is_construct = false;\n  params.execution_target = Execution::Target::kCallable;\n  return params;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SetUpForTryCall\",\n                \"parent\": \"InvokeParams\",\n                \"about\": \"Sets up the InvokeParams structure for a 'try' call, where exceptions are caught and potentially returned.\",\n                \"logic\": \"Similar to SetUpForCall, but includes parameters for message handling and an exception output pointer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"callable\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The function to be called.\"\n                    },\n                    {\n                        \"name\": \"receiver\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The receiver object (the 'this' value).\"\n                    },\n                    {\n                        \"name\": \"args\",\n                        \"type\": \"base::Vector<const DirectHandle<Object>>\",\n                        \"purpose\": \"The arguments passed to the function.\"\n                    },\n                    {\n                        \"name\": \"message_handling\",\n                        \"type\": \"Execution::MessageHandling\",\n                        \"purpose\": \"Specifies how messages (e.g., exceptions) are handled.\"\n                    },\n                    {\n                        \"name\": \"exception_out\",\n                        \"type\": \"MaybeDirectHandle<Object>*\",\n                        \"purpose\": \"A pointer to store the exception object, if any.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"InvokeParams\",\n                    \"description\": \"The initialized InvokeParams structure.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"Object\",\n                    \"base::Vector\",\n                    \"InvokeParams\",\n                    \"NormalizeReceiver\",\n                    \"isolate->factory()->undefined_value()\",\n                    \"Execution::MessageHandling\",\n                    \"MaybeDirectHandle\",\n                    \"IsScript\",\n                    \"IsFixedArray\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nInvokeParams InvokeParams::SetUpForTryCall(\n    Isolate* isolate, DirectHandle<Object> callable,\n    DirectHandle<Object> receiver,\n    base::Vector<const DirectHandle<Object>> args,\n    Execution::MessageHandling message_handling,\n    MaybeDirectHandle<Object>* exception_out) {\n  InvokeParams params;\n  params.target = callable;\n  params.receiver = NormalizeReceiver(isolate, receiver);\n  // Check for host-defined options argument for scripts.\n  DCHECK_IMPLIES(params.IsScript(), args.size() == 1);\n  DCHECK_IMPLIES(params.IsScript(), IsFixedArray(*args[0]));\n  params.args = args;\n  params.new_target = isolate->factory()->undefined_value();\n  params.microtask_queue = nullptr;\n  params.message_handling = message_handling;\n  params.exception_out = exception_out;\n  params.is_construct = false;\n  params.execution_target = Execution::Target::kCallable;\n  return params;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SetUpForRunMicrotasks\",\n                \"parent\": \"InvokeParams\",\n                \"about\": \"Sets up the InvokeParams structure for running microtasks.\",\n                \"logic\": \"Initializes the InvokeParams structure with the microtask queue and sets the execution target to kRunMicrotasks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"microtask_queue\",\n                        \"type\": \"MicrotaskQueue*\",\n                        \"purpose\": \"The microtask queue to be executed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"InvokeParams\",\n                    \"description\": \"The initialized InvokeParams structure.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"InvokeParams\",\n                    \"MicrotaskQueue\",\n                    \"isolate->factory()->undefined_value()\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nInvokeParams InvokeParams::SetUpForRunMicrotasks(\n    Isolate* isolate, MicrotaskQueue* microtask_queue) {\n  auto undefined = isolate->factory()->undefined_value();\n  InvokeParams params;\n  params.target = undefined;\n  params.receiver = undefined;\n  params.args = {};\n  params.new_target = undefined;\n  params.microtask_queue = microtask_queue;\n  params.message_handling = Execution::MessageHandling::kReport;\n  params.exception_out = nullptr;\n  params.is_construct = false;\n  params.execution_target = Execution::Target::kRunMicrotasks;\n  return params;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JSEntry\",\n                \"about\": \"Determines the correct JSEntry code object based on the execution target and whether it's a constructor call.\",\n                \"logic\": \"Selects the appropriate builtin code (JSConstructEntry, JSEntry, or JSRunMicrotasksEntry) based on the execution target and 'is_construct' flag.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"execution_target\",\n                        \"type\": \"Execution::Target\",\n                        \"purpose\": \"The type of execution target.\"\n                    },\n                    {\n                        \"name\": \"is_construct\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether the invocation is a constructor call.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"DirectHandle<Code>\",\n                    \"description\": \"The JSEntry code object.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Execution::Target\",\n                    \"DirectHandle\",\n                    \"Code\",\n                    \"BUILTIN_CODE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<Code> JSEntry(Isolate* isolate, Execution::Target execution_target,\n                           bool is_construct) {\n  if (is_construct) {\n    DCHECK_EQ(Execution::Target::kCallable, execution_target);\n    return BUILTIN_CODE(isolate, JSConstructEntry);\n  } else if (execution_target == Execution::Target::kCallable) {\n    DCHECK(!is_construct);\n    return BUILTIN_CODE(isolate, JSEntry);\n  } else if (execution_target == Execution::Target::kRunMicrotasks) {\n    DCHECK(!is_construct);\n    return BUILTIN_CODE(isolate, JSRunMicrotasksEntry);\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"NewScriptContext\",\n                \"about\": \"Creates a new script context for executing a script.\",\n                \"logic\": \"Creates a new context for a script, handling name clashes and REPL-mode scenarios. It also initializes the context and updates the script context table.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"function\",\n                        \"type\": \"DirectHandle<JSFunction>\",\n                        \"purpose\": \"The script function to be executed.\"\n                    },\n                    {\n                        \"name\": \"host_defined_options\",\n                        \"type\": \"DirectHandle<FixedArray>\",\n                        \"purpose\": \"Host-defined options for the script context.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MaybeDirectHandle<Context>\",\n                    \"description\": \"The newly created script context, or an empty handle if an error occurred.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"JSFunction\",\n                    \"FixedArray\",\n                    \"Context\",\n                    \"SaveAndSwitchContext\",\n                    \"SharedFunctionInfo\",\n                    \"Script\",\n                    \"ScopeInfo\",\n                    \"NativeContext\",\n                    \"JSGlobalObject\",\n                    \"ScriptContextTable\",\n                    \"ScopeInfo::IterateLocalNames\",\n                    \"String\",\n                    \"VariableMode\",\n                    \"VariableLookupResult\",\n                    \"script_context->Lookup\",\n                    \"IsLexicalVariableMode\",\n                    \"LookupIterator\",\n                    \"JSReceiver::GetPropertyAttributes\",\n                    \"JSGlobalObject::InvalidatePropertyCell\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<Context> NewScriptContext(\n    Isolate* isolate, DirectHandle<JSFunction> function,\n    DirectHandle<FixedArray> host_defined_options) {\n  // TODO(cbruni, 1244145): Use passed in host_defined_options.\n  // Creating a script context is a side effect, so abort if that's not\n  // allowed.\n  if (isolate->should_check_side_effects()) {\n    isolate->Throw(*isolate->factory()->NewEvalError(\n        MessageTemplate::kNoSideEffectDebugEvaluate));\n    return MaybeDirectHandle<Context>();\n  }\n  SaveAndSwitchContext save(isolate, function->context());\n  Tagged<SharedFunctionInfo> sfi = function->shared();\n  Handle<Script> script(Cast<Script>(sfi->script()), isolate);\n  DirectHandle<ScopeInfo> scope_info(sfi->scope_info(), isolate);\n  DirectHandle<NativeContext> native_context(\n      Cast<NativeContext>(function->context()), isolate);\n  DirectHandle<JSGlobalObject> global_object(native_context->global_object(),\n                                             isolate);\n  Handle<ScriptContextTable> script_context(\n      native_context->script_context_table(), isolate);\n\n  // Find name clashes.\n  for (auto name_it : ScopeInfo::IterateLocalNames(scope_info)) {\n    Handle<String> name(name_it->name(), isolate);\n    VariableMode mode = scope_info->ContextLocalMode(name_it->index());\n    VariableLookupResult lookup;\n    if (script_context->Lookup(name, &lookup)) {\n      if (IsLexicalVariableMode(mode) || IsLexicalVariableMode(lookup.mode)) {\n        DirectHandle<Context> context(script_context->get(lookup.context_index),\n                                      isolate);\n        // If we are trying to redeclare a REPL-mode let as a let, REPL-mode\n        // const as a const, REPL-mode using as a using and REPL-mode await\n        // using as an await using allow it.\n        if (!((mode == lookup.mode && IsLexicalVariableMode(mode)) &&\n              scope_info->IsReplModeScope() &&\n              context->scope_info()->IsReplModeScope())) {\n          // ES#sec-globaldeclarationinstantiation 5.b:\n          // If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError\n          // exception.\n          MessageLocation location(script, 0, 1);\n          isolate->ThrowAt(isolate->factory()->NewSyntaxError(\n                               MessageTemplate::kVarRedeclaration, name),\n                           &location);\n          return MaybeDirectHandle<Context>();\n        }\n      }\n    }\n\n    if (IsLexicalVariableMode(mode)) {\n      LookupIterator lookup_it(isolate, global_object, name, global_object,\n                               LookupIterator::OWN_SKIP_INTERCEPTOR);\n      Maybe<PropertyAttributes> maybe =\n          JSReceiver::GetPropertyAttributes(&lookup_it);\n      // Can't fail since the we looking up own properties on the global object\n      // skipping interceptors.\n      CHECK(!maybe.IsNothing());\n      if ((maybe.FromJust() & DONT_DELETE) != 0) {\n        // ES#sec-globaldeclarationinstantiation 5.a:\n        // If envRec.HasVarDeclaration(name) is true, throw a SyntaxError\n        // exception.\n        // ES#sec-globaldeclarationinstantiation 5.d:\n        // If hasRestrictedGlobal is true, throw a SyntaxError exception.\n        MessageLocation location(script, 0, 1);\n        isolate->ThrowAt(isolate->factory()->NewSyntaxError(\n                             MessageTemplate::kVarRedeclaration, name),\n                         &location);\n        return MaybeDirectHandle<Context>();\n      }\n\n      JSGlobalObject::InvalidatePropertyCell(global_object, name);\n    }\n  }\n\n  DirectHandle<Context> result =\n      isolate->factory()->NewScriptContext(native_context, scope_info);\n\n  result->Initialize(isolate);\n  // In REPL mode, we are allowed to add/modify let/const/using/await using\n  // variables. We use the previous defined script context for those.\n  const bool ignore_duplicates = scope_info->IsReplModeScope();\n  DirectHandle<ScriptContextTable> new_script_context_table =\n      ScriptContextTable::Add(isolate, script_context, result,\n                              ignore_duplicates);\n  native_context->synchronized_set_script_context_table(\n      *new_script_context_table);\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Invoke\",\n                \"about\": \"Invokes a JavaScript function or constructor.\",\n                \"logic\": \"Core function for invoking JavaScript code. Handles API function calls, script context setup, and calls the JSEntry stub to execute the code.  Includes stack overflow checks and exception handling.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"params\",\n                        \"type\": \"const InvokeParams&\",\n                        \"purpose\": \"The parameters for the invocation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MaybeHandle<Object>\",\n                    \"description\": \"The result of the invocation, or an empty handle if an exception occurred.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"InvokeParams\",\n                    \"RuntimeCallCounterId::kInvoke\",\n                    \"IsJSGlobalObject\",\n                    \"FixedArray\",\n                    \"isolate->has_exception()\",\n                    \"Isolate::TryGetCurrent()\",\n                    \"VMState<JS>\",\n                    \"AllowJavascriptExecution::IsAllowed\",\n                    \"ThrowOnJavascriptExecution::IsAllowed\",\n                    \"DumpOnJavascriptExecution::IsAllowed\",\n                    \"V8::GetCurrentPlatform()->DumpWithoutCrashing()\",\n                    \"StackLimitCheck\",\n                    \"IsJSFunction\",\n                    \"IsConstructor\",\n                    \"SaveAndSwitchContext\",\n                    \"FunctionTemplateInfo\",\n                    \"Builtins::InvokeApiFunction\",\n                    \"IsJSGlobalProxy\",\n                    \"NewScriptContext\",\n                    \"JSEntry\",\n                    \"SaveContext\",\n                    \"SealHandleScope\",\n                    \"JSParameterCount\",\n                    \"Object::ObjectVerify\",\n                    \"IsException\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nV8_WARN_UNUSED_RESULT MaybeHandle<Object> Invoke(Isolate* isolate,\n                                                 const InvokeParams& params) {\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kInvoke);\n  DCHECK(!IsJSGlobalObject(*params.receiver));\n  DCHECK_LE(params.args.size(), FixedArray::kMaxLength);\n  DCHECK(!isolate->has_exception());\n  // Runtime code must be able to get the \"current\" isolate from TLS, and this\n  // must equal the isolate we execute in.\n  DCHECK_EQ(isolate, Isolate::TryGetCurrent());\n\n#if V8_ENABLE_WEBASSEMBLY\n  // If we have PKU support for Wasm, ensure that code is currently write\n  // protected for this thread.\n  DCHECK_IMPLIES(wasm::GetWasmCodeManager()->HasMemoryProtectionKeySupport(),\n                 !wasm::GetWasmCodeManager()->MemoryProtectionKeyWritable());\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n#ifdef USE_SIMULATOR\n  // Simulators use separate stacks for C++ and JS. JS stack overflow checks\n  // are performed whenever a JS function is called. However, it can be the case\n  // that the C++ stack grows faster than the JS stack, resulting in an overflow\n  // there. Add a check here to make that less likely.\n  StackLimitCheck check(isolate);\n  if (check.HasOverflowed()) {\n    isolate->StackOverflow();\n    isolate->ReportPendingMessages(params.message_handling ==\n                                   Execution::MessageHandling::kReport);\n    return MaybeHandle<Object>();\n  }\n#endif\n\n  // api callbacks can be called directly, unless we want to take the detour\n  // through JS to set up a frame for break-at-entry.\n  if (IsJSFunction(*params.target)) {\n    auto function = Cast<JSFunction>(params.target);\n    if ((!params.is_construct || IsConstructor(*function)) &&\n        function->shared()->IsApiFunction() &&\n        !function->shared()->BreakAtEntry(isolate)) {\n      SaveAndSwitchContext save(isolate, function->context());\n      DCHECK(IsJSGlobalObject(function->context()->global_object()));\n\n      DirectHandle<Object> receiver = params.is_construct\n                                          ? isolate->factory()->the_hole_value()\n                                          : params.receiver;\n      DirectHandle<FunctionTemplateInfo> fun_data(\n          function->shared()->api_func_data(), isolate);\n      auto value = Builtins::InvokeApiFunction(\n          isolate, params.is_construct, fun_data, receiver, params.args,\n          Cast<HeapObject>(params.new_target));\n      bool has_exception = value.is_null();\n      DCHECK_EQ(has_exception, isolate->has_exception());\n      if (has_exception) {\n        isolate->ReportPendingMessages(params.message_handling ==\n                                       Execution::MessageHandling::kReport);\n        return MaybeHandle<Object>();\n      } else {\n        isolate->clear_pending_message();\n      }\n      return value;\n    }\n#ifdef DEBUG\n    if (function->shared()->is_script()) {\n      DCHECK(params.IsScript());\n      DCHECK(IsJSGlobalProxy(*params.receiver));\n      DCHECK_EQ(params.args.size(), 1);\n      DCHECK(IsFixedArray(*params.args[0]));\n    } else {\n      DCHECK(!params.IsScript());\n    }\n#endif\n    // Set up a ScriptContext when running scripts that need it.\n    if (function->shared()->needs_script_context()) {\n      DirectHandle<Context> context;\n      DirectHandle<FixedArray> host_defined_options =\n          const_cast<InvokeParams&>(params).GetAndResetHostDefinedOptions();\n      if (!NewScriptContext(isolate, function, host_defined_options)\n               .ToHandle(&context)) {\n        isolate->ReportPendingMessages(params.message_handling ==\n                                       Execution::MessageHandling::kReport);\n        return MaybeHandle<Object>();\n      }\n\n      // We mutate the context if we allocate a script context. This is\n      // guaranteed to only happen once in a native context since scripts will\n      // always produce name clashes with themselves.\n      function->set_context(*context);\n    }\n  }\n\n  // Entering JavaScript.\n  VMState<JS> state(isolate);\n  if (!AllowJavascriptExecution::IsAllowed(isolate)) {\n    GRACEFUL_FATAL(\"Invoke in DisallowJavascriptExecutionScope\");\n  }\n  if (!ThrowOnJavascriptExecution::IsAllowed(isolate)) {\n    isolate->ThrowIllegalOperation();\n    isolate->ReportPendingMessages(params.message_handling ==\n                                   Execution::MessageHandling::kReport);\n    return MaybeHandle<Object>();\n  }\n  if (!DumpOnJavascriptExecution::IsAllowed(isolate)) {\n    V8::GetCurrentPlatform()->DumpWithoutCrashing();\n    return isolate->factory()->undefined_value();\n  }\n  isolate->IncrementJavascriptExecutionCounter();\n\n  if (params.execution_target == Execution::Target::kCallable) {\n    DirectHandle<NativeContext> context = isolate->native_context();\n    if (!IsUndefined(context->script_execution_callback(), isolate)) {\n      v8::Context::AbortScriptExecutionCallback callback =\n          v8::ToCData<v8::Context::AbortScriptExecutionCallback,\n                      kApiAbortScriptExecutionCallbackTag>(\n              isolate, context->script_execution_callback());\n      v8::Isolate* api_isolate = reinterpret_cast<v8::Isolate*>(isolate);\n      v8::Local<v8::Context> api_context = v8::Utils::ToLocal(context);\n      callback(api_isolate, api_context);\n      DCHECK(!isolate->has_exception());\n      // Always throw an exception to abort execution, if callback exists.\n      isolate->ThrowIllegalOperation();\n      return MaybeHandle<Object>();\n    }\n  }\n\n  // Placeholder for return value.\n  Tagged<Object> value;\n  DirectHandle<Code> code =\n      JSEntry(isolate, params.execution_target, params.is_construct);\n  {\n    // Save and restore context around invocation.\n    SaveContext save(isolate);\n\n    if (v8_flags.clear_exceptions_on_js_entry) isolate->clear_exception();\n\n    if (params.execution_target == Execution::Target::kCallable) {\n      // clang-format off\n      // {new_target}, {target}, {receiver}, return value: tagged pointers\n      // {argv}: pointer to array of tagged pointers\n      using JSEntryFunction = GeneratedCode<Address(\n          Address root_register_value, Address new_target, Address target,\n          Address receiver, intptr_t argc, Address** argv"
}