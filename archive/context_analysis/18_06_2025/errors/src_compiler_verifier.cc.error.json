{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/verifier.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/verifier.cc\",\n            \"file_name\": \"verifier.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the verifier for the Turbofan compiler graph, ensuring graph integrity and type correctness.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for the verifier implementation, such as algorithm, deque, string, and compiler-specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/verifier.h\"\n\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <sstream>\n#include <string>\n\n#include \"src/compiler/all-nodes.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-operator.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/operator.h\"\n#include \"src/compiler/schedule.h\"\n#include \"src/compiler/state-values-utils.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/compiler/type-cache.h\"\n#include \"src/utils/bit-vector.\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Verifier::Visitor\",\n                \"about\": \"Helper class for the Verifier that performs the actual graph traversal and checks.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Memory zone for allocation.\"\n                    },\n                    {\n                        \"name\": \"typing\",\n                        \"type\": \"Typing\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether to perform type checking.\"\n                    },\n                    {\n                        \"name\": \"check_inputs\",\n                        \"type\": \"CheckInputs\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether to check node inputs.\"\n                    },\n                    {\n                        \"name\": \"code_type\",\n                        \"type\": \"CodeType\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The type of code being verified (e.g., JavaScript, WebAssembly).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"Typing\",\n                    \"CheckInputs\",\n                    \"CodeType\",\n                    \"Node\",\n                    \"AllNodes\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass Verifier::Visitor {\n public:\n  Visitor(Zone* z, Typing typed, CheckInputs check_inputs, CodeType code_type)\n      : zone(z),\n        typing(typed),\n        check_inputs(check_inputs),\n        code_type(code_type) {}\n\n  void CheckSwitch(Node* node, const AllNodes& all);\n  void Check(Node* node, const AllNodes& all);\n\n  Zone* zone;\n  Typing typing;\n  CheckInputs check_inputs;\n  CodeType code_type;\n\n private:\n  void CheckNotTyped(Node* node) {\n    // Verification of simplified lowering sets types of many additional nodes.\n    if (v8_flags.verify_simplified_lowering) return;\n\n    if (NodeProperties::IsTyped(node)) {\n      std::ostringstream str;\n      str << \"TypeError: node #\" << node->id() << \":\" << *node->op()\n          << \" should never have a type\";\n      FATAL(\"%s\", str.str().c_str());\n    }\n  }\n  void CheckTypeIs(Node* node, Type type) {\n    if (typing == TYPED && !NodeProperties::GetType(node).Is(type)) {\n      std::ostringstream str;\n      str << \"TypeError: node #\" << node->id() << \":\" << *node->op() << \" type \"\n          << NodeProperties::GetType(node) << \" is not \" << type;\n      FATAL(\"%s\", str.str().c_str());\n    }\n  }\n  void CheckTypeMaybe(Node* node, Type type) {\n    if (typing == TYPED && !NodeProperties::GetType(node).Maybe(type)) {\n      std::ostringstream str;\n      str << \"TypeError: node #\" << node->id() << \":\" << *node->op() << \" type \"\n          << NodeProperties::GetType(node) << \" must intersect \" << type;\n      FATAL(\"%s\", str.str().c_str());\n    }\n  }\n  void CheckValueInputIs(Node* node, int i, Type type) {\n    Node* input = NodeProperties::GetValueInput(node, i);\n    if (typing == TYPED && !NodeProperties::GetType(input).Is(type)) {\n      std::ostringstream str;\n      str << \"TypeError: node #\" << node->id() << \":\" << *node->op()\n          << \"(input @\" << i << \" = \" << input->opcode() << \":\"\n          << input->op()->mnemonic() << \") type \"\n          << NodeProperties::GetType(input) << \" is not \" << type;\n      FATAL(\"%s\", str.str().c_str());\n    }\n  }\n  void CheckOutput(Node* node, Node* use, int count, const char* kind) {\n    if (count <= 0) {\n      std::ostringstream str;\n      str << \"GraphError: node #\" << node->id() << \":\" << *node->op()\n          << \" does not produce \" << kind << \" output used by node #\"\n          << use->id() << \":\" << *use->op();\n      FATAL(\"%s\", str.str().c_str());\n    }\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CheckSwitch\",\n                \"parent\": \"Verifier::Visitor\",\n                \"about\": \"Checks the validity of a Switch node, ensuring correct control flow and unique case values.\",\n                \"logic\": \"Iterates through the uses of the switch node, checking for IfValue and IfDefault nodes. Verifies uniqueness of IfValue parameters and existence of a single IfDefault node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Switch node to check.\"\n                    },\n                    {\n                        \"name\": \"all\",\n                        \"type\": \"const AllNodes&\",\n                        \"purpose\": \"A container of all live nodes in the graph.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"AllNodes\",\n                    \"IfValueParametersOf\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Verifier::Visitor::CheckSwitch(Node* node, const AllNodes& all) {\n  // Count the number of {kIfValue} uses.\n  int case_count = 0;\n  bool expect_default = true;\n\n  // Data structure to check that each {kIfValue} has a unique value.\n  std::unordered_set<int32_t> if_value_parameters;\n\n  Node::Uses uses = node->uses();\n  for (const Node* use : uses) {\n    CHECK(all.IsLive(use));\n    switch (use->opcode()) {\n      case IrOpcode::kIfValue: {\n        // Check if each value is unique.\n        CHECK(\n            if_value_parameters.emplace(IfValueParametersOf(use->op()).value())\n                .second);\n        ++case_count;\n        break;\n      }\n      case IrOpcode::kIfDefault: {\n        // We expect exactly one {kIfDefault}.\n        CHECK(expect_default);\n        expect_default = false;\n        break;\n      }\n      default: {\n        FATAL(\"Switch #%d illegally used by #%d:%s\", node->id(), use->id(),\n              use->op()->mnemonic());\n      }\n    }\n  }\n\n  CHECK(!expect_default);\n  // + 1 because of the one {kIfDefault}.\n  CHECK_EQ(node->op()->ControlOutputCount(), case_count + 1);\n  CheckNotTyped(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Check\",\n                \"parent\": \"Verifier::Visitor\",\n                \"about\": \"Performs the main verification logic for a given node, checking input counts, output counts, and node-specific properties.\",\n                \"logic\": \"Determines the expected input counts for value, context, frame state, effect, and control inputs.  Verifies that the actual input count matches the expected count. Checks for effect outputs to ensure they are consumed.  Performs opcode-specific checks based on the node's type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check.\"\n                    },\n                    {\n                        \"name\": \"all\",\n                        \"type\": \"const AllNodes&\",\n                        \"purpose\": \"A container of all live nodes in the graph.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"AllNodes\",\n                    \"NodeProperties\",\n                    \"OperatorProperties\",\n                    \"IrOpcode\",\n                    \"Type\",\n                    \"BranchParametersOf\",\n                    \"ParameterIndexOf\",\n                    \"StartNode\",\n                    \"ProjectionIndexOf\",\n                    \"SelectParametersOf\",\n                    \"FrameState\",\n                    \"StateValuesAccess\",\n                    \"LoadGlobalParametersOf\",\n                    \"StoreGlobalParametersOf\",\n                    \"DefineNamedOwnPropertyParametersOf\",\n                    \"FeedbackParameterOf\",\n                    \"PropertyAccessOf\",\n                    \"TypeCache\",\n                    \"Integral32OrMinusZeroToBigInt\",\n                    \"TypeGuardTypeOf\",\n                    \"BigInt\",\n                    \"Receiver\",\n                    \"Function\",\n                    \"FieldAccessOf\",\n                    \"ElementAccessOf\",\n                    \"MachineSimd128OpList\",\n                    \"MachineSimd256OpList\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Verifier::Visitor::Check(Node* node, const AllNodes& all) {\n  int value_count = node->op()->ValueInputCount();\n  int context_count = OperatorProperties::GetContextInputCount(node->op());\n  int frame_state_count =\n      OperatorProperties::GetFrameStateInputCount(node->op());\n  int effect_count = node->op()->EffectInputCount();\n  int control_count = node->op()->ControlInputCount();\n\n  // Verify number of inputs matches up.\n  int input_count = value_count + context_count + frame_state_count;\n  if (check_inputs == kAll) {\n    input_count += effect_count + control_count;\n  }\n  CHECK_EQ(input_count, node->InputCount());\n\n  // If this node has any effect outputs, make sure that it is\n  // consumed as an effect input somewhere else.\n  if (node->op()->EffectOutputCount() > 0) {\n#ifdef DEBUG\n    int effect_edges = 0;\n    for (Edge edge : node->use_edges()) {\n      if (all.IsLive(edge.from()) && NodeProperties::IsEffectEdge(edge)) {\n        effect_edges++;\n      }\n    }\n    if (effect_edges == 0) {\n      FailSoon(node);\n    }\n    DCHECK_GT(effect_edges, 0);\n#endif\n  }\n\n  // Verify that frame state has been inserted for the nodes that need it.\n  for (int i = 0; i < frame_state_count; i++) {\n    Node* frame_state = NodeProperties::GetFrameStateInput(node);\n    CHECK(frame_state->opcode() == IrOpcode::kFrameState ||\n          // kFrameState uses Start as a sentinel.\n          (node->opcode() == IrOpcode::kFrameState &&\n           frame_state->opcode() == IrOpcode::kStart));\n  }\n\n  // Verify all value inputs actually produce a value.\n  for (int i = 0; i < value_count; ++i) {\n    Node* value = NodeProperties::GetValueInput(node, i);\n    CheckOutput(value, node, value->op()->ValueOutputCount(), \"value\");\n    // Verify that only parameters and projections can have input nodes with\n    // multiple outputs.\n    CHECK(node->opcode() == IrOpcode::kParameter ||\n          node->opcode() == IrOpcode::kProjection ||\n          value->op()->ValueOutputCount() <= 1);\n  }\n\n  // Verify all context inputs are value nodes.\n  for (int i = 0; i < context_count; ++i) {\n    Node* context = NodeProperties::GetContextInput(node);\n    CheckOutput(context, node, context->op()->ValueOutputCount(), \"context\");\n  }\n\n  if (check_inputs == kAll) {\n    // Verify all effect inputs actually have an effect.\n    for (int i = 0; i < effect_count; ++i) {\n      Node* effect = NodeProperties::GetEffectInput(node);\n      CheckOutput(effect, node, effect->op()->EffectOutputCount(), \"effect\");\n    }\n\n    // Verify all control inputs are control nodes.\n    for (int i = 0; i < control_count; ++i) {\n      Node* control = NodeProperties::GetControlInput(node, i);\n      CheckOutput(control, node, control->op()->ControlOutputCount(),\n                  \"control\");\n    }\n\n    // Verify that nodes that can throw either have both IfSuccess/IfException\n    // projections as the only control uses or no projections at all.\n    if (!node->op()->HasProperty(Operator::kNoThrow)) {\n      Node* discovered_if_exception = nullptr;\n      Node* discovered_if_success = nullptr;\n      Node* discovered_direct_use = nullptr;\n      int total_number_of_control_uses = 0;\n      for (Edge edge : node->use_edges()) {\n        if (!NodeProperties::IsControlEdge(edge)) {\n          continue;\n        }\n        total_number_of_control_uses++;\n        Node* control_use = edge.from();\n        if (control_use->opcode() == IrOpcode::kIfSuccess) {\n          CHECK_NULL(discovered_if_success);  // Only one allowed.\n          discovered_if_success = control_use;\n        } else if (control_use->opcode() == IrOpcode::kIfException) {\n          CHECK_NULL(discovered_if_exception);  // Only one allowed.\n          discovered_if_exception = control_use;\n        } else {\n          discovered_direct_use = control_use;\n        }\n      }\n      if (discovered_if_success && !discovered_if_exception) {\n        FATAL(\n            \"#%d:%s should be followed by IfSuccess/IfException, but is \"\n            \"only followed by single #%d:%s\",\n            node->id(), node->op()->mnemonic(), discovered_if_success->id(),\n            discovered_if_success->op()->mnemonic());\n      }\n      if (discovered_if_exception && !discovered_if_success) {\n        FATAL(\n            \"#%d:%s should be followed by IfSuccess/IfException, but is \"\n            \"only followed by single #%d:%s\",\n            node->id(), node->op()->mnemonic(), discovered_if_exception->id(),\n            discovered_if_exception->op()->mnemonic());\n      }\n      if ((discovered_if_success || discovered_if_exception) &&\n          total_number_of_control_uses != 2) {\n        FATAL(\n            \"#%d:%s if followed by IfSuccess/IfException, there should be \"\n            \"no direct control uses, but direct use #%d:%s was found\",\n            node->id(), node->op()->mnemonic(), discovered_direct_use->id(),\n            discovered_direct_use->op()->mnemonic());\n      }\n    }\n  }\n\n  switch (node->opcode()) {\n    case IrOpcode::kStart: {\n      // Start has no inputs.\n      CHECK_EQ(0, input_count);\n      // Type is a tuple.\n      // TODO(rossberg): Multiple outputs are currently typed as Internal.\n      CheckTypeIs(node, Type::Internal());\n      // Check that parameters are unique. We need this because the register\n      // allocator gets confused when there are two identical parameters which\n      // are both hard-assigned to the same register (such as the instance\n      // parameter in wasm).\n      std::unordered_set<int> param_indices;\n      for (Node* use : node->uses()) {\n        if (all.IsLive(use) && use->opcode() == IrOpcode::kParameter) {\n          int index = ParameterIndexOf(use->op());\n          CHECK_EQ(param_indices.count(index), 0);\n          param_indices.insert(index);\n        }\n      }\n      break;\n    }\n    case IrOpcode::kEnd:\n      // End has no outputs.\n      CHECK_EQ(0, node->op()->ValueOutputCount());\n      CHECK_EQ(0, node->op()->EffectOutputCount());\n      CHECK_EQ(0, node->op()->ControlOutputCount());\n      // All inputs are graph terminators.\n      for (const Node* input : node->inputs()) {\n        CHECK(IrOpcode::IsGraphTerminator(input->opcode()));\n      }\n      CheckNotTyped(node);\n      break;\n    case IrOpcode::kDead:\n      // Dead is never connected to the graph.\n      UNREACHABLE();\n    case IrOpcode::kDeadValue:\n      CheckValueInputIs(node, 0, Type::None());\n      CheckTypeIs(node, Type::None());\n      break;\n    case IrOpcode::kUnreachable:\n      CheckTypeIs(node, Type::None());\n      for (Edge edge : node->use_edges()) {\n        Node* use = edge.from();\n        if (NodeProperties::IsValueEdge(edge) && all.IsLive(use)) {\n          // {Unreachable} nodes can only be used by {DeadValue}, because they\n          // don't actually produce a value.\n          CHECK_EQ(IrOpcode::kDeadValue, use->opcode());\n        }\n      }\n      break;\n    case IrOpcode::kBranch: {\n      // Branch uses are IfTrue and IfFalse.\n      int count_true = 0, count_false = 0;\n      for (const Node* use : node->uses()) {\n        CHECK(all.IsLive(use) && (use->opcode() == IrOpcode::kIfTrue ||\n                                  use->opcode() == IrOpcode::kIfFalse));\n        if (use->opcode() == IrOpcode::kIfTrue) ++count_true;\n        if (use->opcode() == IrOpcode::kIfFalse) ++count_false;\n      }\n      CHECK_EQ(1, count_true);\n      CHECK_EQ(1, count_false);\n      switch (BranchParametersOf(node->op()).semantics()) {\n        case BranchSemantics::kJS:\n        case BranchSemantics::kUnspecified:\n          // The condition must be a Boolean.\n          CheckValueInputIs(node, 0, Type::Boolean());\n          break;\n        case BranchSemantics::kMachine:\n          CheckValueInputIs(node, 0, Type::Machine());\n          break;\n      }\n      CheckNotTyped(node);\n      break;\n    }\n    case IrOpcode::kIfTrue:\n    case IrOpcode::kIfFalse: {\n      Node* control = NodeProperties::GetControlInput(node, 0);\n      CHECK_EQ(IrOpcode::kBranch, control->opcode());\n      CheckNotTyped(node);\n      break;\n    }\n    case IrOpcode::kIfSuccess: {\n      // IfSuccess and IfException continuation only on throwing nodes.\n      Node* input = NodeProperties::GetControlInput(node, 0);\n      CHECK(!input->op()->HasProperty(Operator::kNoThrow));\n      CheckNotTyped(node);\n      break;\n    }\n    case IrOpcode::kIfException: {\n      // IfSuccess and IfException continuation only on throwing nodes.\n      Node* input = NodeProperties::GetControlInput(node, 0);\n      CHECK(!input->op()->HasProperty(Operator::kNoThrow));\n      CheckTypeIs(node, Type::Any());\n      break;\n    }\n    case IrOpcode::kSwitch: {\n      CheckSwitch(node, all);\n      break;\n    }\n    case IrOpcode::kIfValue:\n    case IrOpcode::kIfDefault:\n      CHECK_EQ(IrOpcode::kSwitch,\n               NodeProperties::GetControlInput(node)->opcode());\n      CheckNotTyped(node);\n      break;\n    case IrOpcode::kLoop: {\n      CHECK_EQ(control_count, input_count);\n      CheckNotTyped(node);\n      // All loops need to be connected to a {Terminate} node to ensure they\n      // stay connected to the graph end.\n      bool has_terminate = false;\n      for (const Node* use : node->uses()) {\n        if (all.IsLive(use) && use->opcode() == IrOpcode::kTerminate) {\n          has_terminate = true;\n          break;\n        }\n      }\n      CHECK(has_terminate);\n      break;\n    }\n    case IrOpcode::kMerge:\n      CHECK_EQ(control_count, input_count);\n      CheckNotTyped(node);\n      break;\n    case IrOpcode::kDeoptimizeIf:\n    case IrOpcode::kDeoptimizeUnless:\n    case IrOpcode::kPlug:\n    case IrOpcode::kTrapIf:\n    case IrOpcode::kTrapUnless:\n    case IrOpcode::kAssert:\n      CheckNotTyped(node);\n      break;\n    case IrOpcode::kDeoptimize:\n    case IrOpcode::kReturn:\n    case IrOpcode::kThrow:\n      // Deoptimize, Return and Throw uses are End.\n      for (const Node* use : node->uses()) {\n        if (all.IsLive(use)) {\n          CHECK_EQ(IrOpcode::kEnd, use->opcode());\n        }\n      }\n      CheckNotTyped(node);\n      break;\n    case IrOpcode::kTerminate:\n      // Terminates take one loop and effect.\n      CHECK_EQ(1, control_count);\n      CHECK_EQ(1, effect_count);\n      CHECK_EQ(2, input_count);\n      CHECK_EQ(IrOpcode::kLoop,\n               NodeProperties::GetControlInput(node)->opcode());\n      // Terminate uses are End.\n      for (const Node* use : node->uses()) {\n        if (all.IsLive(use)) {\n          CHECK_EQ(IrOpcode::kEnd, use->opcode());\n        }\n      }\n      CheckNotTyped(node);\n      break;\n\n    // Common operators\n    // ----------------\n    case IrOpcode::kParameter: {\n      // Parameters have the start node as inputs.\n      CHECK_EQ(1, input_count);\n      // Parameter has an input that produces enough values.\n      int const index = ParameterIndexOf(node->op());\n      StartNode start{NodeProperties::GetValueInput(node, 0)};\n      // Currently, parameter indices start at -1 instead of 0.\n      CHECK_LE(-1, index);\n      CHECK_LE(index, start.LastParameterIndex_MaybeNonStandardLayout());\n      CheckTypeIs(node, Type::Any());\n      break;\n    }\n    case IrOpcode::kInt32Constant:    // TODO(turbofan): rename Word32Constant?\n    case IrOpcode::kInt64Constant: {  // TODO(turbofan): rename Word64Constant?\n      // Constants have no inputs.\n      CHECK_EQ(0, input_count);\n      // Wasm numeric constants have types. However, since wasm only gets\n      // verified in untyped mode, we do not need to check that the types match.\n      // TODO(manoskouk): Verify the type if wasm runs in typed mode.\n      if (code_type != kWasm) CheckTypeIs(node, Type::Machine());\n      break;\n    }\n    case IrOpcode::kFloat32Constant:\n    case IrOpcode::kFloat64Constant: {\n      // Constants have no inputs.\n      CHECK_EQ(0, input_count);\n      // Wasm numeric constants have types. However, since wasm only gets\n      // verified in untyped mode, we do not need to check that the types match.\n      // TODO(manoskouk): Verify the type if wasm runs in typed mode.\n      if (code_type != kWasm) CheckNotTyped(node);\n      break;\n    }\n    case IrOpcode::kTaggedIndexConstant:\n    case IrOpcode::kRelocatableInt32Constant:\n    case IrOpcode::kRelocatableInt64Constant:\n      // Constants have no inputs.\n      CHECK_EQ(0, input_count);\n      CheckNotTyped(node);\n      break;\n    case IrOpcode::kNumberConstant:\n      // Constants have no inputs.\n      CHECK_EQ(0, input_count);\n      CheckTypeIs(node, Type::Number());\n      break;\n    case IrOpcode::kHeapConstant:\n    case IrOpcode::kCompressedHeapConstant:\n    case IrOpcode::kTrustedHeapConstant:\n      // Constants have no inputs.\n      CHECK_EQ(0, input_count);\n      CheckTypeIs(node, Type::Any());\n      break;\n    case IrOpcode::kExternalConstant:\n    case IrOpcode::kPointerConstant:\n      // Constants have no inputs.\n      CHECK_EQ(0, input_count);\n      CheckTypeIs(node, Type::ExternalPointer());\n      break;\n    case IrOpcode::kOsrValue:\n      // OSR values have a value and a control input.\n      CHECK_EQ(1, control_count);\n      CHECK_EQ(1, input_count);\n      // Type is merged from other values in the graph and could be any.\n      CheckTypeIs(node, Type::Any());\n      break;\n    case IrOpcode::kProjection: {\n      // Projection has an input that produces enough values.\n      int index = static_cast<int>(ProjectionIndexOf(node->op()));\n      Node* input = NodeProperties::GetValueInput(node, 0);\n      CHECK_GT(input->op()->ValueOutputCount(), index);\n      CheckTypeIs(node, Type::Any());\n      break;\n    }\n    case IrOpcode::kSelect: {\n      CHECK_EQ(0, effect_count);\n      CHECK_EQ(0, control_count);\n      CHECK_EQ(3, value_count);\n      switch (SelectParametersOf(node->op()).semantics()) {\n        case BranchSemantics::kJS:\n        case BranchSemantics::kUnspecified:\n          // The condition must be a Boolean.\n          CheckValueInputIs(node, 0, Type::Boolean());\n          break;\n        case BranchSemantics::kMachine:\n          CheckValueInputIs(node, 0, Type::Machine());\n          break;\n      }\n      CheckTypeIs(node, Type::Any());\n      break;\n    }\n    case IrOpcode::kPhi: {\n      // Phi input count matches parent control node.\n      CHECK_EQ(0, effect_count);\n      CHECK_EQ(1, control_count);\n      Node* control = NodeProperties::GetControlInput(node, 0);\n      CHECK_EQ(value_count, control->op()->ControlInputCount());\n      CHECK_EQ(input_count, 1 + value_count);\n      // Type must be subsumed by all input types.\n      // TODO(rossberg): for now at least, narrowing does not really hold.\n      /*\n      for (int i = 0; i < value_count; ++i) {\n        CHECK(type_of(ValueInput(node, i))->Is(type_of(node)));\n      }\n      */\n      break;\n    }\n    case IrOpcode::kInductionVariablePhi: {\n      // This is only a temporary node for the typer.\n      UNREACHABLE();\n    }\n    case IrOpcode::kEffectPhi: {\n      // EffectPhi input count matches parent control node.\n      CHECK_EQ(0, value_count);\n      CHECK_EQ(1, control_count);\n      Node* control = NodeProperties::GetControlInput(node, 0);\n      CHECK_EQ(effect_count, control->op()->ControlInputCount());\n      CHECK_EQ(input_count, 1 + effect_count);\n      // If the control input is a Merge, then make sure that at least one of\n      // its usages is non-phi.\n      if (control->opcode() == IrOpcode::kMerge) {\n        bool non_phi_use_found = false;\n        for (Node* use : control->uses()) {\n          if (all.IsLive(use) && use->opcode() != IrOpcode::kEffectPhi &&\n              use->opcode() != IrOpcode::kPhi) {\n            non_phi_use_found = true;\n          }\n        }\n        CHECK(non_phi_use_found);\n      }\n      break;\n    }\n    case IrOpcode::kLoopExit: {\n      CHECK_EQ(2, control_count);\n      Node* loop = NodeProperties::GetControlInput(node, 1);\n      CHECK_EQ(IrOpcode::kLoop, loop->opcode());\n      break;\n    }\n    case IrOpcode::kLoopExitValue: {\n      CHECK_EQ(1, control_count);\n      Node* loop_exit = NodeProperties::GetControlInput(node, 0);\n      CHECK_EQ(IrOpcode::kLoopExit, loop_exit->opcode());\n      break;\n    }\n    case IrOpcode::kLoopExitEffect: {\n      CHECK_EQ(1, control_count);\n      Node* loop_exit = NodeProperties::GetControlInput(node, 0);\n      CHECK_EQ(IrOpcode::kLoopExit, loop_exit->opcode());\n      break;\n    }\n    case IrOpcode::kCheckpoint:\n      CheckNotTyped(node);\n      break;\n    case IrOpcode::kBeginRegion:\n      // TODO(rossberg): what are the constraints on these?\n      break;\n    case IrOpcode::kFinishRegion: {\n      // TODO(rossberg): what are the constraints on these?\n      // Type must be subsumed by input type.\n      if (typing == TYPED) {\n        Node* val = NodeProperties::GetValueInput(node, 0);\n        CHECK(NodeProperties::GetType(val).Is(NodeProperties::GetType(node)));\n      }\n      break;\n    }\n    case IrOpcode::kFrameState: {\n      // TODO(jarin): what are the constraints on these?\n      CHECK_EQ(5, value_count);\n      CHECK_EQ(0, control_count);\n      CHECK_EQ(0, effect_count);\n      CHECK_EQ(6, input_count);\n\n      FrameState state{node};\n      CHECK(state.parameters()->opcode() == IrOpcode::kStateValues ||\n            state.parameters()->opcode() == IrOpcode::kTypedStateValues);\n      CHECK(state.locals()->opcode() == IrOpcode::kStateValues ||\n            state.locals()->opcode() == IrOpcode::kTypedStateValues);\n\n      // Checks that the state input is empty for all but kInterpretedFunction\n      // frames, where it should have size one.\n      {\n        const FrameStateFunctionInfo* func_info =\n            state.frame_state_info().function_info();\n        CHECK_EQ(func_info->parameter_count(),\n                 StateValuesAccess(state.parameters()).size());\n        CHECK_EQ(func_info->local_count(),\n                 StateValuesAccess(state.locals()).size());\n\n        Node* accumulator = state.stack();\n        if (func_info->type() == FrameStateType::kUnoptimizedFunction) {\n          // The accumulator (InputAt(2)) cannot be kStateValues.\n          // It can be kTypedStateValues (to signal the type) and it can have\n          // other Node types including that of the optimized_out HeapConstant.\n          CHECK_NE(accumulator->opcode(), IrOpcode::kStateValues);\n          if (accumulator->opcode() == IrOpcode::kTypedStateValues) {\n            CHECK_EQ(1, StateValuesAccess(accumulator).size());\n          }\n        } else {\n          CHECK(accumulator->opcode() == IrOpcode::kTypedStateValues ||\n                accumulator->opcode() == IrOpcode::kStateValues);\n          CHECK_EQ(0, StateValuesAccess(accumulator).size());\n        }\n      }\n      break;\n    }\n    case IrOpcode::kObjectId:\n      CheckTypeIs(node, Type::Object());\n      break;\n    case IrOpcode::kStateValues:\n    case IrOpcode::kTypedStateValues:\n    case IrOpcode::kArgumentsElementsState:\n    case IrOpcode::kArgumentsLengthState:\n    case IrOpcode::kObjectState:\n    case IrOpcode::kTypedObjectState:\n      // TODO(jarin): what are the constraints on these?\n      break;\n    case IrOpcode::kCall:\n      // TODO(rossberg): what are the constraints on these?\n      break;\n    case IrOpcode::kTailCall:\n      // TODO(bmeurer): what are the constraints on these?\n      break;\n    case IrOpcode::kEnterMachineGraph:\n      CheckTypeIs(node, Type::Machine());\n      break;\n    case IrOpcode::kExitMachineGraph:"
}