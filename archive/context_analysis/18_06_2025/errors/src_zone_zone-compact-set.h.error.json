{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-compact-set.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 40, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-compact-set.h\",\n            \"file_name\": \"zone-compact-set.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines a space-efficient, Zone-allocated set for storing Handles or other pointer-like types, optimized for cases with zero or one element.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers for algorithms, initializer lists, type traits, and V8-specific headers for base utilities, handles, and zone management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <algorithm>\n#include <initializer_list>\n#include <type_traits>\n\n#include \"src/base/compiler-specific.h\"\n#include \"src/base/pointer-with-payload.h\"\n#include \"src/common/assert-scope.h\"\n#include \"src/handles/handles.h\"\n#include \"src/zone/zone-containers.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"ZoneCompactSetTraits\",\n                \"about\": \"Provides type traits and helper functions for ZoneCompactSet to work with different Handle-like types.  It's specialized for Handle<T>.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T, typename Enable = void>\nstruct ZoneCompactSetTraits;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"ZoneCompactSetTraits<Handle<T>>\",\n                \"about\": \"A specialization of ZoneCompactSetTraits for v8::internal::Handle<T>.  Provides Handle-specific conversions to and from raw pointers.\",\n                \"dependencies\": [\n                    \"Handle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nstruct ZoneCompactSetTraits<Handle<T>> {\n  using handle_type = Handle<T>;\n  using data_type = Address;\n\n  static data_type* HandleToPointer(handle_type handle) {\n    // Use address() instead of location() to get around handle access checks\n    // (we're not actually dereferencing the handle so it's safe to read its\n    // location)\n    return reinterpret_cast<Address*>(handle.address());\n  }\n  static handle_type PointerToHandle(data_type* ptr) {\n    return handle_type(ptr);\n  }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneCompactSet\",\n                \"about\": \"A Zone-allocated set that compactly encodes zero or one values. Stores a sorted list for two or more values, copied on write. Optimized for cases where the set mostly has zero or one values.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"ZoneCompactSetTraits\",\n                    \"base::Vector\",\n                    \"base::PointerWithPayload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass ZoneCompactSet final {\n  static_assert(std::is_trivially_copyable_v<T>);\n  static_assert(std::is_trivially_destructible_v<T>);\n\n  using Traits = ZoneCompactSetTraits<T>;\n  using handle_type = typename Traits::handle_type;\n  using data_type = typename Traits::data_type;\n\n public:\n  ZoneCompactSet() : data_(kEmptyTag) {}\n  explicit ZoneCompactSet(T handle)\n      : data_(Traits::HandleToPointer(handle), kSingletonTag) {}\n  explicit ZoneCompactSet(std::initializer_list<T> handles, Zone* zone)\n      : ZoneCompactSet(handles.begin(), handles.end(), zone) {}\n\n  ZoneCompactSet(const ZoneCompactSet& other) V8_NOEXCEPT = default;\n  ZoneCompactSet& operator=(const ZoneCompactSet& other) V8_NOEXCEPT = default;\n  ZoneCompactSet(ZoneCompactSet&& other) V8_NOEXCEPT = default;\n  ZoneCompactSet& operator=(ZoneCompactSet&& other) V8_NOEXCEPT = default;\n\n  template <class It,\n            typename = typename std::iterator_traits<It>::iterator_category>\n  explicit ZoneCompactSet(It first, It last, Zone* zone) {\n    auto size = last - first;\n    if (size == 0) {\n      data_ = EmptyValue();\n    } else if (size == 1) {\n      data_ =\n          PointerWithPayload(Traits::HandleToPointer(*first), kSingletonTag);\n    } else {\n      List* list = NewList(size, zone);\n      auto list_it = list->begin();\n      for (auto it = first; it != last; ++it) {\n        *list_it = Traits::HandleToPointer(*it);\n        list_it++;\n      }\n      std::sort(list->begin(), list->end());\n      data_ = PointerWithPayload(list, kListTag);\n    }\n  }\n\n  ZoneCompactSet<T> Clone(Zone* zone) const {\n    return ZoneCompactSet<T>(begin(), end(), zone);\n  }\n\n  bool is_empty() const { return data_ == EmptyValue(); }\n\n  size_t size() const {\n    if (is_empty()) return 0;\n    if (is_singleton()) return 1;\n    return list()->size();\n  }\n\n  T at(size_t i) const {\n    DCHECK_NE(kEmptyTag, data_.GetPayload());\n    if (is_singleton()) {\n      DCHECK_EQ(0u, i);\n      return Traits::PointerToHandle(singleton());\n    }\n    return Traits::PointerToHandle(list()->at(static_cast<int>(i)));\n  }\n\n  T operator[](size_t i) const { return at(i); }\n\n  void insert(T handle, Zone* zone) {\n    data_type* const value = Traits::HandleToPointer(handle);\n    if (is_empty()) {\n      data_ = PointerWithPayload(value, kSingletonTag);\n    } else if (is_singleton()) {\n      if (singleton() == value) return;\n      List* list = NewList(2, zone);\n      if (singleton() < value) {\n        (*list)[0] = singleton();\n        (*list)[1] = value;\n      } else {\n        (*list)[0] = value;\n        (*list)[1] = singleton();\n      }\n      data_ = PointerWithPayload(list, kListTag);\n    } else {\n      const List* current_list = list();\n      auto it =\n          std::lower_bound(current_list->begin(), current_list->end(), value);\n      if (it != current_list->end() && *it == value) {\n        // Already in the list.\n        return;\n      }\n      // Otherwise, lower_bound returned the insertion position to keep the list\n      // sorted.\n      DCHECK(it == current_list->end() || *it > value);\n      // We need to copy the list to mutate it, so that trivial copies of the\n      // data_ pointer don't observe changes to the list.\n      // TODO(leszeks): Avoid copying on every insertion by introducing some\n      // concept of mutable/immutable/frozen/CoW sets.\n      List* new_list = NewList(current_list->size() + 1, zone);\n      auto new_it = new_list->begin();\n      new_it = std::copy(current_list->begin(), it, new_it);\n      *new_it++ = value;\n      new_it = std::copy(it, current_list->end(), new_it);\n      DCHECK_EQ(new_it, new_list->end());\n      DCHECK(std::is_sorted(new_list->begin(), new_list->end()));\n      data_ = PointerWithPayload(new_list, kListTag);\n    }\n  }\n\n  void Union(ZoneCompactSet<T> const& other, Zone* zone) {\n    for (size_t i = 0; i < other.size(); ++i) {\n      insert(other.at(i), zone);\n    }\n  }\n\n  bool contains(ZoneCompactSet<T> const& other) const {\n    if (data_ == other.data_) return true;\n    if (is_empty()) return false;\n    if (other.is_empty()) return true;\n    if (is_singleton()) {\n      DCHECK_IMPLIES(other.is_singleton(), other.singleton() != singleton());\n      return false;\n    }\n    const List* list = this->list();\n    DCHECK(std::is_sorted(list->begin(), list->end()));\n    if (other.is_singleton()) {\n      return std::binary_search(list->begin(), list->end(), other.singleton());\n    }\n    DCHECK(other.is_list());\n    DCHECK(std::is_sorted(other.list()->begin(), other.list()->end()));\n    // For each element in the `other` list, find the matching element in this\n    // list. Since both lists are sorted, each search candidate will be larger\n    // than the previous, and each found element will be the lower bound for\n    // the search of the next element.\n    auto it = list->begin();\n    for (const data_type* pointer : *other.list()) {\n      it = std::lower_bound(it, list->end(), pointer);\n      if (it == list->end() || *it != pointer) return false;\n    }\n    return true;\n  }\n\n  bool contains(T handle) const {\n    if (is_empty()) return false;\n    data_type* pointer = Traits::HandleToPointer(handle);\n    if (is_singleton()) {\n      return singleton() == pointer;\n    }\n    const List* list = this->list();\n    DCHECK(std::is_sorted(list->begin(), list->end()));\n    return std::binary_search(list->begin(), list->end(), pointer);\n  }\n\n  void remove(T handle, Zone* zone) {\n    if (is_empty()) return;\n    data_type* pointer = Traits::HandleToPointer(handle);\n    if (is_singleton()) {\n      if (singleton() == pointer) {\n        data_ = EmptyValue();\n      }\n      return;\n    }\n    const List* current_list = list();\n    auto found_it =\n        std::lower_bound(current_list->begin(), current_list->end(), pointer);\n    if (found_it == current_list->end() || *found_it != pointer) {\n      // Not in the list.\n      return;\n    }\n    // Otherwise, lower_bound returned the location of the value.\n\n    // Drop back down to singleton mode if the size will drops to 1 -- this is\n    // needed to ensure that comparisons are correct. We never have to drop down\n    // from list to zero size.\n    DCHECK_GE(current_list->size(), 2);\n    if (current_list->size() == 2) {\n      data_type* other_value;\n      if (found_it == current_list->begin()) {\n        other_value = current_list->at(1);\n      } else {\n        other_value = current_list->at(0);\n      }\n      data_ = PointerWithPayload(other_value, kSingletonTag);\n      return;\n    }\n\n    // We need to copy the list to mutate it, so that trivial copies of the\n    // data_ pointer don't observe changes to the list.\n    List* new_list = NewList(current_list->size() - 1, zone);\n    auto new_it = new_list->begin();\n    new_it = std::copy(current_list->begin(), found_it, new_it);\n    new_it = std::copy(found_it + 1, current_list->end(), new_it);\n    DCHECK_EQ(new_it, new_list->end());\n    DCHECK(std::is_sorted(new_list->begin(), new_list->end()));\n    data_ = PointerWithPayload(new_list, kListTag);\n  }\n\n  void clear() { data_ = EmptyValue(); }\n\n  friend bool operator==(ZoneCompactSet<T> const& lhs,\n                         ZoneCompactSet<T> const& rhs) {\n    if (lhs.data_ == rhs.data_) return true;\n    if (lhs.is_list() && rhs.is_list()) {\n      List const* const lhs_list = lhs.list();\n      List const* const rhs_list = rhs.list();\n      return std::equal(lhs_list->begin(), lhs_list->end(), rhs_list->begin(),\n                        rhs_list->end());\n    }\n    return false;\n  }\n\n  friend bool operator!=(ZoneCompactSet<T> const& lhs,\n                         ZoneCompactSet<T> const& rhs) {\n    return !(lhs == rhs);\n  }\n\n  friend uintptr_t hash_value(ZoneCompactSet<T> const& set) {\n    return set.data_.raw();\n  }\n\n  class const_iterator;\n  inline const_iterator begin() const;\n  inline const_iterator end() const;\n\n private:\n  enum Tag { kSingletonTag = 0, kEmptyTag = 1, kListTag = 2 };\n\n  using List = base::Vector<data_type*>;\n  using PointerWithPayload = base::PointerWithPayload<void, Tag, 2>;\n\n  bool is_singleton() const { return data_.GetPayload() == kSingletonTag; }\n  bool is_list() const { return data_.GetPayload() == kListTag; }\n\n  List const* list() const {\n    DCHECK(is_list());\n    return static_cast<List const*>(data_.GetPointerWithKnownPayload(kListTag));\n  }\n\n  data_type* singleton() const {\n    return static_cast<data_type*>(\n        data_.GetPointerWithKnownPayload(kSingletonTag));\n  }\n\n  List* NewList(size_t size, Zone* zone) {\n    // We need to allocate both the List, and the backing store of the list, in\n    // the zone, so that we have a List pointer and not an on-stack List (which\n    // we can't use in the `data_` pointer).\n    return zone->New<List>(zone->AllocateArray<data_type*>(size), size);\n  }\n\n  static PointerWithPayload EmptyValue() {\n    return PointerWithPayload(nullptr, kEmptyTag);\n  }\n\n  PointerWithPayload data_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for ZoneCompactSet to provide a string representation.\",\n                \"logic\": \"Iterates through the set and appends each element to the output stream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"set\",\n                        \"type\": \"ZoneCompactSet<T>\",\n                        \"purpose\": \"The ZoneCompactSet to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"ZoneCompactSet\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, ZoneCompactSet<T> set) {\n  for (size_t i = 0; i < set.size(); ++i) {\n    if (i > 0) os << \", \";\n    os << set.at(i);\n  }\n  return os;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneCompactSet<T>::const_iterator\",\n                \"about\": \"Iterator for ZoneCompactSet.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"ZoneCompactSet\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass ZoneCompactSet<T>::const_iterator {\n public:\n  using iterator_category = std::forward_iterator_tag;\n  using difference_type = std::ptrdiff_t;\n  using value_type = T;\n  using reference = value_type;\n  using pointer = value_type*;\n\n  const_iterator(const const_iterator& other) = default;\n  const_iterator& operator=(const const_iterator& other) = default;\n\n  reference operator*() const { return (*set_)[current_]; }\n  bool operator==(const const_iterator& other) const {\n    return set_ == other.set_ && current_ == other.current_;\n  }\n  bool operator!=(const const_iterator& other) const {\n    return !(*this == other);\n  }\n  const_iterator& operator++() {\n    DCHECK(current_ < set_->size());\n    current_ += 1;\n    return *this;\n  }\n  const_iterator operator++(int);\n\n  difference_type operator-(const const_iterator& other) const {\n    DCHECK_EQ(set_, other.set_);\n    return current_ - other.current_;\n  }\n\n private:\n  friend class ZoneCompactSet<T>;\n\n  explicit const_iterator(const ZoneCompactSet<T>* set, size_t current)\n      : set_(set), current_(current) {}\n\n  const ZoneCompactSet<T>* set_;\n  size_t current_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"begin\",\n                \"parent\": \"ZoneCompactSet\",\n                \"about\": \"Returns an iterator to the beginning of the ZoneCompactSet.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"ZoneCompactSet<T>::const_iterator\",\n                    \"description\": \"An iterator pointing to the beginning of the set.\"\n                },\n                \"dependencies\": [\n                    \"ZoneCompactSet::const_iterator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\ntypename ZoneCompactSet<T>::const_iterator ZoneCompactSet<T>::begin() const {\n  return ZoneCompactSet<T>::const_iterator(this, 0);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"end\",\n                \"parent\": \"ZoneCompactSet\",\n                \"about\": \"Returns an iterator to the end of the ZoneCompactSet.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"ZoneCompactSet<T>::const_iterator\",\n                    \"description\": \"An iterator pointing to the end of the set.\"\n                },\n                \"dependencies\": [\n                    \"ZoneCompactSet::const_iterator\",\n                    \"ZoneCompactSet::size\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\ntypename ZoneCompactSet<T>::const_iterator ZoneCompactSet<T>::end() const {\n  return ZoneCompactSet<T>::const_iterator(this, size());\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"alias\",\n                \"name\": \"ZoneHandleSet\",\n                \"about\": \"Type alias for ZoneCompactSet<Handle<T>>.  Represents a compact set of Handles.\",\n                \"dependencies\": [\n                    \"ZoneCompactSet\",\n                    \"Handle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nusing ZoneHandleSet = ZoneCompactSet<Handle<T>>;\n        ]]></code>\n    </class>\n</file>\n```"
}