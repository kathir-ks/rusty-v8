{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/s390/baseline-assembler-s390-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/s390/baseline-assembler-s390-inl.h\",\n      \"file_name\": \"baseline-assembler-s390-inl.h\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Provides inline implementations for the BaselineAssembler class on the s390 architecture, used in V8's baseline compiler (Sparkplug).\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes necessary header files for baseline assembler, interface descriptors, S390 assembler, and literal objects.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/baseline/baseline-assembler.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/codegen/s390/assembler-s390-inl.h\"\n#include \"src/objects/literal-objects-inl.h\"\n    ]]></code>\n  </imports>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"BaselineAssembler::ScratchRegisterScope\",\n        \"extends\": null,\n        \"implements\": [],\n        \"about\": \"Manages the allocation and deallocation of scratch registers within a BaselineAssembler to avoid register conflicts.\",\n        \"attributes\": [\n          {\n            \"name\": \"assembler_\",\n            \"type\": \"BaselineAssembler*\",\n            \"access\": \"private\",\n            \"purpose\": \"Pointer to the BaselineAssembler instance.\"\n          },\n          {\n            \"name\": \"prev_scope_\",\n            \"type\": \"ScratchRegisterScope*\",\n            \"access\": \"private\",\n            \"purpose\": \"Pointer to the previous ScratchRegisterScope in the stack.\"\n          },\n          {\n            \"name\": \"registers_used_\",\n            \"type\": \"int\",\n            \"access\": \"private\",\n            \"purpose\": \"Keeps track of the number of scratch registers currently in use.\"\n          }\n        ],\n        \"dependencies\": [\n          \"BaselineAssembler\",\n          \"detail::kNumScratchRegisters\",\n          \"detail::kScratchRegisters\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nclass BaselineAssembler::ScratchRegisterScope {\n public:\n  explicit ScratchRegisterScope(BaselineAssembler* assembler)\n      : assembler_(assembler),\n        prev_scope_(assembler->scratch_register_scope_),\n        registers_used_(prev_scope_ == nullptr ? 0\n                                               : prev_scope_->registers_used_) {\n    assembler_->scratch_register_scope_ = this;\n  }\n  ~ScratchRegisterScope() { assembler_->scratch_register_scope_ = prev_scope_; }\n\n  Register AcquireScratch() {\n    DCHECK_LT(registers_used_, detail::kNumScratchRegisters);\n    return detail::kScratchRegisters[registers_used_++];\n  }\n\n private:\n  BaselineAssembler* assembler_;\n  ScratchRegisterScope* prev_scope_;\n  int registers_used_;\n};\n    ]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"JumpIfHelper\",\n        \"parent\": null,\n        \"about\": \"Helper function to generate conditional jump instructions based on the condition code and register comparison.\",\n        \"logic\": \"Compares two registers (lhs and rhs) based on the provided condition code (cc) and then jumps to the target label if the condition is met. Handles both signed and unsigned comparisons for 32-bit and 64-bit values.\",\n        \"parameters\": [\n          {\n            \"name\": \"assm\",\n            \"type\": \"MacroAssembler*\",\n            \"purpose\": \"Pointer to the MacroAssembler instance.\"\n          },\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition code to use for the conditional jump.\"\n          },\n          {\n            \"name\": \"lhs\",\n            \"type\": \"Register\",\n            \"purpose\": \"The left-hand side register for comparison.\"\n          },\n          {\n            \"name\": \"rhs\",\n            \"type\": \"Register\",\n            \"purpose\": \"The right-hand side register for comparison.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The target label to jump to if the condition is met.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\ntemplate <int width = 64>\nstatic void JumpIfHelper(MacroAssembler* assm, Condition cc, Register lhs,\n                         Register rhs, Label* target) {\n  static_assert(width == 64 || width == 32,\n                \"only support 64 and 32 bit compare\");\n  if (width == 64) {\n    if (is_signed(cc)) {\n      __ CmpS64(lhs, rhs);\n    } else {\n      __ CmpU64(lhs, rhs);\n    }\n  } else {\n    if (is_signed(cc)) {\n      __ CmpS32(lhs, rhs);\n    } else {\n      __ CmpU32(lhs, rhs);\n    }\n  }\n  __ b(to_condition(cc), target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"RegisterFrameOperand\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Calculates the MemOperand for accessing a register within the interpreter's register file in the current stack frame.\",\n        \"logic\": \"Calculates the offset based on the interpreter register's index and the system pointer size. Returns a MemOperand representing the memory location.\",\n        \"parameters\": [\n          {\n            \"name\": \"interpreter_register\",\n            \"type\": \"interpreter::Register\",\n            \"purpose\": \"The interpreter register to access.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"MemOperand\",\n          \"description\": \"A MemOperand representing the memory location of the register in the frame.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nMemOperand BaselineAssembler::RegisterFrameOperand(\n    interpreter::Register interpreter_register) {\n  return MemOperand(fp, interpreter_register.ToOperand() * kSystemPointerSize);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"RegisterFrameAddress\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Calculates the memory address of a register within the interpreter's register file in the current stack frame and stores it in a scratch register.\",\n        \"logic\": \"Calculates the offset based on the interpreter register's index and the system pointer size. Adds the offset to the frame pointer (fp) and stores the resulting address in the provided scratch register.\",\n        \"parameters\": [\n          {\n            \"name\": \"interpreter_register\",\n            \"type\": \"interpreter::Register\",\n            \"purpose\": \"The interpreter register to access.\"\n          },\n          {\n            \"name\": \"rscratch\",\n            \"type\": \"Register\",\n            \"purpose\": \"The scratch register to store the calculated address.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::RegisterFrameAddress(\n    interpreter::Register interpreter_register, Register rscratch) {\n  return __ AddS64(rscratch, fp,\n                   interpreter_register.ToOperand() * kSystemPointerSize);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"FeedbackVectorOperand\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Returns a MemOperand for accessing the feedback vector in the current stack frame.\",\n        \"logic\": \"Returns a MemOperand that references the feedback vector's location based on the BaselineFrameConstants::kFeedbackVectorFromFp offset from the frame pointer (fp).\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"MemOperand\",\n          \"description\": \"A MemOperand representing the memory location of the feedback vector.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackVectorOperand() {\n  return MemOperand(fp, BaselineFrameConstants::kFeedbackVectorFromFp);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"FeedbackCellOperand\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Returns a MemOperand for accessing the feedback cell in the current stack frame.\",\n        \"logic\": \"Returns a MemOperand that references the feedback cell's location based on the BaselineFrameConstants::kFeedbackCellFromFp offset from the frame pointer (fp).\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"MemOperand\",\n          \"description\": \"A MemOperand representing the memory location of the feedback cell.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackCellOperand() {\n  return MemOperand(fp, BaselineFrameConstants::kFeedbackCellFromFp);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Bind\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Binds a label to the current code position.\",\n        \"logic\": \"Calls the underlying MacroAssembler's `bind` method to associate the given label with the current instruction's address.\",\n        \"parameters\": [\n          {\n            \"name\": \"label\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The label to bind.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::Bind(Label* label) { __ bind(label); }\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpTarget\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Placeholder for a jump target, does nothing on s390.\",\n        \"logic\": \"This is essentially a no-op for the s390 architecture. It might be used for padding or alignment in other architectures.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpTarget() {\n  // NOP on arm.\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Jump\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Unconditional jump to a target label.\",\n        \"logic\": \"Emits an unconditional branch instruction to the specified target label.\",\n        \"parameters\": [\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The target label to jump to.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::Jump(Label* target, Label::Distance distance) {\n  ASM_CODE_COMMENT(masm_);\n  __ b(target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfRoot\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump if a register contains a specific root value.\",\n        \"logic\": \"Emits a conditional jump instruction that checks if the given register contains a pointer to the specified root object. Uses the underlying MacroAssembler's `JumpIfRoot` method.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register to check.\"\n          },\n          {\n            \"name\": \"index\",\n            \"type\": \"RootIndex\",\n            \"purpose\": \"The index of the root object to compare against.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The target label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfRoot(Register value, RootIndex index,\n                                   Label* target, Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  __ JumpIfRoot(value, index, target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfNotRoot\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump if a register does not contain a specific root value.\",\n        \"logic\": \"Emits a conditional jump instruction that checks if the given register does not contain a pointer to the specified root object. Uses the underlying MacroAssembler's `JumpIfNotRoot` method.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register to check.\"\n          },\n          {\n            \"name\": \"index\",\n            \"type\": \"RootIndex\",\n            \"purpose\": \"The index of the root object to compare against.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The target label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotRoot(Register value, RootIndex index,\n                                      Label* target, Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  __ JumpIfNotRoot(value, index, target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfSmi\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump if a register contains a Smi (Small Integer).\",\n        \"logic\": \"Emits a conditional jump instruction that checks if the given register contains a Smi. Uses the underlying MacroAssembler's `JumpIfSmi` method.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register to check.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The target label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Register value, Label* target,\n                                  Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  __ JumpIfSmi(value, target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfImmediate\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump if a register's value matches an immediate value.\",\n        \"logic\": \"Emits a conditional jump instruction that compares the given register's value with an immediate integer value, and jumps to target if the condition is met.\",\n        \"parameters\": [\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition to check (e.g., kEqual, kNotEqual).\"\n          },\n          {\n            \"name\": \"left\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register whose value will be compared.\"\n          },\n          {\n            \"name\": \"right\",\n            \"type\": \"int\",\n            \"purpose\": \"The immediate integer value to compare against.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,\n                                        Label* target,\n                                        Label::Distance distance) {\n  ASM_CODE_COMMENT(masm_);\n  JumpIf(cc, left, Operand(right), target, distance);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfNotSmi\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump if a register does not contain a Smi (Small Integer).\",\n        \"logic\": \"Emits a conditional jump instruction that checks if the given register does not contain a Smi. Uses the underlying MacroAssembler's `JumpIfNotSmi` method.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register to check.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The target label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotSmi(Register value, Label* target,\n                                     Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  __ JumpIfNotSmi(value, target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"TestAndBranch\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Performs a bitwise AND operation and jumps based on the result.\",\n        \"logic\": \"Performs a bitwise AND of a register's value with a mask, and then jumps to a target label if the specified condition is met (based on the flags set by the AND operation).\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register to perform the AND operation on.\"\n          },\n          {\n            \"name\": \"mask\",\n            \"type\": \"int\",\n            \"purpose\": \"The mask to use for the AND operation.\"\n          },\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition to check after the AND operation.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::TestAndBranch(Register value, int mask, Condition cc,\n                                      Label* target, Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  __ AndP(r0, value, Operand(mask));\n  __ b(to_condition(cc), target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIf\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump based on a comparison between a register and an operand.\",\n        \"logic\": \"Compares the value of a register with an operand (immediate or register) and jumps to a target label if the specified condition is met. Handles both signed and unsigned comparisons.\",\n        \"parameters\": [\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition to check (e.g., kEqual, kNotEqual, kGreaterThan).\"\n          },\n          {\n            \"name\": \"lhs\",\n            \"type\": \"Register\",\n            \"purpose\": \"The left-hand side register for comparison.\"\n          },\n          {\n            \"name\": \"rhs\",\n            \"type\": \"Operand&\",\n            \"purpose\": \"The right-hand side operand (immediate or register) for comparison.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIf(Condition cc, Register lhs, const Operand& rhs,\n                               Label* target, Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  if (is_signed(cc)) {\n    __ CmpS64(lhs, rhs);\n  } else {\n    __ CmpU64(lhs, rhs);\n  }\n  __ b(to_condition(cc), target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfObjectTypeFast\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump based on an object's instance type, using a scratch register.\",\n        \"logic\": \"Checks if an object's instance type matches the specified instance type and jumps to a target label if the condition is met. Uses a scratch register for temporary storage.\",\n        \"parameters\": [\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition to check (e.g., kEqual, kNotEqual).\"\n          },\n          {\n            \"name\": \"object\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register containing the object pointer.\"\n          },\n          {\n            \"name\": \"instance_type\",\n            \"type\": \"InstanceType\",\n            \"purpose\": \"The instance type to compare against.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"ScratchRegisterScope\",\n          \"JumpIfObjectType\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectTypeFast(Condition cc, Register object,\n                                             InstanceType instance_type,\n                                             Label* target,\n                                             Label::Distance distance) {\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  JumpIfObjectType(cc, object, instance_type, scratch, target, distance);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfObjectType\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump based on an object's instance type.\",\n        \"logic\": \"Loads the object's map, extracts the instance type from the map, and compares it with the specified instance type. Jumps to a target label if the condition is met.\",\n        \"parameters\": [\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition to check (e.g., kEqual, kNotEqual).\"\n          },\n          {\n            \"name\": \"object\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register containing the object pointer.\"\n          },\n          {\n            \"name\": \"instance_type\",\n            \"type\": \"InstanceType\",\n            \"purpose\": \"The instance type to compare against.\"\n          },\n          {\n            \"name\": \"map\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register to store the object's map.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"ScratchRegisterScope\",\n          \"JumpIf\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectType(Condition cc, Register object,\n                                         InstanceType instance_type,\n                                         Register map, Label* target,\n                                         Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  ScratchRegisterScope temps(this);\n  Register type = temps.AcquireScratch();\n  __ LoadMap(map, object);\n  __ LoadU16(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n  JumpIf(cc, type, Operand(instance_type), target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfInstanceType\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump based on the instance type from a map object.\",\n        \"logic\": \"Loads the instance type from a map object and compares it with the specified instance type. Jumps to a target label if the condition is met. Includes debug-only assertions to verify the map object.\",\n        \"parameters\": [\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition to check (e.g., kEqual, kNotEqual).\"\n          },\n          {\n            \"name\": \"map\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register containing the map object pointer.\"\n          },\n          {\n            \"name\": \"instance_type\",\n            \"type\": \"InstanceType\",\n            \"purpose\": \"The instance type to compare against.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"ScratchRegisterScope\",\n          \"JumpIf\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfInstanceType(Condition cc, Register map,\n                                           InstanceType instance_type,\n                                           Label* target, Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  ScratchRegisterScope temps(this);\n  Register type = temps.AcquireScratch();\n  if (v8_flags.debug_code) {\n    __ AssertNotSmi(map);\n    __ CompareObjectType(map, type, type, MAP_TYPE);\n    __ Assert(eq, AbortReason::kUnexpectedValue);\n  }\n  __ LoadU16(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n  JumpIf(cc, type, Operand(instance_type), target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfPointer\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump based on a comparison between a register and a memory location.\",\n        \"logic\": \"Loads a value from a memory location into a scratch register and then performs a comparison with another register, jumping to the target label if the condition is met.\",\n        \"parameters\": [\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition to check (e.g., kEqual, kNotEqual).\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"Register\",\n            \"purpose\": \"The register to compare.\"\n          },\n          {\n            \"name\": \"operand\",\n            \"type\": \"MemOperand\",\n            \"purpose\": \"The memory location to compare against.\"\n          },\n          {\n            \"name\": \"target\",\n            \"type\": \"Label*\",\n            \"purpose\": \"The label to jump to if the condition is met.\"\n          },\n          {\n            \"name\": \"distance\",\n            \"type\": \"Label::Distance\",\n            \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"ScratchRegisterScope\",\n          \"JumpIfHelper\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid BaselineAssembler::JumpIfPointer(Condition cc, Register value,\n                                      MemOperand operand, Label* target,\n                                      Label::Distance) {\n  ASM_CODE_COMMENT(masm_);\n  ScratchRegisterScope temps(this);\n  Register tmp = temps.AcquireScratch();\n  __ LoadU64(tmp, operand);\n  JumpIfHelper(masm_, cc, value, tmp, target);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"JumpIfSmi\",\n        \"parent\": \"BaselineAssembler\",\n        \"about\": \"Conditional jump if a register contains a specific Smi (Small Integer) value.\",\n        \"logic\": \"Compares the value of a register (assumed to hold a Smi) with a given Smi literal. Jumps to the target if the specified condition is met.\",\n        \"parameters\": [\n          {\n            \"name\": \"cc\",\n            \"type\": \"Condition\",\n            \"purpose\": \"The condition to check (e.g"
}