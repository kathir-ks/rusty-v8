{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/declaration-visitor.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 41, column 51",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/declaration-visitor.cc\",\n            \"file_name\": \"declaration-visitor.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the DeclarationVisitor and PredeclarationVisitor classes for processing Torque AST nodes related to declarations.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for declaration visiting, AST node manipulation, Kythe data collection, server data management, type inference, and type visiting.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/declaration-visitor.h\"\n\n#include <optional>\n\n#include \"src/torque/ast.h\"\n#include \"src/torque/kythe-data.h\"\n#include \"src/torque/server-data.h\"\n#include \"src/torque/type-inference.h\"\n#include \"src/torque/type-visitor.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetOrCreateNamespace\",\n                \"parent\": null,\n                \"about\": \"Retrieves an existing namespace or creates a new one if it doesn't exist.\",\n                \"logic\": \"First, it tries to find the namespace using TryLookupShallow. If it exists, it returns the existing namespace. If not, it declares a new namespace using DeclareNamespace and returns it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The name of the namespace to retrieve or create.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Namespace*\",\n                    \"description\": \"A pointer to the existing or newly created Namespace object.\"\n                },\n                \"dependencies\": [\n                    \"FilterDeclarables\",\n                    \"Declarations::TryLookupShallow\",\n                    \"Declarations::DeclareNamespace\",\n                    \"Namespace\",\n                    \"QualifiedName\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNamespace* GetOrCreateNamespace(const std::string& name) {\n  std::vector<Namespace*> existing_namespaces = FilterDeclarables<Namespace>(\n      Declarations::TryLookupShallow(QualifiedName(name)));\n  if (existing_namespaces.empty()) {\n    return Declarations::DeclareNamespace(name);\n  }\n  DCHECK_EQ(1, existing_namespaces.size());\n  return existing_namespaces.front();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PredeclarationVisitor\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Visits declaration nodes to perform predeclaration, mainly for namespaces and generic types/callables.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Declaration\",\n                    \"NamespaceDeclaration\",\n                    \"GenericCallableDeclaration\",\n                    \"GenericTypeDeclaration\",\n                    \"CurrentSourcePosition\",\n                    \"AstNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid PredeclarationVisitor::Predeclare(Declaration* decl) {\n  CurrentSourcePosition::Scope scope(decl->pos);\n  switch (decl->kind) {\n#define ENUM_ITEM(name)        \\\n  case AstNode::Kind::k##name: \\\n    return Predeclare(name::cast(decl));\n    AST_TYPE_DECLARATION_NODE_KIND_LIST(ENUM_ITEM)\n#undef ENUM_ITEM\n    case AstNode::Kind::kNamespaceDeclaration:\n      return Predeclare(NamespaceDeclaration::cast(decl));\n    case AstNode::Kind::kGenericCallableDeclaration:\n      return Predeclare(GenericCallableDeclaration::cast(decl));\n    case AstNode::Kind::kGenericTypeDeclaration:\n      return Predeclare(GenericTypeDeclaration::cast(decl));\n\n    default:\n      // Only processes type declaration nodes, namespaces and generics.\n      break;\n  }\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DeclarationVisitor\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Visits declaration nodes to process them and create corresponding Torque objects.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Declaration\",\n                    \"BuiltinDeclaration\",\n                    \"ExternalBuiltinDeclaration\",\n                    \"ExternalRuntimeDeclaration\",\n                    \"ExternalMacroDeclaration\",\n                    \"TorqueBuiltinDeclaration\",\n                    \"TorqueMacroDeclaration\",\n                    \"IntrinsicDeclaration\",\n                    \"ConstDeclaration\",\n                    \"SpecializationDeclaration\",\n                    \"ExternConstDeclaration\",\n                    \"CppIncludeDeclaration\",\n                    \"TypeVisitor\",\n                    \"Builtin\",\n                    \"Signature\",\n                    \"Statement\",\n                    \"std::optional\",\n                    \"TypeOracle\",\n                    \"RuntimeFunction\",\n                    \"Macro\",\n                    \"Const\",\n                    \"ExternConstant\",\n                    \"SpecializationKey\",\n                    \"Callable\",\n                    \"Namespace\",\n                    \"TypeAlias\",\n                    \"CallableDeclaration\",\n                    \"IntrinsicDeclaration\",\n                    \"MacroDeclaration\",\n                    \"CurrentSourcePosition\",\n                    \"CurrentScope\",\n                    \"GlobalContext\",\n                    \"KytheData\",\n                    \"LanguageServerData\",\n                    \"Error\",\n                    \"ReportError\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid DeclarationVisitor::Visit(Declaration* decl) {\n  CurrentSourcePosition::Scope scope(decl->pos);\n  switch (decl->kind) {\n#define ENUM_ITEM(name)        \\\n  case AstNode::Kind::k##name: \\\n    return Visit(name::cast(decl));\n    AST_DECLARATION_NODE_KIND_LIST(ENUM_ITEM)\n#undef ENUM_ITEM\n    default:\n      UNIMPLEMENTED();\n  }\n}\n\nBuiltin* DeclarationVisitor::CreateBuiltin(\n    BuiltinDeclaration* decl, std::string external_name,\n    std::string readable_name, Signature signature,\n    std::optional<std::string> use_counter_name,\n    std::optional<Statement*> body) {\n  const bool javascript = decl->javascript_linkage;\n  const bool varargs = decl->parameters.has_varargs;\n  Builtin::Kind kind = !javascript ? Builtin::kStub\n                                   : varargs ? Builtin::kVarArgsJavaScript\n                                             : Builtin::kFixedArgsJavaScript;\n  bool has_custom_interface_descriptor = false;\n  if (decl->kind == AstNode::Kind::kTorqueBuiltinDeclaration) {\n    has_custom_interface_descriptor =\n        static_cast<TorqueBuiltinDeclaration*>(decl)\n            ->has_custom_interface_descriptor;\n  }\n\n  if (varargs && !javascript) {\n    Error(\"Rest parameters require \", decl->name,\n          \" to be a JavaScript builtin\");\n  }\n\n  if (javascript) {\n    if (!signature.return_type->IsSubtypeOf(TypeOracle::GetJSAnyType())) {\n      Error(\"Return type of JavaScript-linkage builtins has to be JSAny.\")\n          .Position(decl->return_type->pos);\n    }\n    // Validate the parameter types. In general, for JS builtins the parameters\n    // must all be tagged values (JSAny). However, we currently allow declaring\n    // \"extern javascript\" builtins with any parameter types. The reason is\n    // that those are typically used for tailcalls, in which case we typically\n    // need to supply the implicit parameters of the JS calling convention\n    // (target, receiver, argc, etc.). It would probablu be nicer if we could\n    // instead declare these parameters as js-implicit (like we do for\n    // torque-defined javascript builtins) and then allow explicitly supplying\n    // the implicit arguments during tailscalls. It's unclear though if that's\n    // worth the effort. In particular, calls and tailcalls to javascript\n    // builtins will emit CSA::CallJSBuiltin and CSA::TailCallJSBuiltin calls\n    // which will validate the parameter types at C++ compile time.\n    if (decl->kind != AstNode::Kind::kExternalBuiltinDeclaration) {\n      for (size_t i = signature.implicit_count;\n           i < signature.parameter_types.types.size(); ++i) {\n        const Type* parameter_type = signature.parameter_types.types[i];\n        if (!TypeOracle::GetJSAnyType()->IsSubtypeOf(parameter_type)) {\n          Error(\n              \"Parameters of JavaScript-linkage builtins have to be a \"\n              \"supertype \"\n              \"of JSAny.\")\n              .Position(decl->parameters.types[i]->pos);\n        }\n      }\n    }\n  }\n\n  for (size_t i = 0; i < signature.types().size(); ++i) {\n    const Type* parameter_type = signature.types()[i];\n    if (parameter_type->StructSupertype()) {\n      Error(\"Builtin do not support structs as arguments, but argument \",\n            signature.parameter_names[i], \" has type \", *signature.types()[i],\n            \".\");\n    }\n    if (parameter_type->IsFloat32() || parameter_type->IsFloat64()) {\n      if (!has_custom_interface_descriptor) {\n        Error(\"Builtin \", external_name,\n              \" needs a custom interface descriptor, \"\n              \"because it uses type \",\n              *parameter_type, \" for argument \", signature.parameter_names[i],\n              \". One reason being \"\n              \"that the default descriptor defines xmm0 to be the first \"\n              \"floating point argument register, which is current used as \"\n              \"scratch on ia32 and cannot be allocated.\");\n      }\n    }\n  }\n\n  if (signature.return_type->StructSupertype() && javascript) {\n    Error(\n        \"Builtins with JS linkage cannot return structs, but the return type \"\n        \"is \",\n        *signature.return_type, \".\");\n  }\n\n  if (signature.return_type == TypeOracle::GetVoidType()) {\n    Error(\"Builtins cannot have return type void.\");\n  }\n\n  Builtin::Flags flags = Builtin::Flag::kNone;\n  if (has_custom_interface_descriptor)\n    flags |= Builtin::Flag::kCustomInterfaceDescriptor;\n  Builtin* builtin = Declarations::CreateBuiltin(\n      std::move(external_name), std::move(readable_name), kind, flags,\n      std::move(signature), std::move(use_counter_name), body);\n  // TODO(v8:12261): Recheck this.\n  // builtin->SetIdentifierPosition(decl->name->pos);\n  return builtin;\n}\n\nvoid DeclarationVisitor::Visit(ExternalBuiltinDeclaration* decl) {\n  Builtin* builtin = CreateBuiltin(decl, decl->name->value, decl->name->value,\n                                   TypeVisitor::MakeSignature(decl),\n                                   std::nullopt, std::nullopt);\n  builtin->SetIdentifierPosition(decl->name->pos);\n  Declarations::Declare(decl->name->value, builtin);\n}\n\nvoid DeclarationVisitor::Visit(ExternalRuntimeDeclaration* decl) {\n  Signature signature = TypeVisitor::MakeSignature(decl);\n  if (signature.parameter_types.types.empty()) {\n    ReportError(\n        \"Missing parameters for runtime function, at least the context \"\n        \"parameter is required.\");\n  }\n  if (!(signature.parameter_types.types[0] == TypeOracle::GetContextType() ||\n        signature.parameter_types.types[0] == TypeOracle::GetNoContextType())) {\n    ReportError(\n        \"first parameter to runtime functions has to be the context and have \"\n        \"type Context or NoContext, but found type \",\n        *signature.parameter_types.types[0]);\n  }\n  if (!(signature.return_type->IsSubtypeOf(TypeOracle::GetStrongTaggedType()) ||\n        signature.return_type == TypeOracle::GetVoidType() ||\n        signature.return_type == TypeOracle::GetNeverType())) {\n    ReportError(\n        \"runtime functions can only return strong tagged values, but \"\n        \"found type \",\n        *signature.return_type);\n  }\n  for (const Type* parameter_type : signature.parameter_types.types) {\n    if (!parameter_type->IsSubtypeOf(TypeOracle::GetStrongTaggedType())) {\n      ReportError(\n          \"runtime functions can only take strong tagged parameters, but \"\n          \"found type \",\n          *parameter_type);\n    }\n  }\n\n  RuntimeFunction* function =\n      Declarations::DeclareRuntimeFunction(decl->name->value, signature);\n  function->SetIdentifierPosition(decl->name->pos);\n  function->SetPosition(decl->pos);\n  if (GlobalContext::collect_kythe_data()) {\n    KytheData::AddFunctionDefinition(function);\n  }\n}\n\nvoid DeclarationVisitor::Visit(ExternalMacroDeclaration* decl) {\n  Macro* macro = Declarations::DeclareMacro(\n      decl->name->value, true, decl->external_assembler_name,\n      TypeVisitor::MakeSignature(decl), std::nullopt, decl->op);\n  macro->SetIdentifierPosition(decl->name->pos);\n  macro->SetPosition(decl->pos);\n  if (GlobalContext::collect_kythe_data()) {\n    KytheData::AddFunctionDefinition(macro);\n  }\n}\n\nvoid DeclarationVisitor::Visit(TorqueBuiltinDeclaration* decl) {\n  Signature signature = TypeVisitor::MakeSignature(decl);\n  if (decl->use_counter_name &&\n      (signature.types().empty() ||\n       (signature.types()[0] != TypeOracle::GetNativeContextType() &&\n        signature.types()[0] != TypeOracle::GetContextType()))) {\n    ReportError(\n        \"@incrementUseCounter requires the builtin's first parameter to be of \"\n        \"type Context or NativeContext, but found type \",\n        *signature.types()[0]);\n  }\n  auto builtin = CreateBuiltin(decl, decl->name->value, decl->name->value,\n                               signature, decl->use_counter_name, decl->body);\n  builtin->SetIdentifierPosition(decl->name->pos);\n  builtin->SetPosition(decl->pos);\n  Declarations::Declare(decl->name->value, builtin);\n}\n\nvoid DeclarationVisitor::Visit(TorqueMacroDeclaration* decl) {\n  Macro* macro = Declarations::DeclareMacro(\n      decl->name->value, decl->export_to_csa, std::nullopt,\n      TypeVisitor::MakeSignature(decl), decl->body, decl->op);\n  macro->SetIdentifierPosition(decl->name->pos);\n  macro->SetPosition(decl->pos);\n  if (GlobalContext::collect_kythe_data()) {\n    KytheData::AddFunctionDefinition(macro);\n  }\n}\n\nvoid DeclarationVisitor::Visit(IntrinsicDeclaration* decl) {\n  Declarations::DeclareIntrinsic(decl->name->value,\n                                 TypeVisitor::MakeSignature(decl));\n}\n\nvoid DeclarationVisitor::Visit(ConstDeclaration* decl) {\n  auto constant = Declarations::DeclareNamespaceConstant(\n      decl->name, TypeVisitor::ComputeType(decl->type), decl->expression);\n  if (GlobalContext::collect_kythe_data()) {\n    KytheData::AddConstantDefinition(constant);\n  }\n}\n\nvoid DeclarationVisitor::Visit(SpecializationDeclaration* decl) {\n  std::vector<GenericCallable*> generic_list =\n      Declarations::LookupGeneric(decl->name->value);\n  // Find the matching generic specialization based on the concrete parameter\n  // list.\n  GenericCallable* matching_generic = nullptr;\n  Signature signature_with_types = TypeVisitor::MakeSignature(decl);\n  for (GenericCallable* generic : generic_list) {\n    // This argument inference is just to trigger constraint checking on the\n    // generic arguments.\n    TypeArgumentInference inference = generic->InferSpecializationTypes(\n        TypeVisitor::ComputeTypeVector(decl->generic_parameters), {});\n    if (inference.HasFailed()) {\n      continue;\n    }\n    Signature generic_signature_with_types =\n        MakeSpecializedSignature(SpecializationKey<GenericCallable>{\n            generic, TypeVisitor::ComputeTypeVector(decl->generic_parameters)});\n    if (signature_with_types.HasSameTypesAs(generic_signature_with_types,\n                                            ParameterMode::kIgnoreImplicit)) {\n      if (matching_generic != nullptr) {\n        std::stringstream stream;\n        stream << \"specialization of \" << decl->name\n               << \" is ambigous, it matches more than one generic declaration (\"\n               << *matching_generic << \" and \" << *generic << \")\";\n        ReportError(stream.str());\n      }\n      matching_generic = generic;\n    }\n  }\n\n  if (matching_generic == nullptr) {\n    std::stringstream stream;\n    if (generic_list.empty()) {\n      stream << \"no generic defined with the name \" << decl->name;\n      ReportError(stream.str());\n    }\n    stream << \"specialization of \" << decl->name\n           << \" doesn't match any generic declaration\\n\";\n    stream << \"specialization signature:\";\n    stream << \"\\n  \" << signature_with_types;\n    stream << \"\\ncandidates are:\";\n    for (GenericCallable* generic : generic_list) {\n      stream << \"\\n  \"\n             << MakeSpecializedSignature(SpecializationKey<GenericCallable>{\n                    generic,\n                    TypeVisitor::ComputeTypeVector(decl->generic_parameters)});\n    }\n    ReportError(stream.str());\n  }\n\n  if (GlobalContext::collect_language_server_data()) {\n    LanguageServerData::AddDefinition(decl->name->pos,\n                                      matching_generic->IdentifierPosition());\n  }\n\n  CallableDeclaration* generic_declaration = matching_generic->declaration();\n\n  Specialize(SpecializationKey<GenericCallable>{matching_generic,\n                                                TypeVisitor::ComputeTypeVector(\n                                                    decl->generic_parameters)},\n             generic_declaration, decl, decl->body, decl->pos);\n}\n\nvoid DeclarationVisitor::Visit(ExternConstDeclaration* decl) {\n  const Type* type = TypeVisitor::ComputeType(decl->type);\n  if (!type->IsConstexpr()) {\n    std::stringstream stream;\n    stream << \"extern constants must have constexpr type, but found: \\\"\"\n           << *type << \"\\\"\\n\";\n    ReportError(stream.str());\n  }\n\n  ExternConstant* constant =\n      Declarations::DeclareExternConstant(decl->name, type, decl->literal);\n  if (GlobalContext::collect_kythe_data()) {\n    KytheData::AddConstantDefinition(constant);\n  }\n}\n\nvoid DeclarationVisitor::Visit(CppIncludeDeclaration* decl) {\n  GlobalContext::AddCppInclude(decl->include_path);\n}\n\nvoid DeclarationVisitor::DeclareSpecializedTypes(\n    const SpecializationKey<GenericCallable>& key) {\n  size_t i = 0;\n  const std::size_t generic_parameter_count =\n      key.generic->generic_parameters().size();\n  if (generic_parameter_count != key.specialized_types.size()) {\n    std::stringstream stream;\n    stream << \"Wrong generic argument count for specialization of \\\"\"\n           << key.generic->name() << \"\\\", expected: \" << generic_parameter_count\n           << \", actual: \" << key.specialized_types.size();\n    ReportError(stream.str());\n  }\n\n  for (auto type : key.specialized_types) {\n    Identifier* generic_type_name = key.generic->generic_parameters()[i++].name;\n    TypeAlias* alias = Declarations::DeclareType(generic_type_name, type);\n    alias->SetIsUserDefined(false);\n  }\n}\n\nSignature DeclarationVisitor::MakeSpecializedSignature(\n    const SpecializationKey<GenericCallable>& key) {\n  CurrentScope::Scope generic_scope(key.generic->ParentScope());\n  // Create a temporary fake-namespace just to temporarily declare the\n  // specialization aliases for the generic types to create a signature.\n  Namespace tmp_namespace(\"_tmp\");\n  CurrentScope::Scope tmp_namespace_scope(&tmp_namespace);\n  DeclareSpecializedTypes(key);\n  return TypeVisitor::MakeSignature(key.generic->declaration());\n}\n\nCallable* DeclarationVisitor::SpecializeImplicit(\n    const SpecializationKey<GenericCallable>& key) {\n  std::optional<Statement*> body = key.generic->CallableBody();\n  if (!body && IntrinsicDeclaration::DynamicCast(key.generic->declaration()) ==\n                   nullptr) {\n    ReportError(\"missing specialization of \", key.generic->name(),\n                \" with types <\", key.specialized_types, \"> declared at \",\n                key.generic->Position());\n  }\n  SpecializationRequester requester{CurrentSourcePosition::Get(),\n                                    CurrentScope::Get(), \"\"};\n  CurrentScope::Scope generic_scope(key.generic->ParentScope());\n  Callable* result = Specialize(key, key.generic->declaration(), std::nullopt,\n                                body, CurrentSourcePosition::Get());\n  result->SetIsUserDefined(false);\n  requester.name = result->ReadableName();\n  result->SetSpecializationRequester(requester);\n  CurrentScope::Scope callable_scope(result);\n  DeclareSpecializedTypes(key);\n  return result;\n}\n\nCallable* DeclarationVisitor::Specialize(\n    const SpecializationKey<GenericCallable>& key,\n    CallableDeclaration* declaration,\n    std::optional<const SpecializationDeclaration*> explicit_specialization,\n    std::optional<Statement*> body, SourcePosition position) {\n  CurrentSourcePosition::Scope pos_scope(position);\n  size_t generic_parameter_count = key.generic->generic_parameters().size();\n  if (generic_parameter_count != key.specialized_types.size()) {\n    std::stringstream stream;\n    stream << \"number of template parameters (\"\n           << std::to_string(key.specialized_types.size())\n           << \") to intantiation of generic \" << declaration->name\n           << \" doesnt match the generic's declaration (\"\n           << std::to_string(generic_parameter_count) << \")\";\n    ReportError(stream.str());\n  }\n  if (key.generic->GetSpecialization(key.specialized_types)) {\n    ReportError(\"cannot redeclare specialization of \", key.generic->name(),\n                \" with types <\", key.specialized_types, \">\");\n  }\n\n  Signature type_signature =\n      explicit_specialization\n          ? TypeVisitor::MakeSignature(*explicit_specialization)\n          : MakeSpecializedSignature(key);\n\n  std::string generated_name = Declarations::GetGeneratedCallableName(\n      declaration->name->value, key.specialized_types);\n  std::stringstream readable_name;\n  readable_name << declaration->name->value << \"<\";\n  bool first = true;\n  for (const Type* t : key.specialized_types) {\n    if (!first) readable_name << \", \";\n    readable_name << *t;\n    first = false;\n  }\n  readable_name << \">\";\n  Callable* callable;\n  if (MacroDeclaration::DynamicCast(declaration) != nullptr) {\n    callable =\n        Declarations::CreateTorqueMacro(generated_name, readable_name.str(),\n                                        false, type_signature, *body, true);\n  } else if (IntrinsicDeclaration::DynamicCast(declaration) != nullptr) {\n    callable =\n        Declarations::CreateIntrinsic(declaration->name->value, type_signature);\n  } else {\n    BuiltinDeclaration* builtin = BuiltinDeclaration::cast(declaration);\n    std::optional<std::string> use_counter_name;\n    if (TorqueBuiltinDeclaration* torque_builtin =\n            TorqueBuiltinDeclaration::DynamicCast(builtin)) {\n      use_counter_name = torque_builtin->use_counter_name;\n    } else {\n      use_counter_name = std::nullopt;\n    }\n    callable = CreateBuiltin(\n        builtin, GlobalContext::MakeUniqueName(generated_name),\n        readable_name.str(), type_signature, use_counter_name, *body);\n  }\n  key.generic->AddSpecialization(key.specialized_types, callable);\n  return callable;\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ResolvePredeclarations\",\n                \"parent\": \"PredeclarationVisitor\",\n                \"about\": \"Resolves predeclarations, specifically for type aliases.\",\n                \"logic\": \"Iterates through all declarables, checks if a declarable is a TypeAlias, and if so, calls its Resolve() method within the appropriate scope and source position.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"GlobalContext::AllDeclarables\",\n                    \"TypeAlias::DynamicCast\",\n                    \"CurrentScope::Scope\",\n                    \"CurrentSourcePosition::Scope\",\n                    \"TypeAlias::Resolve\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid PredeclarationVisitor::ResolvePredeclarations() {\n  const auto& all_declarables = GlobalContext::AllDeclarables();\n  for (size_t i = 0; i < all_declarables.size(); ++i) {\n    Declarable* declarable = all_declarables[i].get();\n    if (const TypeAlias* alias = TypeAlias::DynamicCast(declarable)) {\n      CurrentScope::Scope scope_activator(alias->ParentScope());\n      CurrentSourcePosition::Scope position_activator(alias->Position());\n      alias->Resolve();\n    }\n  }\n}\n        ]]></code>\n    </func>\n</file>\n```"
}