{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/memory-lowering.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/memory-lowering.cc\",\n            \"file_name\": \"memory-lowering.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements memory lowering optimizations for the V8 compiler, including allocation folding and write barrier elimination.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for compiler, codegen, and memory management functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/memory-lowering.h\"\n\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/roots/roots-inl.h\"\n#include \"src/sandbox/external-pointer-inl.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-objects.h\"\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Represents a set of allocations that have been folded together for optimization.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"node_ids_\",\n                        \"type\": \"ZoneSet<NodeId>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the IDs of nodes belonging to this allocation group.\"\n                    },\n                    {\n                        \"name\": \"allocation_\",\n                        \"type\": \"AllocationType\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates the allocation type (e.g., young or old generation).\"\n                    },\n                    {\n                        \"name\": \"size_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the total allocated size of the group. It's a Node in the graph.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass MemoryLowering::AllocationGroup final : public ZoneObject {\n public:\n  AllocationGroup(Node* node, AllocationType allocation, Zone* zone);\n  AllocationGroup(Node* node, AllocationType allocation, Node* size,\n                  Zone* zone);\n  ~AllocationGroup() = default;\n\n  void Add(Node* object);\n  bool Contains(Node* object) const;\n  bool IsYoungGenerationAllocation() const {\n    return allocation() == AllocationType::kYoung;\n  }\n\n  AllocationType allocation() const { return allocation_; }\n  Node* size() const { return size_; }\n\n private:\n  ZoneSet<NodeId> node_ids_;\n  AllocationType const allocation_;\n  Node* const size_;\n\n  static inline AllocationType CheckAllocationType(AllocationType allocation) {\n    // For non-generational heap, all young allocations are redirected to old\n    // space.\n    if (v8_flags.single_generation && allocation == AllocationType::kYoung) {\n      return AllocationType::kOld;\n    }\n    return allocation;\n  }\n\n  DISALLOW_IMPLICIT_CONSTRUCTORS(AllocationGroup);\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationGroup::AllocationGroup\",\n                \"parent\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Constructor for AllocationGroup that takes a node and an allocation type.\",\n                \"logic\": \"Initializes the node_ids_ set with the provided node's ID and sets the allocation type, potentially adjusting it based on single-generation flags.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The initial node to include in the allocation group.\"\n                    },\n                    {\n                        \"name\": \"allocation\",\n                        \"type\": \"AllocationType\",\n                        \"purpose\": \"The type of allocation (e.g., young or old generation).\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to use for allocating the ZoneSet.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"Constructor, so no return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nAllocationGroup::AllocationGroup(Node* node, AllocationType allocation, Zone* zone)\n    : node_ids_(zone),\n      allocation_(CheckAllocationType(allocation)),\n      size_(nullptr) {\n  node_ids_.insert(node->id());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationGroup::AllocationGroup\",\n                \"parent\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Constructor for AllocationGroup that takes a node, an allocation type, and a size node.\",\n                \"logic\": \"Initializes the node_ids_ set with the provided node's ID, sets the allocation type, potentially adjusting it based on single-generation flags and stores the size node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The initial node to include in the allocation group.\"\n                    },\n                    {\n                        \"name\": \"allocation\",\n                        \"type\": \"AllocationType\",\n                        \"purpose\": \"The type of allocation (e.g., young or old generation).\"\n                    },\n                    {\n                        \"name\": \"size\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"Node representing the size of the allocation.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to use for allocating the ZoneSet.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"Constructor, so no return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nAllocationGroup::AllocationGroup(Node* node, AllocationType allocation, Node* size,\n                  Zone* zone)\n    : node_ids_(zone),\n      allocation_(CheckAllocationType(allocation)),\n      size_(size) {\n  node_ids_.insert(node->id());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationGroup::Add\",\n                \"parent\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Adds a node to the allocation group.\",\n                \"logic\": \"Inserts the node's ID into the node_ids_ set.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to add to the allocation group.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AllocationGroup::Add(Node* object) {\n  node_ids_.insert(object->id());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationGroup::Contains\",\n                \"parent\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Checks if a node belongs to this allocation group.\",\n                \"logic\": \"Traverses the chain of value inputs for nodes like BitcastTaggedToWord, BitcastWordToTagged, Int32Add, and Int64Add until it finds a node ID present in the node_ids_ set, or returns false.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check for membership.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the node belongs to the group, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool AllocationGroup::Contains(Node* node) const {\n  // Additions should stay within the same allocated object, so it's safe to\n  // ignore them.\n  while (node_ids_.find(node->id()) == node_ids_.end()) {\n    switch (node->opcode()) {\n      case IrOpcode::kBitcastTaggedToWord:\n      case IrOpcode::kBitcastWordToTagged:\n      case IrOpcode::kInt32Add:\n      case IrOpcode::kInt64Add:\n        node = NodeProperties::GetValueInput(node, 0);\n        break;\n      default:\n        return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationGroup::IsYoungGenerationAllocation\",\n                \"parent\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Determines if the allocation group represents a young generation allocation.\",\n                \"logic\": \"Returns true if the allocation type is kYoung.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if it's a young generation allocation, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool AllocationGroup::IsYoungGenerationAllocation() const {\n    return allocation() == AllocationType::kYoung;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationGroup::allocation\",\n                \"parent\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Getter for the allocation type.\",\n                \"logic\": \"Returns the allocation_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"AllocationType\",\n                    \"description\": \"The allocation type.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nAllocationType AllocationGroup::allocation() const { return allocation_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationGroup::size\",\n                \"parent\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Getter for the size node.\",\n                \"logic\": \"Returns the size_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The size node.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nNode* AllocationGroup::size() const { return size_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationGroup::CheckAllocationType\",\n                \"parent\": \"MemoryLowering::AllocationGroup\",\n                \"about\": \"Adjusts the allocation type based on the single-generation flag.\",\n                \"logic\": \"If the single_generation flag is enabled, all young allocations are redirected to old space. Otherwise, the allocation type is returned as is.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"allocation\",\n                        \"type\": \"AllocationType\",\n                        \"purpose\": \"The original allocation type.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"AllocationType\",\n                    \"description\": \"The adjusted allocation type.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstatic inline AllocationType AllocationGroup::CheckAllocationType(AllocationType allocation) {\n    // For non-generational heap, all young allocations are redirected to old\n    // space.\n    if (v8_flags.single_generation && allocation == AllocationType::kYoung) {\n      return AllocationType::kOld;\n    }\n    return allocation;\n  }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemoryLowering\",\n                \"about\": \"Implements memory lowering optimizations within the V8 compiler.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating compiler data structures.\"\n                    },\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"Graph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The compiler's graph representation.\"\n                    },\n                    {\n                        \"name\": \"common_\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Helper for creating common operators.\"\n                    },\n                    {\n                        \"name\": \"machine_\",\n                        \"type\": \"MachineOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Helper for creating machine-specific operators.\"\n                    },\n                    {\n                        \"name\": \"graph_assembler_\",\n                        \"type\": \"JSGraphAssembler*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Assembler for constructing the graph.\"\n                    },\n                    {\n                        \"name\": \"is_wasm_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if the compilation target is WebAssembly.\"\n                    },\n                    {\n                        \"name\": \"allocation_folding_\",\n                        \"type\": \"AllocationFolding\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Specifies whether allocation folding is enabled.\"\n                    },\n                    {\n                        \"name\": \"write_barrier_assert_failed_\",\n                        \"type\": \"WriteBarrierAssertFailedCallback\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Callback function for assertion failures related to write barriers.\"\n                    },\n                    {\n                        \"name\": \"function_debug_name_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The name of the function being compiled (for debugging).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"JSGraph\",\n                    \"Zone\",\n                    \"JSGraphAssembler\",\n                    \"AllocationFolding\",\n                    \"WriteBarrierAssertFailedCallback\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass MemoryLowering {\n public:\n  MemoryLowering(JSGraph* jsgraph, Zone* zone,\n                               JSGraphAssembler* graph_assembler, bool is_wasm,\n                               AllocationFolding allocation_folding,\n                               WriteBarrierAssertFailedCallback callback,\n                               const char* function_debug_name);\n\n  Zone* graph_zone() const;\n\n  Reduction Reduce(Node* node);\n\n private:\n  Isolate* isolate_;\n  Zone* zone_;\n  Graph* graph_;\n  CommonOperatorBuilder* common_;\n  MachineOperatorBuilder* machine_;\n  JSGraphAssembler* graph_assembler_;\n  bool is_wasm_;\n  AllocationFolding allocation_folding_;\n  WriteBarrierAssertFailedCallback write_barrier_assert_failed_;\n  const char* function_debug_name_;\n\n  Zone* graph_zone() const { return graph()->zone(); }\n\n  Reduction Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kAllocate:\n      // Allocate nodes were purged from the graph in effect-control\n      // linearization.\n      UNREACHABLE();\n    case IrOpcode::kAllocateRaw:\n      return ReduceAllocateRaw(node);\n    case IrOpcode::kLoadFromObject:\n    case IrOpcode::kLoadImmutableFromObject:\n      return ReduceLoadFromObject(node);\n    case IrOpcode::kLoadElement:\n      return ReduceLoadElement(node);\n    case IrOpcode::kLoadField:\n      return ReduceLoadField(node);\n    case IrOpcode::kStoreToObject:\n    case IrOpcode::kInitializeImmutableInObject:\n      return ReduceStoreToObject(node);\n    case IrOpcode::kStoreElement:\n      return ReduceStoreElement(node);\n    case IrOpcode::kStoreField:\n      return ReduceStoreField(node);\n    case IrOpcode::kStore:\n      return ReduceStore(node);\n    default:\n      return NoChange();\n  }\n}\n\n  void EnsureAllocateOperator();\n\n#if V8_ENABLE_WEBASSEMBLY\n  Node* GetWasmInstanceNode();\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n#define __ gasm()->\n\n  Node* AlignToAllocationAlignment(Node* value);\n\n  Reduction ReduceAllocateRaw(Node* node,\n                                            AllocationType allocation_type,\n                                            AllocationState const** state_ptr = nullptr);\n\n  Reduction ReduceLoadFromObject(Node* node);\n\n  Reduction ReduceLoadElement(Node* node);\n\n  Reduction ReduceLoadExternalPointerField(Node* node);\n\n  Reduction ReduceLoadBoundedSize(Node* node);\n\n  Reduction ReduceLoadMap(Node* node);\n\n  Reduction ReduceLoadField(Node* node);\n\n  Reduction ReduceStoreToObject(Node* node,\n                                              AllocationState const* state = nullptr);\n\n  Reduction ReduceStoreElement(Node* node,\n                                             AllocationState const* state = nullptr);\n\n  Reduction ReduceStoreField(Node* node,\n                                           AllocationState const* state = nullptr);\n\n  Reduction ReduceStore(Node* node,\n                                      AllocationState const* state = nullptr);\n\n  Node* ComputeIndex(ElementAccess const& access, Node* index);\n\n#undef __\n\n  Reduction ReduceAllocateRaw(Node* node);\n\n  WriteBarrierKind ComputeWriteBarrierKind(\n    Node* node, Node* object, Node* value, AllocationState const* state,\n    WriteBarrierKind write_barrier_kind);\n\n  class AllocationGroup final;\n\n  class AllocationState final {\n   public:\n    AllocationState();\n    AllocationState(AllocationGroup* group, Node* effect);\n    AllocationState(AllocationGroup* group, intptr_t size, Node* top,\n                    Node* effect);\n\n    AllocationGroup* group() const { return group_; }\n    intptr_t size() const { return size_; }\n    Node* top() const { return top_; }\n    Node* effect() const { return effect_; }\n\n    bool IsYoungGenerationAllocation() const;\n\n    static AllocationState Open(AllocationGroup* group, intptr_t size, Node* top,\n                                Node* effect, Zone* zone) {\n      return AllocationState(group, size, top, effect);\n    }\n    static AllocationState Closed(AllocationGroup* group, Node* effect,\n                                  Zone* zone) {\n      return AllocationState(group, effect);\n    }\n\n   private:\n    AllocationGroup* const group_;\n    intptr_t const size_;\n    Node* const top_;\n    Node* const effect_;\n  };\n\n  ZoneUnique<Operator> allocate_operator_;\n#if V8_ENABLE_WEBASSEMBLY\n  ZoneUnique<Node> wasm_instance_node_;\n#endif\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MemoryLowering::MemoryLowering\",\n                \"parent\": \"MemoryLowering\",\n                \"about\": \"Constructor for the MemoryLowering class.\",\n                \"logic\": \"Initializes the member variables with the provided arguments.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"jsgraph\",\n                        \"type\": \"JSGraph*\",\n                        \"purpose\": \"The JSGraph instance.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone.\"\n                    },\n                    {\n                        \"name\": \"graph_assembler\",\n                        \"type\": \"JSGraphAssembler*\",\n                        \"purpose\": \"The JSGraphAssembler instance.\"\n                    },\n                    {\n                        \"name\": \"is_wasm\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the target is WebAssembly.\"\n                    },\n                    {\n                        \"name\": \"allocation_folding\",\n                        \"type\": \"AllocationFolding\",\n                        \"purpose\": \"Specifies the allocation folding strategy.\"\n                    },\n                    {\n                        \"name\": \"callback\",\n                        \"type\": \"WriteBarrierAssertFailedCallback\",\n                        \"purpose\": \"The callback for write barrier assertion failures.\"\n                    },\n                    {\n                        \"name\": \"function_debug_name\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The debug name of the function being compiled.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"Constructor, so no return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nMemoryLowering::MemoryLowering(JSGraph* jsgraph, Zone* zone,\n                               JSGraphAssembler* graph_assembler, bool is_wasm,\n                               AllocationFolding allocation_folding,\n                               WriteBarrierAssertFailedCallback callback,\n                               const char* function_debug_name)\n    : isolate_(jsgraph->isolate()),\n      zone_(zone),\n      graph_(jsgraph->graph()),\n      common_(jsgraph->common()),\n      machine_(jsgraph->machine()),\n      graph_assembler_(graph_assembler),\n      is_wasm_(is_wasm),\n      allocation_folding_(allocation_folding),\n      write_barrier_assert_failed_(callback),\n      function_debug_name_(function_debug_name) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MemoryLowering::EnsureAllocateOperator\",\n                \"parent\": \"MemoryLowering\",\n                \"about\": \"Ensures that the allocate_operator_ is set.\",\n                \"logic\": \"If allocate_operator_ is not set, it creates a Call operator based on the AllocateDescriptor and the stub call mode.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AllocateDescriptor\",\n                    \"Linkage\",\n                    \"CallDescriptor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid MemoryLowering::EnsureAllocateOperator() {\n  if (allocate_operator_.is_set()) return;\n\n  auto descriptor = AllocateDescriptor{};\n  StubCallMode mode = isolate_ != nullptr ? StubCallMode::kCallCodeObject\n                                          : StubCallMode::kCallBuiltinPointer;\n  auto call_descriptor = Linkage::GetStubCallDescriptor(\n      graph_zone(), descriptor, descriptor.GetStackParameterCount(),\n      CallDescriptor::kCanUseRoots, Operator::kNoThrow, mode);\n  allocate_operator_.set(common()->Call(call_descriptor));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MemoryLowering::AlignToAllocationAlignment\",\n                \"parent\": \"MemoryLowering\",\n                \"about\": \"Aligns a given value to the allocation alignment boundary.\",\n                \"logic\": \"If pointer compression is enabled, it checks if the value is already aligned. If not, it adds kTaggedSize or performs a bitwise AND operation to align the value. Otherwise, the original value is returned.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The value to align.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The aligned value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nNode* MemoryLowering::AlignToAllocationAlignment(Node* value) {\n  if (!V8_COMPRESS_POINTERS_8GB_BOOL) return value;\n\n  auto already_aligned = __ MakeLabel(MachineRepresentation::kWord64);\n  Node* alignment_check = __ WordEqual(\n      __ WordAnd(value, __ UintPtrConstant(kObjectAlignment8GbHeapMask)),\n      __ UintPtrConstant(0));\n\n  __ GotoIf(alignment_check, &already_aligned, value);\n  {\n    Node* aligned_value;\n    if (kObjectAlignment8GbHeap == 2 * kTaggedSize) {\n      aligned_value = __ IntPtrAdd(value, __ IntPtrConstant(kTaggedSize));\n    } else {\n      aligned_value = __ WordAnd(\n          __ IntPtrAdd(value, __ IntPtrConstant(kObjectAlignment8GbHeapMask)),\n          __ UintPtrConstant(~kObjectAlignment8GbHeapMask));\n    }\n    __ Goto(&already_aligned, aligned_value);\n  }\n\n  __ Bind(&already_aligned);\n\n  return already_aligned.PhiAt(0);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MemoryLowering::ReduceAllocateRaw\",\n                \"parent\": \"MemoryLowering\",\n                \"about\": \"Reduces an AllocateRaw node to lower-level operations for memory allocation.\",\n                \"logic\": \"Handles the allocation of raw memory blocks. It determines the allocation strategy (young or old generation), loads the top and limit addresses, checks if the allocation can be folded into a previous allocation, and performs the allocation using either bump pointer allocation or a runtime call.  It uses allocation folding if enabled via the v8_flags.inline_new flag.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The AllocateRaw node to reduce.\"\n                    },\n                    {\n                        \"name\": \"allocation_type\",\n                        \"type\": \"AllocationType\",\n                        \"purpose\": \"The type of allocation (young or old generation).\"\n                    },\n                     {\n                        \"name\": \"state_ptr\",\n                        \"type\": \"AllocationState const**\",\n                        \"purpose\": \"Pointer to the allocation state to use for allocation folding.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A Reduction object indicating the result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"AllocationState\",\n                    \"AllocationGroup\",\n                    \"IntPtrMatcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction MemoryLowering::ReduceAllocateRaw(Node* node,\n                                            AllocationType allocation_type,\n                                            AllocationState const** state_ptr) {\n  DCHECK_EQ(IrOpcode::kAllocateRaw, node->opcode());\n  DCHECK_IMPLIES(allocation_folding_ == AllocationFolding::kDoAllocationFolding,\n                 state_ptr != nullptr);\n  if (v8_flags.single_generation && allocation_type == AllocationType::kYoung) {\n    allocation_type = AllocationType::kOld;\n  }\n  // InstructionStream objects may have a maximum size smaller than\n  // kMaxHeapObjectSize due to guard pages. If we need to support allocating\n  // code here we would need to call\n  // MemoryChunkLayout::MaxRegularCodeObjectSize() at runtime.\n  DCHECK_NE(allocation_type, AllocationType::kCode);\n  Node* value;\n  Node* size = node->InputAt(0);\n  Node* effect = node->InputAt(1);\n  Node* control = node->InputAt(2);\n\n  gasm()->InitializeEffectControl(effect, control);\n\n  Node* allocate_builtin;\n  if (!is_wasm_) {\n    if (allocation_type == AllocationType::kYoung) {\n      allocate_builtin = __ AllocateInYoungGenerationStubConstant();\n    } else {\n      allocate_builtin = __ AllocateInOldGenerationStubConstant();\n    }\n  } else {\n#if V8_ENABLE_WEBASSEMBLY\n    // This lowering is used by Wasm, where we compile isolate-independent\n    // code. Builtin calls simply encode the target builtin ID, which will\n    // be patched to the builtin's address later.\n    if (isolate_ == nullptr) {\n      Builtin builtin;\n      if (allocation_type == AllocationType::kYoung) {\n        builtin = Builtin::kWasmAllocateInYoungGeneration;\n      } else {\n        builtin = Builtin::kWasmAllocateInOldGeneration;\n      }\n      static_assert(std::is_same<Smi, BuiltinPtr>(), \"BuiltinPtr must be Smi\");\n      allocate_builtin =\n          graph()->NewNode(common()->NumberConstant(static_cast<int>(builtin)));\n    } else {\n      if (allocation_type == AllocationType::kYoung) {\n        allocate_builtin = __ WasmAllocateInYoungGenerationStubConstant();\n      } else {\n        allocate_builtin = __ WasmAllocateInOldGenerationStubConstant();\n      }\n    }\n#else\n    UNREACHABLE();\n#endif\n  }\n\n  // Determine the top/limit addresses.\n  Node* top_address;\n  Node* limit_address;\n  if (isolate_ != nullptr) {\n    top_address = __ ExternalConstant(\n        allocation_type == AllocationType::kYoung\n            ? ExternalReference::new_space_allocation_top_address(isolate())\n            : ExternalReference::old_space_allocation_top_address(isolate()));\n    limit_address = __ ExternalConstant(\n        allocation_type == AllocationType::kYoung\n            ? ExternalReference::new_space_allocation_limit_address(isolate())\n            : ExternalReference::old_space_allocation_limit_address(isolate()));\n  } else {\n    // Wasm mode: producing isolate-independent code, loading the isolate\n    // address at runtime.\n#if V8_ENABLE_WEBASSEMBLY\n    Node* instance_node = GetWasmInstanceNode();\n    int top_address_offset =\n        allocation_type == AllocationType::kYoung\n            ? WasmTrustedInstanceData::kNewAllocationTopAddressOffset\n            : WasmTrustedInstanceData::kOldAllocationTopAddressOffset;\n    int limit_address_offset =\n        allocation_type == AllocationType::kYoung\n            ? WasmTrustedInstanceData::kNewAllocationLimitAddressOffset\n            : WasmTrustedInstanceData::kOldAllocationLimitAddressOffset;\n    top_address =\n        __ Load(MachineType::Pointer(), instance_node,\n                __ IntPtrConstant(top_address_offset - kHeapObjectTag));\n    limit_address =\n        __ Load(MachineType::Pointer(), instance_node,\n                __ IntPtrConstant(limit_address_offset - kHeapObjectTag));\n#else\n    UNREACHABLE();\n#endif  // V8_ENABLE_WEBASSEMBLY\n  }\n\n  // Check if we can fold this allocation into a previous allocation represented\n  // by the incoming {state}.\n  IntPtrMatcher m(size);\n  if (m.IsInRange(0, kMaxRegularHeapObjectSize) && v8_flags.inline_new &&\n      allocation_folding_ == AllocationFolding::kDoAllocationFolding) {\n    intptr_t const object_size =\n        ALIGN_TO_ALLOCATION_ALIGNMENT(m.ResolvedValue());\n    AllocationState const* state = *state_ptr;\n    if (state->size() <= kMaxRegularHeapObjectSize - object_size &&\n        state->group()->allocation() == allocation_type) {\n      // We can fold this Allocate {node} into the allocation {group}\n      // represented by the given {state}. Compute the upper bound for\n      // the new {state}.\n      intptr_t const state_size = state->size() + object_size;\n\n      // Update the reservation check to the actual maximum upper bound.\n      AllocationGroup* const group = state->group();\n      if (machine()->Is64()) {\n        if (OpParameter<int64_t>(group->size()->op()) < state_size) {\n          NodeProperties::ChangeOp(group->size(),\n                                   common()->Int64Constant(state_size));\n        }\n      } else {\n        if (OpParameter<int32_t>(group->size()->op()) < state_size) {\n          NodeProperties::ChangeOp(\n              group->size(),\n              common()->Int32Constant(static_cast<int32_t>(state_size)));\n        }\n      }\n\n      // Update the allocation top with the new object allocation.\n      // TODO(bmeurer): Defer writing back top as much as possible.\n      DCHECK_IMPLIES(V8_COMPRESS_POINTERS_8GB_BOOL,\n                     IsAligned(object_size, kObjectAlignment8GbHeap));\n      Node* top = __ IntAdd(state->top(), __ IntPtrConstant(object_size));\n      __ Store(StoreRepresentation(MachineType::PointerRepresentation(),\n                                   kNoWriteBarrier),\n               top_address, __ IntPtrConstant(0), top);\n\n      // Compute the effective inner allocated address.\n      value = __ BitcastWordToTagged(\n          __ IntAdd(state->top(), __ IntPtrConstant(kHeapObjectTag)));\n      effect = gasm()->effect();\n      control = gasm()->control();\n\n      // Extend the allocation {group}.\n      group->Add(value);\n      *state_ptr =\n          AllocationState::Open(group, state_size, top, effect, zone());\n    } else {\n      auto call_runtime = __ MakeDeferredLabel();\n      auto done = __ MakeLabel(MachineType::PointerRepresentation());\n\n      // Setup a mutable reservation size node; will be patched as we fold\n      // additional allocations into this new group.\n      Node* reservation_size = __ UniqueIntPtrConstant(object_size);\n\n      // Load allocation top and limit.\n      Node* top =\n          __ Load(MachineType::"
}