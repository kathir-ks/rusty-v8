{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-graph.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 301, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-graph.h\",\n            \"file_name\": \"js-graph.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the JSGraph class, a facade on a TFGraph that enhances it with JS-specific notions, operators, constants, and helper methods.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary V8 headers for globals, compiler components, execution, and objects.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/common/globals.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/js-operator.h\"\n#include \"src/compiler/machine-graph.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/objects/oddball.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSGraph\",\n                \"extends\": \"MachineGraph\",\n                \"about\": \"A facade on a TFGraph, enhancing the graph with JS-specific notions.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"javascript_\",\n                        \"type\": \"JSOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Helper class for building JavaScript operators.\"\n                    },\n                    {\n                        \"name\": \"simplified_\",\n                        \"type\": \"SimplifiedOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Helper class for building Simplified operators.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Isolate\",\n                    \"TFGraph\",\n                    \"CommonOperatorBuilder\",\n                    \"JSOperatorBuilder\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"MachineOperatorBuilder\",\n                    \"ObjectRef\",\n                    \"JSHeapBroker\",\n                    \"Factory\",\n                    \"Node\",\n                    \"Code\",\n                    \"Map\",\n                    \"FixedArray\",\n                    \"String\",\n                    \"HeapNumber\",\n                    \"Undefined\",\n                    \"Hole\",\n                    \"True\",\n                    \"False\",\n                    \"Null\",\n                    \"Number\",\n                    \"UntaggedT\",\n                    \"Boolean\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE JSGraph : public MachineGraph {\n public:\n  JSGraph(Isolate* isolate, TFGraph* graph, CommonOperatorBuilder* common,\n          JSOperatorBuilder* javascript, SimplifiedOperatorBuilder* simplified,\n          MachineOperatorBuilder* machine)\n      : MachineGraph(graph, common, machine),\n        isolate_(isolate),\n        javascript_(javascript),\n        simplified_(simplified) {}\n\n  JSGraph(const JSGraph&) = delete;\n  JSGraph& operator=(const JSGraph&) = delete;\n\n  // CEntryStubs are cached depending on the result size and other flags.\n  Node* CEntryStubConstant(int result_size,\n                           ArgvMode argv_mode = ArgvMode::kStack,\n                           bool builtin_exit_frame = false);\n\n  // Used for padding frames. (alias: the hole)\n  TNode<Hole> PaddingConstant() { return TheHoleConstant(); }\n\n  // Used for stubs and runtime functions with no context. (alias: SMI zero)\n  TNode<Number> NoContextConstant() { return ZeroConstant(); }\n\n  // Creates a HeapConstant node, possibly canonicalized.\n  // Checks that we don't emit hole values. Use this if possible to emit\n  // JSReceiver heap constants.\n  Node* HeapConstantNoHole(Handle<HeapObject> value);\n\n  // Creates a HeapConstant node, possibly canonicalized.\n  // This can be used whenever we might need to emit a hole value or a\n  // JSReceiver. Use this cautiously only if you really need it.\n  Node* HeapConstantMaybeHole(Handle<HeapObject> value);\n\n  // Creates a HeapConstant node, possibly canonicalized.\n  // This is only used to emit hole values. Use this if you are sure that you\n  // only emit a Hole value.\n  Node* HeapConstantHole(Handle<HeapObject> value);\n\n  // Createas a TrustedHeapConstant node.\n  // This is similar to HeapConstant, but for constants that live in trusted\n  // space (having a different cage base) and therefore shouldn't be compressed.\n  Node* TrustedHeapConstant(Handle<HeapObject> value);\n\n  // Creates a Constant node of the appropriate type for\n  // the given object.  Inspect the (serialized) object and determine whether\n  // one of the canonicalized globals or a number constant should be returned.\n  // Checks that we do not emit a Hole value, use this whenever possible.\n  Node* ConstantNoHole(ObjectRef ref, JSHeapBroker* broker);\n  // Creates a Constant node of the appropriate type for\n  // the given object.  Inspect the (serialized) object and determine whether\n  // one of the canonicalized globals or a number constant should be returned.\n  // Use this if you really need to emit Hole values.\n  Node* ConstantMaybeHole(ObjectRef ref, JSHeapBroker* broker);\n\n  // Creates a NumberConstant node, usually canonicalized.\n  Node* ConstantMaybeHole(double value);\n  // Same, but checks that we are not emitting a kHoleNanInt64, please use\n  // whenever you can.\n  Node* ConstantNoHole(double value);\n\n  // Creates a Constant node that holds a mutable Heap Number.\n  // This is different from ConstantNoHole, which reads the double value and\n  // creates a Constant node from it.\n  Node* ConstantMutableHeapNumber(HeapNumberRef ref, JSHeapBroker* broker);\n\n  // Creates a HeapConstant node for either true or false.\n  TNode<Boolean> BooleanConstant(bool is_true) {\n    return is_true ? TNode<Boolean>(TrueConstant())\n                   : TNode<Boolean>(FalseConstant());\n  }\n\n  Node* SmiConstant(int32_t immediate) {\n    DCHECK(Smi::IsValid(immediate));\n    return ConstantMaybeHole(immediate);\n  }\n\n  JSOperatorBuilder* javascript() const { return javascript_; }\n  SimplifiedOperatorBuilder* simplified() const { return simplified_; }\n  Isolate* isolate() const { return isolate_; }\n  Factory* factory() const { return isolate()->factory(); }\n\n  // Adds all the cached nodes to the given list.\n  void GetCachedNodes(NodeVector* nodes);\n\n// Cached global nodes.\n#define CACHED_GLOBAL_LIST(V)                                 \\\n  V(AllocateInYoungGenerationStubConstant, Code)              \\\n  V(AllocateInOldGenerationStubConstant, Code)                \\\n  IF_WASM(V, WasmAllocateInYoungGenerationStubConstant, Code) \\\n  IF_WASM(V, WasmAllocateInOldGenerationStubConstant, Code)   \\\n  V(ArrayConstructorStubConstant, Code)                       \\\n  V(BigIntMapConstant, Map)                                   \\\n  V(BooleanMapConstant, Map)                                  \\\n  V(ToNumberBuiltinConstant, Code)                            \\\n  V(PlainPrimitiveToNumberBuiltinConstant, Code)              \\\n  V(EmptyFixedArrayConstant, FixedArray)                      \\\n  V(EmptyStringConstant, String)                              \\\n  V(FixedArrayMapConstant, Map)                               \\\n  V(PropertyArrayMapConstant, Map)                            \\\n  V(FixedDoubleArrayMapConstant, Map)                         \\\n  V(WeakFixedArrayMapConstant, Map)                           \\\n  V(HeapNumberMapConstant, Map)                               \\\n  V(UndefinedConstant, Undefined)                             \\\n  V(TheHoleConstant, Hole)                                    \\\n  V(PropertyCellHoleConstant, Hole)                           \\\n  V(HashTableHoleConstant, Hole)                              \\\n  V(PromiseHoleConstant, Hole)                                \\\n  V(UninitializedConstant, Hole)                               \\\n  V(OptimizedOutConstant, Hole)                               \\\n  V(StaleRegisterConstant, Hole)                               \\\n  V(TrueConstant, True)                                       \\\n  V(FalseConstant, False)                                     \\\n  V(NullConstant, Null)                                       \\\n  V(ZeroConstant, Number)                                     \\\n  V(MinusZeroConstant, Number)                                \\\n  V(OneConstant, Number)                                      \\\n  V(MinusOneConstant, Number)                                 \\\n  V(NaNConstant, Number)                                      \\\n  V(EmptyStateValues, UntaggedT)                              \\\n  V(SingleDeadTypedStateValues, UntaggedT)                    \\\n  V(ExternalObjectMapConstant, Map)\n\n// Cached global node accessor methods.\n#define DECLARE_GETTER(name, Type) TNode<Type> name();\n  CACHED_GLOBAL_LIST(DECLARE_GETTER)\n#undef DECLARE_GETTER\n\n private:\n  Isolate* isolate_;\n  JSOperatorBuilder* javascript_;\n  SimplifiedOperatorBuilder* simplified_;\n\n#define CACHED_CENTRY_LIST(V) \\\n  V(CEntryStub1Constant)      \\\n  V(CEntryStub2Constant)      \\\n  V(CEntryStub3Constant)      \\\n  V(CEntryStub1WithBuiltinExitFrameConstant)\n\n// Canonicalized global node fields.\n#define DECLARE_FIELD(name, ...) Node* name##_ = nullptr;\n  CACHED_GLOBAL_LIST(DECLARE_FIELD)\n  CACHED_CENTRY_LIST(DECLARE_FIELD)\n#undef DECLARE_FIELD\n\n  // Internal helper to canonicalize a number constant.\n  Node* NumberConstant(double value);\n\n  // Internal helper that creates a Constant node of the appropriate type for\n  // the given object.  Inspect the (serialized) object and determine whether\n  // one of the canonicalized globals or a number constant should be returned.\n  Node* Constant(ObjectRef value, JSHeapBroker* broker);\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CEntryStubConstant\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Returns a cached CEntryStub constant node.\",\n                \"logic\": \"This function likely retrieves a pre-existing CEntryStub node based on the provided parameters (result size, argv mode, and builtin exit frame). CEntryStubs are used to call C++ functions from the JavaScript runtime.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"result_size\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The size of the result returned by the C++ function.\"\n                    },\n                    {\n                        \"name\": \"argv_mode\",\n                        \"type\": \"ArgvMode\",\n                        \"purpose\": \"Specifies how arguments are passed to the C++ function (e.g., on the stack).\"\n                    },\n                    {\n                        \"name\": \"builtin_exit_frame\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether the C++ function uses a builtin exit frame.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the CEntryStub constant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* CEntryStubConstant(int result_size,\n                           ArgvMode argv_mode = ArgvMode::kStack,\n                           bool builtin_exit_frame = false);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PaddingConstant\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Returns a TNode<Hole> representing a padding constant (the hole).\",\n                \"logic\": \"Simply returns the result of TheHoleConstant(), which likely retrieves a canonicalized representation of the hole value.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"TNode<Hole>\",\n                    \"description\": \"A TNode<Hole> representing the padding constant.\"\n                },\n                \"dependencies\": [\n                    \"TNode\",\n                    \"Hole\",\n                    \"TheHoleConstant\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  TNode<Hole> PaddingConstant() { return TheHoleConstant(); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NoContextConstant\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Returns a TNode<Number> representing a constant for stubs and runtime functions with no context (SMI zero).\",\n                \"logic\": \"Simply returns the result of ZeroConstant(), which likely retrieves a canonicalized representation of the SMI zero value.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"TNode<Number>\",\n                    \"description\": \"A TNode<Number> representing the no-context constant.\"\n                },\n                \"dependencies\": [\n                    \"TNode\",\n                    \"Number\",\n                    \"ZeroConstant\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  TNode<Number> NoContextConstant() { return ZeroConstant(); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HeapConstantNoHole\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a HeapConstant node, possibly canonicalized, and ensures that hole values are not emitted. Used to emit JSReceiver heap constants if possible.\",\n                \"logic\": \"The function takes a Handle<HeapObject> and returns a Node*. It probably checks if the passed Handle represents a 'hole' and if not, it either reuses existing node or creates a new HeapConstant node for the given Handle after possibly canonicalizing it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"purpose\": \"The heap object to create a constant for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the HeapConstant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Handle\",\n                    \"HeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* HeapConstantNoHole(Handle<HeapObject> value);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HeapConstantMaybeHole\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a HeapConstant node, possibly canonicalized, allowing for hole values. Use cautiously.\",\n                \"logic\": \"Similar to HeapConstantNoHole but allows for the possibility of the Handle<HeapObject> value to represent a hole. Thus it skips the check against hole values. This function is to be used carefully and only when absolutely necessary.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"purpose\": \"The heap object to create a constant for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the HeapConstant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Handle\",\n                    \"HeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* HeapConstantMaybeHole(Handle<HeapObject> value);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HeapConstantHole\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a HeapConstant node, possibly canonicalized, for hole values only.\",\n                \"logic\": \"This function is only used to emit hole values. It likely asserts or assumes that the input Handle<HeapObject> represents the hole value, and then creates and returns a HeapConstant node for it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"purpose\": \"The heap object representing the hole.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the HeapConstant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Handle\",\n                    \"HeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* HeapConstantHole(Handle<HeapObject> value);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TrustedHeapConstant\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a TrustedHeapConstant node for constants in trusted space.\",\n                \"logic\": \"Creates a HeapConstant node, but for constants that live in trusted space (having a different cage base) and therefore shouldn't be compressed. It likely does canonicalization similar to other HeapConstant variants.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"purpose\": \"The heap object to create a constant for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the TrustedHeapConstant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Handle\",\n                    \"HeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* TrustedHeapConstant(Handle<HeapObject> value);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ConstantNoHole\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a Constant node of the appropriate type for the given ObjectRef, ensuring no hole values are emitted.\",\n                \"logic\": \"Inspects the ObjectRef and determines whether one of the canonicalized globals or a number constant should be returned. This function checks that no hole values are emitted and uses the JSHeapBroker.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ref\",\n                        \"type\": \"ObjectRef\",\n                        \"purpose\": \"The object reference to create a constant for.\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker to use for accessing heap objects.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the Constant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ObjectRef\",\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* ConstantNoHole(ObjectRef ref, JSHeapBroker* broker);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ConstantMaybeHole\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a Constant node of the appropriate type for the given ObjectRef, allowing for hole values. Use cautiously.\",\n                \"logic\": \"Inspects the ObjectRef and determines whether one of the canonicalized globals or a number constant should be returned. This function allows for emitting hole values and uses the JSHeapBroker.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ref\",\n                        \"type\": \"ObjectRef\",\n                        \"purpose\": \"The object reference to create a constant for.\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker to use for accessing heap objects.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the Constant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ObjectRef\",\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* ConstantMaybeHole(ObjectRef ref, JSHeapBroker* broker);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ConstantMaybeHole\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a NumberConstant node, usually canonicalized, allowing for hole values represented as NaN.\",\n                \"logic\": \"The function attempts to create a NumberConstant node. It likely canonicalizes the double value, reusing an existing node if possible. It allows for the possibility of the double value to be a kHoleNanInt64, which represents the 'hole' value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The double value to create a constant for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the NumberConstant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* ConstantMaybeHole(double value);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ConstantNoHole\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a NumberConstant node, usually canonicalized, ensuring no hole values are emitted.\",\n                \"logic\": \"Similar to ConstantMaybeHole(double), but specifically checks that we are not emitting a kHoleNanInt64 value. It reuses existing node if possible.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The double value to create a constant for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the NumberConstant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* ConstantNoHole(double value);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ConstantMutableHeapNumber\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a Constant node that holds a mutable Heap Number.\",\n                \"logic\": \"This is different from ConstantNoHole, which reads the double value and creates a Constant node from it.  This function creates a Constant node that points to the provided HeapNumberRef.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ref\",\n                        \"type\": \"HeapNumberRef\",\n                        \"purpose\": \"The HeapNumberRef to create a constant for.\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker to use for accessing heap objects.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the Constant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"HeapNumberRef\",\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* ConstantMutableHeapNumber(HeapNumberRef ref, JSHeapBroker* broker);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BooleanConstant\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a HeapConstant node for either true or false.\",\n                \"logic\": \"Returns the TrueConstant() if is_true is true, otherwise returns FalseConstant().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"is_true\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether to return the true or false constant.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"TNode<Boolean>\",\n                    \"description\": \"A TNode<Boolean> representing either true or false.\"\n                },\n                \"dependencies\": [\n                    \"TNode\",\n                    \"Boolean\",\n                    \"TrueConstant\",\n                    \"FalseConstant\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  TNode<Boolean> BooleanConstant(bool is_true) {\n    return is_true ? TNode<Boolean>(TrueConstant())\n                   : TNode<Boolean>(FalseConstant());\n  }\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SmiConstant\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Creates a Smi constant node.\",\n                \"logic\": \"The function takes an int32_t value and creates a Smi (small integer) constant node. It asserts that the passed immediate is a valid Smi. It relies on ConstantMaybeHole to create the underlying node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"immediate\",\n                        \"type\": \"int32_t\",\n                        \"purpose\": \"The integer value to create a Smi constant for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the Smi constant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ConstantMaybeHole\",\n                    \"Smi\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* SmiConstant(int32_t immediate) {\n    DCHECK(Smi::IsValid(immediate));\n    return ConstantMaybeHole(immediate);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"javascript\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Returns the JSOperatorBuilder.\",\n                \"logic\": \"Simple getter for javascript_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"JSOperatorBuilder*\",\n                    \"description\": \"A pointer to the JSOperatorBuilder.\"\n                },\n                \"dependencies\": [\n                    \"JSOperatorBuilder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  JSOperatorBuilder* javascript() const { return javascript_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"simplified\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Returns the SimplifiedOperatorBuilder.\",\n                \"logic\": \"Simple getter for simplified_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"SimplifiedOperatorBuilder*\",\n                    \"description\": \"A pointer to the SimplifiedOperatorBuilder.\"\n                },\n                \"dependencies\": [\n                    \"SimplifiedOperatorBuilder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  SimplifiedOperatorBuilder* simplified() const { return simplified_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"isolate\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Returns the Isolate.\",\n                \"logic\": \"Simple getter for isolate_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Isolate*\",\n                    \"description\": \"A pointer to the Isolate.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Isolate* isolate() const { return isolate_; }\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"factory\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Returns the Factory associated with the Isolate.\",\n                \"logic\": \"Simple getter for the Isolate's factory.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Factory*\",\n                    \"description\": \"A pointer to the Factory.\"\n                },\n                \"dependencies\": [\n                    \"Factory\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Factory* factory() const { return isolate()->factory(); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetCachedNodes\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Adds all the cached nodes to the given list.\",\n                \"logic\": \"Iterates through the cached global nodes and adds them to the given NodeVector.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"nodes\",\n                        \"type\": \"NodeVector*\",\n                        \"purpose\": \"The NodeVector to add the cached nodes to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NodeVector\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void GetCachedNodes(NodeVector* nodes);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NumberConstant\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Internal helper to canonicalize a number constant.\",\n                \"logic\": \"This is an internal helper that likely canonicalizes the provided double value and returns a pointer to the corresponding Node. It reuses the same Node if the same double value was requested before.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The double value to create a constant for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the Number Constant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* NumberConstant(double value);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Constant\",\n                \"parent\": \"JSGraph\",\n                \"about\": \"Internal helper that creates a Constant node of the appropriate type for the given object.\",\n                \"logic\": \"This function inspects the ObjectRef and determines whether one of the canonicalized globals or a number constant should be returned. It probably uses NumberConstant internally if the object is a number.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"ObjectRef\",\n                        \"purpose\": \"The object reference to create a constant for.\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker to use for accessing heap objects.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the Constant node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ObjectRef\",\n                    \"JSHeapBroker\",\n                    \"NumberConstant\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* Constant(ObjectRef value, JSHeapBroker* broker);\n        ]]></code>\n    </func>\n</file>\n```"
}