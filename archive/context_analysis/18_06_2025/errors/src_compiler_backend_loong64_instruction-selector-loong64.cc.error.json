{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/loong64/instruction-selector-loong64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/loong64/instruction-selector-loong64.cc\",\n        \"file_name\": \"instruction-selector-loong64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"This file implements the instruction selector for the Loong64 architecture.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for base functionalities, logging, code generation, compiler backend, and turboshaft operations.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n\n#include \"src/base/bits.h\"\n#include \"src/base/logging.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Loong64OperandGeneratorT\",\n            \"extends\": \"OperandGeneratorT\",\n            \"about\": \"Adds Loong64-specific methods for generating InstructionOperands.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OperandGeneratorT\",\n                \"OpIndex\",\n                \"ConstantOp\",\n                \"RootsTable\",\n                \"Handle\",\n                \"HeapObject\",\n                \"RootIndex\",\n                \"MacroAssemblerBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Loong64OperandGeneratorT final : public OperandGeneratorT {\n public:\n  explicit Loong64OperandGeneratorT(InstructionSelectorT* selector)\n      : OperandGeneratorT(selector) {}\n\n  InstructionOperand UseOperand(OpIndex node, InstructionCode opcode) {\n    if (CanBeImmediate(node, opcode)) {\n      return UseImmediate(node);\n    }\n    return UseRegister(node);\n  }\n\n  // Use the zero register if the node has the immediate value zero, otherwise\n  // assign a register.\n  InstructionOperand UseRegisterOrImmediateZero(OpIndex node) {\n    if (const ConstantOp* constant =\n            selector()->Get(node).TryCast<ConstantOp>()) {\n      if ((constant->IsIntegral() && constant->integral() == 0) ||\n          (constant->kind == ConstantOp::Kind::kFloat32 &&\n           constant->float32().get_bits() == 0) ||\n          (constant->kind == ConstantOp::Kind::kFloat64 &&\n           constant->float64().get_bits() == 0))\n        return UseImmediate(node);\n    }\n    return UseRegister(node);\n  }\n\n  bool IsIntegerConstant(OpIndex node) {\n    int64_t unused;\n    return selector()->MatchSignedIntegralConstant(node, &unused);\n  }\n\n  std::optional<int64_t> GetOptionalIntegerConstant(OpIndex operation) {\n    if (int64_t constant; MatchSignedIntegralConstant(operation, &constant)) {\n      return constant;\n    }\n    return std::nullopt;\n  }\n\n  bool CanBeImmediate(OpIndex node, InstructionCode mode) {\n    const ConstantOp* constant = selector()->Get(node).TryCast<ConstantOp>();\n    if (!constant) return false;\n    if (constant->kind == ConstantOp::Kind::kCompressedHeapObject) {\n      if (!COMPRESS_POINTERS_BOOL) return false;\n      // For builtin code we need static roots\n      if (selector()->isolate()->bootstrapper() && !V8_STATIC_ROOTS_BOOL) {\n        return false;\n      }\n      const RootsTable& roots_table = selector()->isolate()->roots_table();\n      RootIndex root_index;\n      Handle<HeapObject> value = constant->handle();\n      if (roots_table.IsRootHandle(value, &root_index)) {\n        if (!RootsTable::IsReadOnly(root_index)) return false;\n        return CanBeImmediate(MacroAssemblerBase::ReadOnlyRootPtr(\n                                  root_index, selector()->isolate()),\n                              mode);\n      }\n      return false;\n    }\n\n    int64_t value;\n    return selector()->MatchSignedIntegralConstant(node, &value) &&\n           CanBeImmediate(value, mode);\n  }\n\n  bool CanBeImmediate(int64_t value, InstructionCode opcode) {\n    switch (ArchOpcodeField::decode(opcode)) {\n      case kLoong64Cmp32:\n      case kLoong64Cmp64:\n        return true;\n      case kLoong64Sll_w:\n      case kLoong64Srl_w:\n      case kLoong64Sra_w:\n        return is_uint5(value);\n      case kLoong64Sll_d:\n      case kLoong64Srl_d:\n      case kLoong64Sra_d:\n        return is_uint6(value);\n      case kLoong64And:\n      case kLoong64And32:\n      case kLoong64Or:\n      case kLoong64Or32:\n      case kLoong64Xor:\n      case kLoong64Xor32:\n      case kLoong64Tst:\n        return is_uint12(value);\n      case kLoong64Ld_w:\n      case kLoong64St_w:\n      case kLoong64Ld_d:\n      case kLoong64St_d:\n      case kAtomicLoadWord32:\n      case kAtomicStoreWord32:\n      case kLoong64Word64AtomicLoadUint64:\n      case kLoong64Word64AtomicStoreWord64:\n      case kLoong64StoreCompressTagged:\n        return (is_int12(value) || (is_int16(value) && ((value & 0b11) == 0)));\n      default:\n        return is_int12(value);\n    }\n  }\n\n private:\n  bool ImmediateFitsAddrMode1Instruction(int32_t imm) const {\n    TRACE(\"UNIMPLEMENTED instr_sel: %s at line %d\\n\", __FUNCTION__, __LINE__);\n    return false;\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRR\",\n            \"about\": \"Emits an instruction with two register operands.\",\n            \"logic\": \"Generates operands for a register-register instruction and emits the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Loong64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitRR(InstructionSelectorT* selector, ArchOpcode opcode,\n                    OpIndex node) {\n  Loong64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRI\",\n            \"about\": \"Placeholder for instructions with two register operands and one immediate operand.\",\n            \"logic\": \"Marks the function as unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitRRI(InstructionSelectorT* selector, ArchOpcode opcode,\n                     OpIndex node) {\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitSimdShift\",\n            \"about\": \"Emits an instruction for SIMD shift operations, handling both register and immediate shift amounts.\",\n            \"logic\": \"Checks if the shift amount is a constant and emits the instruction accordingly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Loong64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ConstantOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitSimdShift(InstructionSelectorT* selector, ArchOpcode opcode,\n                           OpIndex node) {\n  Loong64OperandGeneratorT g(selector);\n  OpIndex rhs = selector->input_at(node, 1);\n  if (selector->Get(rhs).TryCast<ConstantOp>()) {\n    selector->Emit(opcode, g.DefineAsRegister(node),\n                   g.UseRegister(selector->input_at(node, 0)),\n                   g.UseImmediate(selector->input_at(node, 1)));\n  } else {\n    selector->Emit(opcode, g.DefineAsRegister(node),\n                   g.UseRegister(selector->input_at(node, 0)),\n                   g.UseRegister(selector->input_at(node, 1)));\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRIR\",\n            \"about\": \"Placeholder for instructions with two register operands, one immediate operand, and another register operand.\",\n            \"logic\": \"Marks the function as unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitRRIR(InstructionSelectorT* selector, ArchOpcode opcode,\n                      OpIndex node) {\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRR\",\n            \"about\": \"Emits an instruction with three register operands.\",\n            \"logic\": \"Generates operands for a register-register-register instruction and emits the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Loong64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void VisitRRR(InstructionSelectorT* selector, ArchOpcode opcode, OpIndex node) {\n  Loong64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)),\n                 g.UseRegister(selector->input_at(node, 1)));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitUniqueRRR\",\n            \"about\": \"Emits an instruction with three register operands, ensuring the source registers are unique.\",\n            \"logic\": \"Generates operands for a register-register-register instruction, enforcing unique registers, and emits the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Loong64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitUniqueRRR(InstructionSelectorT* selector, ArchOpcode opcode,\n                           OpIndex node) {\n  Loong64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseUniqueRegister(selector->input_at(node, 0)),\n                 g.UseUniqueRegister(selector->input_at(node, 1)));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRRR\",\n            \"about\": \"Placeholder for instructions with four register operands.\",\n            \"logic\": \"Marks the function as unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void VisitRRRR(InstructionSelectorT* selector, ArchOpcode opcode,\n               OpIndex node) {\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRO\",\n            \"about\": \"Emits an instruction with two register operands and one generic operand (register or immediate).\",\n            \"logic\": \"Generates operands for a register-register/immediate instruction and emits the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Loong64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitRRO(InstructionSelectorT* selector, ArchOpcode opcode,\n                     OpIndex node) {\n  Loong64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)),\n                 g.UseOperand(selector->input_at(node, 1), opcode));\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ExtendingLoadMatcher\",\n            \"about\": \"Matches extending load patterns for instruction selection.\",\n            \"attributes\": [\n                {\n                    \"name\": \"matches_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether a match was found.\"\n                },\n                {\n                    \"name\": \"selector_\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"base_\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The base operand of the load.\"\n                },\n                {\n                    \"name\": \"immediate_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The immediate offset of the load.\"\n                },\n                {\n                    \"name\": \"opcode_\",\n                    \"type\": \"ArchOpcode\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The opcode of the load instruction.\"\n                }\n            ],\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ShiftOp\",\n                \"LoadOp\",\n                \"Loong64OperandGeneratorT\",\n                \"Operation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct ExtendingLoadMatcher {\n  ExtendingLoadMatcher(OpIndex node, InstructionSelectorT* selector)\n      : matches_(false), selector_(selector), immediate_(0) {\n    Initialize(node);\n  }\n\n  bool Matches() const { return matches_; }\n\n  OpIndex base() const {\n    DCHECK(Matches());\n    return base_;\n  }\n  int64_t immediate() const {\n    DCHECK(Matches());\n    return immediate_;\n  }\n  ArchOpcode opcode() const {\n    DCHECK(Matches());\n    return opcode_;\n  }\n\n private:\n  bool matches_;\n  InstructionSelectorT* selector_;\n  OpIndex base_{};\n  int64_t immediate_;\n  ArchOpcode opcode_;\n\n  void Initialize(turboshaft::OpIndex node) {\n    const ShiftOp& shift = selector_->Get(node).template Cast<ShiftOp>();\n    DCHECK(shift.kind == ShiftOp::Kind::kShiftRightArithmetic ||\n           shift.kind == ShiftOp::Kind::kShiftRightArithmeticShiftOutZeros);\n    // When loading a 64-bit value and shifting by 32, we should\n    // just load and sign-extend the interesting 4 bytes instead.\n    // This happens, for example, when we're loading and untagging SMIs.\n    const Operation& lhs = selector_->Get(shift.left());\n    int64_t constant_rhs;\n\n    if (lhs.Is<LoadOp>() &&\n        selector_->MatchIntegralWord64Constant(shift.right(), &constant_rhs) &&\n        constant_rhs == 32 && selector_->CanCover(node, shift.left())) {\n      Loong64OperandGeneratorT g(selector_);\n\n      const LoadOp& load = lhs.Cast<LoadOp>();\n      base_ = load.base();\n      opcode_ = kLoong64Ld_w;\n      if (load.index().has_value()) {\n        int64_t index_constant;\n        if (selector_->MatchIntegralWord64Constant(load.index().value(),\n                                                   &index_constant)) {\n          DCHECK_EQ(load.element_size_log2, 0);\n          immediate_ = index_constant + 4;\n          matches_ = g.CanBeImmediate(immediate_, kLoong64Ld_w);\n        }\n      } else {\n        immediate_ = load.offset + 4;\n        matches_ = g.CanBeImmediate(immediate_, kLoong64Ld_w);\n      }\n    }\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryEmitExtendingLoad\",\n            \"about\": \"Attempts to emit an extending load instruction based on the ExtendingLoadMatcher.\",\n            \"logic\": \"If a match is found, emits the appropriate load instruction with an immediate offset.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node in the graph representing the shift operation.\"\n                },\n                {\n                    \"name\": \"output_node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the output node to be defined.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if an extending load instruction was emitted, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ExtendingLoadMatcher\",\n                \"Loong64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool TryEmitExtendingLoad(InstructionSelectorT* selector, OpIndex node,\n                          OpIndex output_node) {\n  ExtendingLoadMatcher m(node, selector);\n  Loong64OperandGeneratorT g(selector);\n  if (m.Matches()) {\n    InstructionOperand inputs[2];\n    inputs[0] = g.UseRegister(m.base());\n    InstructionCode opcode =\n        m.opcode() | AddressingModeField::encode(kMode_MRI);\n    DCHECK(is_int32(m.immediate()));\n    inputs[1] = g.TempImmediate(static_cast<int32_t>(m.immediate()));\n    InstructionOperand outputs[] = {g.DefineAsRegister(output_node)};\n    selector->Emit(opcode, arraysize(outputs), outputs, arraysize(inputs),\n                   inputs);\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchImmediate\",\n            \"about\": \"Attempts to match an immediate operand for a given instruction.\",\n            \"logic\": \"Checks if the node can be represented as an immediate and updates the opcode and inputs accordingly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the opcode to be updated.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node to be matched.\"\n                },\n                {\n                    \"name\": \"input_count_return\",\n                    \"type\": \"size_t*\",\n                    \"purpose\": \"Pointer to the input count to be updated.\"\n                },\n                {\n                    \"name\": \"inputs\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the input operand array.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if an immediate operand was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Loong64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool TryMatchImmediate(InstructionSelectorT* selector,\n                       InstructionCode* opcode_return, OpIndex node,\n                       size_t* input_count_return, InstructionOperand* inputs) {\n  Loong64OperandGeneratorT g(selector);\n  if (g.CanBeImmediate(node, *opcode_return)) {\n    *opcode_return |= AddressingModeField::encode(kMode_MRI);\n    inputs[0] = g.UseImmediate(node);\n    *input_count_return = 1;\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Shared routine for multiple binary operations.\",\n            \"logic\": \"Emits a binary instruction, handling immediates and reverse opcodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"turboshaft::OpIndex\",\n                    \"purpose\": \"The index of the node in the graph representing the binary operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"has_reverse_opcode\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates if there is a reverse opcode that can be used if the operands are swapped.\"\n                },\n                {\n                    \"name\": \"reverse_opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The reverse opcode to use.\"\n                },\n                {\n                    \"name\": \"cont\",\n                    \"type\": \"FlagsContinuationT*\",\n                    \"purpose\": \"A flags continuation to emit alongside the instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Loong64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"FlagsContinuationT\",\n                \"Operation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitBinop(InstructionSelectorT* selector, turboshaft::OpIndex node,\n                       InstructionCode opcode, bool has_reverse_opcode,\n                       InstructionCode reverse_opcode,\n                       FlagsContinuationT* cont) {\n  Loong64OperandGeneratorT g(selector);\n  InstructionOperand inputs[2];\n  size_t input_count = 0;\n  InstructionOperand outputs[1];\n  size_t output_count = 0;\n\n  const Operation& binop = selector->Get(node);\n  OpIndex left_node = binop.input(0);\n  OpIndex right_node = binop.input(1);\n\n  if (TryMatchImmediate(selector, &opcode, right_node, &input_count,\n                        &inputs[1])) {\n    inputs[0] = g.UseRegister(left_node);\n    input_count++;\n  } else if (has_reverse_opcode &&\n             TryMatchImmediate(selector, &reverse_opcode, left_node,\n                               &input_count, &inputs[1])) {\n    inputs[0] = g.UseRegister(right_node);\n    opcode = reverse_opcode;\n    input_count++;\n  } else {\n    inputs[input_count++] = g.UseRegister(left_node);\n    inputs[input_count++] = g.UseOperand(right_node, opcode);\n  }\n\n  outputs[output_count++] = g.DefineAsRegister(node);\n\n  DCHECK_NE(0u, input_count);\n  DCHECK_EQ(1u, output_count);\n  DCHECK_GE(arraysize(inputs), input_count);\n  DCHECK_GE(arraysize(outputs), output_count);\n\n  selector->EmitWithContinuation(opcode, output_count, outputs, input_count,\n                                 inputs, cont);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Overload of VisitBinop without FlagsContinuationT.\",\n            \"logic\": \"Calls the main VisitBinop function with a default FlagsContinuationT.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"turboshaft::OpIndex\",\n                    \"purpose\": \"The index of the node in the graph representing the binary operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"has_reverse_opcode\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates if there is a reverse opcode that can be used if the operands are swapped.\"\n                },\n                {\n                    \"name\": \"reverse_opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The reverse opcode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FlagsContinuationT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitBinop(InstructionSelectorT* selector, turboshaft::OpIndex node,\n                       InstructionCode opcode, bool has_reverse_opcode,\n                       InstructionCode reverse_opcode) {\n  FlagsContinuationT cont;\n  VisitBinop(selector, node, opcode, has_reverse_opcode, reverse_opcode, &cont);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Overload of VisitBinop without reverse opcode.\",\n            \"logic\": \"Calls the main VisitBinop function with no reverse opcode and default FlagsContinuationT.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"turboshaft::OpIndex\",\n                    \"purpose\": \"The index of the node in the graph representing the binary operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"cont\",\n                    \"type\": \"FlagsContinuationT*\",\n                    \"purpose\": \"A flags continuation to emit alongside the instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            static void VisitBinop(InstructionSelectorT* selector, turboshaft::OpIndex node,\n                       InstructionCode opcode, FlagsContinuationT* cont) {\n  VisitBinop(selector, node, opcode, false, kArchNop, cont);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Overload of VisitBinop with only opcode.\",\n            \"logic\": \"Calls the main VisitBinop function with no reverse opcode or FlagsContinuationT.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n"
}