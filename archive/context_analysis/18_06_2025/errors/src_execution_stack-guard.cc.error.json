{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/stack-guard.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/stack-guard.cc\",\n        \"file_name\": \"stack-guard.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides stack guard functionality to prevent stack overflows and handle interrupts in the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for stack guard functionality, atomic operations, compiler dispatcher, interrupts scope, isolate, protectors, simulator, logging, objects, roots, tracing, and memory copy.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/stack-guard.h\"\n\n#include \"src/base/atomicops.h\"\n#include \"src/compiler-dispatcher/optimizing-compile-dispatcher.h\"\n#include \"src/execution/interrupts-scope.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/execution/protectors-inl.h\"\n#include \"src/execution/simulator.h\"\n#include \"src/logging/counters.h\"\n#include \"src/objects/backing-store.h\"\n#include \"src/roots/roots-inl.h\"\n#include \"src/tracing/trace-event.h\"\n#include \"src/utils/memcopy.h\"\n\n#ifdef V8_ENABLE_SPARKPLUG\n#include \"src/baseline/baseline-batch-compiler.h\"\n#endif\n\n#ifdef V8_ENABLE_MAGLEV\n#include \"src/maglev/maglev-concurrent-dispatcher.h\"\n#endif  // V8_ENABLE_MAGLEV\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-engine.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"update_interrupt_requests_and_stack_limits\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Updates the interrupt requests and stack limits based on pending interrupts.\",\n            \"logic\": \"Checks for pending interrupts and sets the stack limits accordingly. If there are pending interrupts, the stack limit is set to kInterruptLimit; otherwise, it's set to the real stack limit.  It also updates the interrupt_requested flags for different interrupt levels.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lock\",\n                    \"type\": \"const ExecutionAccess&\",\n                    \"purpose\": \"Provides exclusive access to the isolate's execution state.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"InterruptLevel\",\n                \"std::array\",\n                \"InterruptLevelMask\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::update_interrupt_requests_and_stack_limits(\n    const ExecutionAccess& lock) {\n  DCHECK_NOT_NULL(isolate_);\n  if (has_pending_interrupts(lock)) {\n    thread_local_.set_jslimit(kInterruptLimit);\n#ifdef USE_SIMULATOR\n    thread_local_.set_climit(kInterruptLimit);\n#endif\n  } else {\n    thread_local_.set_jslimit(thread_local_.real_jslimit_);\n#ifdef USE_SIMULATOR\n    thread_local_.set_climit(thread_local_.real_climit_);\n#endif\n  }\n  for (InterruptLevel level :\n       std::array{InterruptLevel::kNoGC, InterruptLevel::kNoHeapWrites,\n                  InterruptLevel::kAnyEffect}) {\n    thread_local_.set_interrupt_requested(\n        level, InterruptLevelMask(level) & thread_local_.interrupt_flags_);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetStackLimit\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Sets the stack limit to the specified value.\",\n            \"logic\": \"Sets both the C stack limit and the JavaScript stack limit. Uses SimulatorStack::JsLimitFromCLimit to derive the JavaScript limit from the C limit.  Acquires an ExecutionAccess lock for thread safety.\",\n            \"parameters\": [\n                {\n                    \"name\": \"limit\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"The new stack limit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"SimulatorStack::JsLimitFromCLimit\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::SetStackLimit(uintptr_t limit) {\n  ExecutionAccess access(isolate_);\n  SetStackLimitInternal(access, limit,\n                        SimulatorStack::JsLimitFromCLimit(isolate_, limit));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetStackLimitInternal\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Sets the internal stack limit to the specified values.\",\n            \"logic\": \"Sets both the C stack limit and the JavaScript stack limit. Updates `real_jslimit_` and `real_climit_` only if current limits are not special (e.g. due to pending interrupt). Acquires an ExecutionAccess lock for thread safety.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lock\",\n                    \"type\": \"const ExecutionAccess&\",\n                    \"purpose\": \"Provides exclusive access to the isolate's execution state.\"\n                },\n                {\n                    \"name\": \"limit\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"The new C stack limit.\"\n                },\n                {\n                    \"name\": \"jslimit\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"The new JavaScript stack limit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::SetStackLimitInternal(const ExecutionAccess& lock,\n                                       uintptr_t limit, uintptr_t jslimit) {\n  // If the current limits are special (e.g. due to a pending interrupt) then\n  // leave them alone.\n  if (thread_local_.jslimit() == thread_local_.real_jslimit_) {\n    thread_local_.set_jslimit(jslimit);\n  }\n  thread_local_.real_jslimit_ = jslimit;\n#ifdef USE_SIMULATOR\n  if (thread_local_.climit() == thread_local_.real_climit_) {\n    thread_local_.set_climit(limit);\n  }\n  thread_local_.real_climit_ = limit;\n#endif\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetStackLimitForStackSwitching\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Sets the stack limit for stack switching.\",\n            \"logic\": \"Uses a compare-and-swap operation to update the JavaScript stack limit without acquiring a lock. This is intended for stack switching scenarios. Also updates the `real_jslimit_`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"limit\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"The new stack limit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"base::Relaxed_CompareAndSwap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::SetStackLimitForStackSwitching(uintptr_t limit) {\n  // Try to compare and swap the new jslimit without the ExecutionAccess lock.\n  uintptr_t old_jslimit = base::Relaxed_CompareAndSwap(\n      &thread_local_.jslimit_, thread_local_.real_jslimit_, limit);\n  USE(old_jslimit);\n  DCHECK_IMPLIES(old_jslimit != thread_local_.real_jslimit_,\n                 old_jslimit == kInterruptLimit);\n  // Either way, set the real limit. This does not require synchronization.\n  thread_local_.real_jslimit_ = limit;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AdjustStackLimitForSimulator\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Adjusts stack limit specifically for the simulator.\",\n            \"logic\": \"Calculates jslimit from climit using `SimulatorStack::JsLimitFromCLimit` and sets it to `thread_local_.jslimit_` only if current `jslimit` is equal to `real_jslimit_`.  This function is only compiled when `USE_SIMULATOR` is defined.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"SimulatorStack::JsLimitFromCLimit\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef USE_SIMULATOR\nvoid StackGuard::AdjustStackLimitForSimulator() {\n  ExecutionAccess access(isolate_);\n  uintptr_t climit = thread_local_.real_climit_;\n  // If the current limits are special (e.g. due to a pending interrupt) then\n  // leave them alone.\n  uintptr_t jslimit = SimulatorStack::JsLimitFromCLimit(isolate_, climit);\n  if (thread_local_.jslimit() == thread_local_.real_jslimit_) {\n    thread_local_.set_jslimit(jslimit);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ResetStackLimitForSimulator\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Resets stack limit specifically for the simulator.\",\n            \"logic\": \"Resets `thread_local_.jslimit_` to its `real_jslimit_` value, but only if the current value is not equal to `kInterruptLimit`, i.e., there's no pending interrupt.  This function is only compiled when `USE_SIMULATOR` is defined.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::ResetStackLimitForSimulator() {\n  ExecutionAccess access(isolate_);\n  // If the current limits are special due to a pending interrupt then\n  // leave them alone.\n  if (thread_local_.jslimit() != kInterruptLimit) {\n    thread_local_.set_jslimit(thread_local_.real_jslimit_);\n  }\n}\n#endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PushInterruptsScope\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Pushes a new interrupts scope onto the stack.\",\n            \"logic\": \"Adds a new InterruptsScope to the chain. If the scope is postponing interrupts, it intercepts the interrupts specified by the intercept mask. If the scope is running interrupts, it restores postponed interrupts. Then it calls `update_interrupt_requests_and_stack_limits` to ensure stack limits are up-to-date and finally pushes the new `scope`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"scope\",\n                    \"type\": \"InterruptsScope*\",\n                    \"purpose\": \"The new interrupts scope to push.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"InterruptsScope\",\n                \"update_interrupt_requests_and_stack_limits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::PushInterruptsScope(InterruptsScope* scope) {\n  ExecutionAccess access(isolate_);\n  DCHECK_NE(scope->mode_, InterruptsScope::kNoop);\n  if (scope->mode_ == InterruptsScope::kPostponeInterrupts) {\n    // Intercept already requested interrupts.\n    uint32_t intercepted =\n        thread_local_.interrupt_flags_ & scope->intercept_mask_;\n    scope->intercepted_flags_ = intercepted;\n    thread_local_.interrupt_flags_ &= ~intercepted;\n  } else {\n    DCHECK_EQ(scope->mode_, InterruptsScope::kRunInterrupts);\n    // Restore postponed interrupts.\n    uint32_t restored_flags = 0;\n    for (InterruptsScope* current = thread_local_.interrupt_scopes_;\n         current != nullptr; current = current->prev_) {\n      restored_flags |= (current->intercepted_flags_ & scope->intercept_mask_);\n      current->intercepted_flags_ &= ~scope->intercept_mask_;\n    }\n    thread_local_.interrupt_flags_ |= restored_flags;\n  }\n  update_interrupt_requests_and_stack_limits(access);\n  // Add scope to the chain.\n  scope->prev_ = thread_local_.interrupt_scopes_;\n  thread_local_.interrupt_scopes_ = scope;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PopInterruptsScope\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Pops the topmost interrupts scope from the stack.\",\n            \"logic\": \"Removes the topmost InterruptsScope from the chain. If the scope was postponing interrupts, it makes intercepted interrupts active again. If the scope was running interrupts, it postpones existing interrupts if needed by upper scopes.  Finally it calls `update_interrupt_requests_and_stack_limits` to ensure the stack limits are up-to-date.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"InterruptsScope\",\n                \"update_interrupt_requests_and_stack_limits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::PopInterruptsScope() {\n  ExecutionAccess access(isolate_);\n  InterruptsScope* top = thread_local_.interrupt_scopes_;\n  DCHECK_NE(top->mode_, InterruptsScope::kNoop);\n  if (top->mode_ == InterruptsScope::kPostponeInterrupts) {\n    // Make intercepted interrupts active.\n    DCHECK_EQ(thread_local_.interrupt_flags_ & top->intercept_mask_, 0);\n    thread_local_.interrupt_flags_ |= top->intercepted_flags_;\n  } else {\n    DCHECK_EQ(top->mode_, InterruptsScope::kRunInterrupts);\n    // Postpone existing interupts if needed.\n    if (top->prev_) {\n      for (uint32_t interrupt = 1; interrupt < ALL_INTERRUPTS;\n           interrupt = interrupt << 1) {\n        InterruptFlag flag = static_cast<InterruptFlag>(interrupt);\n        if ((thread_local_.interrupt_flags_ & flag) &&\n            top->prev_->Intercept(flag)) {\n          thread_local_.interrupt_flags_ &= ~flag;\n        }\n      }\n    }\n  }\n  update_interrupt_requests_and_stack_limits(access);\n  // Remove scope from chain.\n  thread_local_.interrupt_scopes_ = top->prev_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CheckInterrupt\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Checks if a specific interrupt flag is set.\",\n            \"logic\": \"Checks if the specified interrupt flag is set in the thread-local interrupt flags. Acquires an ExecutionAccess lock for thread safety.\",\n            \"parameters\": [\n                {\n                    \"name\": \"flag\",\n                    \"type\": \"InterruptFlag\",\n                    \"purpose\": \"The interrupt flag to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the interrupt flag is set; otherwise, false.\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"InterruptFlag\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool StackGuard::CheckInterrupt(InterruptFlag flag) {\n  ExecutionAccess access(isolate_);\n  return (thread_local_.interrupt_flags_ & flag) != 0;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RequestInterrupt\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Requests a specific interrupt.\",\n            \"logic\": \"Sets the specified interrupt flag in the thread-local interrupt flags. Before setting, it checks the chain of `InterruptsScope` objects for interception. If the interrupt is intercepted, nothing happens. Finally it calls `update_interrupt_requests_and_stack_limits` to update stack limits. If isolate is waiting in a futex, notifies it to wake up.\",\n            \"parameters\": [\n                {\n                    \"name\": \"flag\",\n                    \"type\": \"InterruptFlag\",\n                    \"purpose\": \"The interrupt flag to request.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"InterruptFlag\",\n                \"InterruptsScope\",\n                \"update_interrupt_requests_and_stack_limits\",\n                \"isolate_->futex_wait_list_node()->NotifyWake()\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::RequestInterrupt(InterruptFlag flag) {\n  ExecutionAccess access(isolate_);\n  // Check the chain of InterruptsScope for interception.\n  if (thread_local_.interrupt_scopes_ &&\n      thread_local_.interrupt_scopes_->Intercept(flag)) {\n    return;\n  }\n\n  // Not intercepted.  Set as active interrupt flag.\n  thread_local_.interrupt_flags_ |= flag;\n  update_interrupt_requests_and_stack_limits(access);\n\n  // If this isolate is waiting in a futex, notify it to wake up.\n  isolate_->futex_wait_list_node()->NotifyWake();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ClearInterrupt\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Clears a specific interrupt.\",\n            \"logic\": \"Clears the specified interrupt flag from the thread-local interrupt flags. It also iterates through the chain of `InterruptsScope` objects and clears the flag from intercepted flags.  Finally it calls `update_interrupt_requests_and_stack_limits` to update stack limits.\",\n            \"parameters\": [\n                {\n                    \"name\": \"flag\",\n                    \"type\": \"InterruptFlag\",\n                    \"purpose\": \"The interrupt flag to clear.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"InterruptFlag\",\n                \"InterruptsScope\",\n                \"update_interrupt_requests_and_stack_limits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::ClearInterrupt(InterruptFlag flag) {\n  ExecutionAccess access(isolate_);\n  // Clear the interrupt flag from the chain of InterruptsScope.\n  for (InterruptsScope* current = thread_local_.interrupt_scopes_;\n       current != nullptr; current = current->prev_) {\n    current->intercepted_flags_ &= ~flag;\n  }\n\n  // Clear the interrupt flag from the active interrupt flags.\n  thread_local_.interrupt_flags_ &= ~flag;\n  update_interrupt_requests_and_stack_limits(access);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"HasTerminationRequest\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Checks if there is a termination request.\",\n            \"logic\": \"Checks if the TERMINATE_EXECUTION interrupt flag is set. If so, it clears the flag and returns true. Acquires an ExecutionAccess lock for thread safety.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if there is a termination request; otherwise, false.\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"update_interrupt_requests_and_stack_limits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool StackGuard::HasTerminationRequest() {\n  if (!thread_local_.has_interrupt_requested(InterruptLevel::kNoGC)) {\n    return false;\n  }\n  ExecutionAccess access(isolate_);\n  if ((thread_local_.interrupt_flags_ & TERMINATE_EXECUTION) != 0) {\n    thread_local_.interrupt_flags_ &= ~TERMINATE_EXECUTION;\n    update_interrupt_requests_and_stack_limits(access);\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FetchAndClearInterrupts\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Fetches and clears interrupts of a specified level.\",\n            \"logic\": \"Atomically fetches and clears the interrupt flags for the specified level. Special handling of `TERMINATE_EXECUTION` interrupt: only that bit will be fetched and cleared.\",\n            \"parameters\": [\n                {\n                    \"name\": \"level\",\n                    \"type\": \"InterruptLevel\",\n                    \"purpose\": \"The level of interrupts to fetch and clear.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The value of the interrupt flags that were fetched.\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"InterruptLevel\",\n                \"InterruptLevelMask\",\n                \"update_interrupt_requests_and_stack_limits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint StackGuard::FetchAndClearInterrupts(InterruptLevel level) {\n  ExecutionAccess access(isolate_);\n  InterruptFlag mask = InterruptLevelMask(level);\n  if ((thread_local_.interrupt_flags_ & TERMINATE_EXECUTION) != 0) {\n    // The TERMINATE_EXECUTION interrupt is special, since it terminates\n    // execution but should leave V8 in a resumable state. If it exists, we only\n    // fetch and clear that bit. On resume, V8 can continue processing other\n    // interrupts.\n    mask = TERMINATE_EXECUTION;\n  }\n\n  int result = static_cast<int>(thread_local_.interrupt_flags_ & mask);\n  thread_local_.interrupt_flags_ &= ~mask;\n  update_interrupt_requests_and_stack_limits(access);\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ArchiveStackGuard\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Archives the stack guard data.\",\n            \"logic\": \"Copies the thread-local stack guard data to the provided buffer and then zeroes out the thread-local data.  Acquires an ExecutionAccess lock for thread safety.\",\n            \"parameters\": [\n                {\n                    \"name\": \"to\",\n                    \"type\": \"char*\",\n                    \"purpose\": \"The buffer to copy the stack guard data to.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"char*\",\n                \"description\": \"A pointer to the next available byte in the buffer after the archived data.\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"MemCopy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nchar* StackGuard::ArchiveStackGuard(char* to) {\n  ExecutionAccess access(isolate_);\n  MemCopy(to, reinterpret_cast<char*>(&thread_local_), sizeof(ThreadLocal));\n  thread_local_ = {};\n  return to + sizeof(ThreadLocal);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RestoreStackGuard\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Restores the stack guard data.\",\n            \"logic\": \"Copies the stack guard data from the provided buffer to the thread-local data.  Acquires an ExecutionAccess lock for thread safety.\",\n            \"parameters\": [\n                {\n                    \"name\": \"from\",\n                    \"type\": \"char*\",\n                    \"purpose\": \"The buffer to copy the stack guard data from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"char*\",\n                \"description\": \"A pointer to the next available byte in the buffer after the restored data.\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"MemCopy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nchar* StackGuard::RestoreStackGuard(char* from) {\n  ExecutionAccess access(isolate_);\n  MemCopy(reinterpret_cast<char*>(&thread_local_), from, sizeof(ThreadLocal));\n  return from + sizeof(ThreadLocal);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FreeThreadResources\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Frees the thread resources associated with the stack guard.\",\n            \"logic\": \"Sets the stack limit for the current thread's `PerIsolateThreadData` to the real C stack limit.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Isolate::PerIsolateThreadData\",\n                \"real_climit()\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::FreeThreadResources() {\n  Isolate::PerIsolateThreadData* per_thread =\n      isolate_->FindOrAllocatePerThreadDataForThisThread();\n  per_thread->set_stack_limit(real_climit());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Initialize\",\n            \"parent\": \"StackGuard::ThreadLocal\",\n            \"about\": \"Initializes the thread-local stack guard data.\",\n            \"logic\": \"Calculates the initial stack limits based on the stack size flag. Sets both JavaScript and C stack limits. Initializes interrupt scopes to nullptr and interrupt flags to 0.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate.\"\n                },\n                {\n                    \"name\": \"lock\",\n                    \"type\": \"const ExecutionAccess&\",\n                    \"purpose\": \"Provides exclusive access to the isolate's execution state.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"base::Stack::GetStackStart\",\n                \"SimulatorStack::JsLimitFromCLimit\",\n                \"ExecutionAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::ThreadLocal::Initialize(Isolate* isolate,\n                                         const ExecutionAccess& lock) {\n  const uintptr_t kLimitSize = v8_flags.stack_size * KB;\n  DCHECK_GT(base::Stack::GetStackStart(), kLimitSize);\n  uintptr_t limit = base::Stack::GetStackStart() - kLimitSize;\n  real_jslimit_ = SimulatorStack::JsLimitFromCLimit(isolate, limit);\n  set_jslimit(SimulatorStack::JsLimitFromCLimit(isolate, limit));\n#ifdef USE_SIMULATOR\n  real_climit_ = limit;\n  set_climit(limit);\n#endif\n  interrupt_scopes_ = nullptr;\n  interrupt_flags_ = 0;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitThread\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Initializes the stack guard for a new thread.\",\n            \"logic\": \"Initializes the thread-local stack guard data and sets the stack limit based on the stored limit in `PerIsolateThreadData` if there's any. You must hold the `ExecutionAccess` lock when you call this.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lock\",\n                    \"type\": \"const ExecutionAccess&\",\n                    \"purpose\": \"Provides exclusive access to the isolate's execution state.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ExecutionAccess\",\n                \"Isolate::PerIsolateThreadData\",\n                \"SetStackLimit\",\n                \"ThreadLocal::Initialize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StackGuard::InitThread(const ExecutionAccess& lock) {\n  thread_local_.Initialize(isolate_, lock);\n  Isolate::PerIsolateThreadData* per_thread =\n      isolate_->FindOrAllocatePerThreadDataForThisThread();\n  uintptr_t stored_limit = per_thread->stack_limit();\n  // You should hold the ExecutionAccess lock when you call this.\n  if (stored_limit != 0) {\n    SetStackLimit(stored_limit);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"HandleInterrupts\",\n            \"parent\": \"StackGuard\",\n            \"about\": \"Handles pending interrupts.\",\n            \"logic\": \"Handles pending interrupts by fetching and clearing interrupt flags, then executing corresponding actions based on each flag. This includes terminating execution, handling GC requests, starting incremental marking, growing shared memory (Wasm), deoptimizing allocation sites, installing optimized/baseline code, and invoking API interrupt callbacks.\",\n            \"parameters\": [\n                {\n                    \"name\": \"level\",\n                    \"type\": \"InterruptLevel\",\n                    \"purpose\": \"The interrupt level to handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Object>\",\n                \"description\": \"Returns undefined_value. Return type likely related to handling execution within V8's object model.\"\n            },\n            \"dependencies\": [\n                \"ReadOnlyRoots\",\n                \"FetchAndClearInterrupts\",\n                \"isolate_->TerminateExecution\",\n                \"isolate_->heap()->HandleGCRequest\",\n                \"isolate_->heap()->StartIncrementalMarkingOnInterrupt\",\n                \"BackingStore::UpdateSharedWasmMemoryObjects\",\n                \"wasm::GetWasmEngine()->LogOutstandingCodesForIsolate\",\n                \"wasm::GetWasmEngine()->ReportLiveCodeFromStackForGC\",\n                \"isolate_->heap()->DeoptMarkedAllocationSites\",\n                \"isolate_->optimizing_compile_dispatcher()->InstallOptimizedFunctions\",\n                \"isolate_->baseline_batch_compiler()->InstallBatch\",\n                \"isolate_->maglev_concurrent_dispatcher()->FinalizeFinishedJobs\",\n                \"isolate_->InvokeApiInterruptCallbacks\",\n                \"isolate_->counters()->stack_interrupts()->Increment\",\n                \"TracingFlags::is_runtime_stats_enabled\",\n                \"Protectors::IsNoProfilingIntact\",\n                \"Protectors::InvalidateNoProfiling\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTagged<Object> StackGuard::HandleInterrupts(InterruptLevel level) {\n  TRACE_EVENT0(\"v8.execute\", \"V8.HandleInterrupts\");\n\n#if DEBUG\n  isolate_->heap()->VerifyNewSpaceTop();\n#endif\n\n  if (v8_flags.verify_predictable) {\n    // Advance synthetic time by making a time request.\n    isolate_->heap()->MonotonicallyIncreasingTimeInMs();\n  }\n\n  // Fetch and clear interrupt bits in one go. See comments inside the method\n  // for special handling of TERMINATE_EXECUTION.\n  int interrupt_flags = FetchAndClearInterrupts(level);\n\n  // All interrupts should be fully processed when returning from this method.\n  ShouldBeZeroOnReturnScope should_be_zero_on_return(&interrupt_flags);\n\n  if (TestAndClear(&interrupt_flags, TERMINATE_EXECUTION)) {\n    TRACE_EVENT0(\"v8.execute\", \"V8.TerminateExecution\");\n    return isolate_->TerminateExecution();\n  }\n\n  if (TestAndClear(&interrupt_flags, GC_REQUEST)) {\n    TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.gc\"), \"V8.GCHandleGCRequest\");\n    isolate_->heap()->HandleGC"
}