{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/mips64/instruction-scheduler-mips64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/mips64/instruction-scheduler-mips64.cc\",\n        \"file_name\": \"instruction-scheduler-mips64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the instruction scheduler for the MIPS64 architecture in the V8 compiler backend. It defines instruction latencies and scheduling support.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for code generation and instruction scheduling.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/codegen/macro-assembler.h\"\n            #include \"src/compiler/backend/instruction-scheduler.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SchedulerSupported\",\n            \"parent\": \"InstructionScheduler\",\n            \"about\": \"Indicates whether instruction scheduling is supported for the MIPS64 architecture.\",\n            \"logic\": \"Always returns true, indicating that scheduling is supported.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true, indicating scheduling support.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool InstructionScheduler::SchedulerSupported() { return true; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetTargetInstructionFlags\",\n            \"parent\": \"InstructionScheduler\",\n            \"about\": \"Retrieves target-specific flags for an instruction based on its opcode.\",\n            \"logic\": \"A switch statement determines instruction flags based on the instruction's `arch_opcode`. Load operations are flagged with `kIsLoadOperation`, store operations with `kHasSideEffect`, and others with `kNoOpcodeFlags`. Uses a macro to handle common opcodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"const Instruction*\",\n                    \"purpose\": \"The instruction to retrieve flags for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"An integer representing the instruction flags.\"\n            },\n            \"dependencies\": [\n                \"Instruction\",\n                \"kNoOpcodeFlags\",\n                \"kIsLoadOperation\",\n                \"kHasSideEffect\",\n                \"COMMON_ARCH_OPCODE_LIST\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            int InstructionScheduler::GetTargetInstructionFlags(\n                const Instruction* instr) const {\n              switch (instr->arch_opcode()) {\n                case kMips64AbsD:\n                case kMips64AbsS:\n                case kMips64Add:\n                case kMips64AddD:\n                case kMips64AddS:\n                case kMips64And:\n                case kMips64And32:\n                case kMips64AssertEqual:\n                case kMips64BitcastDL:\n                case kMips64BitcastLD:\n                case kMips64ByteSwap32:\n                case kMips64ByteSwap64:\n                case kMips64CeilWD:\n                case kMips64CeilWS:\n                case kMips64Clz:\n                case kMips64Cmp:\n                case kMips64CmpD:\n                case kMips64CmpS:\n                case kMips64Ctz:\n                case kMips64CvtDL:\n                case kMips64CvtDS:\n                case kMips64CvtDUl:\n                case kMips64CvtDUw:\n                case kMips64CvtDW:\n                case kMips64CvtSD:\n                case kMips64CvtSL:\n                case kMips64CvtSUl:\n                case kMips64CvtSUw:\n                case kMips64CvtSW:\n                case kMips64DMulHigh:\n                case kMips64DMulHighU:\n                case kMips64DMulOvf:\n                case kMips64MulHighU:\n                case kMips64Dadd:\n                case kMips64DaddOvf:\n                case kMips64Dclz:\n                case kMips64Dctz:\n                case kMips64Ddiv:\n                case kMips64DdivU:\n                case kMips64Dext:\n                case kMips64Dins:\n                case kMips64Div:\n                case kMips64DivD:\n                case kMips64DivS:\n                case kMips64DivU:\n                case kMips64Dlsa:\n                case kMips64Dmod:\n                case kMips64DmodU:\n                case kMips64Dmul:\n                case kMips64Dpopcnt:\n                case kMips64Dror:\n                case kMips64Dsar:\n                case kMips64Dshl:\n                case kMips64Dshr:\n                case kMips64Dsub:\n                case kMips64DsubOvf:\n                case kMips64Ext:\n                case kMips64F64x2Abs:\n                case kMips64F64x2Neg:\n                case kMips64F64x2Sqrt:\n                case kMips64F64x2Add:\n                case kMips64F64x2Sub:\n                case kMips64F64x2Mul:\n                case kMips64F64x2Div:\n                case kMips64F64x2Min:\n                case kMips64F64x2Max:\n                case kMips64F64x2Eq:\n                case kMips64F64x2Ne:\n                case kMips64F64x2Lt:\n                case kMips64F64x2Le:\n                case kMips64F64x2Pmin:\n                case kMips64F64x2Pmax:\n                case kMips64F64x2Ceil:\n                case kMips64F64x2Floor:\n                case kMips64F64x2Trunc:\n                case kMips64F64x2NearestInt:\n                case kMips64F64x2ConvertLowI32x4S:\n                case kMips64F64x2ConvertLowI32x4U:\n                case kMips64F64x2PromoteLowF32x4:\n                case kMips64I64x2Splat:\n                case kMips64I64x2ExtractLane:\n                case kMips64I64x2ReplaceLane:\n                case kMips64I64x2Add:\n                case kMips64I64x2Sub:\n                case kMips64I64x2Mul:\n                case kMips64I64x2Neg:\n                case kMips64I64x2Shl:\n                case kMips64I64x2ShrS:\n                case kMips64I64x2ShrU:\n                case kMips64I64x2BitMask:\n                case kMips64I64x2Eq:\n                case kMips64I64x2Ne:\n                case kMips64I64x2GtS:\n                case kMips64I64x2GeS:\n                case kMips64I64x2Abs:\n                case kMips64I64x2SConvertI32x4Low:\n                case kMips64I64x2SConvertI32x4High:\n                case kMips64I64x2UConvertI32x4Low:\n                case kMips64I64x2UConvertI32x4High:\n                case kMips64ExtMulLow:\n                case kMips64ExtMulHigh:\n                case kMips64ExtAddPairwise:\n                case kMips64F32x4Abs:\n                case kMips64F32x4Add:\n                case kMips64F32x4Eq:\n                case kMips64F32x4ExtractLane:\n                case kMips64F32x4Lt:\n                case kMips64F32x4Le:\n                case kMips64F32x4Max:\n                case kMips64F32x4Min:\n                case kMips64F32x4Mul:\n                case kMips64F32x4Div:\n                case kMips64F32x4Ne:\n                case kMips64F32x4Neg:\n                case kMips64F32x4Sqrt:\n                case kMips64F32x4ReplaceLane:\n                case kMips64F32x4SConvertI32x4:\n                case kMips64F32x4Splat:\n                case kMips64F32x4Sub:\n                case kMips64F32x4UConvertI32x4:\n                case kMips64F32x4Pmin:\n                case kMips64F32x4Pmax:\n                case kMips64F32x4Ceil:\n                case kMips64F32x4Floor:\n                case kMips64F32x4Trunc:\n                case kMips64F32x4NearestInt:\n                case kMips64F32x4DemoteF64x2Zero:\n                case kMips64F64x2Splat:\n                case kMips64F64x2ExtractLane:\n                case kMips64F64x2ReplaceLane:\n                case kMips64Float32Max:\n                case kMips64Float32Min:\n                case kMips64Float32RoundDown:\n                case kMips64Float32RoundTiesEven:\n                case kMips64Float32RoundTruncate:\n                case kMips64Float32RoundUp:\n                case kMips64Float64ExtractLowWord32:\n                case kMips64Float64ExtractHighWord32:\n                case kMips64Float64FromWord32Pair:\n                case kMips64Float64InsertLowWord32:\n                case kMips64Float64InsertHighWord32:\n                case kMips64Float64Max:\n                case kMips64Float64Min:\n                case kMips64Float64RoundDown:\n                case kMips64Float64RoundTiesEven:\n                case kMips64Float64RoundTruncate:\n                case kMips64Float64RoundUp:\n                case kMips64Float64SilenceNaN:\n                case kMips64FloorWD:\n                case kMips64FloorWS:\n                case kMips64I16x8Add:\n                case kMips64I16x8AddSatS:\n                case kMips64I16x8AddSatU:\n                case kMips64I16x8Eq:\n                case kMips64I16x8ExtractLaneU:\n                case kMips64I16x8ExtractLaneS:\n                case kMips64I16x8GeS:\n                case kMips64I16x8GeU:\n                case kMips64I16x8GtS:\n                case kMips64I16x8GtU:\n                case kMips64I16x8MaxS:\n                case kMips64I16x8MaxU:\n                case kMips64I16x8MinS:\n                case kMips64I16x8MinU:\n                case kMips64I16x8Mul:\n                case kMips64I16x8Ne:\n                case kMips64I16x8Neg:\n                case kMips64I16x8ReplaceLane:\n                case kMips64I8x16SConvertI16x8:\n                case kMips64I16x8SConvertI32x4:\n                case kMips64I16x8SConvertI8x16High:\n                case kMips64I16x8SConvertI8x16Low:\n                case kMips64I16x8Shl:\n                case kMips64I16x8ShrS:\n                case kMips64I16x8ShrU:\n                case kMips64I16x8Splat:\n                case kMips64I16x8Sub:\n                case kMips64I16x8SubSatS:\n                case kMips64I16x8SubSatU:\n                case kMips64I8x16UConvertI16x8:\n                case kMips64I16x8UConvertI32x4:\n                case kMips64I16x8UConvertI8x16High:\n                case kMips64I16x8UConvertI8x16Low:\n                case kMips64I16x8RoundingAverageU:\n                case kMips64I16x8Abs:\n                case kMips64I16x8BitMask:\n                case kMips64I16x8Q15MulRSatS:\n                case kMips64I32x4Add:\n                case kMips64I32x4Eq:\n                case kMips64I32x4ExtractLane:\n                case kMips64I32x4GeS:\n                case kMips64I32x4GeU:\n                case kMips64I32x4GtS:\n                case kMips64I32x4GtU:\n                case kMips64I32x4MaxS:\n                case kMips64I32x4MaxU:\n                case kMips64I32x4MinS:\n                case kMips64I32x4MinU:\n                case kMips64I32x4Mul:\n                case kMips64I32x4Ne:\n                case kMips64I32x4Neg:\n                case kMips64I32x4ReplaceLane:\n                case kMips64I32x4SConvertF32x4:\n                case kMips64I32x4SConvertI16x8High:\n                case kMips64I32x4SConvertI16x8Low:\n                case kMips64I32x4Shl:\n                case kMips64I32x4ShrS:\n                case kMips64I32x4ShrU:\n                case kMips64I32x4Splat:\n                case kMips64I32x4Sub:\n                case kMips64I32x4UConvertF32x4:\n                case kMips64I32x4UConvertI16x8High:\n                case kMips64I32x4UConvertI16x8Low:\n                case kMips64I32x4Abs:\n                case kMips64I32x4BitMask:\n                case kMips64I32x4DotI16x8S:\n                case kMips64I32x4TruncSatF64x2SZero:\n                case kMips64I32x4TruncSatF64x2UZero:\n                case kMips64I8x16Add:\n                case kMips64I8x16AddSatS:\n                case kMips64I8x16AddSatU:\n                case kMips64I8x16Eq:\n                case kMips64I8x16ExtractLaneU:\n                case kMips64I8x16ExtractLaneS:\n                case kMips64I8x16GeS:\n                case kMips64I8x16GeU:\n                case kMips64I8x16GtS:\n                case kMips64I8x16GtU:\n                case kMips64I8x16MaxS:\n                case kMips64I8x16MaxU:\n                case kMips64I8x16MinS:\n                case kMips64I8x16MinU:\n                case kMips64I8x16Ne:\n                case kMips64I8x16Neg:\n                case kMips64I8x16ReplaceLane:\n                case kMips64I8x16Shl:\n                case kMips64I8x16ShrS:\n                case kMips64I8x16ShrU:\n                case kMips64I8x16Splat:\n                case kMips64I8x16Sub:\n                case kMips64I8x16SubSatS:\n                case kMips64I8x16SubSatU:\n                case kMips64I8x16RoundingAverageU:\n                case kMips64I8x16Abs:\n                case kMips64I8x16Popcnt:\n                case kMips64I8x16BitMask:\n                case kMips64Ins:\n                case kMips64Lsa:\n                case kMips64MaxD:\n                case kMips64MaxS:\n                case kMips64MinD:\n                case kMips64MinS:\n                case kMips64Mod:\n                case kMips64ModU:\n                case kMips64Mov:\n                case kMips64Mul:\n                case kMips64MulD:\n                case kMips64MulHigh:\n                case kMips64MulOvf:\n                case kMips64MulS:\n                case kMips64NegD:\n                case kMips64NegS:\n                case kMips64Nor:\n                case kMips64Nor32:\n                case kMips64Or:\n                case kMips64Or32:\n                case kMips64Popcnt:\n                case kMips64Ror:\n                case kMips64RoundWD:\n                case kMips64RoundWS:\n                case kMips64S128And:\n                case kMips64S128Or:\n                case kMips64S128Not:\n                case kMips64S128Select:\n                case kMips64S128AndNot:\n                case kMips64S128Xor:\n                case kMips64S128Const:\n                case kMips64S128Zero:\n                case kMips64S128AllOnes:\n                case kMips64S16x8InterleaveEven:\n                case kMips64S16x8InterleaveOdd:\n                case kMips64S16x8InterleaveLeft:\n                case kMips64S16x8InterleaveRight:\n                case kMips64S16x8PackEven:\n                case kMips64S16x8PackOdd:\n                case kMips64S16x2Reverse:\n                case kMips64S16x4Reverse:\n                case kMips64I64x2AllTrue:\n                case kMips64I32x4AllTrue:\n                case kMips64I16x8AllTrue:\n                case kMips64I8x16AllTrue:\n                case kMips64V128AnyTrue:\n                case kMips64S32x4InterleaveEven:\n                case kMips64S32x4InterleaveOdd:\n                case kMips64S32x4InterleaveLeft:\n                case kMips64S32x4InterleaveRight:\n                case kMips64S32x4PackEven:\n                case kMips64S32x4PackOdd:\n                case kMips64S32x4Shuffle:\n                case kMips64S8x16Concat:\n                case kMips64S8x16InterleaveEven:\n                case kMips64S8x16InterleaveOdd:\n                case kMips64S8x16InterleaveLeft:\n                case kMips64S8x16InterleaveRight:\n                case kMips64S8x16PackEven:\n                case kMips64S8x16PackOdd:\n                case kMips64S8x2Reverse:\n                case kMips64S8x4Reverse:\n                case kMips64S8x8Reverse:\n                case kMips64I8x16Shuffle:\n                case kMips64I8x16Swizzle:\n                case kMips64Sar:\n                case kMips64Seb:\n                case kMips64Seh:\n                case kMips64Shl:\n                case kMips64Shr:\n                case kMips64SqrtD:\n                case kMips64SqrtS:\n                case kMips64Sub:\n                case kMips64SubD:\n                case kMips64SubS:\n                case kMips64TruncLD:\n                case kMips64TruncLS:\n                case kMips64TruncUlD:\n                case kMips64TruncUlS:\n                case kMips64TruncUwD:\n                case kMips64TruncUwS:\n                case kMips64TruncWD:\n                case kMips64TruncWS:\n                case kMips64Tst:\n                case kMips64Xor:\n                case kMips64Xor32:\n                  return kNoOpcodeFlags;\n\n                case kMips64Lb:\n                case kMips64Lbu:\n                case kMips64Ld:\n                case kMips64Ldc1:\n                case kMips64Lh:\n                case kMips64Lhu:\n                case kMips64Lw:\n                case kMips64Lwc1:\n                case kMips64Lwu:\n                case kMips64MsaLd:\n                case kMips64Peek:\n                case kMips64Uld:\n                case kMips64Uldc1:\n                case kMips64Ulh:\n                case kMips64Ulhu:\n                case kMips64Ulw:\n                case kMips64Ulwu:\n                case kMips64Ulwc1:\n                case kMips64S128LoadSplat:\n                case kMips64S128Load8x8S:\n                case kMips64S128Load8x8U:\n                case kMips64S128Load16x4S:\n                case kMips64S128Load16x4U:\n                case kMips64S128Load32x2S:\n                case kMips64S128Load32x2U:\n                case kMips64S128Load32Zero:\n                case kMips64S128Load64Zero:\n                case kMips64S128LoadLane:\n                case kMips64Word64AtomicLoadUint64:\n\n                  return kIsLoadOperation;\n\n                case kMips64ModD:\n                case kMips64MsaSt:\n                case kMips64Push:\n                case kMips64Sb:\n                case kMips64Sd:\n                case kMips64Sdc1:\n                case kMips64Sh:\n                case kMips64StackClaim:\n                case kMips64StoreToStackSlot:\n                case kMips64Sw:\n                case kMips64Swc1:\n                case kMips64Usd:\n                case kMips64Usdc1:\n                case kMips64Ush:\n                case kMips64Usw:\n                case kMips64Uswc1:\n                case kMips64Sync:\n                case kMips64S128StoreLane:\n                case kMips64StoreCompressTagged:\n                case kMips64Word64AtomicStoreWord64:\n                case kMips64Word64AtomicAddUint64:\n                case kMips64Word64AtomicSubUint64:\n                case kMips64Word64AtomicAndUint64:\n                case kMips64Word64AtomicOrUint64:\n                case kMips64Word64AtomicXorUint64:\n                case kMips64Word64AtomicExchangeUint64:\n                case kMips64Word64AtomicCompareExchangeUint64:\n                  return kHasSideEffect;\n\n        #define CASE(Name) case k##Name:\n                  COMMON_ARCH_OPCODE_LIST(CASE)\n        #undef CASE\n                  // Already covered in architecture independent code.\n                  UNREACHABLE();\n              }\n\n              UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DadduLatency\",\n            \"about\": \"Calculates the latency for the DADDU instruction.\",\n            \"logic\": \"Returns 1 if the operand is a register, otherwise returns 2 (estimated max).\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_operand_register\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the operand is a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The latency of the DADDU instruction.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            int DadduLatency(bool is_operand_register = true) {\n              if (is_operand_register) {\n                return 1;\n              } else {\n                return 2;  // Estimated max.\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DsubuLatency\",\n            \"about\": \"Calculates the latency for the DSUBU instruction.\",\n            \"logic\": \"Returns the same latency as DADDU.\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_operand_register\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the operand is a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The latency of the DSUBU instruction.\"\n            },\n            \"dependencies\": [\n                \"DadduLatency\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            int DsubuLatency(bool is_operand_register = true) {\n              return DadduLatency(is_operand_register);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AndLatency\",\n            \"about\": \"Calculates the latency for the AND instruction.\",\n            \"logic\": \"Returns the same latency as DADDU.\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_operand_register\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the operand is a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The latency of the AND instruction.\"\n            },\n            \"dependencies\": [\n                \"DadduLatency\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            int AndLatency(bool is_operand_register = true) {\n              return DadduLatency(is_operand_register);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"OrLatency\",\n            \"about\": \"Calculates the latency for the OR instruction.\",\n            \"logic\": \"Returns the same latency as DADDU.\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_operand_register\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the operand is a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The latency of the OR instruction.\"\n            },\n            \"dependencies\": [\n                \"DadduLatency\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            int OrLatency(bool is_operand_register = true) {\n              return DadduLatency(is_operand_register);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"NorLatency\",\n            \"about\": \"Calculates the latency for the NOR instruction.\",\n            \"logic\": \"Returns 1 if the operand is a register, otherwise returns 2 (estimated max).\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_operand_register\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the operand is a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The latency of the NOR instruction.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            int NorLatency(bool is_operand_register = true) {\n              if (is_operand_register) {\n                return 1;\n              } else {\n                return 2;  // Estimated max.\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"XorLatency\",\n            \"about\": \"Calculates the latency for the XOR instruction.\",\n            \"logic\": \"Returns the same latency as DADDU.\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_operand_register\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the operand is a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The latency of the XOR instruction.\"\n            },\n            \"dependencies\": [\n                \"DadduLatency\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            int XorLatency(bool is_operand_register = true) {\n              return DadduLatency(is_operand_register);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MulLatency\",\n            \"about\": \"Calculates the latency for the MUL instruction.\",\n            \"logic\": \"Returns the latency defined by `Latency::MUL` if the operand is a register, otherwise returns `Latency::MUL + 1`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_operand_register\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the operand is a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The latency of the MUL instruction.\"\n            },\n            \"dependencies\": [\n                \"Latency::MUL\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            int MulLatency(bool is_operand_register = true) {\n              if (is_operand_register) {\n                return Latency::MUL;\n              } else {\n                return Latency::MUL + 1;\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DmulLatency\",\n            \"about\": \"Calculates the latency for the DMUL instruction, considering the architecture variant.\",\n            \"logic\": \"If the architecture variant is MIPS64r6 or later, the latency is `Latency::DMUL`. Otherwise, it's `Latency"
}