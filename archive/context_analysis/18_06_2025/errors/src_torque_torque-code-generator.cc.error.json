{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/torque-code-generator.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 35, column 39",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/torque-code-generator.cc\",\n      \"file_name\": \"torque-code-generator.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Implements the TorqueCodeGenerator class, which is responsible for generating code from Torque IR.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes necessary headers for Torque code generation.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/torque/torque-code-generator.h\"\n\n#include \"src/torque/global-context.h\"\n    ]]></code>\n  </imports>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"IsEmptyInstruction\",\n        \"parent\": \"TorqueCodeGenerator\",\n        \"about\": \"Checks if an instruction is an 'empty' instruction that doesn't need to emit source position information.\",\n        \"logic\": \"Checks the instruction kind against a list of instruction kinds that are considered empty.\",\n        \"parameters\": [\n          {\n            \"name\": \"instruction\",\n            \"type\": \"const Instruction&\",\n            \"purpose\": \"The instruction to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the instruction is empty, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"Instruction\",\n          \"InstructionKind\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool TorqueCodeGenerator::IsEmptyInstruction(const Instruction& instruction) {\n  switch (instruction.kind()) {\n    case InstructionKind::kPeekInstruction:\n    case InstructionKind::kPokeInstruction:\n    case InstructionKind::kDeleteRangeInstruction:\n    case InstructionKind::kPushUninitializedInstruction:\n    case InstructionKind::kPushBuiltinPointerInstruction:\n    case InstructionKind::kUnsafeCastInstruction:\n      return true;\n    default:\n      return false;\n  }\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"EmitInstruction\",\n        \"parent\": \"TorqueCodeGenerator\",\n        \"about\": \"Emits code for a given instruction, dispatching to specific emitters based on the instruction kind.\",\n        \"logic\": \"Conditionally emits source position information (in debug mode) and then switches on the instruction kind to call the appropriate EmitInstruction overload. Includes IR annotation if enabled.\",\n        \"parameters\": [\n          {\n            \"name\": \"instruction\",\n            \"type\": \"const Instruction&\",\n            \"purpose\": \"The instruction to emit code for.\"\n          },\n          {\n            \"name\": \"stack\",\n            \"type\": \"Stack<std::string>*\",\n            \"purpose\": \"The stack used for code generation.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"Instruction\",\n          \"InstructionKind\",\n          \"Stack\",\n          \"EmitSourcePosition\",\n          \"EmitIRAnnotation\",\n          \"GlobalContext::annotate_ir\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid TorqueCodeGenerator::EmitInstruction(const Instruction& instruction,\n                                          Stack<std::string>* stack) {\n#ifdef DEBUG\n  if (!IsEmptyInstruction(instruction)) {\n    EmitSourcePosition(instruction->pos);\n  }\n#endif\n\n  switch (instruction.kind()) {\n#define ENUM_ITEM(T)                                  \\\n  case InstructionKind::k##T:                         \\\n    if (GlobalContext::annotate_ir()) {               \\\n      EmitIRAnnotation(instruction.Cast<T>(), stack); \\\n    }                                                 \\\n    return EmitInstruction(instruction.Cast<T>(), stack);\n    TORQUE_INSTRUCTION_LIST(ENUM_ITEM)\n#undef ENUM_ITEM\n  }\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"EmitInstruction\",\n        \"parent\": \"TorqueCodeGenerator\",\n        \"about\": \"Emits code for a PeekInstruction, which pushes a value from a specified slot on the stack.\",\n        \"logic\": \"Peeks the value at the given slot and pushes it onto the stack.\",\n        \"parameters\": [\n          {\n            \"name\": \"instruction\",\n            \"type\": \"const PeekInstruction&\",\n            \"purpose\": \"The PeekInstruction to emit code for.\"\n          },\n          {\n            \"name\": \"stack\",\n            \"type\": \"Stack<std::string>*\",\n            \"purpose\": \"The stack used for code generation.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"PeekInstruction\",\n          \"Stack\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid TorqueCodeGenerator::EmitInstruction(const PeekInstruction& instruction,\n                                          Stack<std::string>* stack) {\n  stack->Push(stack->Peek(instruction.slot));\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"EmitInstruction\",\n        \"parent\": \"TorqueCodeGenerator\",\n        \"about\": \"Emits code for a PokeInstruction, which replaces a value at a specified slot on the stack with the top of the stack.\",\n        \"logic\": \"Pokes (replaces) the value at the given slot with the top of the stack, and then pops the top of the stack.\",\n        \"parameters\": [\n          {\n            \"name\": \"instruction\",\n            \"type\": \"const PokeInstruction&\",\n            \"purpose\": \"The PokeInstruction to emit code for.\"\n          },\n          {\n            \"name\": \"stack\",\n            \"type\": \"Stack<std::string>*\",\n            \"purpose\": \"The stack used for code generation.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"PokeInstruction\",\n          \"Stack\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid TorqueCodeGenerator::EmitInstruction(const PokeInstruction& instruction,\n                                          Stack<std::string>* stack) {\n  stack->Poke(instruction.slot, stack->Top());\n  stack->Pop();\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"EmitInstruction\",\n        \"parent\": \"TorqueCodeGenerator\",\n        \"about\": \"Emits code for a DeleteRangeInstruction, which removes a range of elements from the stack.\",\n        \"logic\": \"Deletes the specified range of elements from the stack.\",\n        \"parameters\": [\n          {\n            \"name\": \"instruction\",\n            \"type\": \"const DeleteRangeInstruction&\",\n            \"purpose\": \"The DeleteRangeInstruction to emit code for.\"\n          },\n          {\n            \"name\": \"stack\",\n            \"type\": \"Stack<std::string>*\",\n            \"purpose\": \"The stack used for code generation.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"DeleteRangeInstruction\",\n          \"Stack\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid TorqueCodeGenerator::EmitInstruction(\n    const DeleteRangeInstruction& instruction, Stack<std::string>* stack) {\n  stack->DeleteRange(instruction.range);\n}\n    ]]></code>\n  </func>\n  <dependencies>\n    <class>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"class\",\n          \"name\": \"TorqueCodeGenerator\",\n          \"about\": \"Abstract base class for Torque code generators.\",\n          \"dependencies\": [\n            \"Instruction\",\n            \"InstructionKind\",\n            \"Stack\"\n          ]\n        }\n      </metadata>\n      <code><![CDATA[\n        class TorqueCodeGenerator {\n         public:\n          virtual ~TorqueCodeGenerator() = default;\n\n          static bool IsEmptyInstruction(const Instruction& instruction);\n          void EmitInstruction(const Instruction& instruction,\n                                Stack<std::string>* stack);\n\n         protected:\n          virtual void EmitInstruction(const PeekInstruction& instruction,\n                                          Stack<std::string>* stack) = 0;\n          virtual void EmitInstruction(const PokeInstruction& instruction,\n                                          Stack<std::string>* stack) = 0;\n          virtual void EmitInstruction(\n            const DeleteRangeInstruction& instruction, Stack<std::string>* stack) = 0;\n        };\n      ]]></code>\n    </class>\n    <class>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"class\",\n          \"name\": \"Instruction\",\n          \"about\": \"Base class for all Torque IR instructions.\"\n        }\n      </metadata>\n      <code><![CDATA[\n        class Instruction {\n         public:\n          enum Kind {\n            kPeekInstruction,\n            kPokeInstruction,\n            kDeleteRangeInstruction,\n            kPushUninitializedInstruction,\n            kPushBuiltinPointerInstruction,\n            kUnsafeCastInstruction\n          };\n\n          Kind kind() const { return kind_; }\n         private:\n          Kind kind_;\n        };\n      ]]></code>\n    </class>\n    <class>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"class\",\n          \"name\": \"PeekInstruction\",\n          \"about\": \"Represents an instruction to peek a value from the stack.\"\n        }\n      </metadata>\n      <code><![CDATA[\n        class PeekInstruction : public Instruction {\n         public:\n          int slot;\n        };\n      ]]></code>\n    </class>\n    <class>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"class\",\n          \"name\": \"PokeInstruction\",\n          \"about\": \"Represents an instruction to poke a value onto the stack.\"\n        }\n      </metadata>\n      <code><![CDATA[\n        class PokeInstruction : public Instruction {\n         public:\n          int slot;\n        };\n      ]]></code>\n    </class>\n     <class>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"class\",\n          \"name\": \"DeleteRangeInstruction\",\n          \"about\": \"Represents an instruction to delete a range from stack.\"\n        }\n      </metadata>\n      <code><![CDATA[\n        class DeleteRangeInstruction : public Instruction {\n         public:\n          int range;\n        };\n      ]]></code>\n    </class>\n     <class>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"class\",\n          \"name\": \"Stack\",\n          \"about\": \"Represents stack of strings.\"\n        }\n      </metadata>\n      <code><![CDATA[\n        template <typename T>\n        class Stack {\n         public:\n          void Push(const T& value);\n          T Peek(int slot) const;\n          T Top() const;\n          void Poke(int slot, const T& value);\n          void Pop();\n          void DeleteRange(int range);\n        };\n      ]]></code>\n    </class>\n  </dependencies>\n</file>\n```"
}