{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/frame-translation-builder.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/frame-translation-builder.cc\",\n            \"file_name\": \"frame-translation-builder.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Builds frame translations for deoptimization, which are used to reconstruct the state of a JavaScript frame when deoptimization occurs.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for frame translation building, optional, base utilities, translated state, objects, and compression utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/deoptimizer/frame-translation-builder.h\"\n\n            #include <optional>\n\n            #include \"src/base/vlq.h\"\n            #include \"src/deoptimizer/translated-state.h\"\n            #include \"src/objects/fixed-array-inl.h\"\n\n            #ifdef V8_USE_ZLIB\n            #include \"third_party/zlib/google/compression_utils_portable.h\"\n            #endif  // V8_USE_ZLIB\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OperandBase\",\n                \"about\": \"Base class for operands used in frame translations. Holds the operand value.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"value_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the operand value.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class OperandBase {\n            public:\n            explicit OperandBase(uint32_t value) : value_(value) {}\n            uint32_t value() const { return value_; }\n\n            private:\n            uint32_t value_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SmallUnsignedOperand\",\n                \"extends\": \"OperandBase\",\n                \"about\": \"Represents a small unsigned operand. Uses VLQ encoding.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OperandBase\",\n                    \"base::kDataMask\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class SmallUnsignedOperand : public OperandBase {\n            public:\n            explicit SmallUnsignedOperand(uint32_t value) : OperandBase(value) {\n                DCHECK_LE(value, base::kDataMask);\n            }\n            void WriteVLQ(ZoneVector<uint8_t>* buffer) { buffer->push_back(value()); }\n            bool IsSigned() const { return false; }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UnsignedOperand\",\n                \"extends\": \"OperandBase\",\n                \"about\": \"Represents an unsigned operand. Uses VLQ encoding.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OperandBase\",\n                    \"base::VLQEncodeUnsigned\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class UnsignedOperand : public OperandBase {\n            public:\n            explicit UnsignedOperand(int32_t value)\n                : UnsignedOperand(static_cast<uint32_t>(value)) {\n                DCHECK_GE(value, 0);\n            }\n            explicit UnsignedOperand(uint32_t value) : OperandBase(value) {}\n            void WriteVLQ(ZoneVector<uint8_t>* buffer) {\n                base::VLQEncodeUnsigned(\n                    [buffer](uint8_t value) { buffer->push_back(value); }, value());\n            }\n            bool IsSigned() const { return false; }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SignedOperand\",\n                \"extends\": \"OperandBase\",\n                \"about\": \"Represents a signed operand. Uses VLQ encoding.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OperandBase\",\n                    \"base::VLQEncode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class SignedOperand : public OperandBase {\n            public:\n            explicit SignedOperand(int32_t value) : OperandBase(value) {}\n            // Use UnsignedOperand for unsigned values.\n            explicit SignedOperand(uint32_t value) = delete;\n            void WriteVLQ(ZoneVector<uint8_t>* buffer) {\n                base::VLQEncode(\n                    [buffer](uint8_t value) {\n                        buffer->push_back(value);\n                        return &buffer->back();\n                    },\n                    value());\n            }\n            bool IsSigned() const { return true; }\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"OperandsEqual\",\n                \"about\": \"Compares a variable number of operands to an array of expected operands.\",\n                \"logic\": \"Uses a fold expression to compare each operand's value with the corresponding value in the expected_operands array.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"expected_operands\",\n                        \"type\": \"uint32_t*\",\n                        \"purpose\": \"Pointer to an array of expected operand values.\"\n                    },\n                    {\n                        \"name\": \"operands\",\n                        \"type\": \"T...\",\n                        \"purpose\": \"Variable number of operand objects derived from OperandBase.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if all operands are equal to their corresponding expected values, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"OperandBase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename... T>\n            inline bool OperandsEqual(uint32_t* expected_operands, T... operands) {\n            return (... && (*(expected_operands++) == operands.value()));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddRawToContents\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a raw translation opcode and its operands to the contents_ vector.\",\n                \"logic\": \"Appends the opcode and operand values to the contents_ vector. Performs a check that the number of provided operands matches the expected operand count for the given opcode.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"TranslationOpcode\",\n                        \"purpose\": \"The translation opcode to add.\"\n                    },\n                    {\n                        \"name\": \"operands\",\n                        \"type\": \"T...\",\n                        \"purpose\": \"Variable number of operand objects (SmallUnsignedOperand, UnsignedOperand, SignedOperand).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TranslationOpcode\",\n                    \"TranslationOpcodeOperandCount\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename... T>\n            void FrameTranslationBuilder::AddRawToContents(TranslationOpcode opcode,\n                                                        T... operands) {\n            DCHECK_EQ(sizeof...(T), TranslationOpcodeOperandCount(opcode));\n            DCHECK(!v8_flags.turbo_compress_frame_translations);\n            contents_.push_back(static_cast<uint8_t>(opcode));\n            (..., operands.WriteVLQ(&contents_));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddRawToContentsForCompression\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a raw translation opcode and its operands to the contents_for_compression_ vector.\",\n                \"logic\": \"Appends the opcode and raw operand values to the contents_for_compression_ vector when turbo_compress_frame_translations flag is enabled. Performs a check that the number of provided operands matches the expected operand count for the given opcode.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"TranslationOpcode\",\n                        \"purpose\": \"The translation opcode to add.\"\n                    },\n                    {\n                        \"name\": \"operands\",\n                        \"type\": \"T...\",\n                        \"purpose\": \"Variable number of operand objects (SmallUnsignedOperand, UnsignedOperand, SignedOperand).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TranslationOpcode\",\n                    \"TranslationOpcodeOperandCount\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename... T>\n            void FrameTranslationBuilder::AddRawToContentsForCompression(\n                TranslationOpcode opcode, T... operands) {\n            DCHECK_EQ(sizeof...(T), TranslationOpcodeOperandCount(opcode));\n            DCHECK(v8_flags.turbo_compress_frame_translations);\n            contents_for_compression_.push_back(static_cast<uint8_t>(opcode));\n            (..., contents_for_compression_.push_back(operands.value()));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddRawBegin\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a raw BEGIN opcode (with or without feedback) to the contents_ or contents_for_compression_ vector.\",\n                \"logic\": \"Chooses the correct BEGIN opcode based on the update_feedback flag. Calls either AddRawToContents or AddRawToContentsForCompression based on the turbo_compress_frame_translations flag. Includes slow asserts for debugging.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"update_feedback\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether to use the BEGIN opcode that includes feedback.\"\n                    },\n                    {\n                        \"name\": \"operands\",\n                        \"type\": \"T...\",\n                        \"purpose\": \"Variable number of operand objects (UnsignedOperand, SignedOperand).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TranslationOpcode\",\n                    \"AddRawToContents\",\n                    \"AddRawToContentsForCompression\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename... T>\n            void FrameTranslationBuilder::AddRawBegin(bool update_feedback, T... operands) {\n            auto opcode = update_feedback ? TranslationOpcode::BEGIN_WITH_FEEDBACK\n                                        : TranslationOpcode::BEGIN_WITHOUT_FEEDBACK;\n            if (V8_UNLIKELY(v8_flags.turbo_compress_frame_translations)) {\n                AddRawToContentsForCompression(opcode, operands...);\n            } else {\n                AddRawToContents(opcode, operands...);\n            #ifdef ENABLE_SLOW_DCHECKS\n                if (v8_flags.enable_slow_asserts) {\n                all_instructions_.emplace_back(opcode, operands...);\n                }\n            #endif\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BeginTranslation\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Begins a new frame translation sequence.  Handles reuse of existing 'basis' translations to optimize size.\",\n                \"logic\": \"Determines whether to reuse a previous basis translation or start a new one based on the success of the previous translation. Adds a BEGIN opcode with the distance from the last start index, frame count, and JavaScript frame count.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"frame_count\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The total number of frames in the translation.\"\n                    },\n                    {\n                        \"name\": \"jsframe_count\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of JavaScript frames in the translation.\"\n                    },\n                    {\n                        \"name\": \"update_feedback\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether to update feedback during deoptimization.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The start index of the translation in the contents_ vector.\"\n                },\n                \"dependencies\": [\n                    \"FinishPendingInstructionIfNeeded\",\n                    \"Size\",\n                    \"AddRawBegin\",\n                    \"UnsignedOperand\",\n                    \"SignedOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            int FrameTranslationBuilder::BeginTranslation(int frame_count,\n                                                        int jsframe_count,\n                                                        bool update_feedback) {\n            FinishPendingInstructionIfNeeded();\n            int start_index = Size();\n            int distance_from_last_start = 0;\n\n            // We should reuse an existing basis translation if:\n            // - we just finished writing the basis translation\n            //   (match_previous_allowed_ is false), or\n            // - the translation we just finished was moderately successful at reusing\n            //   instructions from the basis translation. We'll define \"moderately\n            //   successful\" as reusing more than 3/4 of the basis instructions.\n            // Otherwise we should reset and write a new basis translation. At the\n            // beginning, match_previous_allowed_ is initialized to true so that this\n            // logic decides to start a new basis translation.\n            if (!match_previous_allowed_ ||\n                total_matching_instructions_in_current_translation_ >\n                    instruction_index_within_translation_ / 4 * 3) {\n                // Use the existing basis translation.\n                distance_from_last_start = start_index - index_of_basis_translation_start_;\n                match_previous_allowed_ = true;\n            } else {\n                // Abandon the existing basis translation and write a new one.\n                basis_instructions_.clear();\n                index_of_basis_translation_start_ = start_index;\n                match_previous_allowed_ = false;\n            }\n\n            total_matching_instructions_in_current_translation_ = 0;\n            instruction_index_within_translation_ = 0;\n\n            // BEGIN instructions can't be replaced by MATCH_PREVIOUS_TRANSLATION, so\n            // use a special helper function rather than calling Add().\n            AddRawBegin(update_feedback, UnsignedOperand(distance_from_last_start),\n                        SignedOperand(frame_count), SignedOperand(jsframe_count));\n            return start_index;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FinishPendingInstructionIfNeeded\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Finishes a pending MATCH_PREVIOUS_TRANSLATION instruction if there are any matching instructions.\",\n                \"logic\": \"If matching_instructions_count_ is greater than 0, it appends a MATCH_PREVIOUS_TRANSLATION opcode or a short form of it to the contents_ vector, then resets matching_instructions_count_ to 0.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AddRawToContents\",\n                    \"TranslationOpcode\",\n                    \"UnsignedOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void FrameTranslationBuilder::FinishPendingInstructionIfNeeded() {\n            if (matching_instructions_count_) {\n                total_matching_instructions_in_current_translation_ +=\n                    matching_instructions_count_;\n\n                // There is a short form for the MATCH_PREVIOUS_TRANSLATION instruction\n                // because it's the most common opcode: rather than spending a byte on the\n                // opcode and a second byte on the operand, we can use only a single byte\n                // which doesn't match any valid opcode.\n                const int kMaxShortenableOperand =\n                    std::numeric_limits<uint8_t>::max() - kNumTranslationOpcodes;\n                if (matching_instructions_count_ <= kMaxShortenableOperand) {\n                contents_.push_back(kNumTranslationOpcodes +\n                                    matching_instructions_count_);\n                } else {\n                // The operand didn't fit in the opcode byte, so encode it normally.\n                AddRawToContents(\n                    TranslationOpcode::MATCH_PREVIOUS_TRANSLATION,\n                    UnsignedOperand(static_cast<uint32_t>(matching_instructions_count_)));\n                }\n                matching_instructions_count_ = 0;\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Add\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a translation opcode and its operands to the frame translation. Manages matching instructions against a basis translation.\",\n                \"logic\": \"Checks if the instruction matches the corresponding instruction in the basis translation. If it matches, increments matching_instructions_count_. Otherwise, finishes the pending MATCH_PREVIOUS_TRANSLATION instruction and adds the current instruction to the contents_ vector and basis_instructions_ if not already present.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"TranslationOpcode\",\n                        \"purpose\": \"The translation opcode to add.\"\n                    },\n                    {\n                        \"name\": \"operands\",\n                        \"type\": \"T...\",\n                        \"purpose\": \"Variable number of operand objects (SmallUnsignedOperand, UnsignedOperand, SignedOperand).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TranslationOpcode\",\n                    \"TranslationOpcodeOperandCount\",\n                    \"AddRawToContentsForCompression\",\n                    \"FinishPendingInstructionIfNeeded\",\n                    \"AddRawToContents\",\n                    \"OperandsEqual\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename... T>\n            void FrameTranslationBuilder::Add(TranslationOpcode opcode, T... operands) {\n            DCHECK_EQ(sizeof...(T), TranslationOpcodeOperandCount(opcode));\n            if (V8_UNLIKELY(v8_flags.turbo_compress_frame_translations)) {\n                AddRawToContentsForCompression(opcode, operands...);\n                return;\n            }\n            #ifdef ENABLE_SLOW_DCHECKS\n            if (v8_flags.enable_slow_asserts) {\n                all_instructions_.emplace_back(opcode, operands...);\n            }\n            #endif\n            if (match_previous_allowed_ &&\n                instruction_index_within_translation_ < basis_instructions_.size() &&\n                opcode ==\n                    basis_instructions_[instruction_index_within_translation_].opcode &&\n                OperandsEqual(\n                    basis_instructions_[instruction_index_within_translation_].operands,\n                    operands...)) {\n                ++matching_instructions_count_;\n            } else {\n                FinishPendingInstructionIfNeeded();\n                AddRawToContents(opcode, operands...);\n                if (!match_previous_allowed_) {\n                // Include this instruction in basis_instructions_ so that future\n                // translations can check whether they match with it.\n                DCHECK_EQ(basis_instructions_.size(),\n                            instruction_index_within_translation_);\n                basis_instructions_.emplace_back(opcode, operands...);\n                }\n            }\n            ++instruction_index_within_translation_;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ToFrameTranslation\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Converts the built frame translation into a DeoptimizationFrameTranslation object.\",\n                \"logic\": \"Compresses the frame translation data if turbo_compress_frame_translations is enabled. Otherwise, creates a DeoptimizationFrameTranslation object and copies the contents_ into it. Includes slow asserts for debugging.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"factory\",\n                        \"type\": \"LocalFactory*\",\n                        \"purpose\": \"The factory used to create the DeoptimizationFrameTranslation object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"DirectHandle<DeoptimizationFrameTranslation>\",\n                    \"description\": \"A handle to the newly created DeoptimizationFrameTranslation object.\"\n                },\n                \"dependencies\": [\n                    \"FinishPendingInstructionIfNeeded\",\n                    \"SizeInBytes\",\n                    \"LocalFactory\",\n                    \"NewDeoptimizationFrameTranslation\",\n                    \"DeoptimizationFrameTranslation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            DirectHandle<DeoptimizationFrameTranslation>\n            FrameTranslationBuilder::ToFrameTranslation(LocalFactory* factory) {\n            #ifdef V8_USE_ZLIB\n            if (V8_UNLIKELY(v8_flags.turbo_compress_frame_translations)) {\n                const int input_size = SizeInBytes();\n                uLongf compressed_data_size = compressBound(input_size);\n\n                ZoneVector<uint8_t> compressed_data(compressed_data_size, zone());\n\n                CHECK_EQ(\n                    zlib_internal::CompressHelper(\n                        zlib_internal::ZRAW, compressed_data.data(), &compressed_data_size,\n                        reinterpret_cast<const Bytef*>(contents_for_compression_.data()),\n                        input_size, Z_DEFAULT_COMPRESSION, nullptr, nullptr),\n                    Z_OK);\n\n                const int translation_array_size =\n                    static_cast<int>(compressed_data_size) +\n                    DeoptimizationFrameTranslation::kUncompressedSizeSize;\n                DirectHandle<DeoptimizationFrameTranslation> result =\n                    factory->NewDeoptimizationFrameTranslation(translation_array_size);\n\n                result->set_int(DeoptimizationFrameTranslation::kUncompressedSizeOffset,\n                                Size());\n                std::memcpy(\n                    result->begin() + DeoptimizationFrameTranslation::kCompressedDataOffset,\n                    compressed_data.data(), compressed_data_size);\n\n                return result;\n            }\n            #endif\n            DCHECK(!v8_flags.turbo_compress_frame_translations);\n            FinishPendingInstructionIfNeeded();\n            DirectHandle<DeoptimizationFrameTranslation> result =\n                factory->NewDeoptimizationFrameTranslation(SizeInBytes());\n            if (SizeInBytes() == 0) return result;\n            memcpy(result->begin(), contents_.data(), contents_.size() * sizeof(uint8_t));\n            #ifdef ENABLE_SLOW_DCHECKS\n            DeoptimizationFrameTranslation::Iterator iter(*result, 0);\n            ValidateBytes(iter);\n            #endif\n            return result;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ToFrameTranslationWasm\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Returns the frame translation as a base::Vector of bytes for WebAssembly.\",\n                \"logic\": \"Finishes any pending instructions and returns a copy of the contents_ vector as a base::Vector.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"base::Vector<const uint8_t>\",\n                    \"description\": \"A base::Vector containing the frame translation data.\"\n                },\n                \"dependencies\": [\n                    \"FinishPendingInstructionIfNeeded\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            base::Vector<const uint8_t> FrameTranslationBuilder::ToFrameTranslationWasm() {\n            DCHECK(!v8_flags.turbo_compress_frame_translations);\n            FinishPendingInstructionIfNeeded();\n            base::Vector<const uint8_t> result = base::VectorOf(contents_);\n            #ifdef ENABLE_SLOW_DCHECKS\n            DeoptTranslationIterator iter(result, 0);\n            ValidateBytes(iter);\n            #endif\n            return result;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ValidateBytes\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Validates the bytes in the frame translation against the expected instructions.\",\n                \"logic\": \"Iterates through the all_instructions_ vector and checks that the opcodes and operands match the expected values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"iter\",\n                        \"type\": \"DeoptTranslationIterator&\",\n                        \"purpose\": \"The iterator used to read the frame translation data.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"DeoptTranslationIterator\",\n                    \"TranslationOpcodeOperandCount\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void FrameTranslationBuilder::ValidateBytes(\n                DeoptTranslationIterator& iter) const {\n            #ifdef ENABLE_SLOW_DCHECKS\n            if (v8_flags.enable_slow_asserts) {\n                // Check that we can read back all of the same content we intended to write.\n                for (size_t i = 0; i < all_instructions_.size(); ++i) {\n                CHECK(iter.HasNextOpcode());\n                const Instruction& instruction = all_instructions_[i];\n                CHECK_EQ(instruction.opcode, iter.NextOpcode());\n                for (int j = 0; j < TranslationOpcodeOperandCount(instruction.opcode);\n                    ++j) {\n                    uint32_t operand = instruction.is_operand_signed[j]\n                                    ? iter.NextOperand()\n                                    : iter.NextOperandUnsigned();\n                    CHECK_EQ(instruction.operands[j], operand);\n                }\n                }\n            }\n            #endif\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BeginBuiltinContinuationFrame\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a BEGIN_BUILTIN_CONTINUATION_FRAME opcode to the frame translation.\",\n                \"logic\": \"Adds the opcode and its operands (bytecode_offset, literal_id, and height) to the translation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"bytecode_offset\",\n                        \"type\": \"BytecodeOffset\",\n                        \"purpose\": \"The bytecode offset.\"\n                    },\n                    {\n                        \"name\": \"literal_id\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The literal ID.\"\n                    },\n                    {\n                        \"name\": \"height\",\n                        \"type\": \"unsigned\",\n                        \"purpose\": \"The frame height.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Add\",\n                    \"TranslationOpcode\",\n                    \"SignedOperand\",\n                    \"UnsignedOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void FrameTranslationBuilder::BeginBuiltinContinuationFrame(\n                BytecodeOffset bytecode_offset, int literal_id, unsigned height) {\n            auto opcode = TranslationOpcode::BUILTIN_CONTINUATION_FRAME;\n            Add(opcode, SignedOperand(bytecode_offset.ToInt()), SignedOperand(literal_id),\n                UnsignedOperand(height));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BeginJSToWasmBuiltinContinuationFrame\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a JS_TO_WASM_BUILTIN_CONTINUATION_FRAME opcode to the frame translation.\",\n                \"logic\": \"Adds the opcode and its operands to the translation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"bytecode_offset\",\n                        \"type\": \"BytecodeOffset\",\n                        \"purpose\": \"The bytecode offset.\"\n                    },\n                    {\n                        \"name\": \"literal_id\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The literal ID.\"\n                    },\n                    {\n                        \"name\": \"height\",\n                        \"type\": \"unsigned\",\n                        \"purpose\": \"The frame height.\"\n                    },\n                    {\n                        \"name\": \"return_kind\",\n                        \"type\": \"std::optional<wasm::ValueKind>\",\n                        \"purpose\": \"The optional WebAssembly value kind to return.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Add\",\n                    \"TranslationOpcode\",\n                    \"SignedOperand\",\n                    \"UnsignedOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_ENABLE_WEBASSEMBLY\n            void FrameTranslationBuilder::BeginJSToWasmBuiltinContinuationFrame(\n                BytecodeOffset bytecode_offset, int literal_id, unsigned height,\n                std::optional<wasm::ValueKind> return_kind) {\n            auto opcode = TranslationOpcode::JS_TO_WASM_BUILTIN_CONTINUATION_FRAME;\n            Add(opcode, SignedOperand(bytecode_offset.ToInt()), SignedOperand(literal_id),\n                UnsignedOperand(height),\n                SignedOperand(return_kind ? static_cast<int>(return_kind.value())\n                                        : kNoWasmReturnKind));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BeginWasmInlinedIntoJSFrame\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a WASM_INLINED_INTO_JS_FRAME opcode to the frame translation.\",\n                \"logic\": \"Adds the opcode and its operands to the translation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"bailout_id\",\n                        \"type\": \"BytecodeOffset\",\n                        \"purpose\": \"The bailout ID.\"\n                    },\n                    {\n                        \"name\": \"literal_id\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The literal ID.\"\n                    },\n                    {\n                        \"name\": \"height\",\n                        \"type\": \"unsigned\",\n                        \"purpose\": \"The frame height.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Add\",\n                    \"TranslationOpcode\",\n                    \"SignedOperand\",\n                    \"UnsignedOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void FrameTranslationBuilder::BeginWasmInlinedIntoJSFrame(\n                BytecodeOffset bailout_id, int literal_id, unsigned height) {\n            auto opcode = TranslationOpcode::WASM_INLINED_INTO_JS_FRAME;\n            Add(opcode, SignedOperand(bailout_id.ToInt()), SignedOperand(literal_id),\n                UnsignedOperand(height));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BeginLiftoffFrame\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a LIFTOFF_FRAME opcode to the frame translation.\",\n                \"logic\": \"Adds the opcode and its operands to the translation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"bailout_id\",\n                        \"type\": \"BytecodeOffset\",\n                        \"purpose\": \"The bailout ID.\"\n                    },\n                    {\n                        \"name\": \"height\",\n                        \"type\": \"unsigned\",\n                        \"purpose\": \"The frame height.\"\n                    },\n                    {\n                        \"name\": \"wasm_function_index\",\n                        \"type\": \"uint32_t\",\n                        \"purpose\": \"The WebAssembly function index.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Add\",\n                    \"TranslationOpcode\",\n                    \"SignedOperand\",\n                    \"UnsignedOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void FrameTranslationBuilder::BeginLiftoffFrame(BytecodeOffset bailout_id,\n                                                        unsigned height,\n                                                        uint32_t wasm_function_index) {\n            auto opcode = TranslationOpcode::LIFTOFF_FRAME;\n            Add(opcode, SignedOperand(bailout_id.ToInt()), UnsignedOperand(height),\n                UnsignedOperand(wasm_function_index));\n            }\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BeginJavaScriptBuiltinContinuationFrame\",\n                \"parent\": \"FrameTranslationBuilder\",\n                \"about\": \"Adds a JAVASCRIPT_BUILTIN_CONTINUATION_FRAME opcode to the frame translation.\",\n                \"logic\": \"Adds the opcode and its operands to the translation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"bytecode_offset\",\n                        \"type\": \"BytecodeOffset\",\n                        \"purpose\": \"The bytecode offset.\"\n                    },\n                    {\n                        \"name\": \"literal_id\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The literal ID"
}