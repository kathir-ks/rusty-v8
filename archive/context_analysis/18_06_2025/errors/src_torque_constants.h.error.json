{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/constants.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 135, column 51",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/constants.h\",\n            \"file_name\": \"constants.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines constant strings, flags, and inline functions used in the Torque language and code generator.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers for string manipulation and data structures.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstring>\n            #include <string>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the base::Flags class for managing enum flags.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/flags.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"AbstractTypeFlag\",\n                \"about\": \"Defines flags related to abstract types in Torque.\",\n                \"dependencies\": [\n                    \"base::Flags\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class AbstractTypeFlag {\n              kNone = 0,\n              kTransient = 1 << 0,\n              kConstexpr = 1 << 1,\n              kUseParentTypeChecker = 1 << 2,\n            };\n            using AbstractTypeFlags = base::Flags<AbstractTypeFlag>;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"ClassFlag\",\n                \"about\": \"Defines flags related to classes in Torque.\",\n                \"dependencies\": [\n                    \"base::Flags\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class ClassFlag {\n              kNone = 0,\n              kExtern = 1 << 0,\n              kTransient = 1 << 1,\n              kAbstract = 1 << 2,\n              kIsShape = 1 << 3,\n              kHasSameInstanceTypeAsParent = 1 << 4,\n              kGenerateCppClassDefinitions = 1 << 5,\n              kHighestInstanceTypeWithinParent = 1 << 6,\n              kLowestInstanceTypeWithinParent = 1 << 7,\n              kUndefinedLayout = 1 << 8,\n              kGenerateBodyDescriptor = 1 << 9,\n              kExport = 1 << 10,\n              kDoNotGenerateCast = 1 << 11,\n              kGenerateUniqueMap = 1 << 12,\n              kGenerateFactoryFunction = 1 << 13,\n              kCppObjectDefinition = 1 << 14,\n              kCppObjectLayoutDefinition = 1 << 15,\n            };\n            using ClassFlags = base::Flags<ClassFlag>;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"StructFlag\",\n                \"about\": \"Defines flags related to structs in Torque.\",\n                \"dependencies\": [\n                    \"base::Flags\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class StructFlag { kNone = 0, kExport = 1 << 0 };\n            using StructFlags = base::Flags<StructFlag>;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"FieldSynchronization\",\n                \"about\": \"Defines enum to specify the synchronization semantics to use when generating accesses for a field\"\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class FieldSynchronization {\n              kNone,\n              kRelaxed,\n              kAcquireRelease,\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsConstexprName\",\n                \"about\": \"Checks if a type name starts with the constexpr prefix.\",\n                \"logic\": \"Uses `name.substr` and `std::strlen` to compare the beginning of the input string with the `CONSTEXPR_TYPE_PREFIX`.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The type name to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the name starts with the constexpr prefix, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            inline bool IsConstexprName(const std::string& name) {\n              return name.substr(0, std::strlen(CONSTEXPR_TYPE_PREFIX)) ==\n                     CONSTEXPR_TYPE_PREFIX;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetNonConstexprName\",\n                \"about\": \"Removes the constexpr prefix from a type name if it exists.\",\n                \"logic\": \"Checks if the name is a constexpr name using IsConstexprName. If it is, it returns a substring without the prefix; otherwise, it returns the original name.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The type name to process.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"The type name without the constexpr prefix, or the original name if it didn't have the prefix.\"\n                },\n                \"dependencies\": [\n                    \"IsConstexprName\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::string GetNonConstexprName(const std::string& name) {\n              if (!IsConstexprName(name)) return name;\n              return name.substr(std::strlen(CONSTEXPR_TYPE_PREFIX));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetConstexprName\",\n                \"about\": \"Adds the constexpr prefix to a type name if it doesn't already have it.\",\n                \"logic\": \"Checks if the name is already a constexpr name using IsConstexprName. If it isn't, it prepends the `CONSTEXPR_TYPE_PREFIX`; otherwise, it returns the original name.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The type name to process.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"The type name with the constexpr prefix, or the original name if it already had the prefix.\"\n                },\n                \"dependencies\": [\n                    \"IsConstexprName\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::string GetConstexprName(const std::string& name) {\n              if (IsConstexprName(name)) return name;\n              return CONSTEXPR_TYPE_PREFIX + name;\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"v8::internal::torque\",\n                \"about\": \"Namespace containing Torque-related constants and functions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace internal {\n            namespace torque {\n            static const char* const CONSTEXPR_TYPE_PREFIX = \"constexpr \";\n            static const char* const NEVER_TYPE_STRING = \"never\";\n            static const char* const CONSTEXPR_BOOL_TYPE_STRING = \"constexpr bool\";\n            static const char* const CONSTEXPR_STRING_TYPE_STRING = \"constexpr string\";\n            static const char* const CONSTEXPR_INTPTR_TYPE_STRING = \"constexpr intptr\";\n            static const char* const CONSTEXPR_INSTANCE_TYPE_TYPE_STRING =\n                \"constexpr InstanceType\";\n            static const char* const BOOL_TYPE_STRING = \"bool\";\n            static const char* const VOID_TYPE_STRING = \"void\";\n            static const char* const ARGUMENTS_TYPE_STRING = \"Arguments\";\n            static const char* const CONTEXT_TYPE_STRING = \"Context\";\n            static const char* const NO_CONTEXT_TYPE_STRING = \"NoContext\";\n            static const char* const NATIVE_CONTEXT_TYPE_STRING = \"NativeContext\";\n            static const char* const JS_FUNCTION_TYPE_STRING = \"JSFunction\";\n            static const char* const MAP_TYPE_STRING = \"Map\";\n            static const char* const OBJECT_TYPE_STRING = \"Object\";\n            static const char* const HEAP_OBJECT_TYPE_STRING = \"HeapObject\";\n            static const char* const TAGGED_ZERO_PATTERN_TYPE_STRING = \"TaggedZeroPattern\";\n            static const char* const JSANY_TYPE_STRING = \"JSAny\";\n            static const char* const JSOBJECT_TYPE_STRING = \"JSObject\";\n            static const char* const SMI_TYPE_STRING = \"Smi\";\n            static const char* const TAGGED_TYPE_STRING = \"Tagged\";\n            static const char* const STRONG_TAGGED_TYPE_STRING = \"StrongTagged\";\n            static const char* const UNINITIALIZED_TYPE_STRING = \"Uninitialized\";\n            static const char* const UNINITIALIZED_HEAP_OBJECT_TYPE_STRING =\n                \"UninitializedHeapObject\";\n            static const char* const RAWPTR_TYPE_STRING = \"RawPtr\";\n            static const char* const EXTERNALPTR_TYPE_STRING = \"ExternalPointer\";\n            static const char* const CPPHEAPPTR_TYPE_STRING = \"CppHeapPointer\";\n            static const char* const TRUSTEDPTR_TYPE_STRING = \"TrustedPointer\";\n            static const char* const PROTECTEDPTR_TYPE_STRING = \"ProtectedPointer\";\n            static const char* const DISPATCH_HANDLE_TYPE_STRING = \"DispatchHandle\";\n            static const char* const CONST_STRING_TYPE_STRING = \"constexpr string\";\n            static const char* const STRING_TYPE_STRING = \"String\";\n            static const char* const NUMBER_TYPE_STRING = \"Number\";\n            static const char* const BUILTIN_POINTER_TYPE_STRING = \"BuiltinPtr\";\n            static const char* const INTPTR_TYPE_STRING = \"intptr\";\n            static const char* const UINTPTR_TYPE_STRING = \"uintptr\";\n            static const char* const INT64_TYPE_STRING = \"int64\";\n            static const char* const UINT64_TYPE_STRING = \"uint64\";\n            static const char* const INT31_TYPE_STRING = \"int31\";\n            static const char* const INT32_TYPE_STRING = \"int32\";\n            static const char* const UINT31_TYPE_STRING = \"uint31\";\n            static const char* const UINT32_TYPE_STRING = \"uint32\";\n            static const char* const INT16_TYPE_STRING = \"int16\";\n            static const char* const UINT16_TYPE_STRING = \"uint16\";\n            static const char* const INT8_TYPE_STRING = \"int8\";\n            static const char* const UINT8_TYPE_STRING = \"uint8\";\n            static const char* const BINT_TYPE_STRING = \"bint\";\n            static const char* const CHAR8_TYPE_STRING = \"char8\";\n            static const char* const CHAR16_TYPE_STRING = \"char16\";\n            static const char* const FLOAT16_RAW_BITS_TYPE_STRING = \"float16_raw_bits\";\n            static const char* const FLOAT32_TYPE_STRING = \"float32\";\n            static const char* const FLOAT64_TYPE_STRING = \"float64\";\n            static const char* const FLOAT64_OR_UNDEFINED_OR_HOLE_TYPE_STRING =\n                \"float64_or_undefined_or_hole\";\n            static const char* const CONST_INT31_TYPE_STRING = \"constexpr int31\";\n            static const char* const CONST_INT32_TYPE_STRING = \"constexpr int32\";\n            static const char* const CONST_FLOAT64_TYPE_STRING = \"constexpr float64\";\n            static const char* const INTEGER_LITERAL_TYPE_STRING =\n                \"constexpr IntegerLiteral\";\n            static const char* const TORQUE_INTERNAL_NAMESPACE_STRING = \"torque_internal\";\n            static const char* const MUTABLE_REFERENCE_TYPE_STRING = \"MutableReference\";\n            static const char* const CONST_REFERENCE_TYPE_STRING = \"ConstReference\";\n            static const char* const MUTABLE_SLICE_TYPE_STRING = \"MutableSlice\";\n            static const char* const CONST_SLICE_TYPE_STRING = \"ConstSlice\";\n            static const char* const WEAK_TYPE_STRING = \"Weak\";\n            static const char* const SMI_TAGGED_TYPE_STRING = \"SmiTagged\";\n            static const char* const LAZY_TYPE_STRING = \"Lazy\";\n            static const char* const UNINITIALIZED_ITERATOR_TYPE_STRING =\n                \"UninitializedIterator\";\n            static const char* const GENERIC_TYPE_INSTANTIATION_NAMESPACE_STRING =\n                \"_generic_type_instantiation_namespace\";\n            static const char* const FIXED_ARRAY_BASE_TYPE_STRING = \"FixedArrayBase\";\n            static const char* const WEAK_HEAP_OBJECT = \"WeakHeapObject\";\n            static const char* const STATIC_ASSERT_MACRO_STRING = \"StaticAssert\";\n            static const char* const ANNOTATION_ABSTRACT = \"@abstract\";\n            static const char* const ANNOTATION_HAS_SAME_INSTANCE_TYPE_AS_PARENT =\n                \"@hasSameInstanceTypeAsParent\";\n            static const char* const ANNOTATION_DO_NOT_GENERATE_CPP_CLASS =\n                \"@doNotGenerateCppClass\";\n            static const char* const ANNOTATION_CUSTOM_MAP = \"@customMap\";\n            static const char* const ANNOTATION_CUSTOM_CPP_CLASS = \"@customCppClass\";\n            static const char* const ANNOTATION_HIGHEST_INSTANCE_TYPE_WITHIN_PARENT =\n                \"@highestInstanceTypeWithinParentClassRange\";\n            static const char* const ANNOTATION_LOWEST_INSTANCE_TYPE_WITHIN_PARENT =\n                \"@lowestInstanceTypeWithinParentClassRange\";\n            static const char* const ANNOTATION_RESERVE_BITS_IN_INSTANCE_TYPE =\n                \"@reserveBitsInInstanceType\";\n            static const char* const ANNOTATION_INSTANCE_TYPE_VALUE =\n                \"@apiExposedInstanceTypeValue\";\n            static const char* const ANNOTATION_IF = \"@if\";\n            static const char* const ANNOTATION_IFNOT = \"@ifnot\";\n            static const char* const ANNOTATION_GENERATE_BODY_DESCRIPTOR =\n                \"@generateBodyDescriptor\";\n            static const char* const ANNOTATION_GENERATE_UNIQUE_MAP = \"@generateUniqueMap\";\n            static const char* const ANNOTATION_GENERATE_FACTORY_FUNCTION =\n                \"@generateFactoryFunction\";\n            static const char* const ANNOTATION_EXPORT = \"@export\";\n            static const char* const ANNOTATION_DO_NOT_GENERATE_CAST = \"@doNotGenerateCast\";\n            static const char* const ANNOTATION_USE_PARENT_TYPE_CHECKER =\n                \"@useParentTypeChecker\";\n            static const char* const ANNOTATION_CPP_OBJECT_DEFINITION =\n                \"@cppObjectDefinition\";\n            static const char* const ANNOTATION_CPP_OBJECT_LAYOUT_DEFINITION =\n                \"@cppObjectLayoutDefinition\";\n            static const char* const ANNOTATION_SAME_ENUM_VALUE_AS = \"@sameEnumValueAs\";\n            // Generate C++ accessors with relaxed store semantics.\n            // Weak<T> and Tagged<MaybeObject> fields always use relaxed store.\n            static const char* const ANNOTATION_CPP_RELAXED_STORE = \"@cppRelaxedStore\";\n            // Generate C++ accessors with relaxed load semantics.\n            static const char* const ANNOTATION_CPP_RELAXED_LOAD = \"@cppRelaxedLoad\";\n            // Generate C++ accessors with release store semantics.\n            static const char* const ANNOTATION_CPP_RELEASE_STORE = \"@cppReleaseStore\";\n            // Generate C++ accessors with acquire load semantics.\n            static const char* const ANNOTATION_CPP_ACQUIRE_LOAD = \"@cppAcquireLoad\";\n            // Generate BodyDescriptor using IterateCustomWeakPointers.\n            static const char* const ANNOTATION_CUSTOM_WEAK_MARKING = \"@customWeakMarking\";\n            // Do not generate an interface descriptor for this builtin.\n            static const char* const ANNOTATION_CUSTOM_INTERFACE_DESCRIPTOR =\n                \"@customInterfaceDescriptor\";\n            // Automatically generates a call to IncrementUseCounter at the start of a\n            // builtin.\n            static const char* const ANNOTATION_INCREMENT_USE_COUNTER =\n                \"@incrementUseCounter\";\n            inline bool IsConstexprName(const std::string& name) {\n              return name.substr(0, std::strlen(CONSTEXPR_TYPE_PREFIX)) ==\n                     CONSTEXPR_TYPE_PREFIX;\n            }\n            inline std::string GetNonConstexprName(const std::string& name) {\n              if (!IsConstexprName(name)) return name;\n              return name.substr(std::strlen(CONSTEXPR_TYPE_PREFIX));\n            }\n            inline std::string GetConstexprName(const std::string& name) {\n              if (IsConstexprName(name)) return name;\n              return CONSTEXPR_TYPE_PREFIX + name;\n            }\n            enum class AbstractTypeFlag {\n              kNone = 0,\n              kTransient = 1 << 0,\n              kConstexpr = 1 << 1,\n              kUseParentTypeChecker = 1 << 2,\n            };\n            using AbstractTypeFlags = base::Flags<AbstractTypeFlag>;\n            enum class ClassFlag {\n              kNone = 0,\n              kExtern = 1 << 0,\n              kTransient = 1 << 1,\n              kAbstract = 1 << 2,\n              kIsShape = 1 << 3,\n              kHasSameInstanceTypeAsParent = 1 << 4,\n              kGenerateCppClassDefinitions = 1 << 5,\n              kHighestInstanceTypeWithinParent = 1 << 6,\n              kLowestInstanceTypeWithinParent = 1 << 7,\n              kUndefinedLayout = 1 << 8,\n              kGenerateBodyDescriptor = 1 << 9,\n              kExport = 1 << 10,\n              kDoNotGenerateCast = 1 << 11,\n              kGenerateUniqueMap = 1 << 12,\n              kGenerateFactoryFunction = 1 << 13,\n              kCppObjectDefinition = 1 << 14,\n              kCppObjectLayoutDefinition = 1 << 15,\n            };\n            using ClassFlags = base::Flags<ClassFlag>;\n            enum class StructFlag { kNone = 0, kExport = 1 << 0 };\n            using StructFlags = base::Flags<StructFlag>;\n            enum class FieldSynchronization {\n              kNone,\n              kRelaxed,\n              kAcquireRelease,\n            };\n\n            }  // namespace torque\n            }  // namespace internal\n            }  // namespace v8\n        ]]></code>\n    </class>\n</file>\n```"
}