{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/sidetable.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 153, column 50",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/sidetable.h\",\n        \"file_name\": \"sidetable.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines sidetable data structures for Turboshaft compiler, used for storing per-operation or per-block data.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers for algorithms and type traits.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <algorithm>\n            #include <type_traits>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes Turboshaft operations and zone containers from the V8 codebase.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GrowingSidetable\",\n            \"about\": \"A sidetable that automatically grows when accessed out of bounds, default-initializing new elements.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OpIndex\",\n                \"BlockIndex\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T, class Key>\n            class GrowingSidetable {\n            public:\n            static_assert(std::is_same_v<Key, OpIndex> ||\n                            std::is_same_v<Key, BlockIndex>);\n\n            T& operator[](Key index) {\n                DCHECK(index.valid());\n                size_t i = index.id();\n                if (V8_UNLIKELY(i >= table_.size())) {\n                table_.resize(NextSize(i));\n                // Make sure we also get access to potential over-allocation by\n                // `resize()`.\n                table_.resize(table_.capacity());\n                }\n                return table_[i];\n            }\n\n            const T& operator[](Key index) const {\n                DCHECK(index.valid());\n                size_t i = index.id();\n                if (V8_UNLIKELY(i >= table_.size())) {\n                table_.resize(NextSize(i));\n                // Make sure we also get access to potential over-allocation by\n                // `resize()`.\n                table_.resize(table_.capacity());\n                }\n                return table_[i];\n            }\n\n            // Reset by filling the table with the default value instead of shrinking to\n            // keep the memory for later phases.\n            void Reset() { std::fill(table_.begin(), table_.end(), T{}); }\n\n            // Returns `true` if the table never contained any values, even before\n            // `Reset()`.\n            bool empty() const { return table_.empty(); }\n\n            protected:\n            // Constructors are protected: use GrowingBlockSidetable or\n            // GrowingOpIndexSidetable instead.\n            explicit GrowingSidetable(Zone* zone) : table_(zone) {}\n            GrowingSidetable(size_t size, const T& initial_value, Zone* zone)\n                : table_(size, initial_value, zone) {}\n\n            mutable ZoneVector<T> table_;\n\n            size_t NextSize(size_t out_of_bounds_index) const {\n                DCHECK_GE(out_of_bounds_index, table_.size());\n                return out_of_bounds_index + out_of_bounds_index / 2 + 32;\n            }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FixedSidetable\",\n            \"about\": \"A fixed-size sidetable. Elements are default-initialized.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OpIndex\",\n                \"BlockIndex\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T, class Key>\n            class FixedSidetable {\n            public:\n            static_assert(std::is_same_v<Key, OpIndex> ||\n                            std::is_same_v<Key, BlockIndex>);\n\n            T& operator[](Key op) {\n                DCHECK_LT(op.id(), table_.size());\n                return table_[op.id()];\n            }\n\n            const T& operator[](Key op) const {\n                DCHECK_LT(op.id(), table_.size());\n                return table_[op.id()];\n            }\n\n            protected:\n            // Constructors are protected: use FixedBlockSidetable or\n            // FixedOpIndexSidetable instead.\n            explicit FixedSidetable(size_t size, Zone* zone) : table_(size, zone) {}\n            FixedSidetable(size_t size, const T& default_value, Zone* zone)\n                : table_(size, default_value, zone) {}\n\n            ZoneVector<T> table_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GrowingBlockSidetable\",\n            \"extends\": \"detail::GrowingSidetable<T, BlockIndex>\",\n            \"about\": \"A growing sidetable specialized for BlockIndex keys.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"detail::GrowingSidetable\",\n                \"BlockIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class GrowingBlockSidetable : public detail::GrowingSidetable<T, BlockIndex> {\n            using Base = detail::GrowingSidetable<T, BlockIndex>;\n\n            public:\n            explicit GrowingBlockSidetable(Zone* zone) : Base(zone) {}\n\n            GrowingBlockSidetable(size_t size, const T& initial_value, Zone* zone)\n                : Base(size, initial_value, zone) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FixedBlockSidetable\",\n            \"extends\": \"detail::FixedSidetable<T, BlockIndex>\",\n            \"about\": \"A fixed-size sidetable specialized for BlockIndex keys.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"detail::FixedSidetable\",\n                \"BlockIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class FixedBlockSidetable : public detail::FixedSidetable<T, BlockIndex> {\n            using Base = detail::FixedSidetable<T, BlockIndex>;\n\n            public:\n            explicit FixedBlockSidetable(size_t size, Zone* zone) : Base(size, zone) {}\n\n            FixedBlockSidetable(size_t size, const T& initial_value, Zone* zone)\n                : Base(size, initial_value, zone) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GrowingOpIndexSidetable\",\n            \"extends\": \"detail::GrowingSidetable<T, OpIndex>\",\n            \"about\": \"A growing sidetable specialized for OpIndex keys.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"detail::GrowingSidetable\",\n                \"OpIndex\",\n                \"Graph\",\n                \"OpIndexBelongsToTableGraph\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            class GrowingOpIndexSidetable : public detail::GrowingSidetable<T, OpIndex> {\n            using Base = detail::GrowingSidetable<T, OpIndex>;\n\n            public:\n            explicit GrowingOpIndexSidetable(Zone* zone, const Graph* graph)\n                : Base(zone)\n            #ifdef DEBUG\n                ,\n                graph_(graph)\n            #endif\n            {\n                USE(graph);\n            }\n\n            GrowingOpIndexSidetable(size_t size, const T& initial_value, Zone* zone,\n                                    const Graph* graph)\n                : Base(size, initial_value, zone)\n            #ifdef DEBUG\n                ,\n                graph_(graph)\n            #endif\n            {\n                USE(graph);\n            }\n\n            T& operator[](OpIndex index) {\n                DCHECK(OpIndexBelongsToTableGraph(graph_, index));\n                return Base::operator[](index);\n            }\n\n            const T& operator[](OpIndex index) const {\n                DCHECK(OpIndexBelongsToTableGraph(graph_, index));\n                return Base::operator[](index);\n            }\n\n            void SwapData(GrowingOpIndexSidetable<T>& other) {\n                std::swap(Base::table_, other.table_);\n            }\n\n            public:\n            #ifdef DEBUG\n            const Graph* graph_;\n            #endif\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FixedOpIndexSidetable\",\n            \"extends\": \"detail::FixedSidetable<T, OpIndex>\",\n            \"about\": \"A fixed-size sidetable specialized for OpIndex keys.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"detail::FixedSidetable\",\n                \"OpIndex\",\n                \"Graph\",\n                \"OpIndexBelongsToTableGraph\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            class FixedOpIndexSidetable : public detail::FixedSidetable<T, OpIndex> {\n            using Base = detail::FixedSidetable<T, OpIndex>;\n\n            public:\n            FixedOpIndexSidetable(size_t size, Zone* zone, const Graph* graph)\n                : Base(size, zone)\n            #ifdef DEBUG\n                ,\n                graph_(graph)\n            #endif\n            {\n            }\n            FixedOpIndexSidetable(size_t size, const T& default_value, Zone* zone,\n                                    const Graph* graph)\n                : Base(size, default_value, zone)\n            #ifdef DEBUG\n                ,\n                graph_(graph)\n            #endif\n            {\n            }\n\n            T& operator[](OpIndex index) {\n                DCHECK(OpIndexBelongsToTableGraph(graph_, index));\n                return Base::operator[](index);\n            }\n\n            const T& operator[](OpIndex index) const {\n                DCHECK(OpIndexBelongsToTableGraph(graph_, index));\n                return Base::operator[](index);\n            }\n\n            void SwapData(FixedOpIndexSidetable<T>& other) {\n                std::swap(Base::table_, other.table_);\n            }\n\n            public:\n            #ifdef DEBUG\n            const Graph* graph_;\n            #endif\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SparseOpIndexSideTable\",\n            \"about\": \"A sidetable that stores data sparsely using a hash map.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OpIndex\",\n                \"Graph\",\n                \"ZoneAbslFlatHashMap\",\n                \"OpIndexBelongsToTableGraph\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            class SparseOpIndexSideTable {\n            public:\n            SparseOpIndexSideTable(Zone* zone, const Graph* graph)\n                : data_(zone)\n            #ifdef DEBUG\n                ,\n                graph_(graph)\n            #endif\n            {\n            }\n\n            T& operator[](OpIndex index) {\n                DCHECK(OpIndexBelongsToTableGraph(graph_, index));\n                return data_[index];\n            }\n\n            const T& operator[](OpIndex index) const {\n                DCHECK(OpIndexBelongsToTableGraph(graph_, index));\n                DCHECK(data_.contains(index));\n                return data_.at(index);\n            }\n\n            bool contains(OpIndex index, const T** value = nullptr) const {\n                DCHECK(OpIndexBelongsToTableGraph(graph_, index));\n                if (auto it = data_.find(index); it != data_.end()) {\n                if (value) *value = &it->second;\n                return true;\n                }\n                return false;\n            }\n\n            void remove(OpIndex index) {\n                DCHECK(OpIndexBelongsToTableGraph(graph_, index));\n                auto it = data_.find(index);\n                if (it != data_.end()) data_.erase(it);\n            }\n\n            auto begin() { return data_.begin(); }\n            auto end() { return data_.end(); }\n\n            private:\n            ZoneAbslFlatHashMap<OpIndex, T> data_;\n            #ifdef DEBUG\n            const Graph* graph_;\n            #endif\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"OpIndexBelongsToTableGraph\",\n                \"about\": \"Checks if an OpIndex belongs to a given graph.\",\n                \"return\": {\n                    \"type\": \"bool\"\n                }\n            }\n            </metadata>\n            <code><![CDATA[\n                bool OpIndexBelongsToTableGraph(const Graph* graph, OpIndex index);\n            ]]></code>\n        </func>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OpIndex\",\n                \"about\": \"Index for identifying operations in the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class OpIndex {\n                public:\n                    bool valid() const;\n                    size_t id() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BlockIndex\",\n                \"about\": \"Index for identifying basic blocks in the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BlockIndex {\n                public:\n                    bool valid() const;\n                    size_t id() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Graph\",\n                \"about\": \"Represents the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Graph {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneVector\",\n                \"about\": \"A vector-like container that allocates memory from a Zone.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class ZoneVector {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneAbslFlatHashMap\",\n                \"about\": \"A hash map that allocates memory from a Zone.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename K, typename V>\n                class ZoneAbslFlatHashMap {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}