{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-allocator.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 188, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-allocator.h\",\n        \"file_name\": \"zone-allocator.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines ZoneAllocator and RecyclingZoneAllocator classes for memory management within Zones in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library limits header for size limits\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <limits>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes the Zone class definition from the V8 codebase.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneAllocator\",\n            \"about\": \"A template class that provides allocation and deallocation of memory within a specified Zone.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the Zone object that manages the memory.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"is_compressed_pointer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class ZoneAllocator {\n            public:\n              using value_type = T;\n\n            #ifdef V8_OS_WIN\n              // The exported class ParallelMove derives from ZoneVector, which derives\n              // from std::vector.  On Windows, the semantics of dllexport mean that\n              // a class's superclasses that are not explicitly exported themselves get\n              // implicitly exported together with the subclass, and exporting a class\n              // exports all its functions -- including the std::vector() constructors\n              // that don't take an explicit allocator argument, which in turn reference\n              // the vector allocator's default constructor. So this constructor needs\n              // to exist for linking purposes, even if it's never called.\n              // Other fixes would be to disallow subclasses of ZoneVector (etc) to be\n              // exported, or using composition instead of inheritance for either\n              // ZoneVector and friends or for ParallelMove.\n              ZoneAllocator() : ZoneAllocator(nullptr) { UNREACHABLE(); }\n            #endif\n              explicit ZoneAllocator(Zone* zone) : zone_(zone) {\n                // If we are going to allocate compressed pointers in the zone it must\n                // support compression.\n                DCHECK_IMPLIES(is_compressed_pointer<T>::value,\n                               zone_->supports_compression());\n              }\n              template <typename U>\n              ZoneAllocator(const ZoneAllocator<U>& other) V8_NOEXCEPT\n                  : ZoneAllocator<T>(other.zone()) {\n                // If we are going to allocate compressed pointers in the zone it must\n                // support compression.\n                DCHECK_IMPLIES(is_compressed_pointer<T>::value,\n                               zone_->supports_compression());\n              }\n\n              T* allocate(size_t length) { return zone_->AllocateArray<T>(length); }\n              void deallocate(T* p, size_t length) { zone_->DeleteArray<T>(p, length); }\n\n              bool operator==(ZoneAllocator const& other) const {\n                return zone_ == other.zone_;\n              }\n              bool operator!=(ZoneAllocator const& other) const {\n                return zone_ != other.zone_;\n              }\n\n              Zone* zone() const { return zone_; }\n\n             private:\n              Zone* zone_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RecyclingZoneAllocator\",\n            \"extends\": \"ZoneAllocator\",\n            \"about\": \"A template class that extends ZoneAllocator and maintains a free list of deallocated chunks for reuse, improving allocation performance for similar-sized blocks.\",\n            \"attributes\": [\n                {\n                    \"name\": \"free_list_\",\n                    \"type\": \"FreeBlock*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the head of the free list.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class RecyclingZoneAllocator : public ZoneAllocator<T> {\n            public:\n              explicit RecyclingZoneAllocator(Zone* zone)\n                  : ZoneAllocator<T>(zone), free_list_(nullptr) {}\n              template <typename U>\n              RecyclingZoneAllocator(const RecyclingZoneAllocator<U>& other) V8_NOEXCEPT\n                  : ZoneAllocator<T>(other),\n                    free_list_(nullptr) {}\n\n              T* allocate(size_t n) {\n                // Only check top block in free list, since this will be equal to or larger\n                // than the other blocks in the free list.\n                if (free_list_ && free_list_->size >= n) {\n                  T* return_val = reinterpret_cast<T*>(free_list_);\n                  free_list_ = free_list_->next;\n                  return return_val;\n                }\n                return ZoneAllocator<T>::allocate(n);\n              }\n\n              void deallocate(T* p, size_t n) {\n                if ((sizeof(T) * n < sizeof(FreeBlock))) return;\n\n                // Only add block to free_list if it is equal or larger than previous block\n                // so that allocation stays O(1) only having to look at the top block.\n                if (!free_list_ || free_list_->size <= n) {\n                  // Store the free-list within the block being deallocated.\n                  DCHECK((sizeof(T) * n >= sizeof(FreeBlock)));\n                  FreeBlock* new_free_block = reinterpret_cast<FreeBlock*>(p);\n\n                  new_free_block->size = n;\n                  new_free_block->next = free_list_;\n                  free_list_ = new_free_block;\n                }\n              }\n\n             private:\n              struct FreeBlock {\n                FreeBlock* next;\n                size_t size;\n              };\n\n              FreeBlock* free_list_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"alias\",\n            \"name\": \"ZoneBoolAllocator\",\n            \"about\": \"Type alias for ZoneAllocator<bool>.\",\n            \"dependencies\": [\n                \"ZoneAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using ZoneBoolAllocator = ZoneAllocator<bool>;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"alias\",\n            \"name\": \"ZoneIntAllocator\",\n            \"about\": \"Type alias for ZoneAllocator<int>.\",\n            \"dependencies\": [\n                \"ZoneAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using ZoneIntAllocator = ZoneAllocator<int>;\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Zone\",\n                \"about\": \"Manages a region of memory.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Zone {\n                 public:\n                  void* Allocate(size_t size);\n                  template <typename T>\n                  T* AllocateArray(size_t length);\n                  template <typename T>\n                  void DeleteArray(T* p, size_t length);\n                  bool supports_compression() const { return false; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"is_compressed_pointer\",\n                \"about\": \"Type trait to check if a type is a compressed pointer.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                struct is_compressed_pointer : std::false_type {};\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"DCHECK_IMPLIES\",\n                \"about\": \"Assertion that checks implication\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK_IMPLIES(a, b)  DCHECK(!(a) || (b))\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"UNREACHABLE\",\n                \"about\": \"Indicates unreachable code\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define UNREACHABLE() abort()\n            ]]></code>\n        </func>\n    </dependencies>\n</file>\n```"
}