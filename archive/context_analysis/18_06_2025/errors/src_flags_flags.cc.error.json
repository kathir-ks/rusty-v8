{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/flags/flags.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/flags/flags.cc\",\n        \"file_name\": \"flags.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines and manages command-line flags for the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers for various functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/flags/flags.h\"\n\n            #include <algorithm>\n            #include <array>\n            #include <cctype>\n            #include <cerrno>\n            #include <cinttypes>\n            #include <cstdlib>\n            #include <cstring>\n            #include <iomanip>\n            #include <optional>\n            #include <set>\n            #include <sstream>\n\n            #include \"src/base/hashing.h\"\n            #include \"src/base/lazy-instance.h\"\n            #include \"src/base/platform/platform.h\"\n            #include \"src/codegen/cpu-features.h\"\n            #include \"src/flags/flags-impl.h\"\n            #include \"src/logging/tracing-flags.h\"\n            #include \"src/tracing/tracing-category-observer.h\"\n            #include \"src/utils/allocation.h\"\n            #include \"src/utils/memcopy.h\"\n            #include \"src/utils/ostreams.h\"\n            #include \"src/utils/utils.h\"\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/wasm/wasm-limits.h\"\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FlagHelpers\",\n            \"about\": \"Provides helper functions for flag name normalization and comparison.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8::internal {\n\n            char FlagHelpers::NormalizeChar(char ch) { return ch == '_' ? '-' : ch; }\n\n            int FlagHelpers::FlagNamesCmp(const char* a, const char* b) {\n            int i = 0;\n            char ac, bc;\n            do {\n                ac = NormalizeChar(a[i]);\n                bc = NormalizeChar(b[i]);\n                if (ac < bc) return -1;\n                if (ac > bc) return 1;\n                i++;\n            } while (ac != '\\0');\n            DCHECK_EQ(bc, '\\0');\n            return 0;\n            }\n\n            bool FlagHelpers::EqualNames(const char* a, const char* b) {\n            return FlagNamesCmp(a, b) == 0;\n            }\n\n            // Checks if two flag names are equal, allowing for the second name to have a\n            // suffix starting with a white space character, e.g. \"max_opt < 3\". This is\n            // used in flag implications.\n            bool FlagHelpers::EqualNameWithSuffix(const char* a, const char* b) {\n            char ac, bc;\n            for (int i = 0; true; ++i) {\n                ac = NormalizeChar(a[i]);\n                bc = NormalizeChar(b[i]);\n                if (ac == '\\0') break;\n                if (ac != bc) return false;\n            }\n            return bc == '\\0' || std::isspace(bc);\n            }\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the output stream operator to print a FlagName object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"flag_name\",\n                    \"type\": \"FlagName\",\n                    \"purpose\": \"The FlagName object to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The modified output stream.\"\n            },\n            \"dependencies\": [\n                \"FlagHelpers::NormalizeChar\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os, FlagName flag_name) {\n            os << (flag_name.negated ? \"--no-\" : \"--\");\n            for (const char* p = flag_name.name; *p; ++p) {\n                os << FlagHelpers::NormalizeChar(*p);\n            }\n            return os;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"set_string_value\",\n            \"parent\": \"Flag\",\n            \"about\": \"Sets the string value of a flag, managing memory allocation.\",\n            \"logic\": \"If the flag currently owns the memory for the string value, it will be freed. The new value is then set, with the ownership flag updated.\",\n            \"parameters\": [\n                {\n                    \"name\": \"new_value\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The new string value to set.\"\n                },\n                {\n                    \"name\": \"owns_new_value\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the flag should take ownership of the new value.\"\n                },\n                {\n                    \"name\": \"set_by\",\n                    \"type\": \"SetBy\",\n                    \"purpose\": \"Indicates how the flag value was set (e.g., command line, implication).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"std::strcmp\",\n                \"DeleteArray\",\n                \"CheckFlagChange\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Flag::set_string_value(const char* new_value, bool owns_new_value,\n                                        SetBy set_by) {\n            DCHECK_EQ(TYPE_STRING, type_);\n            DCHECK_IMPLIES(owns_new_value, new_value != nullptr);\n            const char* old_value = string_value();\n            DCHECK_IMPLIES(owns_ptr_, old_value != nullptr);\n            bool change_flag = old_value\n                                ? !new_value || std::strcmp(old_value, new_value) != 0\n                                : !!new_value;\n            change_flag = CheckFlagChange(set_by, change_flag);\n            if (change_flag) {\n                DCHECK(!IsReadOnly());\n                if (owns_ptr_) DeleteArray(old_value);\n                *reinterpret_cast<FlagValue<const char*>*>(valptr_) = new_value;\n                owns_ptr_ = owns_new_value;\n            } else {\n                if (owns_new_value) DeleteArray(new_value);\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ShouldCheckFlagContradictions\",\n            \"parent\": \"Flag\",\n            \"about\": \"Determines whether flag contradictions should be checked.\",\n            \"logic\": \"Checks the global flag `abort_on_contradictory_flags` and `fuzzing` to determine if contradictions should be checked. It also temporarily disables contradiction checking for the next flag if `allow_overwriting_for_next_flag` is set.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if contradictions should be checked, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"v8_flags.abort_on_contradictory_flags\",\n                \"v8_flags.fuzzing\",\n                \"v8_flags.allow_overwriting_for_next_flag\",\n                \"FindFlagByPointer\",\n                \"Flag::Reset\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool Flag::ShouldCheckFlagContradictions() {\n            if (v8_flags.allow_overwriting_for_next_flag) {\n                // Setting the flag manually to false before calling Reset() avoids this\n                // becoming re-entrant.\n                v8_flags.allow_overwriting_for_next_flag = false;\n                FindFlagByPointer(&v8_flags.allow_overwriting_for_next_flag)->Reset();\n                return false;\n            }\n            return v8_flags.abort_on_contradictory_flags && !v8_flags.fuzzing;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CheckFlagChange\",\n            \"parent\": \"Flag\",\n            \"about\": \"Checks if a flag change is allowed, considering contradictions and read-only status.\",\n            \"logic\": \"This function is the core of flag management. It checks for contradictory flag settings, read-only status, and implication rules. If contradictions are detected, it raises a fatal error.  It returns whether the value can be changed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"new_set_by\",\n                    \"type\": \"SetBy\",\n                    \"purpose\": \"Indicates how the flag value is being set.\"\n                },\n                {\n                    \"name\": \"change_flag\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the flag's value is actually changing.\"\n                },\n                {\n                    \"name\": \"implied_by\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the flag implying this change, if any.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the flag change is allowed, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ShouldCheckFlagContradictions\",\n                \"IsReadOnly\",\n                \"FatalError\",\n                \"FlagName\",\n                \"IsAnyImplication\",\n                \"DCHECK_NOT_NULL\",\n                \"FindImplicationFlagByName\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool Flag::CheckFlagChange(SetBy new_set_by, bool change_flag,\n                                   const char* implied_by) {\n            if (new_set_by == SetBy::kWeakImplication &&\n                (set_by_ == SetBy::kImplication || set_by_ == SetBy::kCommandLine)) {\n                return false;\n            }\n            if (ShouldCheckFlagContradictions()) {\n                static constexpr const char kHint[] =\n                    \"If a test variant caused this, it might be necessary to specify \"\n                    \"additional contradictory flags in \"\n                    \"tools/testrunner/local/variants.py.\";\n                struct FatalError : public std::ostringstream {\n                // MSVC complains about non-returning destructor; disable that.\n                MSVC_SUPPRESS_WARNING(4722)\n                ~FatalError() { FATAL(\"%s.\\n%s\", str().c_str(), kHint); }\n                };\n                // Readonly flags cannot change value.\n                if (change_flag && IsReadOnly()) {\n                // Exit instead of abort for certain testing situations.\n                if (v8_flags.exit_on_contradictory_flags) base::OS::ExitProcess(0);\n                if (implied_by == nullptr) {\n                    FatalError{} << \"Contradictory value for readonly flag \"\n                                 << FlagName{name()};\n                } else {\n                    DCHECK(IsAnyImplication(new_set_by));\n                    FatalError{} << \"Contradictory value for readonly flag \"\n                                 << FlagName{name()} << \" implied by \" << implied_by;\n                }\n                }\n                // For bool flags, we only check for a conflict if the value actually\n                // changes. So specifying the same flag with the same value multiple times\n                // is allowed.\n                // For other flags, we disallow specifying them explicitly or in the\n                // presence of an implication if the value is not the same.\n                // This is to simplify the rules describing conflicts in variants.py: A\n                // repeated non-boolean flag is considered an error.\n                bool is_bool_flag = type_ == TYPE_MAYBE_BOOL || type_ == TYPE_BOOL;\n                bool check_implications = change_flag;\n                switch (set_by_) {\n                case SetBy::kDefault:\n                    break;\n                case SetBy::kWeakImplication:\n                    if (new_set_by == SetBy::kWeakImplication && check_implications) {\n                    FatalError{} << \"Contradictory weak flag implications from \"\n                                 << FlagName{implied_by_} << \" and \"\n                                 << FlagName{implied_by} << \" for flag \"\n                                 << FlagName{name()};\n                    }\n                    break;\n                case SetBy::kImplication:\n                    if (new_set_by == SetBy::kImplication && check_implications) {\n                    FatalError{} << \"Contradictory flag implications from \"\n                                 << FlagName{implied_by_} << \" and \"\n                                 << FlagName{implied_by} << \" for flag \"\n                                 << FlagName{name()};\n                    }\n                    break;\n                case SetBy::kCommandLine:\n                    if (new_set_by == SetBy::kImplication && check_implications) {\n                    // Exit instead of abort for certain testing situations.\n                    if (v8_flags.exit_on_contradictory_flags) base::OS::ExitProcess(0);\n                    if (is_bool_flag) {\n                        FatalError{} << \"Flag \" << FlagName{name()} << \": value implied by \"\n                                     << FlagName{implied_by}\n                                     << \" conflicts with explicit specification\";\n                    } else {\n                        FatalError{} << \"Flag \" << FlagName{name()} << \" is implied by \"\n                                     << FlagName{implied_by}\n                                     << \" but also specified explicitly\";\n                    }\n                    } else if (new_set_by == SetBy::kCommandLine && check_implications) {\n                    // Exit instead of abort for certain testing situations.\n                    if (v8_flags.exit_on_contradictory_flags) base::OS::ExitProcess(0);\n                    if (is_bool_flag) {\n                        FatalError{} << \"Command-line provided flag \" << FlagName{name()}\n                                     << \" specified as both true and false\";\n                    } else {\n                        FatalError{} << \"Command-line provided flag \" << FlagName{name()}\n                                     << \" specified multiple times\";\n                    }\n                    }\n                    break;\n                }\n            }\n            if (change_flag && IsReadOnly()) {\n                // Readonly flags must never change value.\n                return false;\n            }\n            set_by_ = new_set_by;\n            if (IsAnyImplication(new_set_by)) {\n                DCHECK_NOT_NULL(implied_by);\n                implied_by_ = implied_by;\n        #ifdef DEBUG\n                // This only works when implied_by is a flag_name or !flag_name, but it\n                // can also be a condition e.g. flag_name > 3. Since this is only used for\n                // checks in DEBUG mode, we will just ignore the more complex conditions\n                // for now - that will just lead to a nullptr which won't be followed.\n                implied_by_ptr_ = static_cast<Flag*>(FindImplicationFlagByName(\n                    implied_by[0] == '!' ? implied_by + 1 : implied_by));\n                DCHECK_NE(implied_by_ptr_, this);\n        #endif\n            }\n            return change_flag;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsDefault\",\n            \"parent\": \"Flag\",\n            \"about\": \"Checks if the flag is set to its default value.\",\n            \"logic\": \"Compares the current value of the flag to its default value based on its type.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the flag is set to its default value, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"bool_variable\",\n                \"bool_default\",\n                \"maybe_bool_variable\",\n                \"int_variable\",\n                \"int_default\",\n                \"uint_variable\",\n                \"uint_default\",\n                \"uint64_variable\",\n                \"uint64_default\",\n                \"float_variable\",\n                \"float_default\",\n                \"size_t_variable\",\n                \"size_t_default\",\n                \"string_value\",\n                \"string_default\",\n                \"strcmp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool Flag::IsDefault() const {\n            switch (type_) {\n                case TYPE_BOOL:\n                return bool_variable() == bool_default();\n                case TYPE_MAYBE_BOOL:\n                return maybe_bool_variable().has_value() == false;\n                case TYPE_INT:\n                return int_variable() == int_default();\n                case TYPE_UINT:\n                return uint_variable() == uint_default();\n                case TYPE_UINT64:\n                return uint64_variable() == uint64_default();\n                case TYPE_FLOAT:\n                return float_variable() == float_default();\n                case TYPE_SIZE_T:\n                return size_t_variable() == size_t_default();\n                case TYPE_STRING: {\n                const char* str1 = string_value();\n                const char* str2 = string_default();\n                if (str2 == nullptr) return str1 == nullptr;\n                if (str1 == nullptr) return str2 == nullptr;\n                return strcmp(str1, str2) == 0;\n                }\n            }\n            UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReleaseDynamicAllocations\",\n            \"parent\": \"Flag\",\n            \"about\": \"Releases dynamically allocated memory associated with the flag, specifically for string flags.\",\n            \"logic\": \"If the flag is a string type and owns the pointer to the string, the memory is deallocated.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TYPE_STRING\",\n                \"owns_ptr_\",\n                \"string_value\",\n                \"DeleteArray\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Flag::ReleaseDynamicAllocations() {\n            if (type_ != TYPE_STRING) return;\n            if (owns_ptr_) DeleteArray(string_value());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reset\",\n            \"parent\": \"Flag\",\n            \"about\": \"Resets the flag to its default value.\",\n            \"logic\": \"Sets the flag's value to its default based on the flag's type.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"set_bool_variable\",\n                \"bool_default\",\n                \"set_maybe_bool_variable\",\n                \"set_int_variable\",\n                \"int_default\",\n                \"set_uint_variable\",\n                \"uint_default\",\n                \"set_uint64_variable\",\n                \"uint64_default\",\n                \"set_float_variable\",\n                \"float_default\",\n                \"set_size_t_variable\",\n                \"size_t_default\",\n                \"set_string_value\",\n                \"string_default\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Flag::Reset() {\n            switch (type_) {\n                case TYPE_BOOL:\n                set_bool_variable(bool_default(), SetBy::kDefault);\n                break;\n                case TYPE_MAYBE_BOOL:\n                set_maybe_bool_variable(std::nullopt, SetBy::kDefault);\n                break;\n                case TYPE_INT:\n                set_int_variable(int_default(), SetBy::kDefault);\n                break;\n                case TYPE_UINT:\n                set_uint_variable(uint_default(), SetBy::kDefault);\n                break;\n                case TYPE_UINT64:\n                set_uint64_variable(uint64_default(), SetBy::kDefault);\n                break;\n                case TYPE_FLOAT:\n                set_float_variable(float_default(), SetBy::kDefault);\n                break;\n                case TYPE_SIZE_T:\n                set_size_t_variable(size_t_default(), SetBy::kDefault);\n                break;\n                case TYPE_STRING:\n                set_string_value(string_default(), false, SetBy::kDefault);\n                break;\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Flags\",\n            \"about\": \"Returns a vector containing all the defined flags.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"base::Vector<Flag>\",\n                \"description\": \"A vector containing all the defined flags.\"\n            },\n            \"dependencies\": [\n                \"flags\",\n                \"base::ArrayVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            base::Vector<Flag> Flags() { return base::ArrayVector(flags); }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FlagLess\",\n            \"about\": \"A functor for comparing Flag pointers based on their names, used for sorting.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct FlagLess {\n            bool operator()(const Flag* a, const Flag* b) const {\n                return FlagHelpers::FlagNamesCmp(a->name(), b->name()) < 0;\n            }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FlagNameGreater\",\n            \"about\": \"A functor for comparing a Flag pointer to a flag name, used for binary search.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct FlagNameGreater {\n            bool operator()(const Flag* a, const char* b) const {\n                return FlagHelpers::FlagNamesCmp(a->name(), b) > 0;\n            }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FlagMapByName\",\n            \"about\": \"A helper class for efficient flag lookup by name using binary search.\",\n            \"attributes\": [\n                {\n                    \"name\": \"flags_\",\n                    \"type\": \"std::array<Flag*, kNumFlags>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"An array of flag pointers, sorted by flag name.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // Optimized look-up of flags by name using binary search. Works only for flags\n            // that can be found. If the looked-up flag might not exit in the list, an\n            // additional name check of the returned flag is required.\n            class FlagMapByName {\n            public:\n            FlagMapByName() {\n                for (size_t i = 0; i < kNumFlags; ++i) {\n                flags_[i] = &flags[i];\n                }\n                std::sort(flags_.begin(), flags_.end(), FlagLess());\n            }\n\n            // Returns the greatest flag whose name is less than or equal to the given\n            // name (lexicographically). This allows for finding the right flag even if\n            // there is a suffix, as in the case of implications, e.g. \"max_opt < 3\".\n            Flag* GetFlag(const char* name) {\n                auto it = std::lower_bound(flags_.rbegin(), flags_.rend(), name,\n                                            FlagNameGreater());\n                if (it == flags_.rend()) return nullptr;\n                return *it;\n            }\n\n            private:\n            std::array<Flag*, kNumFlags> flags_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FindImplicationFlagByName\",\n            \"about\": \"Finds a flag by name, assuming it exists, and allowing for suffixes used in implications.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the flag to find.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Flag*\",\n                \"description\": \"A pointer to the found flag.\"\n            },\n            \"dependencies\": [\n                \"GetFlagMap\",\n                \"FlagHelpers::EqualNameWithSuffix\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // This should be used to look up flags that we know were defined.\n            // It allows for suffixes used in implications, e.g. \"max_opt < 3\",\n            Flag* FindImplicationFlagByName(const char* name) {\n            Flag* flag = GetFlagMap()->GetFlag(name);\n            CHECK(flag != nullptr);\n            DCHECK(FlagHelpers::EqualNameWithSuffix(flag->name(), name));\n            return flag;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FindFlagByName\",\n            \"about\": \"Finds a flag by name, returning nullptr if it doesn't exist.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the flag to find.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Flag*\",\n                \"description\": \"A pointer to the found flag, or nullptr if not found.\"\n            },\n            \"dependencies\": [\n                \"GetFlagMap\",\n                \"FlagHelpers::EqualNames\",\n                \"kNumFlags\",\n                \"flags\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // This can be used to look up flags that might not exist (e.g. invalid command\n            // line flags).\n            Flag* FindFlagByName(const char* name) {\n            Flag* flag = GetFlagMap()->GetFlag(name);\n            // GetFlag returns an invalid lower bound for flags not in the list. So\n            // we need to verify the name again.\n            if (flag != nullptr && FlagHelpers::EqualNames(flag->name(), name)) {\n                return flag;\n            }\n        #ifdef DEBUG\n            // Ensure the flag is not in the global list.\n            for (size_t i = 0; i < kNumFlags; ++i) {\n                DCHECK(!FlagHelpers::EqualNames(name, flags[i].name()));\n            }\n        #endif\n            return nullptr;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FindFlagByPointer\",\n            \"about\": \"Finds a flag by the pointer to its value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"ptr\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"A pointer to the flag's value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Flag*\",\n                \"description\": \"A pointer to the found flag, or nullptr if not found.\"\n            },\n            \"dependencies\": [\n                \"kNumFlags\",\n                \"flags\",\n                \"Flag::PointsTo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Flag* FindFlagByPointer(const void* ptr) {\n            for (size_t i = 0; i < kNumFlags; ++i) {\n                if (flags[i].PointsTo(ptr)) return &flags[i];\n            }\n            return nullptr;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Type2String\",\n            \"about\": \"Converts a flag type to a string representation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"Flag::FlagType\",\n                    \"purpose\": \"The flag type to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const char*\",\n                \"description\": \"A string representation of the flag type.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            static const char* Type2String(Flag::FlagType type) {\n            switch (type) {\n                case Flag::TYPE_BOOL:\n                return \"bool\";\n                case Flag::TYPE_MAYBE_BOOL:\n                return \"maybe_bool\";\n                case Flag::TYPE_INT:\n                return \"int\";\n                case Flag::TYPE_UINT:\n                return \"uint\";\n                case Flag::TYPE_UINT64:\n                return \"uint64\";\n                case Flag::TYPE_FLOAT:\n                return \"float\";\n                case Flag::TYPE_SIZE_T:\n                return \"size_t\";\n                case Flag::TYPE_STRING:\n                return \"string\";\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the output stream operator to print a flag value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"flag_value\",\n                    \"type\": \"PrintFlagValue\",\n                    \"purpose\": \"The flag value to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The modified output stream.\"\n            },\n            \"dependencies\": [\n                \"Flag::type\",\n                \"Flag::bool_variable\",\n                \"Flag::maybe_bool_variable\",\n                \"Flag::int_variable\",\n                \"Flag::uint_variable\",\n                \"Flag::uint64_variable\",\n                \"Flag::float_variable\",\n                \"Flag::size_t_variable\",\n                \"Flag::string_value\",\n                \"std::quoted\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os, PrintFlagValue flag_value) {\n            const Flag& flag = flag_value.flag;\n            switch (flag.type()) {\n                case Flag::TYPE_BOOL:\n                os << (flag.bool_variable() ? \"true\" : \"false\");\n                break;\n                case Flag::TYPE_MAYBE_BOOL:\n                os << (flag.maybe_bool_variable().has_value()\n                            ? (flag.maybe_bool_variable().value() ? \"true\" : \"false\")\n                            : \"unset\");\n                break;\n                case Flag::TYPE_INT:\n                os << flag.int_variable();\n                break;\n                case Flag::TYPE_UINT:\n                os << flag.uint_variable();\n                break;\n                case Flag::TYPE_UINT64:\n                os << flag.uint64_variable();\n                break;\n                case Flag::TYPE_FLOAT:\n                os << flag.float_variable();\n                break;\n                case Flag::TYPE_SIZE_T:\n                os << flag.size_t_variable();\n                break;\n                case Flag::TYPE_STRING: {\n                const char* str = flag.string_value();\n                os << std::quoted(str ? str : \"\");\n                break;\n                }\n            }\n            return os;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the output stream operator to print a Flag object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"flag\",\n                    \"type\": \"const Flag&\",\n                    \"purpose\": \"The flag to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The modified output stream.\"\n            },\n            \"dependencies\": [\n                \"Flag::type\",\n                \"Flag::TYPE_BOOL\",\n                \"Flag::name\",\n                \"Flag::bool_variable\",\n                \"FlagName\",\n                \"PrintFlagValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream"
}