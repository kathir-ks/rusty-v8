{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/snapshot-table.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/snapshot-table.h\",\n        \"file_name\": \"snapshot-table.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines a SnapshotTable data structure for storing mappings and efficiently creating/managing snapshots of its state.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8 specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <iostream>\n            #include <limits>\n\n            #include \"src/base/iterator.h\"\n            #include \"src/base/small-vector.h\"\n            #include \"src/compiler/turboshaft/fast-hash.h\"\n            #include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"NoKeyData\",\n            \"about\": \"An empty struct used as a default template parameter for SnapshotTable when no key data is needed.\",\n            \"attributes\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct NoKeyData {};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"NoChangeCallback\",\n            \"about\": \"A struct providing a default no-op change callback for SnapshotTable operations.\",\n            \"attributes\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct NoChangeCallback {\n              template <class Key, class Value>\n              void operator()(Key key, const Value& old_value,\n                              const Value& new_value) const {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SnapshotTableEntry\",\n            \"about\": \"Represents an entry in the SnapshotTable, storing the value, key data, and metadata for merging snapshots.\",\n            \"attributes\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The value associated with the key.\"\n                },\n                {\n                    \"name\": \"merge_offset\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Offset in `merge_values_` where merged values are stored.\"\n                },\n                {\n                    \"name\": \"last_merged_predecessor\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Index of the last predecessor for which a value was recorded during merging.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Value, class KeyData>\n            struct SnapshotTableEntry : KeyData {\n              Value value;\n              // `merge_offset` is the offset in `merge_values_` where we store the\n              // merged values. It is used during merging (to know what to merge) and when\n              // calling GetPredecessorValue.\n              uint32_t merge_offset = kNoMergeOffset;\n              // Used during merging: the index of the predecessor for which we last\n              // recorded a value. This allows us to only use the last value for a given\n              // predecessor and skip over all earlier ones.\n              uint32_t last_merged_predecessor = kNoMergedPredecessor;\n\n              explicit SnapshotTableEntry(Value value, KeyData data)\n                  : KeyData(std::move(data)), value(std::move(value)) {}\n\n              static constexpr uint32_t kNoMergeOffset =\n                  std::numeric_limits<uint32_t>::max();\n              static constexpr uint32_t kNoMergedPredecessor =\n                  std::numeric_limits<uint32_t>::max();\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SnapshotTableKey\",\n            \"about\": \"Represents a key to an entry in the SnapshotTable. Implemented as a pointer to the entry for efficiency.\",\n            \"attributes\": [\n                {\n                    \"name\": \"entry_\",\n                    \"type\": \"SnapshotTableEntry<Value, KeyData>*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the SnapshotTableEntry this key represents.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SnapshotTableEntry\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Value, class KeyData>\n            class SnapshotTableKey {\n             public:\n              bool operator==(SnapshotTableKey other) const {\n                return entry_ == other.entry_;\n              }\n              const KeyData& data() const { return *entry_; }\n              KeyData& data() { return *entry_; }\n              SnapshotTableKey() : entry_(nullptr) {}\n\n              bool valid() const { return entry_ != nullptr; }\n\n             private:\n              friend class SnapshotTable<Value, KeyData>;\n              SnapshotTableEntry<Value, KeyData>* entry_;\n              explicit SnapshotTableKey(SnapshotTableEntry<Value, KeyData>& entry)\n                  : entry_(&entry) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SnapshotTable\",\n            \"about\": \"Implements a table that stores a mapping from keys to values and efficiently manages snapshots of the table's state.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone used for memory allocation.\"\n                },\n                {\n                    \"name\": \"table_\",\n                    \"type\": \"ZoneDeque<TableEntry>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying table storing the entries.\"\n                },\n                {\n                    \"name\": \"snapshots_\",\n                    \"type\": \"ZoneDeque<SnapshotData>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A deque storing the snapshot metadata.\"\n                },\n                {\n                    \"name\": \"log_\",\n                    \"type\": \"ZoneVector<LogEntry>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector storing the log of changes to the table.\"\n                },\n                {\n                    \"name\": \"root_snapshot_\",\n                    \"type\": \"SnapshotData*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the root snapshot.\"\n                },\n                {\n                    \"name\": \"current_snapshot_\",\n                    \"type\": \"SnapshotData*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the current snapshot.\"\n                },\n                {\n                    \"name\": \"merging_entries_\",\n                    \"type\": \"ZoneVector<TableEntry*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Temporary vector to store entries being merged.\"\n                },\n                {\n                    \"name\": \"merge_values_\",\n                    \"type\": \"ZoneVector<Value>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Temporary vector to store merged values.\"\n                },\n                {\n                    \"name\": \"path_\",\n                    \"type\": \"ZoneVector<SnapshotData*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Temporary vector to store the path to a common ancestor snapshot.\"\n                },\n                {\n                    \"name\": \"snapshot_was_created_with_merge\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Debug flag to track if a snapshot was created with merging.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SnapshotTableEntry\",\n                \"SnapshotTableKey\",\n                \"NoKeyData\",\n                \"NoChangeCallback\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Value, class KeyData = NoKeyData>\n            class SnapshotTable {\n             private:\n              struct LogEntry;\n              struct SnapshotData;\n\n             public:\n              using TableEntry = SnapshotTableEntry<Value, KeyData>;\n              using Key = SnapshotTableKey<Value, KeyData>;\n\n              // A `Snapshot` captures the state of the `SnapshotTable`.\n              // A `Snapshot` is implemented as a pointer to internal data and is therefore\n              // cheap to copy.\n              class MaybeSnapshot;\n              class Snapshot {\n               public:\n                bool operator==(Snapshot other) const { return data_ == other.data_; }\n\n               private:\n                friend SnapshotTable;\n                friend MaybeSnapshot;\n\n                SnapshotData* data_;\n                explicit Snapshot(SnapshotData& data) : data_(&data) {}\n                explicit Snapshot(SnapshotData* data) : data_(data) {}\n              };\n\n              class MaybeSnapshot {\n               public:\n                bool has_value() const { return data_ != nullptr; }\n                Snapshot value() const {\n                  DCHECK(has_value());\n                  return Snapshot{data_};\n                }\n\n                void Set(Snapshot snapshot) { data_ = snapshot.data_; }\n\n                MaybeSnapshot() = default;\n                explicit MaybeSnapshot(Snapshot snapshot) : data_(snapshot.data_) {}\n\n               private:\n                SnapshotData* data_ = nullptr;\n              };\n\n              // A new Snapshot is based on a list of predecessor Snapshots. If no\n              // predecessor is given, the new Snapshot is based on the initial state of the\n              // table. A single predecessor Snapshot resets the table to exactly this\n              // Snapshot. In the case of multiple Snapshots, a merge function is used to\n              // unify values that were set since the last common ancestor snapshot.\n              // The previous Snapshot needs to be closed using Seal() before another one\n              // can be created.\n              // The function `change_callback` is invoked for every atomic update to a\n              // table entry as part of switching to the new snapshot and merging.\n              // Note that the callback might be invoked multiple times for the same key,\n              // because we first roll-back changes to the common ancestor and then apply\n              // the merge function. The second update will have the new value of the first\n              // update as old value. We should not rely on the exact sequence of updates,\n              // only on the fact that the updates collectively transform the table into the\n              // new state. The motivation for this feature are secondary indices that need\n              // to be kept in sync with the main table.\n              template <class ChangeCallback = NoChangeCallback>\n              void StartNewSnapshot(base::Vector<const Snapshot> predecessors,\n                                    const ChangeCallback& change_callback = {})\n                requires(std::is_invocable_v<ChangeCallback, Key, Value, Value>)\n              {\n                DCHECK(current_snapshot_->IsSealed());\n                MoveToNewSnapshot(predecessors, change_callback);\n            #ifdef DEBUG\n                snapshot_was_created_with_merge = false;\n            #endif\n              }\n              template <class ChangeCallback = NoChangeCallback>\n              void StartNewSnapshot(std::initializer_list<Snapshot> predecessors = {},\n                                    const ChangeCallback& change_callback = {})\n                requires(std::is_invocable_v<ChangeCallback, Key, Value, Value>)\n              {\n                StartNewSnapshot(base::VectorOf(predecessors), change_callback);\n              }\n              template <class ChangeCallback = NoChangeCallback>\n              void StartNewSnapshot(Snapshot parent,\n                                    const ChangeCallback& change_callback = {})\n                requires(std::is_invocable_v<ChangeCallback, Key, Value, Value>)\n              {\n                StartNewSnapshot({parent}, change_callback);\n              }\n              template <class MergeFun, class ChangeCallback = NoChangeCallback>\n              void StartNewSnapshot(base::Vector<const Snapshot> predecessors,\n                                    const MergeFun& merge_fun,\n                                    const ChangeCallback& change_callback = {})\n                requires(std::is_invocable_v<MergeFun, Key, base::Vector<const Value>> &&\n                         std::is_invocable_v<ChangeCallback, Key, Value, Value>)\n              {\n                StartNewSnapshot(predecessors, change_callback);\n                MergePredecessors(predecessors, merge_fun, change_callback);\n            #ifdef DEBUG\n                snapshot_was_created_with_merge = true;\n            #endif\n              }\n              template <class MergeFun, class ChangeCallback = NoChangeCallback>\n              void StartNewSnapshot(std::initializer_list<Snapshot> predecessors,\n                                    const MergeFun& merge_fun,\n                                    const ChangeCallback& change_callback = {})\n                requires(std::is_invocable_v<MergeFun, Key, base::Vector<const Value>> &&\n                         std::is_invocable_v<ChangeCallback, Key, Value, Value>)\n              {\n                StartNewSnapshot(base::VectorOf(predecessors), merge_fun, change_callback);\n              }\n\n              Snapshot Seal() {\n                current_snapshot_->Seal(log_.size());\n                // Reseting the entries' `merge_offset` and `last_merged_predecessor`\n                // fields, so that they are cleared for the next Merge.\n                for (TableEntry* entry : merging_entries_) {\n                  entry->last_merged_predecessor = kNoMergedPredecessor;\n                  entry->merge_offset = kNoMergeOffset;\n                }\n                merge_values_.clear();\n                merging_entries_.clear();\n\n                // Optimization: If nothing changed in the new snapshot, we discard it and\n                // use its parent instead.\n                if (current_snapshot_->log_begin == current_snapshot_->log_end) {\n                  SnapshotData* parent = current_snapshot_->parent;\n                  DCHECK_EQ(current_snapshot_, &snapshots_.back());\n                  snapshots_.pop_back();\n                  current_snapshot_ = parent;\n                  return Snapshot{*parent};\n                }\n                return Snapshot{*current_snapshot_};\n              }\n\n              const Value& Get(Key key) const { return key.entry_->value; }\n\n              // Returns the value associated to {key} in its {predecessor_index}th\n              // predecessor (where \"predecessor\" refers to the predecessors that were\n              // passed to StartNewSnapshot when creating the current snapshot).\n              // This function should only be used if the snapshot was started with a merge\n              // function.\n              // If {key} wasn't merged but was Set in the current snapshot, then\n              // the newly set value will be returned rather than the predecessor value.\n              const Value& GetPredecessorValue(Key key, int predecessor_index) {\n                DCHECK(!current_snapshot_->IsSealed());\n                DCHECK(snapshot_was_created_with_merge);\n                if (key.entry_->merge_offset == kNoMergeOffset) return Get(key);\n                return merge_values_[key.entry_->merge_offset + predecessor_index];\n              }\n\n              // {Set} returns whether the {new_value} is different from the previous value.\n              bool Set(Key key, Value new_value) {\n                DCHECK(!current_snapshot_->IsSealed());\n                if (key.entry_->value == new_value) return false;\n                log_.push_back(LogEntry{*key.entry_, key.entry_->value, new_value});\n                key.entry_->value = new_value;\n                return true;\n              }\n\n              explicit SnapshotTable(Zone* zone) : zone_(zone) {\n                root_snapshot_ = &NewSnapshot(nullptr);\n                root_snapshot_->Seal(0);\n                current_snapshot_ = root_snapshot_;\n              }\n\n              // The initial value is independent of the snapshot mechanism. Creating a key\n              // with a certain initial value later has the same effect as creating the key\n              // before all modifications to the table.\n              // Keys have identity, and the data embedded in the key is mutable.\n              Key NewKey(KeyData data, Value initial_value = Value{}) {\n                return Key{table_.emplace_back(\n                    TableEntry{std::move(initial_value), std::move(data)})};\n              }\n              Key NewKey(Value initial_value = Value{}) {\n                return NewKey(KeyData{}, initial_value);\n              }\n\n              // Returns true if {current_snapshot_} is sealed.\n              bool IsSealed() { return current_snapshot_->IsSealed(); }\n\n             private:\n              Zone* zone_;\n              ZoneDeque<TableEntry> table_{zone_};\n              ZoneDeque<SnapshotData> snapshots_{zone_};\n              // While logically each snapshot has its own log, we allocate the memory as a\n              // single global log with each snapshot pointing to a section of it to reduce\n              // the number of allocations.\n              ZoneVector<LogEntry> log_{zone_};\n              SnapshotData* root_snapshot_;\n              SnapshotData* current_snapshot_;\n\n              // The following members are only used temporarily during a merge operation\n              // or when creating a new snapshot.\n              // They are declared here to recycle the memory, avoiding repeated\n              // Zone-allocation.\n              ZoneVector<TableEntry*> merging_entries_{zone_};\n              ZoneVector<Value> merge_values_{zone_};\n              ZoneVector<SnapshotData*> path_{zone_};\n\n            #ifdef DEBUG\n              bool snapshot_was_created_with_merge = false;\n            #endif\n\n              SnapshotData& NewSnapshot(SnapshotData* parent) {\n                return snapshots_.emplace_back(parent, log_.size());\n              }\n\n              base::Vector<LogEntry> LogEntries(SnapshotData* s) {\n                return base::VectorOf(&log_[s->log_begin], s->log_end - s->log_begin);\n              }\n\n              template <class ChangeCallback = NoChangeCallback>\n              void RevertCurrentSnapshot(ChangeCallback& change_callback) {\n                DCHECK(current_snapshot_->IsSealed());\n                base::Vector<LogEntry> log_entries = LogEntries(current_snapshot_);\n                for (const LogEntry& entry : base::Reversed(log_entries)) {\n                  DCHECK_EQ(entry.table_entry.value, entry.new_value);\n                  DCHECK_NE(entry.new_value, entry.old_value);\n                  change_callback(Key{entry.table_entry}, entry.new_value, entry.old_value);\n                  entry.table_entry.value = entry.old_value;\n                }\n                current_snapshot_ = current_snapshot_->parent;\n                DCHECK_NOT_NULL(current_snapshot_);\n              }\n\n              template <class ChangeCallback = NoChangeCallback>\n              void ReplaySnapshot(SnapshotData* snapshot, ChangeCallback& change_callback) {\n                DCHECK_EQ(snapshot->parent, current_snapshot_);\n                for (const LogEntry& entry : LogEntries(snapshot)) {\n                  DCHECK_EQ(entry.table_entry.value, entry.old_value);\n                  DCHECK_NE(entry.new_value, entry.old_value);\n                  change_callback(Key{entry.table_entry}, entry.old_value, entry.new_value);\n                  entry.table_entry.value = entry.new_value;\n                }\n                current_snapshot_ = snapshot;\n              }\n\n              void RecordMergeValue(TableEntry& entry, const Value& value,\n                                    uint32_t predecessor_index, uint32_t predecessor_count);\n              template <class ChangeCallback>\n              SnapshotData& MoveToNewSnapshot(base::Vector<const Snapshot> predecessors,\n                                              const ChangeCallback& change_callback);\n              template <class MergeFun, class ChangeCallback>\n              void MergePredecessors(base::Vector<const Snapshot> predecessors,\n                                     const MergeFun& merge_fun,\n                                     const ChangeCallback& change_callback);\n\n              static constexpr uint32_t kNoMergeOffset =\n                  std::numeric_limits<uint32_t>::max();\n              static constexpr uint32_t kNoMergedPredecessor =\n                  std::numeric_limits<uint32_t>::max();\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SnapshotTable<Value, KeyData>::LogEntry\",\n            \"about\": \"Represents a single log entry in the SnapshotTable's history, tracking a change to a table entry.\",\n            \"attributes\": [\n                {\n                    \"name\": \"table_entry\",\n                    \"type\": \"TableEntry&\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Reference to the table entry that was modified.\"\n                },\n                {\n                    \"name\": \"old_value\",\n                    \"type\": \"Value\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The value of the entry before the change.\"\n                },\n                {\n                    \"name\": \"new_value\",\n                    \"type\": \"Value\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The value of the entry after the change.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SnapshotTableEntry\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Value, class KeyData>\n            struct SnapshotTable<Value, KeyData>::LogEntry {\n              TableEntry& table_entry;\n              Value old_value;\n              Value new_value;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SnapshotTable<Value, KeyData>::SnapshotData\",\n            \"about\": \"Stores metadata about a snapshot, including its parent, depth, and log boundaries.\",\n            \"attributes\": [\n                {\n                    \"name\": \"parent\",\n                    \"type\": \"SnapshotData*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Pointer to the parent snapshot.\"\n                },\n                {\n                    \"name\": \"depth\",\n                    \"type\": \"const uint32_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Depth of the snapshot in the snapshot tree.\"\n                },\n                {\n                    \"name\": \"log_begin\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Starting index of the log entries for this snapshot.\"\n                },\n                {\n                    \"name\": \"log_end\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Ending index of the log entries for this snapshot.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Value, class KeyData>\n            struct SnapshotTable<Value, KeyData>::SnapshotData {\n              SnapshotData* parent;\n\n              const uint32_t depth = parent ? parent->depth + 1 : 0;\n              size_t log_begin;\n              size_t log_end = kInvalidOffset;\n\n              static constexpr size_t kInvalidOffset = std::numeric_limits<size_t>::max();\n\n              SnapshotData(SnapshotData* parent, size_t log_begin)\n                  : parent(parent), log_begin(log_begin) {}\n\n              SnapshotData* CommonAncestor(SnapshotData* other) {\n                SnapshotData* self = this;\n                while (other->depth > self->depth) other = other->parent;\n                while (self->depth > other->depth) self = self->parent;\n                while (other != self) {\n                  self = self->parent;\n                  other = other->parent;\n                }\n                return self;\n              }\n              void Seal(size_t end) {\n                DCHECK_WITH_MSG(!IsSealed(), \"A Snapshot can only be sealed once\");\n                this->log_end = end;\n              }\n\n              bool IsSealed() const { return log_end != kInvalidOffset; }\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SnapshotTable<Value, KeyData>::RecordMergeValue\",\n            \"parent\": \"SnapshotTable\",\n            \"about\": \"Records a merged value for a given table entry and predecessor index.\",\n            \"logic\": \"Records the value for a specific predecessor in the merge_values_ vector. Allocates space in merge_values_ if this is the first time a value is recorded for this entry.\",\n            \"parameters\": [\n                {\n                    \"name\": \"entry\",\n                    \"type\": \"TableEntry&\",\n                    \"purpose\": \"The table entry to record the merged value for.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"const Value&\",\n                    \"purpose\": \"The merged value to record.\"\n                },\n                {\n                    \"name\": \"predecessor_index\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The index of the predecessor snapshot.\"\n                },\n                {\n                    \"name\": \"predecessor_count\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The total number of predecessor snapshots.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Value, class KeyData>\n            void SnapshotTable<Value, KeyData>::RecordMergeValue(\n                TableEntry& entry, const Value& value, uint32_t predecessor_index,\n                uint32_t predecessor_count) {\n              if (predecessor_index == entry.last_merged_predecessor) {\n                DCHECK_NE(entry.merge_offset, kNoMergeOffset);\n                // We already recorded a later value for this predecessor, so we should skip\n                // earlier values.\n                return;\n              }\n              if (entry.merge_offset == kNoMergeOffset) {\n                // Allocate space for the merge values. All the merge values are initialized\n                // to the value from the parent snapshot. This way, we get the right value\n                // for predecessors that did not change the value.\n                DCHECK_EQ(entry.last_merged_predecessor, kNoMergedPredecessor);\n                CHECK_LE(merge_values_.size() + predecessor_count,\n                         std::numeric_limits<uint32_t>::max());\n                entry.merge_offset = static_cast<uint32_t>(merge_values_.size());\n                merging_entries_.push_back(&entry);\n                merge_values_.insert(merge_values_.end(), predecessor_count, entry.value);\n              }\n              merge_values_[entry.merge_offset + predecessor_index] = value;\n              entry.last_merged_predecessor = predecessor_index;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SnapshotTable<Value, KeyData>::MoveToNewSnapshot\",\n            \"parent\": \"SnapshotTable\",\n            \"about\": \"Prepares the SnapshotTable to start a new snapshot by reverting and replaying snapshots to reach the common ancestor.\",\n            \"logic\": \"Finds the common ancestor of the current snapshot and the predecessors, reverts snapshots back to the common ancestor with the current snapshot, and then replays snapshots forward to the common ancestor of the predecessors.\",\n            \"parameters\": [\n                {\n                    \"name\": \"predecessors\",\n                    \"type\": \"base::Vector<const Snapshot>\",\n                    \"purpose\": \"The predecessors of the new snapshot.\"\n                },\n                {\n                    \"name\": \"change_callback\",\n                    \"type\": \"const ChangeCallback&\",\n                    \"purpose\": \"The callback to invoke for each change during revert and replay.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"SnapshotData&\",\n                \"description\": \"A reference to the newly created snapshot data.\"\n            },\n            \"dependencies\": [\n                \"LogEntries\",\n                \"RevertCurrentSnapshot\",\n                \"ReplaySnapshot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Value, class KeyData>\n            template <class ChangeCallback>\n            typename SnapshotTable<Value, KeyData>::SnapshotData&\n            SnapshotTable<Value, KeyData>::MoveToNewSnapshot(\n                base::Vector<const Snapshot> predecessors,\n                const ChangeCallback& change_callback) {\n              DCHECK_WITH_MSG(\n                  current_snapshot_->IsSealed(),\n                  \"A new Snapshot was opened before the previous Snapshot was sealed\");\n\n              SnapshotData* common_ancestor;\n              if (predecessors.empty()) {\n                common_ancestor = root_snapshot_;\n              } else {\n                common_ancestor = predecessors.first().data_;\n                for (Snapshot s : predecessors.SubVectorFrom(1)) {\n                  common_ancestor = common_ancestor->CommonAncestor(s.data_);\n                }\n              }\n              SnapshotData* go_back_to = common_ancestor->CommonAncestor(current_snapshot_);\n              while (current_snapshot_ != go_back_to) {\n                RevertCurrentSnapshot(change_callback);\n              }\n              {\n                // Replay to common_ancestor.\n                path_.clear();\n                for (SnapshotData* s = common_ancestor; s != go_back_to; s = s->parent) {\n                  path_.push_back(s);\n                }\n                for (SnapshotData* s : base::Reversed(path_)) {\n                  ReplaySnapshot(s, change_callback);\n                }\n              }\n\n              DCHECK_EQ(current_snapshot_, common_ancestor);\n              SnapshotData& new_snapshot = NewSnapshot(common_ancestor);\n              current_snapshot_ = &new_snapshot;\n              return new_snapshot;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SnapshotTable<Value, KeyData>::MergePredecessors\",\n            \"parent\": \"SnapshotTable\",\n            \"about\": \"Merges all entries modified in predecessors since the last common ancestor by adding them to the current snapshot.\",\n            \"logic\": \"Iterates through the predecessor logs, recording merge values for each key that has changed. Then, calls the merge function for each merged entry and updates the table accordingly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"predecessors\",\n                    \"type\": \"base::Vector<const Snapshot>\",\n                    \"purpose\": \"The predecessors to merge.\"\n                },\n                {\n                    \"name\": \"merge_fun\",\n                    \"type\": \"const MergeFun&\",\n                    \"purpose\": \"The function to use for merging values.\"\n                },\n                {\n                    \"name\": \"change_callback\",\n                    \"type\": \"const ChangeCallback&\",\n                    \"purpose\": \"The callback to invoke for each change during merging.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"LogEntries\",\n                \"RecordMergeValue\",\n                \"Set\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Value, class KeyData>\n            template <class MergeFun, class ChangeCallback>\n            void SnapshotTable<Value, KeyData>::MergePredecessors(\n                base::Vector<const Snapshot> predecessors, const MergeFun& merge_fun,\n                const ChangeCallback& change_callback) {\n              CHECK_LE(predecessors.size(), std::numeric_limits<uint32_t>::max());\n              uint32_t predecessor_count = static_cast<uint32_t>(predecessors.size());\n              if (predecessor_count < 1) return;\n\n              // The merging works by reserving `predecessor_count` many slots in\n              // `merge_values_` for every key that we find while going through the\n              // predecessor logs. There, we place the values of the corresponding\n              // predecessors, so that we can finally call the `merge_fun` by creating a\n              // `base::Vector` pointing to the collected values inside of `merge_values_`.\n              DCHECK(merge_values_.empty());\n              DCHECK(merging_entries_.empty());\n              SnapshotData* common_ancestor = current_snapshot_->parent;\n\n              // Collect all the entries that require merging. For this, we walk the logs of\n              // the predecessors backwards until reaching the common ancestor.\n              for (uint32_t i = 0; i < predecessor_count; ++i) {\n                for (SnapshotData* predecessor = predecessors[i].data_;\n                     predecessor != common_ancestor; predecessor = predecessor->parent) {\n                  base::Vector<LogEntry> log_entries = LogEntries(predecessor);\n                  for (const LogEntry& entry : base::Reversed(log_entries)) {\n                    RecordMergeValue(entry.table_entry, entry.new_value, i,\n                                     predecessor_count);\n                  }\n                }\n              }\n              // Actually perform the merging by calling the merge function and modifying\n              // the table.\n              for (TableEntry* entry : merging_entries_) {\n                Key key{*entry};\n                Value value = merge_fun(\n                    key, base::VectorOf<const Value>(&merge_values_[entry->merge_offset],\n                                                     predecessor_count));\n                Value old_value = entry->value;\n                if (Set(key, std::move(value))) {\n                  change_callback(key, old_value, entry->value);\n                }\n              }\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ChangeTrackingSnapshotTable\",\n            \"extends\": \"SnapshotTable\",\n            \"about\": \"Extends SnapshotTable to automatically invoke OnNewKey and OnValueChange on the subclass whenever the table state changes.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"SnapshotTable\",\n                \"NoKeyData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Derived, class Value, class KeyData = NoKeyData>\n            class ChangeTrackingSnapshotTable : public SnapshotTable<Value, KeyData> {\n             public:\n              using Super = SnapshotTable<Value, KeyData>;\n              using Super::Super;"
}