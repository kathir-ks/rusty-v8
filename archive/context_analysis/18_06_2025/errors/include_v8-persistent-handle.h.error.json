{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-persistent-handle.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-persistent-handle.h\",\n        \"file_name\": \"v8-persistent-handle.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines persistent handle classes (Eternal, PersistentBase, Persistent, Global) for managing object lifetimes in V8 outside of handle scopes.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary V8 internal headers and standard library features.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"v8-internal.h\"            // NOLINT(build/include_directory)\n#include \"v8-local-handle.h\"        // NOLINT(build/include_directory)\n#include \"v8-weak-callback-info.h\"  // NOLINT(build/include_directory)\n#include \"v8config.h\"               // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Eternal\",\n            \"extends\": \"api_internal::IndirectHandleBase\",\n            \"about\": \"Represents a handle that lives for the lifetime of the isolate and is set only once.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Local\",\n                \"api_internal::IndirectHandleBase\",\n                \"api_internal::Eternalize\",\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass Eternal : public api_internal::IndirectHandleBase {\n public:\n  V8_INLINE Eternal() = default;\n\n  /**\n   * Constructor for handling automatic up casting.\n   */\n  template <class S>\n    requires(std::is_base_of_v<T, S>)\n  V8_INLINE Eternal(Isolate* isolate, Local<S> handle) {\n    Set(isolate, handle);\n  }\n\n  // Can only be safely called if already set.\n  V8_INLINE Local<T> Get(Isolate* isolate) const {\n    // The eternal handle will never go away, so as with the roots, we don't\n    // even need to open a handle.\n    return Local<T>::FromSlot(slot());\n  }\n\n  template <class S>\n    requires(std::is_base_of_v<T, S>)\n  void Set(Isolate* isolate, Local<S> handle) {\n    slot() =\n        api_internal::Eternalize(isolate, *handle.template UnsafeAs<Value>());\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PersistentBase\",\n            \"extends\": \"api_internal::IndirectHandleBase\",\n            \"about\": \"Base class for persistent handles, which are object references that are independent of handle scopes and remain valid until explicitly disposed.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Local\",\n                \"api_internal::IndirectHandleBase\",\n                \"internal::HandleHelper\",\n                \"WeakCallbackInfo\",\n                \"api_internal::MakeWeak\",\n                \"api_internal::ClearWeak\",\n                \"api_internal::AnnotateStrongRetainer\",\n                \"internal::Internals\",\n                \"api_internal::DisposeGlobal\",\n                \"Object\",\n                \"internal::ValueHelper\",\n                \"api_internal::GlobalizeReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass PersistentBase : public api_internal::IndirectHandleBase {\n public:\n  /**\n   * If non-empty, destroy the underlying storage cell\n   * IsEmpty() will return true after this call.\n   */\n  V8_INLINE void Reset();\n\n  /**\n   * If non-empty, destroy the underlying storage cell\n   * and create a new one with the contents of other if other is non empty\n   */\n  template <class S>\n  V8_INLINE void Reset(Isolate* isolate, const Local<S>& other);\n\n  /**\n   * If non-empty, destroy the underlying storage cell\n   * and create a new one with the contents of other if other is non empty\n   */\n  template <class S>\n  V8_INLINE void Reset(Isolate* isolate, const PersistentBase<S>& other);\n\n  V8_INLINE Local<T> Get(Isolate* isolate) const {\n    return Local<T>::New(isolate, *this);\n  }\n\n  template <class S>\n  V8_INLINE bool operator==(const PersistentBase<S>& that) const {\n    return internal::HandleHelper::EqualHandles(*this, that);\n  }\n\n  template <class S>\n  V8_INLINE bool operator==(const Local<S>& that) const {\n    return internal::HandleHelper::EqualHandles(*this, that);\n  }\n\n  template <class S>\n  V8_INLINE bool operator!=(const PersistentBase<S>& that) const {\n    return !operator==(that);\n  }\n\n  template <class S>\n  V8_INLINE bool operator!=(const Local<S>& that) const {\n    return !operator==(that);\n  }\n\n  /**\n   * Install a finalization callback on this object.\n   * NOTE: There is no guarantee as to *when* or even *if* the callback is\n   * invoked. The invocation is performed solely on a best effort basis.\n   * As always, GC-based finalization should *not* be relied upon for any\n   * critical form of resource management!\n   *\n   * The callback is supposed to reset the handle. No further V8 API may be\n   * called in this callback. In case additional work involving V8 needs to be\n   * done, a second callback can be scheduled using\n   * WeakCallbackInfo<void>::SetSecondPassCallback.\n   */\n  template <typename P>\n  V8_INLINE void SetWeak(P* parameter,\n                         typename WeakCallbackInfo<P>::Callback callback,\n                         WeakCallbackType type);\n\n  /**\n   * Turns this handle into a weak phantom handle without finalization callback.\n   * The handle will be reset automatically when the garbage collector detects\n   * that the object is no longer reachable.\n   */\n  V8_INLINE void SetWeak();\n\n  template <typename P>\n  V8_INLINE P* ClearWeak();\n\n  // TODO(dcarney): remove this.\n  V8_INLINE void ClearWeak() { ClearWeak<void>(); }\n\n  /**\n   * Annotates the strong handle with the given label, which is then used by the\n   * heap snapshot generator as a name of the edge from the root to the handle.\n   * The function does not take ownership of the label and assumes that the\n   * label is valid as long as the handle is valid.\n   */\n  V8_INLINE void AnnotateStrongRetainer(const char* label);\n\n  /** Returns true if the handle's reference is weak.  */\n  V8_INLINE bool IsWeak() const;\n\n  /**\n   * Assigns a wrapper class ID to the handle.\n   */\n  V8_INLINE void SetWrapperClassId(uint16_t class_id);\n\n  /**\n   * Returns the class ID previously assigned to this handle or 0 if no class ID\n   * was previously assigned.\n   */\n  V8_INLINE uint16_t WrapperClassId() const;\n\n  PersistentBase(const PersistentBase& other) = delete;\n  void operator=(const PersistentBase&) = delete;\n\n private:\n  friend class Isolate;\n  friend class Utils;\n  template <class F>\n  friend class Local;\n  template <class F1, class F2>\n  friend class Persistent;\n  template <class F>\n  friend class Global;\n  template <class F>\n  friend class PersistentBase;\n  template <class F>\n  friend class ReturnValue;\n  template <class F1, class F2, class F3>\n  friend class PersistentValueMapBase;\n  friend class Object;\n  friend class internal::ValueHelper;\n\n  V8_INLINE PersistentBase() = default;\n\n  V8_INLINE explicit PersistentBase(internal::Address* location)\n      : IndirectHandleBase(location) {}\n\n  V8_INLINE static internal::Address* New(Isolate* isolate, T* that);\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NonCopyablePersistentTraits\",\n            \"about\": \"Defines traits for Persistent that disallows copy and assignment operations.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Persistent\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass NonCopyablePersistentTraits {\n public:\n  using NonCopyablePersistent = Persistent<T, NonCopyablePersistentTraits<T>>;\n  static const bool kResetInDestructor = false;\n  template <class S, class M>\n  V8_INLINE static void Copy(const Persistent<S, M>& source,\n                             NonCopyablePersistent* dest) {\n    static_assert(sizeof(S) < 0,\n                  \"NonCopyablePersistentTraits::Copy is not instantiable\");\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Persistent\",\n            \"extends\": \"PersistentBase\",\n            \"about\": \"A PersistentBase which allows copy and assignment, controlled by the traits class M.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Local\",\n                \"PersistentBase\",\n                \"NonCopyablePersistentTraits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, class M>\nclass Persistent : public PersistentBase<T> {\n public:\n  /**\n   * A Persistent with no storage cell.\n   */\n  V8_INLINE Persistent() = default;\n\n  /**\n   * Construct a Persistent from a Local with automatic up casting.\n   * When the Local is non-empty, a new storage cell is created\n   * pointing to the same object, and no flags are set.\n   */\n  template <class S>\n    requires(std::is_base_of_v<T, S>)\n  V8_INLINE Persistent(Isolate* isolate, Local<S> that)\n      : PersistentBase<T>(\n            PersistentBase<T>::New(isolate, that.template value<S>())) {}\n\n  /**\n   * Construct a Persistent from a Persistent with automatic up casting.\n   * When the Persistent is non-empty, a new storage cell is created\n   * pointing to the same object, and no flags are set.\n   */\n  template <class S, class M2>\n    requires(std::is_base_of_v<T, S>)\n  V8_INLINE Persistent(Isolate* isolate, const Persistent<S, M2>& that)\n      : PersistentBase<T>(\n            PersistentBase<T>::New(isolate, that.template value<S>())) {}\n\n  /**\n   * The copy constructors and assignment operator create a Persistent\n   * exactly as the Persistent constructor, but the Copy function from the\n   * traits class is called, allowing the setting of flags based on the\n   * copied Persistent.\n   */\n  V8_INLINE Persistent(const Persistent& that) : PersistentBase<T>() {\n    Copy(that);\n  }\n  template <class S, class M2>\n  V8_INLINE Persistent(const Persistent<S, M2>& that) : PersistentBase<T>() {\n    Copy(that);\n  }\n  V8_INLINE Persistent& operator=(const Persistent& that) {\n    Copy(that);\n    return *this;\n  }\n  template <class S, class M2>\n  V8_INLINE Persistent& operator=(const Persistent<S, M2>& that) {\n    Copy(that);\n    return *this;\n  }\n\n  /**\n   * The destructor will dispose the Persistent based on the\n   * kResetInDestructor flags in the traits class.  Since not calling dispose\n   * can result in a memory leak, it is recommended to always set this flag.\n   */\n  V8_INLINE ~Persistent() {\n    if (M::kResetInDestructor) this->Reset();\n  }\n\n  // TODO(dcarney): this is pretty useless, fix or remove\n  template <class S, class M2>\n  V8_INLINE static Persistent<T, M>& Cast(const Persistent<S, M2>& that) {\n#ifdef V8_ENABLE_CHECKS\n    // If we're going to perform the type check then we have to check\n    // that the handle isn't empty before doing the checked cast.\n    if (!that.IsEmpty()) T::Cast(that.template value<S>());\n#endif\n    return reinterpret_cast<Persistent<T, M>&>(\n        const_cast<Persistent<S, M2>&>(that));\n  }\n\n  // TODO(dcarney): this is pretty useless, fix or remove\n  template <class S, class M2>\n  V8_INLINE Persistent<S, M2>& As() const {\n    return Persistent<S, M2>::Cast(*this);\n  }\n\n private:\n  friend class Isolate;\n  friend class Utils;\n  template <class F>\n  friend class Local;\n  template <class F1, class F2>\n  friend class Persistent;\n  template <class F>\n  friend class ReturnValue;\n\n  template <class S, class M2>\n  V8_INLINE void Copy(const Persistent<S, M2>& that);\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Global\",\n            \"extends\": \"PersistentBase\",\n            \"about\": \"A PersistentBase which has move semantics.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Local\",\n                \"PersistentBase\",\n                \"api_internal::MoveGlobalReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass Global : public PersistentBase<T> {\n public:\n  /**\n   * A Global with no storage cell.\n   */\n  V8_INLINE Global() = default;\n\n  /**\n   * Construct a Global from a Local with automatic up casting.\n   * When the Local is non-empty, a new storage cell is created\n   * pointing to the same object, and no flags are set.\n   */\n  template <class S>\n    requires(std::is_base_of_v<T, S>)\n  V8_INLINE Global(Isolate* isolate, Local<S> that)\n      : PersistentBase<T>(\n            PersistentBase<T>::New(isolate, that.template value<S>())) {}\n\n  /**\n   * Construct a Global from a PersistentBase with automatic up casting.\n   * When the Persistent is non-empty, a new storage cell is created\n   * pointing to the same object, and no flags are set.\n   */\n  template <class S>\n    requires(std::is_base_of_v<T, S>)\n  V8_INLINE Global(Isolate* isolate, const PersistentBase<S>& that)\n      : PersistentBase<T>(\n            PersistentBase<T>::New(isolate, that.template value<S>())) {}\n\n  /**\n   * Move constructor.\n   */\n  V8_INLINE Global(Global&& other);\n\n  V8_INLINE ~Global() { this->Reset(); }\n\n  /**\n   * Move via assignment.\n   */\n  template <class S>\n  V8_INLINE Global& operator=(Global<S>&& rhs);\n\n  /**\n   * Pass allows returning uniques from functions, etc.\n   */\n  Global Pass() { return static_cast<Global&&>(*this); }\n\n  /*\n   * For compatibility with Chromium's base::Bind (base::Passed).\n   */\n  using MoveOnlyTypeForCPP03 = void;\n\n  Global(const Global&) = delete;\n  void operator=(const Global&) = delete;\n\n private:\n  template <class F>\n  friend class ReturnValue;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PersistentHandleVisitor\",\n            \"about\": \"Interface for iterating through all the persistent handles in the heap.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Persistent\",\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT PersistentHandleVisitor {\n public:\n  virtual ~PersistentHandleVisitor() = default;\n  virtual void VisitPersistentHandle(Persistent<Value>* value,\n                                     uint16_t class_id) {}\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"New\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Creates a new global reference to a V8 object.\",\n            \"logic\": \"If the passed object is not empty, creates a new global reference using api_internal::GlobalizeReference. Returns nullptr otherwise.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate to associate with the global reference.\"\n                },\n                {\n                    \"name\": \"that\",\n                    \"type\": \"T*\",\n                    \"purpose\": \"The V8 object to create a global reference to.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"internal::Address*\",\n                \"description\": \"The address of the new global reference, or nullptr if the object is empty.\"\n            },\n            \"dependencies\": [\n                \"internal::ValueHelper\",\n                \"api_internal::GlobalizeReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\ninternal::Address* PersistentBase<T>::New(Isolate* isolate, T* that) {\n  if (internal::ValueHelper::IsEmpty(that)) return nullptr;\n  return api_internal::GlobalizeReference(\n      reinterpret_cast<internal::Isolate*>(isolate),\n      internal::ValueHelper::ValueAsAddress(that));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Copy\",\n            \"parent\": \"Persistent\",\n            \"about\": \"Copies a persistent handle, creating a new global reference.\",\n            \"logic\": \"Resets the current handle, and if the source handle is not empty, creates a new global reference by copying the source's global reference.\",\n            \"parameters\": [\n                {\n                    \"name\": \"that\",\n                    \"type\": \"const Persistent<S, M2>&\",\n                    \"purpose\": \"The source persistent handle to copy.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"api_internal::CopyGlobalReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, class M>\ntemplate <class S, class M2>\nvoid Persistent<T, M>::Copy(const Persistent<S, M2>& that) {\n  static_assert(std::is_base_of<T, S>::value, \"type check\");\n  this->Reset();\n  if (that.IsEmpty()) return;\n  this->slot() = api_internal::CopyGlobalReference(that.slot());\n  M::Copy(that, this);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsWeak\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Checks if the persistent handle is weak.\",\n            \"logic\": \"Uses internal::Internals::GetNodeState to determine if the handle's node state indicates that it's a weak value.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handle is weak, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"internal::Internals\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nbool PersistentBase<T>::IsWeak() const {\n  using I = internal::Internals;\n  if (this->IsEmpty()) return false;\n  return I::GetNodeState(this->slot()) == I::kNodeStateIsWeakValue;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reset\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Resets the persistent handle, disposing of the underlying storage cell.\",\n            \"logic\": \"If the handle is not empty, disposes of the global reference using api_internal::DisposeGlobal and clears the handle's slot.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"api_internal::DisposeGlobal\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nvoid PersistentBase<T>::Reset() {\n  if (this->IsEmpty()) return;\n  api_internal::DisposeGlobal(this->slot());\n  this->Clear();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reset\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Resets the persistent handle and creates a new one with the contents of a Local handle.\",\n            \"logic\": \"Resets the current handle, and if the Local handle is not empty, creates a new global reference pointing to the same object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate to associate with the new global reference.\"\n                },\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const Local<S>&\",\n                    \"purpose\": \"The Local handle to copy.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PersistentBase::New\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\ntemplate <class S>\nvoid PersistentBase<T>::Reset(Isolate* isolate, const Local<S>& other) {\n  static_assert(std::is_base_of<T, S>::value, \"type check\");\n  Reset();\n  if (other.IsEmpty()) return;\n  this->slot() = New(isolate, *other);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reset\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Resets the persistent handle and creates a new one with the contents of another PersistentBase handle.\",\n            \"logic\": \"Resets the current handle, and if the other PersistentBase handle is not empty, creates a new global reference pointing to the same object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate to associate with the new global reference.\"\n                },\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const PersistentBase<S>&\",\n                    \"purpose\": \"The other PersistentBase handle to copy.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PersistentBase::New\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\ntemplate <class S>\nvoid PersistentBase<T>::Reset(Isolate* isolate,\n                              const PersistentBase<S>& other) {\n  static_assert(std::is_base_of<T, S>::value, \"type check\");\n  Reset();\n  if (other.IsEmpty()) return;\n  this->slot() = New(isolate, other.template value<S>());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetWeak\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Installs a weak callback on the persistent handle.\",\n            \"logic\": \"Calls api_internal::MakeWeak to install a finalization callback that is invoked when the object is garbage collected.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parameter\",\n                    \"type\": \"P*\",\n                    \"purpose\": \"User-provided data passed to the callback.\"\n                },\n                {\n                    \"name\": \"callback\",\n                    \"type\": \"typename WeakCallbackInfo<P>::Callback\",\n                    \"purpose\": \"The callback function to invoke when the object is garbage collected.\"\n                },\n                {\n                    \"name\": \"type\",\n                    \"type\": \"WeakCallbackType\",\n                    \"purpose\": \"The type of weak callback to install.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"api_internal::MakeWeak\",\n                \"WeakCallbackInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\ntemplate <typename P>\nV8_INLINE void PersistentBase<T>::SetWeak(\n    P* parameter, typename WeakCallbackInfo<P>::Callback callback,\n    WeakCallbackType type) {\n  using Callback = WeakCallbackInfo<void>::Callback;\n#if (__GNUC__ >= 8) && !defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n  api_internal::MakeWeak(this->slot(), parameter,\n                         reinterpret_cast<Callback>(callback), type);\n#if (__GNUC__ >= 8) && !defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetWeak\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Turns the persistent handle into a weak phantom handle without a finalization callback.\",\n            \"logic\": \"Calls api_internal::MakeWeak to set the handle as weak, causing it to be automatically reset when the object is garbage collected.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"api_internal::MakeWeak\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nvoid PersistentBase<T>::SetWeak() {\n  api_internal::MakeWeak(&this->slot());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ClearWeak\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Clears the weak callback associated with the persistent handle.\",\n            \"logic\": \"Calls api_internal::ClearWeak to clear the weak callback and retrieve the user-provided data.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"P*\",\n                \"description\": \"The user-provided data associated with the weak callback.\"\n            },\n            \"dependencies\": [\n                \"api_internal::ClearWeak\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\ntemplate <typename P>\nP* PersistentBase<T>::ClearWeak() {\n  return reinterpret_cast<P*>(api_internal::ClearWeak(this->slot()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AnnotateStrongRetainer\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Annotates the strong handle with a label for heap snapshots.\",\n            \"logic\": \"Calls api_internal::AnnotateStrongRetainer to associate a label with the handle, which is used by the heap snapshot generator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"label\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The label to associate with the handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"api_internal::AnnotateStrongRetainer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nvoid PersistentBase<T>::AnnotateStrongRetainer(const char* label) {\n  api_internal::AnnotateStrongRetainer(this->slot(), label);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetWrapperClassId\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Assigns a wrapper class ID to the handle.\",\n            \"logic\": \"Sets the class ID in the handle's metadata, used for identifying the handle's type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"class_id\",\n                    \"type\": \"uint16_t\",\n                    \"purpose\": \"The class ID to assign to the handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"internal::Internals\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nvoid PersistentBase<T>::SetWrapperClassId(uint16_t class_id) {\n  using I = internal::Internals;\n  if (this->IsEmpty()) return;\n  uint8_t* addr = reinterpret_cast<uint8_t*>(slot()) + I::kNodeClassIdOffset;\n  *reinterpret_cast<uint16_t*>(addr) = class_id;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WrapperClassId\",\n            \"parent\": \"PersistentBase\",\n            \"about\": \"Returns the class ID previously assigned to the handle.\",\n            \"logic\": \"Retrieves the class ID from the handle's metadata.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"uint16_t\",\n                \"description\": \"The class ID assigned to the handle, or 0 if no class ID was assigned.\"\n            },\n            \"dependencies\": [\n                \"internal::Internals\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nuint16_t PersistentBase<T>::WrapperClassId() const {\n  using I = internal::Internals;\n  if (this->IsEmpty()) return 0;\n  uint8_t* addr = reinterpret_cast<uint8_t*>(slot()) + I::kNodeClassIdOffset;\n  return *reinterpret_cast<uint16_t*>(addr);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"Global\",\n            \"parent\": \"Global\",\n            \"about\": \"Move constructor for the Global class.\",\n            \"logic\": \"Moves the underlying storage cell from another Global object to the current Global object.  If the other object is not empty, the internal storage is moved using api_internal::MoveGlobalReference and the other Global is cleared.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"Global&&\",\n                    \"purpose\": \"The Global object to move from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Global\",\n                \"description\": \"A new Global object with the moved storage.\"\n            },\n            \"dependencies\": [\n                \"api_internal::MoveGlobalReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nGlobal<T>::Global(Global&& other) : PersistentBase<T>(other.slot()) {\n  if (!other.IsEmpty()) {\n    api_internal::MoveGlobalReference(&other.slot(), &this->slot());\n    other.Clear();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator=\",\n            \"parent\": \"Global\",\n            \"about\": \"Move assignment operator for the Global class.\",\n            \"logic\": \"Moves the underlying storage cell from another Global object to the current Global object.  If the other object is not empty, the internal storage is moved using api_internal::MoveGlobalReference and the other Global is cleared.  The current object is reset before the move.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"Global<S>&&\",\n                    \"purpose\": \"The Global object to move from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Global&\",\n                \"description\": \"A reference to the current Global object"
}