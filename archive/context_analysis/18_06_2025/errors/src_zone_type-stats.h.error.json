{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/type-stats.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 197, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/type-stats.h\",\n        \"file_name\": \"type-stats.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the TypeStats class for tracking allocation statistics of different types within a Zone.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers for input/output stream forward declarations, type traits, type indexing, and unordered maps.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <iosfwd>\n            #include <type_traits>\n            #include <typeindex>\n            #include <unordered_map>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes V8's global definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypeStats\",\n            \"about\": \"Collects allocation statistics for different C++ types to help track memory usage.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"std::type_index\",\n                \"std::unordered_map\",\n                \"V8_ENABLE_PRECISE_ZONE_STATS\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class TypeStats {\n            public:\n              TypeStats() = default;\n\n              template <typename TypeTag>\n              void AddAllocated(size_t bytes) {\n                StatsEntry& entry = map_[std::type_index(typeid(TypeTag))];\n                entry.allocation_count++;\n                entry.allocated_bytes += bytes;\n                // sizeof(IncompleteType) is not allowed so record size as a sizeof(char).\n                constexpr bool kIsIncomplete =\n                    std::is_same<TypeTag, void>::value || std::is_array<TypeTag>::value;\n                using TypeTagForSizeof =\n                    typename std::conditional<kIsIncomplete, char, TypeTag>::type;\n                entry.instance_size = sizeof(TypeTagForSizeof);\n              }\n\n              template <typename TypeTag>\n              void AddDeallocated(size_t bytes) {\n                StatsEntry& entry = map_[std::type_index(typeid(TypeTag))];\n                entry.deallocated_bytes += bytes;\n              }\n\n              // Merges other stats into this stats object.\n              void MergeWith(const TypeStats& other);\n\n              // Prints recorded statisticts to stdout.\n              void Dump() const;\n\n             private:\n              struct StatsEntry {\n                size_t allocation_count = 0;\n                size_t allocated_bytes = 0;\n                size_t deallocated_bytes = 0;\n                size_t instance_size = 0;\n              };\n\n              void Add(std::type_index type_id, const StatsEntry& other_entry) {\n                StatsEntry& entry = map_[type_id];\n                entry.allocation_count += other_entry.allocation_count;\n                entry.allocated_bytes += other_entry.allocated_bytes;\n                entry.deallocated_bytes += other_entry.deallocated_bytes;\n                entry.instance_size = other_entry.instance_size;\n              }\n\n              using HashMap = std::unordered_map<std::type_index, StatsEntry>;\n              HashMap map_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddAllocated\",\n            \"parent\": \"TypeStats\",\n            \"about\": \"Tracks memory allocation for a specific type.\",\n            \"logic\": \"Increments the allocation count and allocated bytes for the given type. Uses type traits to determine the correct size for incomplete types.\",\n            \"parameters\": [\n                {\n                    \"name\": \"bytes\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of bytes allocated.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"std::type_index\",\n                \"typeid\",\n                \"StatsEntry\",\n                \"std::is_same\",\n                \"std::is_array\",\n                \"std::conditional\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename TypeTag>\n            void TypeStats::AddAllocated(size_t bytes) {\n              StatsEntry& entry = map_[std::type_index(typeid(TypeTag))];\n              entry.allocation_count++;\n              entry.allocated_bytes += bytes;\n              // sizeof(IncompleteType) is not allowed so record size as a sizeof(char).\n              constexpr bool kIsIncomplete =\n                  std::is_same<TypeTag, void>::value || std::is_array<TypeTag>::value;\n              using TypeTagForSizeof =\n                  typename std::conditional<kIsIncomplete, char, TypeTag>::type;\n              entry.instance_size = sizeof(TypeTagForSizeof);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddDeallocated\",\n            \"parent\": \"TypeStats\",\n            \"about\": \"Tracks memory deallocation for a specific type.\",\n            \"logic\": \"Increments the deallocated bytes for the given type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"bytes\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of bytes deallocated.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"std::type_index\",\n                \"typeid\",\n                \"StatsEntry\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename TypeTag>\n            void TypeStats::AddDeallocated(size_t bytes) {\n              StatsEntry& entry = map_[std::type_index(typeid(TypeTag))];\n              entry.deallocated_bytes += bytes;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MergeWith\",\n            \"parent\": \"TypeStats\",\n            \"about\": \"Merges statistics from another TypeStats object into the current object.\",\n            \"logic\": \"Iterates through the other TypeStats object's map and adds the corresponding entries to the current object's map.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const TypeStats&\",\n                    \"purpose\": \"The TypeStats object to merge with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void TypeStats::MergeWith(const TypeStats& other);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Dump\",\n            \"parent\": \"TypeStats\",\n            \"about\": \"Prints the recorded statistics to stdout.\",\n            \"logic\": \"Iterates through the map and prints the allocation count, allocated bytes, deallocated bytes, and instance size for each type.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void TypeStats::Dump() const;\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"StatsEntry\",\n            \"parent\": \"TypeStats\",\n            \"about\": \"Inner structure to store allocation statistics for a specific type.\",\n            \"attributes\": [\n                {\n                    \"name\": \"allocation_count\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Number of allocations for this type.\"\n                },\n                {\n                    \"name\": \"allocated_bytes\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Total number of bytes allocated for this type.\"\n                },\n                {\n                    \"name\": \"deallocated_bytes\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Total number of bytes deallocated for this type.\"\n                },\n                {\n                    \"name\": \"instance_size\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Size of each instance of this type.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n             struct TypeStats::StatsEntry {\n                size_t allocation_count = 0;\n                size_t allocated_bytes = 0;\n                size_t deallocated_bytes = 0;\n                size_t instance_size = 0;\n              };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Add\",\n            \"parent\": \"TypeStats\",\n            \"about\": \"Adds statistics from another StatsEntry to the corresponding entry in the TypeStats map.\",\n            \"logic\": \"Adds the allocation count, allocated bytes, deallocated bytes, and instance size from the other StatsEntry to the existing entry.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type_id\",\n                    \"type\": \"std::type_index\",\n                    \"purpose\": \"The type index.\"\n                },\n                {\n                    \"name\": \"other_entry\",\n                    \"type\": \"const StatsEntry&\",\n                    \"purpose\": \"The StatsEntry to add.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StatsEntry\",\n                \"std::type_index\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n              void TypeStats::Add(std::type_index type_id, const StatsEntry& other_entry) {\n                StatsEntry& entry = map_[type_id];\n                entry.allocation_count += other_entry.allocation_count;\n                entry.allocated_bytes += other_entry.allocated_bytes;\n                entry.deallocated_bytes += other_entry.deallocated_bytes;\n                entry.instance_size = other_entry.instance_size;\n              }\n        ]]></code>\n    </func>\n</file>\n```"
}