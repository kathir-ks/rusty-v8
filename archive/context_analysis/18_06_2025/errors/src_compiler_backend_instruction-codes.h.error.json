{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-codes.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-codes.h\",\n            \"file_name\": \"instruction-codes.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines instruction codes and related enums/helpers used in the V8 compiler backend for code generation.  It provides a target-independent enumeration of machine instructions, addressing modes, and flags, along with utilities for encoding these into a single instruction code.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include standard C++ input/output stream forward declarations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <iosfwd>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include target-specific instruction codes based on the architecture being compiled for.  The specific file included depends on preprocessor defines.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_TARGET_ARCH_ARM\n            #include \"src/compiler/backend/arm/instruction-codes-arm.h\"\n            #elif V8_TARGET_ARCH_ARM64\n            #include \"src/compiler/backend/arm64/instruction-codes-arm64.h\"\n            #elif V8_TARGET_ARCH_IA32\n            #include \"src/compiler/backend/ia32/instruction-codes-ia32.h\"\n            #elif V8_TARGET_ARCH_MIPS64\n            #include \"src/compiler/backend/mips64/instruction-codes-mips64.h\"\n            #elif V8_TARGET_ARCH_LOONG64\n            #include \"src/compiler/backend/loong64/instruction-codes-loong64.h\"\n            #elif V8_TARGET_ARCH_X64\n            #include \"src/compiler/backend/x64/instruction-codes-x64.h\"\n            #elif V8_TARGET_ARCH_PPC64\n            #include \"src/compiler/backend/ppc/instruction-codes-ppc.h\"\n            #elif V8_TARGET_ARCH_S390X\n            #include \"src/compiler/backend/s390/instruction-codes-s390.h\"\n            #elif V8_TARGET_ARCH_RISCV32 || V8_TARGET_ARCH_RISCV64\n            #include \"src/compiler/backend/riscv/instruction-codes-riscv.h\"\n            #else\n            #define TARGET_ARCH_OPCODE_LIST(V)\n            #define TARGET_ADDRESSING_MODE_LIST(V)\n            #endif\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes for bit field manipulation, atomic memory order, and write barrier kinds.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/bit-field.h\"\n            #include \"src/codegen/atomic-memory-order.h\"\n            #include \"src/compiler/write-barrier-kind.h\"\n        ]]></code>\n    </imports>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum class\",\n                \"name\": \"RecordWriteMode\",\n                \"about\": \"Specifies the mode for ArchStoreWithWriteBarrier instructions, indicating the type of value being written (map, pointer, etc.).  This influences how the write barrier is handled.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class RecordWriteMode {\n            kValueIsMap,\n            kValueIsPointer,\n            kValueIsIndirectPointer,\n            kValueIsEphemeronKey,\n            kValueIsAny,\n            };\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"inline function\",\n                \"name\": \"WriteBarrierKindToRecordWriteMode\",\n                \"about\": \"Converts a WriteBarrierKind to a RecordWriteMode. Used to determine the appropriate write barrier behavior based on the type of write being performed.\",\n                \"logic\": \"A switch statement handles the different WriteBarrierKind values, returning the corresponding RecordWriteMode.  Handles default case with UNREACHABLE().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"write_barrier_kind\",\n                        \"type\": \"WriteBarrierKind\",\n                        \"purpose\": \"The type of write barrier to apply.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"RecordWriteMode\",\n                    \"description\": \"The corresponding RecordWriteMode for the given WriteBarrierKind.\"\n                },\n                \"dependencies\": [\n                    \"WriteBarrierKind\",\n                    \"RecordWriteMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline RecordWriteMode WriteBarrierKindToRecordWriteMode(\n                WriteBarrierKind write_barrier_kind) {\n            switch (write_barrier_kind) {\n                case kMapWriteBarrier:\n                return RecordWriteMode::kValueIsMap;\n                case kPointerWriteBarrier:\n                return RecordWriteMode::kValueIsPointer;\n                case kIndirectPointerWriteBarrier:\n                return RecordWriteMode::kValueIsIndirectPointer;\n                case kEphemeronKeyWriteBarrier:\n                return RecordWriteMode::kValueIsEphemeronKey;\n                case kFullWriteBarrier:\n                return RecordWriteMode::kValueIsAny;\n                case kNoWriteBarrier:\n                // Should not be passed as argument.\n                default:\n                break;\n            }\n            UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"COMMON_ARCH_OPCODE_WITH_MEMORY_ACCESS_MODE_LIST\",\n                \"about\": \"Defines a list of common architecture opcodes that involve memory access and have a memory access mode. Used for generating the ArchOpcode enum.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #define COMMON_ARCH_OPCODE_WITH_MEMORY_ACCESS_MODE_LIST(V) \\\n            V(AtomicExchangeInt8)                                    \\\n            V(AtomicExchangeUint8)                                   \\\n            V(AtomicExchangeInt16)                                  \\\n            V(AtomicExchangeUint16)                                 \\\n            V(AtomicExchangeWord32)                                  \\\n            V(AtomicCompareExchangeInt8)                             \\\n            V(AtomicCompareExchangeUint8)                            \\\n            V(AtomicCompareExchangeInt16)                           \\\n            V(AtomicCompareExchangeUint16)                          \\\n            V(AtomicCompareExchangeWord32)                          \\\n            V(AtomicAddInt8)                                         \\\n            V(AtomicAddUint8)                                        \\\n            V(AtomicAddInt16)                                       \\\n            V(AtomicAddUint16)                                      \\\n            V(AtomicAddWord32)                                       \\\n            V(AtomicSubInt8)                                         \\\n            V(AtomicSubUint8)                                        \\\n            V(AtomicSubInt16)                                       \\\n            V(AtomicSubUint16)                                      \\\n            V(AtomicSubWord32)                                       \\\n            V(AtomicAndInt8)                                         \\\n            V(AtomicAndUint8)                                        \\\n            V(AtomicAndInt16)                                       \\\n            V(AtomicAndUint16)                                      \\\n            V(AtomicAndWord32)                                       \\\n            V(AtomicOrInt8)                                          \\\n            V(AtomicOrUint8)                                         \\\n            V(AtomicOrInt16)                                        \\\n            V(AtomicOrUint16)                                       \\\n            V(AtomicOrWord32)                                        \\\n            V(AtomicXorInt8)                                         \\\n            V(AtomicXorUint8)                                        \\\n            V(AtomicXorInt16)                                       \\\n            V(AtomicXorUint16)                                       \\\n            V(AtomicXorWord32)                                       \\\n            V(ArchStoreWithWriteBarrier)                             \\\n            V(ArchAtomicStoreWithWriteBarrier)                       \\\n            V(ArchStoreIndirectWithWriteBarrier)                     \\\n            V(AtomicLoadInt8)                                        \\\n            V(AtomicLoadUint8)                                       \\\n            V(AtomicLoadInt16)                                       \\\n            V(AtomicLoadUint16)                                      \\\n            V(AtomicLoadWord32)                                      \\\n            V(AtomicStoreWord8)                                      \\\n            V(AtomicStoreWord16)                                     \\\n            V(AtomicStoreWord32)\n        ]]></code>\n    </macro>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"COMMON_ARCH_OPCODE_LIST\",\n                \"about\": \"Defines a list of common architecture opcodes. These are mostly target-independent control flow and utility operations. Used for generating the ArchOpcode enum.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #define COMMON_ARCH_OPCODE_LIST(V)                                         \\\n            /* Tail call opcodes are grouped together to make IsTailCall fast */     \\\n            /* and Arch call opcodes are grouped together to make */                 \\\n            /* IsCallWithDescriptorFlags fast */                                     \\\n            V(ArchTailCallCodeObject)                                                \\\n            V(ArchTailCallAddress)                                                   \\\n            IF_WASM(V, ArchTailCallWasm)                                             \\\n            IF_WASM(V, ArchTailCallWasmIndirect)                                     \\\n            /* Update IsTailCall if further TailCall opcodes are added */            \\\n                                                                                     \\\n            V(ArchCallCodeObject)                                                    \\\n            V(ArchCallJSFunction)                                                    \\\n            IF_WASM(V, ArchCallWasmFunction)                                         \\\n            IF_WASM(V, ArchCallWasmFunctionIndirect)                                 \\\n            V(ArchCallBuiltinPointer)                                                \\\n            /* Update IsCallWithDescriptorFlags if further Call opcodes are added */ \\\n                                                                                     \\\n            V(ArchPrepareCallCFunction)                                              \\\n            V(ArchSaveCallerRegisters)                                               \\\n            V(ArchRestoreCallerRegisters)                                            \\\n            V(ArchCallCFunction)                                                     \\\n            V(ArchCallCFunctionWithFrameState)                                       \\\n            V(ArchPrepareTailCall)                                                   \\\n            V(ArchJmp)                                                               \\\n            V(ArchBinarySearchSwitch)                                                \\\n            V(ArchTableSwitch)                                                       \\\n            V(ArchNop)                                                               \\\n            V(ArchAbortCSADcheck)                                                    \\\n            V(ArchDebugBreak)                                                        \\\n            V(ArchComment)                                                           \\\n            V(ArchThrowTerminator)                                                   \\\n            V(ArchDeoptimize)                                                        \\\n            V(ArchRet)                                                               \\\n            V(ArchFramePointer)                                                      \\\n            IF_WASM(V, ArchStackPointer)                                             \\\n            IF_WASM(V, ArchSetStackPointer)                                          \\\n            V(ArchParentFramePointer)                                                \\\n            V(ArchTruncateDoubleToI)                                                 \\\n            V(ArchStackSlot)                                                         \\\n            V(ArchStackPointerGreaterThan)                                           \\\n            V(ArchStackCheckOffset)                                                  \\\n            V(Ieee754Float64Acos)                                                    \\\n            V(Ieee754Float64Acosh)                                                   \\\n            V(Ieee754Float64Asin)                                                    \\\n            V(Ieee754Float64Asinh)                                                   \\\n            V(Ieee754Float64Atan)                                                    \\\n            V(Ieee754Float64Atanh)                                                   \\\n            V(Ieee754Float64Atan2)                                                   \\\n            V(Ieee754Float64Cbrt)                                                    \\\n            V(Ieee754Float64Cos)                                                     \\\n            V(Ieee754Float64Cosh)                                                    \\\n            V(Ieee754Float64Exp)                                                     \\\n            V(Ieee754Float64Expm1)                                                   \\\n            V(Ieee754Float64Log)                                                     \\\n            V(Ieee754Float64Log1p)                                                   \\\n            V(Ieee754Float64Log10)                                                   \\\n            V(Ieee754Float64Log2)                                                    \\\n            V(Ieee754Float64Pow)                                                     \\\n            V(Ieee754Float64Sin)                                                     \\\n            V(Ieee754Float64Sinh)                                                    \\\n            V(Ieee754Float64Tan)                                                     \\\n            V(Ieee754Float64Tanh)                                                    \\\n            COMMON_ARCH_OPCODE_WITH_MEMORY_ACCESS_MODE_LIST(V)\n        ]]></code>\n    </macro>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"ARCH_OPCODE_LIST\",\n                \"about\": \"Combines the common and target-specific opcode lists.  This macro is the complete listing of architecture opcodes.\",\n                \"dependencies\": [\n                    \"COMMON_ARCH_OPCODE_LIST\",\n                    \"TARGET_ARCH_OPCODE_LIST\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            #define ARCH_OPCODE_LIST(V)  \\\n            COMMON_ARCH_OPCODE_LIST(V) \\\n            TARGET_ARCH_OPCODE_LIST(V)\n        ]]></code>\n    </macro>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"ArchOpcode\",\n                \"about\": \"Enumerates all architecture-specific opcodes used in the compiler backend. The values in this enum are used to identify specific machine instructions during code generation.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum ArchOpcode {\n            #define DECLARE_ARCH_OPCODE(Name) k##Name,\n            ARCH_OPCODE_LIST(DECLARE_ARCH_OPCODE)\n            #undef DECLARE_ARCH_OPCODE\n            #define COUNT_ARCH_OPCODE(Name) +1\n                kLastArchOpcode = -1 ARCH_OPCODE_LIST(COUNT_ARCH_OPCODE)\n            #undef COUNT_ARCH_OPCODE\n            };\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for ArchOpcode to allow printing ArchOpcode values to an output stream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"ao\",\n                        \"type\": \"const ArchOpcode&\",\n                        \"purpose\": \"The ArchOpcode value to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"ArchOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,\n                                                const ArchOpcode& ao);\n        ]]></code>\n    </func>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"ADDRESSING_MODE_LIST\",\n                \"about\": \"Defines a list of addressing modes. Used to generate the AddressingMode enum.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #define ADDRESSING_MODE_LIST(V) \\\n            V(None)                       \\\n            TARGET_ADDRESSING_MODE_LIST(V)\n        ]]></code>\n    </macro>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"AddressingMode\",\n                \"about\": \"Enumerates the different addressing modes supported by the architecture. Addressing modes represent the structure of inputs to an instruction and guide code generation.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum AddressingMode : uint8_t {\n            #define DECLARE_ADDRESSING_MODE(Name) kMode_##Name,\n            ADDRESSING_MODE_LIST(DECLARE_ADDRESSING_MODE)\n            #undef DECLARE_ADDRESSING_MODE\n            #define COUNT_ADDRESSING_MODE(Name) +1\n                kLastAddressingMode = -1 ADDRESSING_MODE_LIST(COUNT_ADDRESSING_MODE)\n            #undef COUNT_ADDRESSING_MODE\n            };\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for AddressingMode to allow printing AddressingMode values to an output stream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"am\",\n                        \"type\": \"const AddressingMode&\",\n                        \"purpose\": \"The AddressingMode value to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"AddressingMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,\n                                                const AddressingMode& am);\n        ]]></code>\n    </func>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"FlagsMode\",\n                \"about\": \"Enumerates the different modes for flags continuation, used to indicate how flags are used after an instruction (e.g., for branching or deoptimization).\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum FlagsMode {\n            kFlags_none = 0,\n            kFlags_branch = 1,\n            kFlags_deoptimize = 2,\n            kFlags_set = 3,\n            kFlags_trap = 4,\n            kFlags_select = 5,\n            kFlags_conditional_set = 6,\n            kFlags_conditional_branch = 7,\n            };\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for FlagsMode to allow printing FlagsMode values to an output stream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"fm\",\n                        \"type\": \"const FlagsMode&\",\n                        \"purpose\": \"The FlagsMode value to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"FlagsMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,\n                                                const FlagsMode& fm);\n        ]]></code>\n    </func>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"FlagsCondition\",\n                \"about\": \"Enumerates the different conditions for flags continuation, used to specify the condition under which a branch or other flag-dependent action should occur.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum FlagsCondition : uint8_t {\n            kEqual,\n            kNotEqual,\n            kSignedLessThan,\n            kSignedGreaterThanOrEqual,\n            kSignedLessThanOrEqual,\n            kSignedGreaterThan,\n            kUnsignedLessThan,\n            kUnsignedGreaterThanOrEqual,\n            kUnsignedLessThanOrEqual,\n            kUnsignedGreaterThan,\n            kFloatLessThanOrUnordered,\n            kFloatGreaterThanOrEqual,\n            kFloatLessThanOrEqual,\n            kFloatGreaterThanOrUnordered,\n            kFloatLessThan,\n            kFloatGreaterThanOrEqualOrUnordered,\n            kFloatLessThanOrEqualOrUnordered,\n            kFloatGreaterThan,\n            kUnorderedEqual,\n            kUnorderedNotEqual,\n            kOverflow,\n            kNotOverflow,\n            kPositiveOrZero,\n            kNegative,\n            kIsNaN,\n            kIsNotNaN,\n            };\n        ]]></code>\n    </enum>\n    <variable>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr FlagsCondition\",\n                \"name\": \"kStackPointerGreaterThanCondition\",\n                \"about\": \"Defines a constant FlagsCondition for stack pointer greater than comparison.\",\n                \"dependencies\": [\n                    \"FlagsCondition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static constexpr FlagsCondition kStackPointerGreaterThanCondition =\n                kUnsignedGreaterThan;\n        ]]></code>\n    </variable>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"inline function\",\n                \"name\": \"NegateFlagsCondition\",\n                \"about\": \"Negates a FlagsCondition by flipping the least significant bit. Used to invert the condition for branching.\",\n                \"logic\": \"Performs a bitwise XOR with 1 to negate the FlagsCondition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"condition\",\n                        \"type\": \"FlagsCondition\",\n                        \"purpose\": \"The FlagsCondition to negate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"FlagsCondition\",\n                    \"description\": \"The negated FlagsCondition.\"\n                },\n                \"dependencies\": [\n                    \"FlagsCondition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline FlagsCondition NegateFlagsCondition(FlagsCondition condition) {\n            return static_cast<FlagsCondition>(condition ^ 1);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CommuteFlagsCondition\",\n                \"about\": \"Commutes a FlagsCondition (e.g., SignedLessThan to SignedGreaterThan).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"condition\",\n                        \"type\": \"FlagsCondition\",\n                        \"purpose\": \"The FlagsCondition to commute.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"FlagsCondition\",\n                    \"description\": \"The commuted FlagsCondition.\"\n                },\n                \"dependencies\": [\n                    \"FlagsCondition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            FlagsCondition CommuteFlagsCondition(FlagsCondition condition);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for FlagsCondition to allow printing FlagsCondition values to an output stream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"fc\",\n                        \"type\": \"const FlagsCondition&\",\n                        \"purpose\": \"The FlagsCondition value to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"FlagsCondition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,\n                                                const FlagsCondition& fc);\n        ]]></code>\n    </func>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"MemoryAccessMode\",\n                \"about\": \"Enumerates the different modes for memory access, indicating whether the access requires special handling (e.g., for out-of-bounds or null dereference protection).\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum MemoryAccessMode {\n            kMemoryAccessDirect = 0,\n            kMemoryAccessProtectedMemOutOfBounds = 1,\n            kMemoryAccessProtectedNullDereference = 2,\n            };\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum class\",\n                \"name\": \"AtomicWidth\",\n                \"about\": \"Enumerates the different widths for atomic operations (32-bit or 64-bit).\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class AtomicWidth { kWord32, kWord64 };\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"inline function\",\n                \"name\": \"AtomicWidthSize\",\n                \"about\": \"Returns the size in bytes for a given AtomicWidth.\",\n                \"logic\": \"A switch statement handles the different AtomicWidth values, returning the corresponding size. Handles default case with UNREACHABLE().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"width\",\n                        \"type\": \"AtomicWidth\",\n                        \"purpose\": \"The AtomicWidth to get the size of.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The size in bytes for the given AtomicWidth.\"\n                },\n                \"dependencies\": [\n                    \"AtomicWidth\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline size_t AtomicWidthSize(AtomicWidth width) {\n            switch (width) {\n                case AtomicWidth::kWord32:\n                return 4;\n                case AtomicWidth::kWord64:\n                return 8;\n            }\n            UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n    <variable>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"static constexpr int\",\n                \"name\": \"kLazyDeoptOnThrowSentinel\",\n                \"about\": \"Defines a sentinel value for lazy deoptimization on throw.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            static constexpr int kLazyDeoptOnThrowSentinel = -1;\n        ]]></code>\n    </variable>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"InstructionCode\",\n                \"about\": \"Defines a type alias for InstructionCode as a uint32_t.  InstructionCode is an opaque, target-specific integer that encodes what code to emit for an instruction.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            using InstructionCode = uint32_t;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"ArchOpcodeField\",\n                \"about\": \"Defines a bit field for encoding ArchOpcode within InstructionCode. It occupies bits 0-9.\",\n                \"dependencies\": [\n                    \"base::BitField\",\n                    \"ArchOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using ArchOpcodeField = base::BitField<ArchOpcode, 0, 9>;\n        ]]></code>\n    </type_alias>\n    <static_assert>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"static_assert\",\n                \"about\": \"Ensures that all ArchOpcode values fit within the ArchOpcodeField.\",\n                \"dependencies\": [\n                    \"ArchOpcodeField\",\n                    \"kLastArchOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static_assert(ArchOpcodeField::is_valid(kLastArchOpcode),\n                          \"All opcodes must fit in the 9-bit ArchOpcodeField.\");\n        ]]></code>\n    </static_assert>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"AddressingModeField\",\n                \"about\": \"Defines a bit field for encoding AddressingMode within InstructionCode. It occupies the next 5 bits after ArchOpcodeField.\",\n                \"dependencies\": [\n                    \"ArchOpcodeField\",\n                    \"AddressingMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using AddressingModeField = ArchOpcodeField::Next<AddressingMode, 5>;\n        ]]></code>\n    </type_alias>\n    <static_assert>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"static_assert\",\n                \"about\": \"Ensures that all AddressingMode values fit within the AddressingModeField.\",\n                \"dependencies\": [\n                    \"AddressingModeField\",\n                    \"kLastAddressingMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static_assert(\n                AddressingModeField::is_valid(kLastAddressingMode),\n                \"All addressing modes must fit in the 5-bit AddressingModeField.\");\n        ]]></code>\n    </static_assert>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"FlagsModeField\",\n                \"about\": \"Defines a bit field for encoding FlagsMode within InstructionCode. It occupies the next 3 bits after AddressingModeField.\",\n                \"dependencies\": [\n                    \"AddressingModeField\",\n                    \"FlagsMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using FlagsModeField = AddressingModeField::Next<FlagsMode, 3>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"FlagsConditionField\",\n                \"about\": \"Defines a bit field for encoding FlagsCondition within InstructionCode. It occupies the next 5 bits after FlagsModeField.\",\n                \"dependencies\": [\n                    \"FlagsModeField\",\n                    \"FlagsCondition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using FlagsConditionField = FlagsModeField::Next<FlagsCondition, 5>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"AtomicWidthField\",\n                \"about\": \"Defines a bit field for encoding AtomicWidth within InstructionCode. It occupies the next 2 bits after FlagsConditionField. Only used on 64-bit architectures.\",\n                \"dependencies\": [\n                    \"FlagsConditionField\",\n                    \"AtomicWidth\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using AtomicWidthField = FlagsConditionField::Next<AtomicWidth, 2>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"AtomicMemoryOrderField\",\n                \"about\": \"Defines a bit field for encoding AtomicMemoryOrder within InstructionCode. It occupies the next 2 bits after AtomicWidthField. Not used on all architectures.\",\n                \"dependencies\": [\n                    \"AtomicWidthField\",\n                    \"AtomicMemoryOrder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using AtomicMemoryOrderField = AtomicWidthField::Next<AtomicMemoryOrder, 2>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"AtomicStoreRecordWriteModeField\",\n                \"about\": \"Defines a bit field for encoding RecordWriteMode within InstructionCode for atomic stores. It occupies the next 4 bits after AtomicMemoryOrderField.\",\n                \"dependencies\": [\n                    \"AtomicMemoryOrderField\",\n                    \"RecordWriteMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using AtomicStoreRecordWriteModeField =\n                AtomicMemoryOrderField::Next<RecordWriteMode, 4>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type alias\",\n                \"name\": \"RecordWriteModeField\",\n                \"about\": \"Defines a bit field for encoding RecordWriteMode within InstructionCode. It occupies the next 3 bits after FlagsConditionField.\",\n                \"dependencies\": [\n                    \"FlagsConditionField\",\n                    \"RecordWriteMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // Write modes for writes with barrier.\n            using RecordWriteModeField = FlagsConditionField::Next<RecordWriteMode, "
}