{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-inlining-into-js.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 53, column 54",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-inlining-into-js.cc\",\n        \"file_name\": \"wasm-inlining-into-js.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the WasmIntoJSInliner class to inline WebAssembly code into JavaScript code within the V8 compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for compiler, wasm, and utility functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/wasm-inlining-into-js.h\"\n\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/wasm-compiler-definitions.h\"\n#include \"src/compiler/wasm-compiler.h\"\n#include \"src/compiler/wasm-graph-assembler.h\"\n#include \"src/wasm/decoder.h\"\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-opcodes-inl.h\"\n#include \"src/wasm/wasm-subtyping.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmIntoJSInlinerImpl\",\n            \"extends\": \"wasm::Decoder\",\n            \"about\": \"Implements the logic for inlining WebAssembly code into JavaScript. This class extends the wasm::Decoder to decode the wasm bytecode and generate the corresponding graph nodes.\",\n            \"attributes\": [\n                {\n                    \"name\": \"module_\",\n                    \"type\": \"const wasm::WasmModule*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the WebAssembly module being compiled.\"\n                },\n                {\n                    \"name\": \"mcgraph_\",\n                    \"type\": \"MachineGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the MachineGraph object, which represents the graph being constructed.\"\n                },\n                {\n                    \"name\": \"body_\",\n                    \"type\": \"const wasm::FunctionBody&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Reference to the function body being inlined.\"\n                },\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"TFGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the Turbofan graph.\"\n                },\n                {\n                    \"name\": \"gasm_\",\n                    \"type\": \"WasmGraphAssembler\",\n                    \"access\": \"private\",\n                    \"purpose\": \"WasmGraphAssembler to construct the graph nodes.\"\n                },\n                {\n                    \"name\": \"source_position_table_\",\n                    \"type\": \"SourcePositionTable*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Used to record source positions for debugging.\"\n                },\n                {\n                    \"name\": \"inlining_id_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"ID of the inlining operation.\"\n                },\n                {\n                    \"name\": \"parameters_\",\n                    \"type\": \"Node**\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of parameter nodes.\"\n                },\n                {\n                    \"name\": \"trusted_data_node_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Node representing trusted data (instance).\"\n                },\n                {\n                    \"name\": \"instruction_start_\",\n                    \"type\": \"const uint8_t*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the start of the current instruction being decoded.\"\n                },\n                {\n                   \"name\": \"is_inlineable_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to indicate if the current function body can be inlined.\"\n                }\n            ],\n            \"dependencies\": [\n                \"wasm::Decoder\",\n                \"wasm::WasmModule\",\n                \"MachineGraph\",\n                \"wasm::FunctionBody\",\n                \"TFGraph\",\n                \"WasmGraphAssembler\",\n                \"SourcePositionTable\",\n                \"Zone\",\n                \"wasm::WasmOpcode\",\n                \"wasm::ValueType\",\n                \"compiler::Type\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass WasmIntoJSInlinerImpl : private wasm::Decoder {\n  using ValidationTag = NoValidationTag;\n\n  struct Value {\n    Node* node = nullptr;\n    wasm::ValueType type = wasm::kWasmBottom;\n  };\n\n public:\n  WasmIntoJSInlinerImpl(Zone* zone, const wasm::WasmModule* module,\n                        MachineGraph* mcgraph, const wasm::FunctionBody& body,\n                        base::Vector<const uint8_t> bytes,\n                        SourcePositionTable* source_position_table,\n                        int inlining_id)\n      : wasm::Decoder(bytes.begin(), bytes.end()),\n        module_(module),\n        mcgraph_(mcgraph),\n        body_(body),\n        graph_(mcgraph->graph()),\n        gasm_(mcgraph, zone),\n        source_position_table_(source_position_table),\n        inlining_id_(inlining_id) {\n    // +1 for instance node.\n    size_t params = body.sig->parameter_count() + 1;\n    Node* start =\n        graph_->NewNode(mcgraph->common()->Start(static_cast<int>(params)));\n    graph_->SetStart(start);\n    graph_->SetEnd(graph_->NewNode(mcgraph->common()->End(0)));\n    gasm_.InitializeEffectControl(start, start);\n\n    // Initialize parameter nodes.\n    // We have to add another +1 as the minimum parameter index is actually\n    // -1, not 0...\n    size_t params_extended = params + 1;\n    parameters_ = zone->AllocateArray<Node*>(params_extended);\n    for (unsigned i = 0; i < params_extended; i++) {\n      parameters_[i] = nullptr;\n    }\n    // Instance node at parameter 0.\n    trusted_data_node_ = Param(wasm::kWasmInstanceDataParameterIndex);\n  }\n\n  Node* Param(int index, const char* debug_name = nullptr) {\n    DCHECK_NOT_NULL(graph_->start());\n    // Turbofan allows negative parameter indices.\n    DCHECK_GE(index, kMinParameterIndex);\n    int array_index = index - kMinParameterIndex;\n    if (parameters_[array_index] == nullptr) {\n      Node* param = graph_->NewNode(\n          mcgraph_->common()->Parameter(index, debug_name), graph_->start());\n      if (index > wasm::kWasmInstanceDataParameterIndex) {\n        // Add a type guard to keep type information based on the inlinee's\n        // signature.\n        wasm::ValueType type = body_.sig->GetParam(index - 1);\n        Type tf_type = compiler::Type::Wasm(type, module_, graph_->zone());\n        param = gasm_.TypeGuard(tf_type, param);\n      }\n      parameters_[array_index] = param;\n    }\n    return parameters_[array_index];\n  }\n\n  bool TryInlining() {\n    if (body_.sig->return_count() > 1) {\n      return false;  // Multi-return is not supported.\n    }\n    // Parse locals.\n    if (consume_u32v() != 0) {\n      // Functions with locals are not supported.\n      return false;\n    }\n    // Parse body.\n    base::SmallVector<Value, 4> stack;\n    while (is_inlineable_) {\n      WasmOpcode opcode = ReadOpcode();\n      switch (opcode) {\n        case wasm::kExprAnyConvertExtern:\n          DCHECK(!stack.empty());\n          stack.back() = ParseAnyConvertExtern(stack.back());\n          continue;\n        case wasm::kExprExternConvertAny:\n          DCHECK(!stack.empty());\n          stack.back() = ParseExternConvertAny(stack.back());\n          continue;\n        case wasm::kExprRefCast:\n        case wasm::kExprRefCastNull:\n          DCHECK(!stack.empty());\n          stack.back() =\n              ParseRefCast(stack.back(), opcode == wasm::kExprRefCastNull);\n          continue;\n        case wasm::kExprArrayLen:\n          DCHECK(!stack.empty());\n          stack.back() = ParseArrayLen(stack.back());\n          continue;\n        case wasm::kExprArrayGet:\n        case wasm::kExprArrayGetS:\n        case wasm::kExprArrayGetU: {\n          DCHECK_GE(stack.size(), 2);\n          Value index = stack.back();\n          stack.pop_back();\n          Value array = stack.back();\n          stack.back() = ParseArrayGet(array, index, opcode);\n          continue;\n        }\n        case wasm::kExprArraySet: {\n          DCHECK_GE(stack.size(), 3);\n          Value value = stack.back();\n          stack.pop_back();\n          Value index = stack.back();\n          stack.pop_back();\n          Value array = stack.back();\n          stack.pop_back();\n          ParseArraySet(array, index, value);\n          continue;\n        }\n        case wasm::kExprStructGet:\n        case wasm::kExprStructGetS:\n        case wasm::kExprStructGetU:\n          DCHECK(!stack.empty());\n          stack.back() = ParseStructGet(stack.back(), opcode);\n          continue;\n        case wasm::kExprStructSet: {\n          DCHECK_GE(stack.size(), 2);\n          Value value = stack.back();\n          stack.pop_back();\n          Value wasm_struct = stack.back();\n          stack.pop_back();\n          ParseStructSet(wasm_struct, value);\n          continue;\n        }\n        case wasm::kExprLocalGet:\n          stack.push_back(ParseLocalGet());\n          continue;\n        case wasm::kExprDrop:\n          DCHECK(!stack.empty());\n          stack.pop_back();\n          continue;\n        case wasm::kExprEnd: {\n          DCHECK_LT(stack.size(), 2);\n          int return_count = static_cast<int>(stack.size());\n          base::SmallVector<Node*, 8> buf(return_count + 3);\n          buf[0] = mcgraph_->Int32Constant(0);\n          if (return_count) {\n            buf[1] = stack.back().node;\n          }\n          buf[return_count + 1] = gasm_.effect();\n          buf[return_count + 2] = gasm_.control();\n          Node* ret = graph_->NewNode(mcgraph_->common()->Return(return_count),\n                                      return_count + 3, buf.data());\n\n          gasm_.MergeControlToEnd(ret);\n          return true;\n        }\n        default:\n          // Instruction not supported for inlining.\n          return false;\n      }\n    }\n    // The decoder found an instruction it couldn't inline successfully.\n    return false;\n  }\n\n private:\n  Value ParseAnyConvertExtern(Value input) {\n    DCHECK(input.type.is_reference_to(wasm::HeapType::kExtern) ||\n           input.type.is_reference_to(wasm::HeapType::kNoExtern));\n    wasm::ValueType result_type = wasm::ValueType::Generic(\n        wasm::GenericKind::kAny, input.type.nullability(), kNotShared);\n    Node* internalized = gasm_.WasmAnyConvertExtern(input.node);\n    return TypeNode(internalized, result_type);\n  }\n\n  Value ParseExternConvertAny(Value input) {\n    DCHECK(input.type.is_reference());\n    wasm::ValueType result_type = wasm::ValueType::Generic(\n        wasm::GenericKind::kExtern, input.type.nullability(), kNotShared);\n    Node* internalized = gasm_.WasmExternConvertAny(input.node);\n    return TypeNode(internalized, result_type);\n  }\n\n  Value ParseLocalGet() {\n    uint32_t index = consume_u32v();\n    DCHECK_LT(index, body_.sig->parameter_count());\n    return TypeNode(Param(index + 1), body_.sig->GetParam(index));\n  }\n\n  Value ParseStructGet(Value struct_val, WasmOpcode opcode) {\n    wasm::ModuleTypeIndex struct_index{consume_u32v()};\n    DCHECK(module_->has_struct(struct_index));\n    const wasm::StructType* struct_type = module_->struct_type(struct_index);\n    uint32_t field_index = consume_u32v();\n    DCHECK_GT(struct_type->field_count(), field_index);\n    const bool is_signed = opcode == wasm::kExprStructGetS;\n    const CheckForNull null_check =\n        struct_val.type.is_nullable() ? kWithNullCheck : kWithoutNullCheck;\n    Node* member = gasm_.StructGet(struct_val.node, struct_type, field_index,\n                                   is_signed, null_check);\n    SetSourcePosition(member);\n    return TypeNode(member, struct_type->field(field_index).Unpacked());\n  }\n\n  void ParseStructSet(Value wasm_struct, Value value) {\n    wasm::ModuleTypeIndex struct_index{consume_u32v()};\n    DCHECK(module_->has_struct(struct_index));\n    const wasm::StructType* struct_type = module_->struct_type(struct_index);\n    uint32_t field_index = consume_u32v();\n    DCHECK_GT(struct_type->field_count(), field_index);\n    const CheckForNull null_check =\n        wasm_struct.type.is_nullable() ? kWithNullCheck : kWithoutNullCheck;\n    gasm_.StructSet(wasm_struct.node, value.node, struct_type, field_index,\n                    null_check);\n    SetSourcePosition(gasm_.effect());\n  }\n\n  Value ParseRefCast(Value input, bool null_succeeds) {\n    auto [heap_index, length] = read_i33v<ValidationTag>(pc_);\n    pc_ += length;\n    if (heap_index < 0) {\n      if ((heap_index & 0x7f) != wasm::kArrayRefCode) {\n        // Abstract casts for non array type are not supported.\n        is_inlineable_ = false;\n        return {};\n      }\n      auto done = gasm_.MakeLabel();\n      // Abstract cast to array.\n      if (input.type.is_nullable() && null_succeeds) {\n        gasm_.GotoIf(gasm_.IsNull(input.node, input.type), &done);\n      }\n      gasm_.TrapIf(gasm_.IsSmi(input.node), TrapId::kTrapIllegalCast);\n      gasm_.TrapUnless(gasm_.HasInstanceType(input.node, WASM_ARRAY_TYPE),\n                       TrapId::kTrapIllegalCast);\n      SetSourcePosition(gasm_.effect());\n      gasm_.Goto(&done);\n      gasm_.Bind(&done);\n      // Add TypeGuard for graph typing.\n      TFGraph* graph = mcgraph_->graph();\n      wasm::ValueType result_type = wasm::ValueType::Generic(\n          wasm::GenericKind::kArray,\n          null_succeeds ? wasm::kNullable : wasm::kNonNullable, kNotShared);\n      Node* type_guard =\n          graph->NewNode(mcgraph_->common()->TypeGuard(\n                             Type::Wasm(result_type, module_, graph->zone())),\n                         input.node, gasm_.effect(), gasm_.control());\n      gasm_.InitializeEffectControl(type_guard, gasm_.control());\n      return TypeNode(type_guard, result_type);\n    }\n    wasm::ModuleTypeIndex target_type_index{static_cast<uint32_t>(heap_index)};\n    if (module_->has_signature(target_type_index)) {\n      is_inlineable_ = false;\n      return {};\n    }\n    wasm::ValueType target_type = wasm::ValueType::RefMaybeNull(\n        module_->heap_type(target_type_index),\n        null_succeeds ? wasm::kNullable : wasm::kNonNullable);\n    Node* rtt = mcgraph_->graph()->NewNode(\n        gasm_.simplified()->RttCanon(target_type.ref_index()),\n        trusted_data_node_);\n    // Technically this is incorrect: the {rtt} node doesn't hold a reference\n    // to an object of type {target_type}, but to such an object's map. But\n    // we only need this type annotation so {ReduceWasmTypeCast} can get to\n    // the {ref_index}, we never need the type's {kind()}.\n    TypeNode(rtt, wasm::ValueType::Ref(target_type.heap_type()));\n    Node* cast = gasm_.WasmTypeCast(input.node, rtt, {input.type, target_type});\n    SetSourcePosition(cast);\n    return TypeNode(cast, target_type);\n  }\n\n  Value ParseArrayLen(Value input) {\n    DCHECK(wasm::IsHeapSubtypeOf(input.type.heap_type(),\n                                 wasm::kWasmArrayRef.heap_type(), module_));\n    const CheckForNull null_check =\n        input.type.is_nullable() ? kWithNullCheck : kWithoutNullCheck;\n    Node* len = gasm_.ArrayLength(input.node, null_check);\n    SetSourcePosition(len);\n    return TypeNode(len, wasm::kWasmI32);\n  }\n\n  Value ParseArrayGet(Value array, Value index, WasmOpcode opcode) {\n    wasm::ModuleTypeIndex array_index{consume_u32v()};\n    DCHECK(module_->has_array(array_index));\n    const wasm::ArrayType* array_type = module_->array_type(array_index);\n    const bool is_signed = opcode == WasmOpcode::kExprArrayGetS;\n    const CheckForNull null_check =\n        array.type.is_nullable() ? kWithNullCheck : kWithoutNullCheck;\n    // Perform bounds check.\n    Node* length = gasm_.ArrayLength(array.node, null_check);\n    SetSourcePosition(length);\n    gasm_.TrapUnless(gasm_.Uint32LessThan(index.node, length),\n                     TrapId::kTrapArrayOutOfBounds);\n    SetSourcePosition(gasm_.effect());\n    // Perform array.get.\n    Node* element =\n        gasm_.ArrayGet(array.node, index.node, array_type, is_signed);\n    return TypeNode(element, array_type->element_type().Unpacked());\n  }\n\n  void ParseArraySet(Value array, Value index, Value value) {\n    wasm::ModuleTypeIndex array_index{consume_u32v()};\n    DCHECK(module_->has_array(array_index));\n    const wasm::ArrayType* array_type = module_->array_type(array_index);\n    const CheckForNull null_check =\n        array.type.is_nullable() ? kWithNullCheck : kWithoutNullCheck;\n    // Perform bounds check.\n    Node* length = gasm_.ArrayLength(array.node, null_check);\n    SetSourcePosition(length);\n    gasm_.TrapUnless(gasm_.Uint32LessThan(index.node, length),\n                     TrapId::kTrapArrayOutOfBounds);\n    SetSourcePosition(gasm_.effect());\n    // Perform array.set.\n    gasm_.ArraySet(array.node, index.node, value.node, array_type);\n  }\n\n  WasmOpcode ReadOpcode() {\n    DCHECK_LT(pc_, end_);\n    instruction_start_ = pc();\n    WasmOpcode opcode = static_cast<WasmOpcode>(*pc_);\n    if (!WasmOpcodes::IsPrefixOpcode(opcode)) {\n      ++pc_;\n      return opcode;\n    }\n    auto [opcode_with_prefix, length] =\n        read_prefixed_opcode<ValidationTag>(pc_);\n    pc_ += length;\n    return opcode_with_prefix;\n  }\n\n  Value TypeNode(Node* node, wasm::ValueType type) {\n    compiler::NodeProperties::SetType(\n        node, compiler::Type::Wasm(type, module_, graph_->zone()));\n    return {node, type};\n  }\n\n  void SetSourcePosition(Node* node) {\n    if (!source_position_table_->IsEnabled()) return;\n    int offset = static_cast<int>(instruction_start_ - start());\n    source_position_table_->SetSourcePosition(\n        node, SourcePosition(offset, inlining_id_));\n  }\n\n  const wasm::WasmModule* module_;\n  MachineGraph* mcgraph_;\n  const wasm::FunctionBody& body_;\n  Node** parameters_;\n  TFGraph* graph_;\n  Node* trusted_data_node_;\n  WasmGraphAssembler gasm_;\n  SourcePositionTable* source_position_table_ = nullptr;\n  const uint8_t* instruction_start_ = pc_;\n  int inlining_id_;\n  bool is_inlineable_ = true;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryInlining\",\n            \"about\": \"Attempts to inline WebAssembly code into JavaScript code.\",\n            \"logic\": \"Creates a WasmIntoJSInlinerImpl object and calls its TryInlining method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"Memory zone for allocations.\"\n                },\n                {\n                    \"name\": \"module\",\n                    \"type\": \"const wasm::WasmModule*\",\n                    \"purpose\": \"WebAssembly module.\"\n                },\n                {\n                    \"name\": \"mcgraph\",\n                    \"type\": \"MachineGraph*\",\n                    \"purpose\": \"Machine graph.\"\n                },\n                {\n                    \"name\": \"body\",\n                    \"type\": \"const wasm::FunctionBody&\",\n                    \"purpose\": \"Function body to inline.\"\n                },\n                {\n                    \"name\": \"bytes\",\n                    \"type\": \"base::Vector<const uint8_t>\",\n                    \"purpose\": \"Bytecode of the function body.\"\n                },\n                {\n                    \"name\": \"source_position_table\",\n                    \"type\": \"SourcePositionTable*\",\n                    \"purpose\": \"Source position table for debugging.\"\n                },\n                {\n                    \"name\": \"inlining_id\",\n                    \"type\": \"int\",\n                    \"purpose\": \"ID of the inlining operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if inlining was successful, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"WasmIntoJSInlinerImpl\",\n                \"wasm::WasmModule\",\n                \"MachineGraph\",\n                \"wasm::FunctionBody\",\n                \"SourcePositionTable\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool WasmIntoJSInliner::TryInlining(Zone* zone, const wasm::WasmModule* module,\n                                    MachineGraph* mcgraph,\n                                    const wasm::FunctionBody& body,\n                                    base::Vector<const uint8_t> bytes,\n                                    SourcePositionTable* source_position_table,\n                                    int inlining_id) {\n  WasmIntoJSInlinerImpl inliner(zone, module, mcgraph, body, bytes,\n                                source_position_table, inlining_id);\n  return inliner.TryInlining();\n}\n        ]]></code>\n    </func>\n</file>\n```"
}