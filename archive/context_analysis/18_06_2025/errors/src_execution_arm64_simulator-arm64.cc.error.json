{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm64/simulator-arm64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm64/simulator-arm64.cc\",\n            \"file_name\": \"simulator-arm64.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the ARM64 simulator for the V8 JavaScript engine, enabling execution of ARM64 code on non-ARM64 platforms.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for simulator functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/arm64/simulator-arm64.h\"\n\n#include \"src/execution/isolate.h\"\n\n#if defined(USE_SIMULATOR)\n\n#include <stdlib.h>\n\n#include <cmath>\n#include <cstdarg>\n#include <type_traits>\n\n#include \"src/base/overflowing-math.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/platform/wrappers.h\"\n#include \"src/base/sanitizer/msan.h\"\n#include \"src/codegen/arm64/decoder-arm64-inl.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/diagnostics/disasm.h\"\n#include \"src/heap/base/stack.h\"\n#include \"src/heap/combined-heap.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/runtime/runtime-utils.h\"\n#include \"src/snapshot/embedded/embedded-data.h\"\n#include \"src/utils/ostreams.h\"\n\n#if V8_OS_WIN\n#include <windows.h>\n#endif\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/trap-handler/trap-handler-simulator.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Simulator::GlobalMonitor\",\n                \"about\": \"Provides global monitoring capabilities within the simulator, likely for thread safety and synchronization.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nDEFINE_LAZY_LEAKY_OBJECT_GETTER(Simulator::GlobalMonitor,\n                                Simulator::GlobalMonitor::Get)\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ProbeMemory\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Probes memory to check accessibility, especially for WebAssembly trap handling.\",\n                \"logic\": \"Checks if the given memory address and size are valid. If not, it sets the program counter to a landing pad for exception handling, specific to WebAssembly.  If WebAssembly trap handling is disabled, it always returns true.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"address\",\n                        \"type\": \"uintptr_t\",\n                        \"purpose\": \"The starting address of the memory region to probe.\"\n                    },\n                    {\n                        \"name\": \"access_size\",\n                        \"type\": \"uintptr_t\",\n                        \"purpose\": \"The size of the memory region being accessed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if memory access is allowed, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool Simulator::ProbeMemory(uintptr_t address, uintptr_t access_size) {\n#if V8_ENABLE_WEBASSEMBLY && V8_TRAP_HANDLER_SUPPORTED\n  uintptr_t last_accessed_byte = address + access_size - 1;\n  uintptr_t current_pc = reinterpret_cast<uintptr_t>(pc_);\n  uintptr_t landing_pad =\n      trap_handler::ProbeMemory(last_accessed_byte, current_pc);\n  if (!landing_pad) return true;\n  set_pc(landing_pad);\n  set_reg(kWasmTrapHandlerFaultAddressRegister.code(), current_pc);\n  return false;\n#else\n  return true;\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TraceSim\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Conditionally prints trace information to the simulator output stream.\",\n                \"logic\": \"Uses a variable argument list to format a string and print it if the v8_flags.trace_sim flag is enabled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"format\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The format string for the trace message.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Simulator::TraceSim(const char* format, ...) {\n  if (v8_flags.trace_sim) {\n    va_list arguments;\n    va_start(arguments, format);\n    base::OS::VFPrint(stream_, format, arguments);\n    va_end(arguments);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SimSystemRegister::SetBits\",\n                \"parent\": \"SimSystemRegister\",\n                \"about\": \"Sets specific bits within a SimSystemRegister, respecting the write ignore mask.\",\n                \"logic\": \"Calculates the bit width, ensures the bits are within the specified width, shifts the bits to the correct position, creates a mask, ensures no writes to ignore bits, and then applies the bits to the register value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"msb\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The most significant bit to set.\"\n                    },\n                    {\n                        \"name\": \"lsb\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The least significant bit to set.\"\n                    },\n                    {\n                        \"name\": \"bits\",\n                        \"type\": \"uint32_t\",\n                        \"purpose\": \"The bits to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SimSystemRegister::SetBits(int msb, int lsb, uint32_t bits) {\n  int width = msb - lsb + 1;\n  DCHECK(is_uintn(bits, width) || is_intn(bits, width));\n\n  bits <<= lsb;\n  uint32_t mask = ((1 << width) - 1) << lsb;\n  DCHECK_EQ(mask & write_ignore_mask_, 0);\n\n  value_ = (value_ & ~mask) | (bits & mask);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SimSystemRegister::DefaultValueFor\",\n                \"parent\": \"SimSystemRegister\",\n                \"about\": \"Returns a default value for the specified system register.\",\n                \"logic\": \"Switch statement to return the default value based on the register ID. Handles NZCV and FPCR, otherwise unreachable.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"type\": \"SystemRegister\",\n                        \"purpose\": \"The ID of the system register to get the default value for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"SimSystemRegister\",\n                    \"description\": \"The default value for the register.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nSimSystemRegister SimSystemRegister::DefaultValueFor(SystemRegister id) {\n  switch (id) {\n    case NZCV:\n      return SimSystemRegister(0x00000000, NZCVWriteIgnoreMask);\n    case FPCR:\n      return SimSystemRegister(0x00000000, FPCRWriteIgnoreMask);\n    default:\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::current\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Gets the active Simulator instance for the current thread within a given isolate.\",\n                \"logic\": \"Retrieves or allocates per-thread data associated with the isolate. If a simulator is not already present in this data, creates a new Simulator instance (with or without tracing based on flags) and stores it in the per-thread data. Returns the simulator.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate for which to get the simulator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Simulator*\",\n                    \"description\": \"The Simulator instance for the current thread.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nSimulator* Simulator::current(Isolate* isolate) {\n  Isolate::PerIsolateThreadData* isolate_data =\n      isolate->FindOrAllocatePerThreadDataForThisThread();\n  DCHECK_NOT_NULL(isolate_data);\n\n  Simulator* sim = isolate_data->simulator();\n  if (sim == nullptr) {\n    if (v8_flags.trace_sim || v8_flags.debug_sim) {\n      sim = new Simulator(new Decoder<DispatchingDecoderVisitor>(), isolate);\n    } else {\n      sim = new Decoder<Simulator>();\n      sim->isolate_ = isolate;\n    }\n    isolate_data->set_simulator(sim);\n  }\n  return sim;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::CallImpl\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Implements the function call mechanism within the simulator, handling argument passing and stack setup.\",\n                \"logic\": \"Iterates through the arguments passed via the CallArgument array.  Registers x0-x7 and d0-d7 are used first.  Remaining arguments are pushed onto the stack with alignment.  Then, sets the program counter to the entry point, sets the link register, runs the code, and restores the stack pointer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"entry\",\n                        \"type\": \"Address\",\n                        \"purpose\": \"The entry point address of the function to call.\"\n                    },\n                    {\n                        \"name\": \"args\",\n                        \"type\": \"CallArgument*\",\n                        \"purpose\": \"An array of CallArgument structures representing the arguments to the function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Simulator::CallImpl(Address entry, CallArgument* args) {\n  int index_x = 0;\n  int index_d = 0;\n\n  std::vector<int64_t> stack_args(0);\n  for (int i = 0; !args[i].IsEnd(); i++) {\n    CallArgument arg = args[i];\n    if (arg.IsX() && (index_x < 8)) {\n      set_xreg(index_x++, arg.bits());\n    } else if (arg.IsD() && (index_d < 8)) {\n      set_dreg_bits(index_d++, arg.bits());\n    } else {\n      DCHECK(arg.IsD() || arg.IsX());\n      stack_args.push_back(arg.bits());\n    }\n  }\n\n  // Process stack arguments, and make sure the stack is suitably aligned.\n  uintptr_t original_stack = sp();\n  uintptr_t entry_stack =\n      original_stack - stack_args.size() * sizeof(stack_args[0]);\n  if (base::OS::ActivationFrameAlignment() != 0) {\n    entry_stack &= -base::OS::ActivationFrameAlignment();\n  }\n  char* stack = reinterpret_cast<char*>(entry_stack);\n  std::vector<int64_t>::const_iterator it;\n  for (it = stack_args.begin(); it != stack_args.end(); it++) {\n    memcpy(stack, &(*it), sizeof(*it));\n    stack += sizeof(*it);\n  }\n\n  DCHECK(reinterpret_cast<uintptr_t>(stack) <= original_stack);\n  set_sp(entry_stack);\n\n  // Call the generated code.\n  set_pc(entry);\n  set_lr(kEndOfSimAddress);\n  CheckPCSComplianceAndRun();\n\n  set_sp(original_stack);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::CheckPCSComplianceAndRun\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Checks compliance with Procedure Call Standard (PCS) before and after running the simulated code, and then executes the code.\",\n                \"logic\": \"Adjusts the JS stack limit, saves callee-saved registers, runs the code, checks that callee-saved registers are preserved, and corrupts caller-saved registers.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Simulator::CheckPCSComplianceAndRun() {\n  // Adjust JS-based stack limit to C-based stack limit.\n  isolate_->stack_guard()->AdjustStackLimitForSimulator();\n\n#ifdef DEBUG\n  DCHECK_EQ(kNumberOfCalleeSavedRegisters, kCalleeSaved.Count());\n  DCHECK_EQ(kNumberOfCalleeSavedVRegisters, kCalleeSavedV.Count());\n\n  int64_t saved_registers[kNumberOfCalleeSavedRegisters];\n  uint64_t saved_fpregisters[kNumberOfCalleeSavedVRegisters];\n\n  CPURegList register_list = kCalleeSaved;\n  CPURegList fpregister_list = kCalleeSavedV;\n\n  for (int i = 0; i < kNumberOfCalleeSavedRegisters; i++) {\n    // x31 is not a caller saved register, so no need to specify if we want\n    // the stack or zero.\n    saved_registers[i] = xreg(PopLowestIndexAsCode(&register_list));\n  }\n  for (int i = 0; i < kNumberOfCalleeSavedVRegisters; i++) {\n    saved_fpregisters[i] = dreg_bits(PopLowestIndexAsCode(&fpregister_list));\n  }\n  int64_t original_stack = sp();\n  int64_t original_fp = fp();\n#endif\n  // Start the simulation!\n  Run();\n#ifdef DEBUG\n  DCHECK_EQ(original_stack, sp());\n  DCHECK_EQ(original_fp, fp());\n  // Check that callee-saved registers have been preserved.\n  register_list = kCalleeSaved;\n  fpregister_list = kCalleeSavedV;\n  for (int i = 0; i < kNumberOfCalleeSavedRegisters; i++) {\n    DCHECK_EQ(saved_registers[i], xreg(PopLowestIndexAsCode(&register_list)));\n  }\n  for (int i = 0; i < kNumberOfCalleeSavedVRegisters; i++) {\n    DCHECK(saved_fpregisters[i] ==\n           dreg_bits(PopLowestIndexAsCode(&fpregister_list)));\n  }\n\n  // Corrupt caller saved register minus the return regiters.\n\n  // In theory x0 to x7 can be used for return values, but V8 only uses x0, x1\n  // for now .\n  register_list = kCallerSaved;\n  register_list.Remove(x0);\n  register_list.Remove(x1);\n\n  // In theory d0 to d7 can be used for return values, but V8 only uses d0\n  // for now .\n  fpregister_list = kCallerSavedV;\n  fpregister_list.Remove(d0);\n\n  CorruptRegisters(&register_list, kCallerSavedRegisterCorruptionValue);\n  CorruptRegisters(&fpregister_list, kCallerSavedVRegisterCorruptionValue);\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::PushAddress\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Pushes an address onto the simulator stack, ensuring proper alignment.\",\n                \"logic\": \"Decrements the stack pointer by twice the register size, places the address at the new stack location, and fills an alignment slot with a zap value.  Returns the new stack pointer value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"address\",\n                        \"type\": \"uintptr_t\",\n                        \"purpose\": \"The address to push onto the stack.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uintptr_t\",\n                    \"description\": \"The new value of the stack pointer.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuintptr_t Simulator::PushAddress(uintptr_t address) {\n  DCHECK(sizeof(uintptr_t) < 2 * kXRegSize);\n  intptr_t new_sp = sp() - 2 * kXRegSize;\n  uintptr_t* alignment_slot = reinterpret_cast<uintptr_t*>(new_sp + kXRegSize);\n  memcpy(alignment_slot, &kSlotsZapValue, kSystemPointerSize);\n  uintptr_t* stack_slot = reinterpret_cast<uintptr_t*>(new_sp);\n  memcpy(stack_slot, &address, kSystemPointerSize);\n  set_sp(new_sp);\n  return new_sp;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::PopAddress\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Pops an address from the simulator stack.\",\n                \"logic\": \"Retrieves the address from the current stack location, increments the stack pointer, and returns the retrieved address.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"uintptr_t\",\n                    \"description\": \"The address popped from the stack.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuintptr_t Simulator::PopAddress() {\n  intptr_t current_sp = sp();\n  uintptr_t* stack_slot = reinterpret_cast<uintptr_t*>(current_sp);\n  uintptr_t address = *stack_slot;\n  DCHECK_LT(sizeof(uintptr_t), 2 * kXRegSize);\n  set_sp(current_sp + 2 * kXRegSize);\n  return address;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::StackLimit\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Returns the limit of the stack area to enable checking for stack overflows.\",\n                \"logic\": \"Calculates the stack limit based on the exhaustion of the C stack or the JS stack, ensuring a safety margin.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"c_limit\",\n                        \"type\": \"uintptr_t\",\n                        \"purpose\": \"The limit of the C stack.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uintptr_t\",\n                    \"description\": \"The stack limit for overflow checking.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuintptr_t Simulator::StackLimit(uintptr_t c_limit) const {\n  // The simulator uses a separate JS stack. If we have exhausted the C stack,\n  // we also drop down the JS limit to reflect the exhaustion on the JS stack.\n  if (base::Stack::GetCurrentStackPosition() < c_limit) {\n    return get_sp();\n  }\n\n  // Otherwise the limit is the JS stack. Leave a safety margin to prevent\n  // overrunning the stack when pushing values.\n  return stack_limit_ + kAdditionalStackMargin;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::StackBase\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Returns the base address of the simulator stack.\",\n                \"logic\": \"Calculates the stack base by adding the allocated stack size and subtracting the stack protection size from the stack start address.  Aligns the result to a 16-byte boundary.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"uintptr_t\",\n                    \"description\": \"The base address of the stack.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuintptr_t Simulator::StackBase() const {\n  uintptr_t result = stack_ + AllocatedStackSize() - kStackProtectionSize;\n  // The stack base is 16-byte aligned.\n  return result & ~0xFULL;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::SetStackLimit\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Sets the stack limit for the simulator.\",\n                \"logic\": \"Calculates and sets the stack limit by subtracting an additional stack margin from the given limit.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"limit\",\n                        \"type\": \"uintptr_t\",\n                        \"purpose\": \"The desired stack limit.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Simulator::SetStackLimit(uintptr_t limit) {\n  stack_limit_ = static_cast<uintptr_t>(limit - kAdditionalStackMargin);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::GetCentralStackView\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Returns a vector representing a view of the central portion of the simulator stack.\",\n                \"logic\": \"Creates a vector of uint8_t representing the usable stack space, starting after the stack protection size and extending to the usable stack size.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"base::Vector<uint8_t>\",\n                    \"description\": \"A vector representing the central stack view.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbase::Vector<uint8_t> Simulator::GetCentralStackView() const {\n  // We do not add an additional safety margin as above in\n  // Simulator::StackLimit, as users of this method are expected to add their\n  // own margin.\n  return base::VectorOf(\n      reinterpret_cast<uint8_t*>(stack_ + kStackProtectionSize),\n      UsableStackSize());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::IterateRegistersAndStack\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Iterates through the registers and stack of the simulator, visiting each pointer.\",\n                \"logic\": \"Iterates through all general-purpose registers and stack slots, calling the VisitPointer method of the provided StackVisitor for each.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"visitor\",\n                        \"type\": \"::heap::base::StackVisitor*\",\n                        \"purpose\": \"The StackVisitor instance to call for each pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nDISABLE_MSAN void Simulator::IterateRegistersAndStack(\n    ::heap::base::StackVisitor* visitor) {\n  for (int i = 0; i < kNumberOfRegisters; ++i) {\n    visitor->VisitPointer(reinterpret_cast<const void*>(xreg(i)));\n  }\n  for (const void* const* current =\n           reinterpret_cast<const void* const*>(get_sp());\n       current < reinterpret_cast<const void* const*>(StackBase()); ++current) {\n    const void* address = *current;\n    if (address == nullptr) {\n      continue;\n    }\n    visitor->VisitPointer(address);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::SetRedirectInstruction\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Sets an instruction to redirect calls to runtime functions.\",\n                \"logic\": \"Modifies an instruction to act as a halt instruction with a specific immediate exception value indicating a redirected call.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to modify.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Simulator::SetRedirectInstruction(Instruction* instruction) {\n  instruction->SetInstructionBits(\n      HLT | Assembler::ImmException(kImmExceptionIsRedirectedCall));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"Simulator::Simulator\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Constructor for the Simulator class, initializes the simulator with a decoder, isolate, and output stream.\",\n                \"logic\": \"Sets up the decoder, appends the simulator as a visitor, initializes the simulator state, allocates the stack, sets the stack limit, sets the output stream, and sets up debugging helpers. Tracing is initialized based on flags.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"decoder\",\n                        \"type\": \"Decoder<DispatchingDecoderVisitor>*\",\n                        \"purpose\": \"The decoder used to decode ARM64 instructions.\"\n                    },\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate associated with the simulator.\"\n                    },\n                    {\n                        \"name\": \"stream\",\n                        \"type\": \"FILE*\",\n                        \"purpose\": \"The output stream to use for tracing and debugging.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"none\",\n                    \"description\": \"Constructor, no return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nSimulator::Simulator(Decoder<DispatchingDecoderVisitor>* decoder,\n                     Isolate* isolate, FILE* stream)\n    : decoder_(decoder),\n      guard_pages_(ENABLE_CONTROL_FLOW_INTEGRITY_BOOL),\n      last_debugger_input_(nullptr),\n      log_parameters_(NO_PARAM),\n      icount_for_stop_sim_at_(0),\n      isolate_(isolate) {\n  // Setup the decoder.\n  decoder_->AppendVisitor(this);\n\n  Init(stream);\n\n  if (v8_flags.trace_sim) {\n    decoder_->InsertVisitorBefore(print_disasm_, this);\n    log_parameters_ = LOG_ALL;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"Simulator::Simulator\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Constructor for the Simulator class, initializes the simulator without tracing.\",\n                \"logic\": \"Initializes member variables and ensures tracing is disabled.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"none\",\n                    \"description\": \"Constructor, no return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nSimulator::Simulator()\n    : decoder_(nullptr),\n      guard_pages_(ENABLE_CONTROL_FLOW_INTEGRITY_BOOL),\n      last_debugger_input_(nullptr),\n      log_parameters_(NO_PARAM),\n      isolate_(nullptr) {\n  Init(stdout);\n  CHECK(!v8_flags.trace_sim);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::Init\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Initializes the simulator, including resetting the state, allocating the stack, and setting up debugging helpers.\",\n                \"logic\": \"Calls ResetState, allocates the stack, sets the stack limit, sets the stack pointer, sets the output stream, initializes disassembler and global monitor.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"stream\",\n                        \"type\": \"FILE*\",\n                        \"purpose\": \"The output stream for logging.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Simulator::Init(FILE* stream) {\n  ResetState();\n\n  // Allocate and setup the simulator stack.\n  size_t stack_size = AllocatedStackSize();\n\n  stack_ = reinterpret_cast<uintptr_t>(new uint8_t[stack_size]());\n  stack_limit_ = stack_ + kStackProtectionSize;\n  set_sp(StackBase());\n\n  stream_ = stream;\n  print_disasm_ = new PrintDisassembler(stream_);\n\n  // The debugger needs to disassemble code without the simulator executing an\n  // instruction, so we create a dedicated decoder.\n  disassembler_decoder_ = new Decoder<DispatchingDecoderVisitor>();\n  disassembler_decoder_->AppendVisitor(print_disasm_);\n\n  global_monitor_ = GlobalMonitor::Get();\n  global_monitor_->PrependProcessor(&global_monitor_processor_);\n\n  // Enabling deadlock detection while simulating is too slow.\n  SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kIgnore);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Simulator::ResetState\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Resets the internal state of the simulator to its initial configuration.\",\n                \"logic\": \"Resets system registers, sets program counter to null, sets all registers to a bad value, sets the link register to the end of the simulation, clears breakpoints, disables break-on-next, and sets the B type to the default.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Simulator::ResetState() {\n  // Reset the system registers.\n  nzcv_ = SimSystemRegister::DefaultValueFor(NZCV);\n  fpcr_ = SimSystemRegister::DefaultValueFor(FPCR);\n\n  // Reset registers to 0.\n  pc_ = nullptr;\n  for (unsigned i = 0; i < kNumberOfRegisters; i++) {\n    set_xreg(i, 0xBADBEEF);\n  }\n  for (unsigned i = 0; i < kNumberOfVRegisters; i++) {\n    // Set FP registers to a value that is NaN in both 32-bit and 64-bit FP.\n    set_dreg_bits(i, 0x7FF000007F800001UL);\n  }\n  // Returning to address 0 exits the Simulator.\n  set_lr(kEndOfSimAddress);\n\n  // Reset debug helpers.\n  breakpoints_.clear();\n  break_on_next_ = false;\n\n  btype_ = DefaultBType;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"destructor\",\n                \"name\": \"Simulator::~Simulator\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Destructor for the Simulator class, frees allocated resources.\",\n                \"logic\": \"Removes the processor from global monitor, deletes stack, disassembler decoder, and the decoder.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"none\",\n                    \"description\": \"Destructor, no return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n"
}