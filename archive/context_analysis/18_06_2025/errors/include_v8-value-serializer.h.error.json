{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-value-serializer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 393, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-value-serializer.h\",\n        \"file_name\": \"v8-value-serializer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the ValueSerializer and ValueDeserializer classes for serializing and deserializing JavaScript values, compatible with the HTML structured clone algorithm.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard C++ headers for size definitions, integer types, memory management, utility classes.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stddef.h>\n            #include <stdint.h>\n\n            #include <memory>\n            #include <utility>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"V8 specific headers for local handles, maybe types, and configuration.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-maybe.h\"         // NOLINT(build/include_directory)\n            #include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SharedValueConveyor\",\n            \"about\": \"Manages the lifetime of shared value conveyors used by V8 to keep JS shared values alive in transit when serialized.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"internal::SharedObjectConveyorHandles\",\n                \"internal::ValueSerializer\",\n                \"internal::ValueDeserializer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT SharedValueConveyor final {\n            public:\n            SharedValueConveyor(SharedValueConveyor&&) noexcept;\n            ~SharedValueConveyor();\n\n            SharedValueConveyor& operator=(SharedValueConveyor&&) noexcept;\n\n            private:\n            friend class internal::ValueSerializer;\n            friend class internal::ValueDeserializer;\n\n            explicit SharedValueConveyor(Isolate* isolate);\n\n            std::unique_ptr<internal::SharedObjectConveyorHandles> private_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueSerializer\",\n            \"about\": \"Value serialization compatible with the HTML structured clone algorithm.\",\n            \"attributes\": [\n                {\n                    \"name\": \"private_\",\n                    \"type\": \"PrivateData*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to private data structure.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Context\",\n                \"Value\",\n                \"ArrayBuffer\",\n                \"Delegate\",\n                \"internal::ValueSerializer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT ValueSerializer {\n            public:\n            class V8_EXPORT Delegate {\n            public:\n                virtual ~Delegate() = default;\n\n                /**\n                 * Handles the case where a DataCloneError would be thrown in the structured\n                 * clone spec. Other V8 embedders may throw some other appropriate exception\n                 * type.\n                 */\n                virtual void ThrowDataCloneError(Local<String> message) = 0;\n\n                /**\n                 * The embedder overrides this method to enable custom host object filter\n                 * with Delegate::IsHostObject.\n                 *\n                 * This method is called at most once per serializer.\n                 */\n                virtual bool HasCustomHostObject(Isolate* isolate);\n\n                /**\n                 * The embedder overrides this method to determine if an JS object is a\n                 * host object and needs to be serialized by the host.\n                 */\n                virtual Maybe<bool> IsHostObject(Isolate* isolate, Local<Object> object);\n\n                /**\n                 * The embedder overrides this method to write some kind of host object, if\n                 * possible. If not, a suitable exception should be thrown and\n                 * Nothing<bool>() returned.\n                 */\n                virtual Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object);\n\n                /**\n                 * Called when the ValueSerializer is going to serialize a\n                 * SharedArrayBuffer object. The embedder must return an ID for the\n                 * object, using the same ID if this SharedArrayBuffer has already been\n                 * serialized in this buffer. When deserializing, this ID will be passed to\n                 * ValueDeserializer::GetSharedArrayBufferFromId as |clone_id|.\n                 *\n                 * If the object cannot be serialized, an\n                 * exception should be thrown and Nothing<uint32_t>() returned.\n                 */\n                virtual Maybe<uint32_t> GetSharedArrayBufferId(\n                    Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer);\n\n                virtual Maybe<uint32_t> GetWasmModuleTransferId(\n                    Isolate* isolate, Local<WasmModuleObject> module);\n\n                /**\n                 * Called when the first shared value is serialized. All subsequent shared\n                 * values will use the same conveyor.\n                 *\n                 * The embedder must ensure the lifetime of the conveyor matches the\n                 * lifetime of the serialized data.\n                 *\n                 * If the embedder supports serializing shared values, this method should\n                 * return true. Otherwise the embedder should throw an exception and return\n                 * false.\n                 *\n                 * This method is called at most once per serializer.\n                 */\n                virtual bool AdoptSharedValueConveyor(Isolate* isolate,\n                                                    SharedValueConveyor&& conveyor);\n\n                /**\n                 * Allocates memory for the buffer of at least the size provided. The actual\n                 * size (which may be greater or equal) is written to |actual_size|. If no\n                 * buffer has been allocated yet, nullptr will be provided.\n                 *\n                 * If the memory cannot be allocated, nullptr should be returned.\n                 * |actual_size| will be ignored. It is assumed that |old_buffer| is still\n                 * valid in this case and has not been modified.\n                 *\n                 * The default implementation uses the stdlib's `realloc()` function.\n                 */\n                virtual void* ReallocateBufferMemory(void* old_buffer, size_t size,\n                                                    size_t* actual_size);\n\n                /**\n                 * Frees a buffer allocated with |ReallocateBufferMemory|.\n                 *\n                 * The default implementation uses the stdlib's `free()` function.\n                 */\n                virtual void FreeBufferMemory(void* buffer);\n            };\n\n            explicit ValueSerializer(Isolate* isolate);\n            ValueSerializer(Isolate* isolate, Delegate* delegate);\n            ~ValueSerializer();\n\n            /**\n             * Writes out a header, which includes the format version.\n             */\n            void WriteHeader();\n\n            /**\n             * Serializes a JavaScript value into the buffer.\n             */\n            V8_WARN_UNUSED_RESULT Maybe<bool> WriteValue(Local<Context> context,\n                                                        Local<Value> value);\n\n            /**\n             * Returns the stored data (allocated using the delegate's\n             * ReallocateBufferMemory) and its size. This serializer should not be used\n             * once the buffer is released. The contents are undefined if a previous write\n             * has failed. Ownership of the buffer is transferred to the caller.\n             */\n            V8_WARN_UNUSED_RESULT std::pair<uint8_t*, size_t> Release();\n\n            /**\n             * Marks an ArrayBuffer as havings its contents transferred out of band.\n             * Pass the corresponding ArrayBuffer in the deserializing context to\n             * ValueDeserializer::TransferArrayBuffer.\n             */\n            void TransferArrayBuffer(uint32_t transfer_id,\n                                    Local<ArrayBuffer> array_buffer);\n\n            /**\n             * Indicate whether to treat ArrayBufferView objects as host objects,\n             * i.e. pass them to Delegate::WriteHostObject. This should not be\n             * called when no Delegate was passed.\n             *\n             * The default is not to treat ArrayBufferViews as host objects.\n             */\n            void SetTreatArrayBufferViewsAsHostObjects(bool mode);\n\n            /**\n             * Write raw data in various common formats to the buffer.\n             * Note that integer types are written in base-128 varint format, not with a\n             * binary copy. For use during an override of Delegate::WriteHostObject.\n             */\n            void WriteUint32(uint32_t value);\n            void WriteUint64(uint64_t value);\n            void WriteDouble(double value);\n            void WriteRawBytes(const void* source, size_t length);\n\n            ValueSerializer(const ValueSerializer&) = delete;\n            void operator=(const ValueSerializer&) = delete;\n\n            private:\n            struct PrivateData;\n            PrivateData* private_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueDeserializer\",\n            \"about\": \"Deserializes values from data written with ValueSerializer, or a compatible implementation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"private_\",\n                    \"type\": \"PrivateData*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to private data structure.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Context\",\n                \"Value\",\n                \"ArrayBuffer\",\n                \"SharedArrayBuffer\",\n                \"WasmModuleObject\",\n                \"Delegate\",\n                \"internal::ValueDeserializer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT ValueDeserializer {\n            public:\n            class V8_EXPORT Delegate {\n            public:\n                virtual ~Delegate() = default;\n\n                /**\n                 * The embedder overrides this method to read some kind of host object, if\n                 * possible. If not, a suitable exception should be thrown and\n                 * MaybeLocal<Object>() returned.\n                 */\n                virtual MaybeLocal<Object> ReadHostObject(Isolate* isolate);\n\n                /**\n                 * Get a WasmModuleObject given a transfer_id previously provided\n                 * by ValueSerializer::Delegate::GetWasmModuleTransferId\n                 */\n                virtual MaybeLocal<WasmModuleObject> GetWasmModuleFromId(\n                    Isolate* isolate, uint32_t transfer_id);\n\n                /**\n                 * Get a SharedArrayBuffer given a clone_id previously provided\n                 * by ValueSerializer::Delegate::GetSharedArrayBufferId\n                 */\n                virtual MaybeLocal<SharedArrayBuffer> GetSharedArrayBufferFromId(\n                    Isolate* isolate, uint32_t clone_id);\n\n                /**\n                 * Get the SharedValueConveyor previously provided by\n                 * ValueSerializer::Delegate::AdoptSharedValueConveyor.\n                 */\n                virtual const SharedValueConveyor* GetSharedValueConveyor(Isolate* isolate);\n            };\n\n            ValueDeserializer(Isolate* isolate, const uint8_t* data, size_t size);\n            ValueDeserializer(Isolate* isolate, const uint8_t* data, size_t size,\n                                Delegate* delegate);\n            ~ValueDeserializer();\n\n            /**\n             * Reads and validates a header (including the format version).\n             * May, for example, reject an invalid or unsupported wire format.\n             */\n            V8_WARN_UNUSED_RESULT Maybe<bool> ReadHeader(Local<Context> context);\n\n            /**\n             * Deserializes a JavaScript value from the buffer.\n             */\n            V8_WARN_UNUSED_RESULT MaybeLocal<Value> ReadValue(Local<Context> context);\n\n            /**\n             * Accepts the array buffer corresponding to the one passed previously to\n             * ValueSerializer::TransferArrayBuffer.\n             */\n            void TransferArrayBuffer(uint32_t transfer_id,\n                                    Local<ArrayBuffer> array_buffer);\n\n            /**\n             * Similar to TransferArrayBuffer, but for SharedArrayBuffer.\n             * The id is not necessarily in the same namespace as unshared ArrayBuffer\n             * objects.\n             */\n            void TransferSharedArrayBuffer(uint32_t id,\n                                            Local<SharedArrayBuffer> shared_array_buffer);\n\n            /**\n             * Must be called before ReadHeader to enable support for reading the legacy\n             * wire format (i.e., which predates this being shipped).\n             *\n             * Don't use this unless you need to read data written by previous versions of\n             * blink::ScriptValueSerializer.\n             */\n            void SetSupportsLegacyWireFormat(bool supports_legacy_wire_format);\n\n            /**\n             * Reads the underlying wire format version. Likely mostly to be useful to\n             * legacy code reading old wire format versions. Must be called after\n             * ReadHeader.\n             */\n            uint32_t GetWireFormatVersion() const;\n\n            /**\n             * Reads raw data in various common formats to the buffer.\n             * Note that integer types are read in base-128 varint format, not with a\n             * binary copy. For use during an override of Delegate::ReadHostObject.\n             */\n            V8_WARN_UNUSED_RESULT bool ReadUint32(uint32_t* value);\n            V8_WARN_UNUSED_RESULT bool ReadUint64(uint64_t* value);\n            V8_WARN_UNUSED_RESULT bool ReadDouble(double* value);\n            V8_WARN_UNUSED_RESULT bool ReadRawBytes(size_t length, const void** data);\n\n            ValueDeserializer(const ValueDeserializer&) = delete;\n            void operator=(const ValueDeserializer&) = delete;\n\n            private:\n            struct PrivateData;\n            PrivateData* private_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueSerializer::Delegate\",\n            \"parent\": null,\n            \"about\": \"Abstract class to customize serialization of host objects\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Local<String>\",\n                \"Local<Object>\",\n                \"SharedArrayBuffer\",\n                \"Local<SharedArrayBuffer>\",\n                \"WasmModuleObject\",\n                \"Local<WasmModuleObject>\",\n                \"SharedValueConveyor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT ValueSerializer::Delegate {\n            public:\n                virtual ~Delegate() = default;\n\n                /**\n                 * Handles the case where a DataCloneError would be thrown in the structured\n                 * clone spec. Other V8 embedders may throw some other appropriate exception\n                 * type.\n                 */\n                virtual void ThrowDataCloneError(Local<String> message) = 0;\n\n                /**\n                 * The embedder overrides this method to enable custom host object filter\n                 * with Delegate::IsHostObject.\n                 *\n                 * This method is called at most once per serializer.\n                 */\n                virtual bool HasCustomHostObject(Isolate* isolate);\n\n                /**\n                 * The embedder overrides this method to determine if an JS object is a\n                 * host object and needs to be serialized by the host.\n                 */\n                virtual Maybe<bool> IsHostObject(Isolate* isolate, Local<Object> object);\n\n                /**\n                 * The embedder overrides this method to write some kind of host object, if\n                 * possible. If not, a suitable exception should be thrown and\n                 * Nothing<bool>() returned.\n                 */\n                virtual Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object);\n\n                /**\n                 * Called when the ValueSerializer is going to serialize a\n                 * SharedArrayBuffer object. The embedder must return an ID for the\n                 * object, using the same ID if this SharedArrayBuffer has already been\n                 * serialized in this buffer. When deserializing, this ID will be passed to\n                 * ValueDeserializer::GetSharedArrayBufferFromId as |clone_id|.\n                 *\n                 * If the object cannot be serialized, an\n                 * exception should be thrown and Nothing<uint32_t>() returned.\n                 */\n                virtual Maybe<uint32_t> GetSharedArrayBufferId(\n                    Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer);\n\n                virtual Maybe<uint32_t> GetWasmModuleTransferId(\n                    Isolate* isolate, Local<WasmModuleObject> module);\n\n                /**\n                 * Called when the first shared value is serialized. All subsequent shared\n                 * values will use the same conveyor.\n                 *\n                 * The embedder must ensure the lifetime of the conveyor matches the\n                 * lifetime of the serialized data.\n                 *\n                 * If the embedder supports serializing shared values, this method should\n                 * return true. Otherwise the embedder should throw an exception and return\n                 * false.\n                 *\n                 * This method is called at most once per serializer.\n                 */\n                virtual bool AdoptSharedValueConveyor(Isolate* isolate,\n                                                    SharedValueConveyor&& conveyor);\n\n                /**\n                 * Allocates memory for the buffer of at least the size provided. The actual\n                 * size (which may be greater or equal) is written to |actual_size|. If no\n                 * buffer has been allocated yet, nullptr will be provided.\n                 *\n                 * If the memory cannot be allocated, nullptr should be returned.\n                 * |actual_size| will be ignored. It is assumed that |old_buffer| is still\n                 * valid in this case and has not been modified.\n                 *\n                 * The default implementation uses the stdlib's `realloc()` function.\n                 */\n                virtual void* ReallocateBufferMemory(void* old_buffer, size_t size,\n                                                    size_t* actual_size);\n\n                /**\n                 * Frees a buffer allocated with |ReallocateBufferMemory|.\n                 *\n                 * The default implementation uses the stdlib's `free()` function.\n                 */\n                virtual void FreeBufferMemory(void* buffer);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueDeserializer::Delegate\",\n            \"parent\": null,\n            \"about\": \"Abstract class to customize deserialization of host objects\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Local<Object>\",\n                \"WasmModuleObject\",\n                \"Local<WasmModuleObject>\",\n                \"SharedArrayBuffer\",\n                \"Local<SharedArrayBuffer>\",\n                \"SharedValueConveyor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT ValueDeserializer::Delegate {\n            public:\n                virtual ~Delegate() = default;\n\n                /**\n                 * The embedder overrides this method to read some kind of host object, if\n                 * possible. If not, a suitable exception should be thrown and\n                 * MaybeLocal<Object>() returned.\n                 */\n                virtual MaybeLocal<Object> ReadHostObject(Isolate* isolate);\n\n                /**\n                 * Get a WasmModuleObject given a transfer_id previously provided\n                 * by ValueSerializer::Delegate::GetWasmModuleTransferId\n                 */\n                virtual MaybeLocal<WasmModuleObject> GetWasmModuleFromId(\n                    Isolate* isolate, uint32_t transfer_id);\n\n                /**\n                 * Get a SharedArrayBuffer given a clone_id previously provided\n                 * by ValueSerializer::Delegate::GetSharedArrayBufferId\n                 */\n                virtual MaybeLocal<SharedArrayBuffer> GetSharedArrayBufferFromId(\n                    Isolate* isolate, uint32_t clone_id);\n\n                /**\n                 * Get the SharedValueConveyor previously provided by\n                 * ValueSerializer::Delegate::AdoptSharedValueConveyor.\n                 */\n                virtual const SharedValueConveyor* GetSharedValueConveyor(Isolate* isolate);\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Context\",\n                \"about\": \"A JavaScript execution context.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Context;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Value\",\n                \"about\": \"The base class for all JavaScript values.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Value;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ArrayBuffer\",\n                \"about\": \"Represents a raw buffer of binary data.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ArrayBuffer;\n            ]]></code>\n        </class>\n         <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SharedArrayBuffer\",\n                \"about\": \"Represents a raw buffer of binary data shared between threads/isolates.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SharedArrayBuffer;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmModuleObject\",\n                \"about\": \"Represents a WebAssembly module object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class WasmModuleObject;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"String\",\n                \"about\": \"Represents a JavaScript string.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class String;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Object\",\n                \"about\": \"Represents a JavaScript object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Object;\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}