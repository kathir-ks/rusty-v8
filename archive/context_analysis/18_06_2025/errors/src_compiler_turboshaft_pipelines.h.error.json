{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/pipelines.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/pipelines.h\",\n            \"file_name\": \"pipelines.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the Pipeline class and related classes for the Turboshaft compiler, which orchestrates the different compilation phases.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8 specific headers required for compilation pipeline definition.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/backend/register-allocator-verifier.h\"\n#include \"src/compiler/basic-block-instrumentor.h\"\n#include \"src/compiler/pipeline-statistics.h\"\n#include \"src/compiler/turbofan-graph-visualizer.h\"\n#include \"src/compiler/turboshaft/block-instrumentation-phase.h\"\n#include \"src/compiler/turboshaft/build-graph-phase.h\"\n#include \"src/compiler/turboshaft/code-elimination-and-simplification-phase.h\"\n#include \"src/compiler/turboshaft/debug-feature-lowering-phase.h\"\n#include \"src/compiler/turboshaft/decompression-optimization-phase.h\"\n#include \"src/compiler/turboshaft/instruction-selection-phase.h\"\n#include \"src/compiler/turboshaft/loop-peeling-phase.h\"\n#include \"src/compiler/turboshaft/loop-unrolling-phase.h\"\n#include \"src/compiler/turboshaft/machine-lowering-phase.h\"\n#include \"src/compiler/turboshaft/maglev-graph-building-phase.h\"\n#include \"src/compiler/turboshaft/optimize-phase.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/register-allocation-phase.h\"\n#include \"src/compiler/turboshaft/sidetable.h\"\n#include \"src/compiler/turboshaft/store-store-elimination-phase.h\"\n#include \"src/compiler/turboshaft/tracing.h\"\n#include \"src/compiler/turboshaft/type-assertions-phase.h\"\n#include \"src/compiler/turboshaft/typed-optimizations-phase.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/compiler/turboshaft/wasm-in-js-inlining-phase.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Pipeline\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Orchestrates the Turboshaft compilation pipeline.  It defines the sequence of phases and provides utilities for running them and printing debug information.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"PipelineData*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the PipelineData object which holds the compilation state.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"PipelineData\",\n                    \"TurboshaftPhase\",\n                    \"PhaseScope\",\n                    \"ZoneWithName\",\n                    \"NodeOriginTable\",\n                    \"RuntimeCallTimerScope\",\n                    \"CodeTracer\",\n                    \"Linkage\",\n                    \"compiler::TFPipelineData\",\n                    \"ProfileDataFromFile\",\n                    \"OsrHelper\",\n                    \"JumpOptimizationInfo\",\n                    \"RegisterConfiguration\",\n                    \"CallDescriptor\",\n                    \"InstructionSequence\",\n                    \"CodeGenerator\",\n                    \"MaybeHandle\",\n                    \"Code\",\n                    \"OptimizedCompilationInfo\",\n                    \"IndirectHandle\",\n                    \"Tracing\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE Pipeline {\n public:\n  explicit Pipeline(PipelineData* data) : data_(data) {}\n\n  PipelineData* data() const { return data_; }\n  void BeginPhaseKind(const char* phase_kind_name) {\n    if (auto statistics = data()->pipeline_statistics()) {\n      statistics->BeginPhaseKind(phase_kind_name);\n    }\n  }\n  void EndPhaseKind() {\n    if (auto statistics = data()->pipeline_statistics()) {\n      statistics->EndPhaseKind();\n    }\n  }\n\n  template <TurboshaftPhase Phase, typename... Args>\n  auto Run(Args&&... args) {\n    // Setup run scope.\n    PhaseScope phase_scope(data_->pipeline_statistics(), Phase::phase_name());\n    ZoneWithName<Phase::kPhaseName> temp_zone(data_->zone_stats(),\n                                              Phase::phase_name());\n    NodeOriginTable::PhaseScope origin_scope(data_->node_origins(),\n                                             Phase::phase_name());\n#ifdef V8_RUNTIME_CALL_STATS\n    RuntimeCallTimerScope runtime_call_timer_scope(data_->runtime_call_stats(),\n                                                   Phase::kRuntimeCallCounterId,\n                                                   Phase::kCounterMode);\n#endif\n\n    Phase phase;\n    using result_t =\n        decltype(phase.Run(data_, temp_zone, std::forward<Args>(args)...));\n    if constexpr (std::is_same_v<result_t, void>) {\n      phase.Run(data_, temp_zone, std::forward<Args>(args)...);\n      if constexpr (produces_printable_graph<Phase>::value) {\n        PrintGraph(temp_zone, Phase::phase_name());\n      }\n      return;\n    } else {\n      auto result = phase.Run(data_, temp_zone, std::forward<Args>(args)...);\n      if constexpr (produces_printable_graph<Phase>::value) {\n        PrintGraph(temp_zone, Phase::phase_name());\n      }\n      return result;\n    }\n    UNREACHABLE();\n  }\n\n  void PrintGraph(Zone* zone, const char* phase_name) {\n    CodeTracer* code_tracer = nullptr;\n    if (data_->info()->trace_turbo_graph()) {\n      // NOTE: We must not call `GetCodeTracer` if tracing is not enabled,\n      // because it may not yet be initialized then and doing so from the\n      // background thread is not threadsafe.\n      code_tracer = data_->GetCodeTracer();\n      DCHECK_NOT_NULL(code_tracer);\n    }\n    PrintTurboshaftGraph(data_, zone, code_tracer, phase_name);\n  }\n\n  void TraceSequence(const char* phase_name) {\n    if (info()->trace_turbo_json()) {\n      UnparkedScopeIfNeeded scope(data()->broker());\n      AllowHandleDereference allow_deref;\n      TurboJsonFile json_of(info(), std::ios_base::app);\n      json_of\n          << \"{\\\"name\\\":\\\"\" << phase_name << \"\\\",\\\"type\\\":\\\"sequence\\\"\"\n          << \",\\\"blocks\\\":\" << InstructionSequenceAsJSON{data()->sequence()}\n          << \",\\\"register_allocation\\\":{\"\n          << RegisterAllocationDataAsJSON{*(data()->register_allocation_data()),\n                                          *(data()->sequence())}\n          << \"}},\\n\";\n    }\n    if (info()->trace_turbo_graph()) {\n      UnparkedScopeIfNeeded scope(data()->broker());\n      AllowHandleDereference allow_deref;\n      CodeTracer::StreamScope tracing_scope(data()->GetCodeTracer());\n      tracing_scope.stream()\n          << \"----- Instruction sequence \" << phase_name << \" -----\\n\"\n          << *data()->sequence();\n    }\n  }\n\n  bool CreateGraphWithMaglev(Linkage* linkage) {\n    UnparkedScopeIfNeeded unparked_scope(data_->broker());\n\n    BeginPhaseKind(\"V8.TFGraphCreation\");\n    turboshaft::Tracing::Scope tracing_scope(data_->info());\n    std::optional<BailoutReason> bailout =\n        Run<turboshaft::MaglevGraphBuildingPhase>(linkage);\n    EndPhaseKind();\n\n    if (bailout.has_value()) {\n      data_->info()->AbortOptimization(bailout.value());\n      return false;\n    }\n\n    return true;\n  }\n\n  bool CreateGraphFromTurbofan(compiler::TFPipelineData* turbofan_data,\n                               Linkage* linkage) {\n    CHECK_IMPLIES(!v8_flags.disable_optimizing_compilers, v8_flags.turboshaft);\n\n    UnparkedScopeIfNeeded scope(data_->broker(),\n                                v8_flags.turboshaft_trace_reduction ||\n                                    v8_flags.turboshaft_trace_emitted);\n\n    turboshaft::Tracing::Scope tracing_scope(data_->info());\n\n    if (std::optional<BailoutReason> bailout =\n            Run<turboshaft::BuildGraphPhase>(turbofan_data, linkage)) {\n      info()->AbortOptimization(*bailout);\n      return false;\n    }\n\n    return true;\n  }\n\n  bool OptimizeTurboshaftGraph(Linkage* linkage) {\n    UnparkedScopeIfNeeded scope(data_->broker(),\n                                v8_flags.turboshaft_trace_reduction ||\n                                    v8_flags.turboshaft_trace_emitted);\n\n    turboshaft::Tracing::Scope tracing_scope(data_->info());\n\n    BeginPhaseKind(\"V8.TurboshaftOptimize\");\n\n#ifdef V8_ENABLE_WEBASSEMBLY\n    // TODO(dlehmann,353475584): Once the Wasm-in-JS TS inlining MVP is feature-\n    // complete and cleaned-up, move its reducer into the beginning of the\n    // `MachineLoweringPhase` since we can reuse the `DataViewLoweringReducer`\n    // there and avoid a separate phase.\n    if (v8_flags.turboshaft_wasm_in_js_inlining) {\n      Run<turboshaft::WasmInJSInliningPhase>();\n    }\n#endif  // !V8_ENABLE_WEBASSEMBLY\n\n    Run<turboshaft::MachineLoweringPhase>();\n\n    if (v8_flags.turboshaft_loop_unrolling) {\n      Run<turboshaft::LoopUnrollingPhase>();\n    }\n\n    if (v8_flags.turbo_store_elimination) {\n      Run<turboshaft::StoreStoreEliminationPhase>();\n    }\n\n    Run<turboshaft::OptimizePhase>();\n\n    if (v8_flags.turboshaft_typed_optimizations) {\n      Run<turboshaft::TypedOptimizationsPhase>();\n    }\n\n    if (v8_flags.turboshaft_assert_types) {\n      Run<turboshaft::TypeAssertionsPhase>();\n    }\n\n    // Perform dead code elimination, reduce stack checks, simplify loads on\n    // platforms where required, ...\n    Run<turboshaft::CodeEliminationAndSimplificationPhase>();\n\n#ifdef V8_ENABLE_DEBUG_CODE\n    if (V8_UNLIKELY(v8_flags.turboshaft_enable_debug_features)) {\n      // This phase has to run very late to allow all previous phases to use\n      // debug features.\n      Run<turboshaft::DebugFeatureLoweringPhase>();\n    }\n#endif  // V8_ENABLE_DEBUG_CODE\n\n    return true;\n  }\n\n  void RunSimplificationAndNormalizationPhase() {\n    Run<SimplificationAndNormalizationPhase>();\n  }\n\n  void PrepareForInstructionSelection(\n      const ProfileDataFromFile* profile = nullptr) {\n    if (V8_UNLIKELY(data()->pipeline_kind() == TurboshaftPipelineKind::kCSA ||\n                    data()->pipeline_kind() ==\n                        TurboshaftPipelineKind::kTSABuiltin)) {\n      if (profile) {\n        Run<ProfileApplicationPhase>(profile);\n      }\n\n      if (v8_flags.reorder_builtins &&\n          Builtins::IsBuiltinId(info()->builtin())) {\n        UnparkedScopeIfNeeded unparked_scope(data()->broker());\n        BasicBlockCallGraphProfiler::StoreCallGraph(info(), data()->graph());\n      }\n\n      if (v8_flags.turbo_profiling) {\n        UnparkedScopeIfNeeded unparked_scope(data()->broker());\n\n        // Basic block profiling disables concurrent compilation, so handle\n        // deref is fine.\n        AllowHandleDereference allow_handle_dereference;\n        const size_t block_count = data()->graph().block_count();\n        BasicBlockProfilerData* profiler_data =\n            BasicBlockProfiler::Get()->NewData(block_count);\n\n        // Set the function name.\n        profiler_data->SetFunctionName(info()->GetDebugName());\n        // Capture the schedule string before instrumentation.\n        if (v8_flags.turbo_profiling_verbose) {\n          std::ostringstream os;\n          os << data()->graph();\n          profiler_data->SetSchedule(os);\n        }\n\n        info()->set_profiler_data(profiler_data);\n\n        Run<BlockInstrumentationPhase>();\n      } else {\n        // We run an empty copying phase to make sure that we have the same\n        // control flow as when taking the profile.\n        ZoneWithName<kTempZoneName> temp_zone(data()->zone_stats(),\n                                              kTempZoneName);\n        CopyingPhase<>::Run(data(), temp_zone);\n      }\n    }\n\n    // DecompressionOptimization has to run as the last phase because it\n    // constructs an (slightly) invalid graph that mixes Tagged and Compressed\n    // representations.\n    Run<DecompressionOptimizationPhase>();\n\n    Run<SpecialRPOSchedulingPhase>();\n  }\n\n  [[nodiscard]] bool SelectInstructions(Linkage* linkage) {\n    auto call_descriptor = linkage->GetIncomingDescriptor();\n\n    // Depending on which code path led us to this function, the frame may or\n    // may not have been initialized. If it hasn't yet, initialize it now.\n    if (!data_->frame()) {\n      data_->InitializeFrameData(call_descriptor);\n    }\n\n    // Select and schedule instructions covering the scheduled graph.\n    CodeTracer* code_tracer = nullptr;\n    if (info()->trace_turbo_graph()) {\n      // NOTE: We must not call `GetCodeTracer` if tracing is not enabled,\n      // because it may not yet be initialized then and doing so from the\n      // background thread is not threadsafe.\n      code_tracer = data_->GetCodeTracer();\n    }\n\n    if (std::optional<BailoutReason> bailout = Run<InstructionSelectionPhase>(\n            call_descriptor, linkage, code_tracer)) {\n      data_->info()->AbortOptimization(*bailout);\n      EndPhaseKind();\n      return false;\n    }\n\n    return true;\n\n    // TODO(nicohartmann@): We might need to provide this.\n    // if (info()->trace_turbo_json()) {\n    //   UnparkedScopeIfNeeded scope(turbofan_data->broker());\n    //   AllowHandleDereference allow_deref;\n    //   TurboCfgFile tcf(isolate());\n    //   tcf << AsC1V(\"CodeGen\", turbofan_data->schedule(),\n    //                turbofan_data->source_positions(),\n    //                turbofan_data->sequence());\n\n    //   std::ostringstream source_position_output;\n    //   // Output source position information before the graph is deleted.\n    //   if (data_->source_positions() != nullptr) {\n    //     data_->source_positions()->PrintJson(source_position_output);\n    //   } else {\n    //     source_position_output << \"{}\";\n    //   }\n    //   source_position_output << \",\\n\\\"nodeOrigins\\\" : \";\n    //   data_->node_origins()->PrintJson(source_position_output);\n    //   data_->set_source_position_output(source_position_output.str());\n    // }\n  }\n\n  bool AllocateRegisters(CallDescriptor* call_descriptor) {\n    BeginPhaseKind(\"V8.TFRegisterAllocation\");\n\n    bool run_verifier = v8_flags.turbo_verify_allocation;\n\n    // Allocate registers.\n    const RegisterConfiguration* config = RegisterConfiguration::Default();\n    std::unique_ptr<const RegisterConfiguration> restricted_config;\n    if (call_descriptor->HasRestrictedAllocatableRegisters()) {\n      RegList registers = call_descriptor->AllocatableRegisters();\n      DCHECK_LT(0, registers.Count());\n      restricted_config.reset(\n          RegisterConfiguration::RestrictGeneralRegisters(registers));\n      config = restricted_config.get();\n    }\n    AllocateRegisters(config, call_descriptor, run_verifier);\n\n    // Verify the instruction sequence has the same hash in two stages.\n    VerifyGeneratedCodeIsIdempotent();\n\n    Run<FrameElisionPhase>();\n\n    // TODO(mtrofin): move this off to the register allocator.\n    bool generate_frame_at_start =\n        data_->sequence()->instruction_blocks().front()->must_construct_frame();\n    // Optimimize jumps.\n    if (v8_flags.turbo_jt) {\n      Run<JumpThreadingPhase>(generate_frame_at_start);\n    }\n\n    EndPhaseKind();\n\n    return true;\n  }\n\n  bool MayHaveUnverifiableGraph() const {\n    // TODO(nicohartmann): Are there any graph which are still verifiable?\n    return true;\n  }\n\n  void VerifyGeneratedCodeIsIdempotent() {\n    JumpOptimizationInfo* jump_opt = data()->jump_optimization_info();\n    if (jump_opt == nullptr) return;\n\n    InstructionSequence* code = data()->sequence();\n    int instruction_blocks = code->InstructionBlockCount();\n    int virtual_registers = code->VirtualRegisterCount();\n    size_t hash_code =\n        base::hash_combine(instruction_blocks, virtual_registers);\n    for (Instruction* instr : *code) {\n      hash_code = base::hash_combine(hash_code, instr->opcode(),\n                                     instr->InputCount(), instr->OutputCount());\n    }\n    for (int i = 0; i < virtual_registers; i++) {\n      hash_code = base::hash_combine(hash_code, code->GetRepresentation(i));\n    }\n    if (jump_opt->is_collecting()) {\n      jump_opt->hash_code = hash_code;\n    } else {\n      CHECK_EQ(hash_code, jump_opt->hash_code);\n    }\n  }\n\n  void AllocateRegisters(const RegisterConfiguration* config,\n                         CallDescriptor* call_descriptor, bool run_verifier);\n\n  void AssembleCode(Linkage* linkage) {\n    BeginPhaseKind(\"V8.TFCodeGeneration\");\n    data()->InitializeCodeGenerator(linkage);\n\n    UnparkedScopeIfNeeded unparked_scope(data()->broker());\n\n    Run<AssembleCodePhase>();\n    if (info()->trace_turbo_json()) {\n      TurboJsonFile json_of(info(), std::ios_base::app);\n      json_of\n          << \"{\\\"name\\\":\\\"code generation\\\"\" << \", \\\"type\\\":\\\"instructions\\\"\"\n          << InstructionStartsAsJSON{&data()->code_generator()->instr_starts()}\n          << TurbolizerCodeOffsetsInfoAsJSON{\n                 &data()->code_generator()->offsets_info()};\n      json_of << \"},\\n\";\n    }\n\n    data()->ClearInstructionComponent();\n    EndPhaseKind();\n  }\n\n  MaybeHandle<Code> GenerateCode(CallDescriptor* call_descriptor) {\n    Linkage linkage(call_descriptor);\n    PrepareForInstructionSelection();\n    if (!SelectInstructions(&linkage)) {\n      return MaybeHandle<Code>();\n    }\n    AllocateRegisters(linkage.GetIncomingDescriptor());\n    AssembleCode(&linkage);\n    return FinalizeCode();\n  }\n\n  [[nodiscard]] bool GenerateCode(\n      Linkage* linkage, std::shared_ptr<OsrHelper> osr_helper = {},\n      JumpOptimizationInfo* jump_optimization_info = nullptr,\n      const ProfileDataFromFile* profile = nullptr, int initial_graph_hash = 0);\n\n  OptimizedCompilationInfo* info() { return data_->info(); }\n\n  MaybeIndirectHandle<Code> FinalizeCode(bool retire_broker = true) {\n    BeginPhaseKind(\"V8.TFFinalizeCode\");\n    if (data_->broker() && retire_broker) {\n      data_->broker()->Retire();\n    }\n    Run<FinalizeCodePhase>();\n\n    MaybeIndirectHandle<Code> maybe_code = data_->code();\n    IndirectHandle<Code> code;\n    if (!maybe_code.ToHandle(&code)) {\n      return maybe_code;\n    }\n\n    data_->info()->SetCode(code);\n    PrintCode(data_->isolate(), code, data_->info());\n\n    // Functions with many inline candidates are sensitive to correct call\n    // frequency feedback and should therefore not be tiered up early.\n    if (v8_flags.profile_guided_optimization &&\n        info()->could_not_inline_all_candidates() &&\n        info()->shared_info()->cached_tiering_decision() !=\n            CachedTieringDecision::kDelayMaglev) {\n      info()->shared_info()->set_cached_tiering_decision(\n          CachedTieringDecision::kNormal);\n    }\n\n    if (info()->trace_turbo_json()) {\n      TurboJsonFile json_of(info(), std::ios_base::app);\n\n      json_of << \"{\\\"name\\\":\\\"disassembly\\\",\\\"type\\\":\\\"disassembly\\\"\"\n              << BlockStartsAsJSON{&data_->code_generator()->block_starts()}\n              << \"\\\"data\\\":\\\"\";\n#ifdef ENABLE_DISASSEMBLER\n      std::stringstream disassembly_stream;\n      code->Disassemble(nullptr, disassembly_stream, data_->isolate());\n      std::string disassembly_string(disassembly_stream.str());\n      for (const auto& c : disassembly_string) {\n        json_of << AsEscapedUC16ForJSON(c);\n      }\n#endif  // ENABLE_DISASSEMBLER\n      json_of << \"\\\"}\\n],\\n\";\n      json_of << \"\\\"nodePositions\\\":\";\n      // TODO(nicohartmann): We should try to always provide source positions.\n      json_of << (data_->source_position_output().empty()\n                      ? \"{}\"\n                      : data_->source_position_output())\n              << \",\\n\";\n      JsonPrintAllSourceWithPositions(json_of, data_->info(), data_->isolate());\n      if (info()->has_bytecode_array()) {\n        json_of << \",\\n\";\n        JsonPrintAllBytecodeSources(json_of, info());\n      }\n      json_of << \"\\n}\";\n    }\n    if (info()->trace_turbo_json() || info()->trace_turbo_graph()) {\n      CodeTracer::StreamScope tracing_scope(data_->GetCodeTracer());\n      tracing_scope.stream()\n          << \"---------------------------------------------------\\n\"\n          << \"Finished compiling method \" << info()->GetDebugName().get()\n          << \" using TurboFan\" << std::endl;\n    }\n    EndPhaseKind();\n    return code;\n  }\n\n  bool CommitDependencies(Handle<Code> code) {\n    return data_->depedencies() == nullptr ||\n           data_->depedencies()->Commit(code);\n  }\n\n private:\n#ifdef DEBUG\n  virtual bool IsBuiltinPipeline() const { return false; }\n#endif\n\n  PipelineData* data_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BuiltinPipeline\",\n                \"extends\": \"Pipeline\",\n                \"implements\": [],\n                \"about\": \"Specialized pipeline for compiling builtin functions.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Pipeline\",\n                    \"PipelineData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass BuiltinPipeline : public Pipeline {\n public:\n  explicit BuiltinPipeline(PipelineData* data) : Pipeline(data) {}\n\n  void OptimizeBuiltin();\n\n#ifdef DEBUG\n  bool IsBuiltinPipeline() const override { return true; }\n#endif\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Run\",\n                \"parent\": \"Pipeline\",\n                \"about\": \"Runs a Turboshaft phase.\",\n                \"logic\": \"This is a template method that takes a TurboshaftPhase and any number of arguments. It sets up the necessary scopes (phase scope, zone scope, node origin scope, and runtime call timer scope) and then runs the phase. If the phase produces a printable graph, it prints the graph.  Uses SFINAE to determine whether the phase returns a value or not and acts accordingly.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"args\",\n                        \"type\": \"Args&&...\",\n                        \"purpose\": \"Arguments to pass to the phase's Run method\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"auto\",\n                    \"description\": \"Returns the result of the phase's Run method if it returns a value, otherwise returns nothing.\"\n                },\n                \"dependencies\": [\n                    \"TurboshaftPhase\",\n                    \"PhaseScope\",\n                    \"ZoneWithName\",\n                    \"NodeOriginTable\",\n                    \"RuntimeCallTimerScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  template <TurboshaftPhase Phase, typename... Args>\n  auto Run(Args&&... args) {\n    // Setup run scope.\n    PhaseScope phase_scope(data_->pipeline_statistics(), Phase::phase_name());\n    ZoneWithName<Phase::kPhaseName> temp_zone(data_->zone_stats(),\n                                              Phase::phase_name());\n    NodeOriginTable::PhaseScope origin_scope(data_->node_origins(),\n                                             Phase::phase_name());\n#ifdef V8_RUNTIME_CALL_STATS\n    RuntimeCallTimerScope runtime_call_timer_scope(data_->runtime_call_stats(),\n                                                   Phase::kRuntimeCallCounterId,\n                                                   Phase::kCounterMode);\n#endif\n\n    Phase phase;\n    using result_t =\n        decltype(phase.Run(data_, temp_zone, std::forward<Args>(args)...));\n    if constexpr (std::is_same_v<result_t, void>) {\n      phase.Run(data_, temp_zone, std::forward<Args>(args)...);\n      if constexpr (produces_printable_graph<Phase>::value) {\n        PrintGraph(temp_zone, Phase::phase_name());\n      }\n      return;\n    } else {\n      auto result = phase.Run(data_, temp_zone, std::forward<Args>(args)...);\n      if constexpr (produces_printable_graph<Phase>::value) {\n        PrintGraph(temp_zone, Phase::phase_name());\n      }\n      return result;\n    }\n    UNREACHABLE();\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PrintGraph\",\n                \"parent\": \"Pipeline\",\n                \"about\": \"Prints the Turboshaft graph for debugging purposes.\",\n                \"logic\": \"Checks if graph tracing is enabled. If so, retrieves the CodeTracer and calls PrintTurboshaftGraph to print the graph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone to allocate temporary objects in.\"\n                    },\n                    {\n                        \"name\": \"phase_name\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The name of the phase.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CodeTracer\",\n                    \"PrintTurboshaftGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void PrintGraph(Zone* zone, const char* phase_name) {\n    CodeTracer* code_tracer = nullptr;\n    if (data_->info()->trace_turbo_graph()) {\n      // NOTE: We must not call `GetCodeTracer` if tracing is not enabled,\n      // because it may not yet be initialized then and doing so from the\n      // background thread is not threadsafe.\n      code_tracer = data_->GetCodeTracer();\n      DCHECK_NOT_NULL(code_tracer);\n    }\n    PrintTurboshaftGraph(data_, zone, code_tracer, phase_name);\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TraceSequence\",\n                \"parent\": \"Pipeline\",\n                \"about\": \"Traces the instruction sequence in JSON and text formats.\",\n                \"logic\": \"If JSON tracing is enabled, outputs the instruction sequence and register allocation data in JSON format. If graph tracing is enabled, outputs the instruction sequence in text format.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"phase_name\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The name of the phase.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"UnparkedScopeIfNeeded\",\n                    \"AllowHandleDereference\",\n                    \"TurboJsonFile\",\n                    \"InstructionSequenceAsJSON\",\n                    \"RegisterAllocationDataAsJSON\",\n                    \"CodeTracer\",\n                    \"CodeTracer::StreamScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void TraceSequence(const char* phase_name) {\n    if (info()->trace_turbo_json()) {\n      UnparkedScopeIfNeeded scope(data()->broker());\n      AllowHandleDereference allow_deref;\n      TurboJsonFile json_of(info(), std::ios_base::app);\n      json_of\n          << \"{\\\"name\\\":\\\"\" << phase_name << \"\\\",\\\"type\\\":\\\"sequence\\\"\"\n          << \",\\\"blocks\\\":\" << InstructionSequenceAsJSON{data()->sequence()}\n          << \",\\\"register_allocation\\\":{\"\n          << RegisterAllocationDataAsJSON{*(data()->register_allocation_data()),\n                                          *(data()->sequence())}\n          << \"}},\\n\";\n    }\n    if (info()->trace_turbo_graph()) {\n      UnparkedScopeIfNeeded scope(data()->broker());\n      AllowHandleDereference allow_deref;\n      CodeTracer::StreamScope tracing_scope(data()->GetCodeTracer());\n      tracing_scope.stream()\n          << \"----- Instruction sequence \" << phase_name << \" -----\\n\"\n          << *data()->sequence();\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CreateGraphWithMaglev\",\n                \"parent\": \"Pipeline\",\n                \"about\": \"Creates a Turboshaft graph from the Maglev graph builder.\",\n                \"logic\": \"Runs the MaglevGraphBuildingPhase and returns whether the graph creation was successful.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"linkage\",\n                        \"type\": \"Linkage*\",\n                        \"purpose\": \"The linkage object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if graph creation was successful, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"UnparkedScopeIfNeeded\",\n                    \"Tracing\",\n                    \"MaglevGraphBuildingPhase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  bool CreateGraphWithMaglev(Linkage* linkage) {\n    UnparkedScopeIfNeeded unparked_scope(data_->broker());\n\n    BeginPhaseKind(\"V8.TFGraphCreation\");\n    turboshaft::Tracing::Scope tracing_scope(data_->info());\n    std::optional<BailoutReason> bailout =\n        Run<turboshaft::MaglevGraphBuildingPhase>(linkage);\n    EndPhaseKind();\n\n    if (bailout.has_value()) {\n      data_->info()->AbortOptimization(bailout.value());\n      return false;\n    }\n\n    return true;\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CreateGraphFromTurbofan\",\n                \"parent\": \"Pipeline\",\n                \"about\": \"Creates a Turboshaft graph from a Turbofan graph.\",\n                \"logic\": \"Runs the BuildGraphPhase and returns whether the graph creation was successful.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"turbofan_data\",\n                        \"type\": \"compiler::TFPipelineData*\",\n                        \"purpose\": \"The Turbofan pipeline data.\"\n                    },\n                    {\n                        \"name\": \"linkage\",\n                        \"type\": \"Linkage*\",\n                        \"purpose\": \"The linkage object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if graph creation was successful, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"UnparkedScopeIfNeeded\",\n                    \"Tracing\",\n                    \"BuildGraphPhase\",\n                    \"compiler::TFPipelineData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  bool CreateGraphFromTurbofan(compiler::TFPipelineData* turbofan_data,\n                               Linkage* linkage) {\n    CHECK_IMPLIES(!v8_flags.disable_optimizing_compilers, v8_flags.turboshaft);\n\n    UnparkedScopeIfNeeded scope(data_->broker(),\n                                v8_flags.turboshaft_trace_reduction ||\n                                    v8_flags.turboshaft_trace_emitted);\n\n    turboshaft::Tracing::Scope tracing_scope(data_->info());\n\n    if (std::optional<BailoutReason> bailout =\n            Run<turboshaft::BuildGraphPhase>(turbofan_data, linkage)) {\n      info()->AbortOptimization(*bailout);\n      return false;\n    }\n\n    return true;\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \""
}