{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/translated-state.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/translated-state.h\",\n            \"file_name\": \"translated-state.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines classes for translating the state of an optimized frame during deoptimization, allowing inspection and modification of frame values.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary standard library headers for optional values, stacks, and vectors.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n#include <stack>\n#include <vector>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes V8-specific headers for SIMD, frame translation, objects, and utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/common/simd128.h\"\n#include \"src/deoptimizer/frame-translation-builder.h\"\n#include \"src/objects/deoptimization-data.h\"\n#include \"src/objects/feedback-vector.h\"\n#include \"src/objects/heap-object.h\"\n#include \"src/objects/shared-function-info.h\"\n#include \"src/utils/boxed-float.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes WebAssembly-specific headers when WebAssembly is enabled.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/value-type.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TranslatedValue\",\n                \"about\": \"Represents a translated value from the optimized frame, handling various data types and materialization states.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind_\",\n                        \"type\": \"Kind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Specifies the type of the translated value.\"\n                    },\n                    {\n                        \"name\": \"materialization_state_\",\n                        \"type\": \"MaterializationState\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the materialization state of the object.\"\n                    },\n                    {\n                        \"name\": \"container_\",\n                        \"type\": \"TranslatedState*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the container TranslatedState.\"\n                    },\n                    {\n                        \"name\": \"storage_\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the materialized value or byte-array.\"\n                    },\n                    {\n                        \"name\": \"raw_literal_\",\n                        \"type\": \"Tagged<Object>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the raw literal value (for tagged objects).\"\n                    },\n                    {\n                        \"name\": \"uint32_value_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the uint32 value.\"\n                    },\n                    {\n                        \"name\": \"int32_value_\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the int32 value.\"\n                    },\n                    {\n                        \"name\": \"uint64_value_\",\n                        \"type\": \"uint64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the uint64 value.\"\n                    },\n                    {\n                        \"name\": \"int64_value_\",\n                        \"type\": \"int64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the int64 value.\"\n                    },\n                    {\n                        \"name\": \"float_value_\",\n                        \"type\": \"Float32\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the float value.\"\n                    },\n                    {\n                        \"name\": \"double_value_\",\n                        \"type\": \"Float64\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the double value.\"\n                    },\n                    {\n                        \"name\": \"materialization_info_\",\n                        \"type\": \"MaterializedObjectInfo\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores materialization information (id and length).\"\n                    },\n                    {\n                        \"name\": \"simd128_value_\",\n                        \"type\": \"Simd128\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the SIMD128 value.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TranslatedState\",\n                    \"Deoptimizer\",\n                    \"DeoptimizationLiteralProvider\",\n                    \"Object\",\n                    \"HeapObject\",\n                    \"Float32\",\n                    \"Float64\",\n                    \"Simd128\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass TranslatedValue {\n public:\n  // Allocation-free getter of the value.\n  // Returns ReadOnlyRoots::arguments_marker() if allocation would be necessary\n  // to get the value. In the case of numbers, returns a Smi if possible.\n  Tagged<Object> GetRawValue() const;\n\n  // Convenience wrapper around GetRawValue (checked).\n  int GetSmiValue() const;\n\n  // Returns the value, possibly materializing it first (and the whole subgraph\n  // reachable from this value). In the case of numbers, returns a Smi if\n  // possible.\n  Handle<Object> GetValue();\n\n  bool IsMaterializedObject() const;\n  bool IsMaterializableByDebugger() const;\n\n private:\n  friend class TranslatedState;\n  friend class TranslatedFrame;\n  friend class Deoptimizer;\n  friend class DeoptimizationLiteralProvider;\n\n  enum Kind : uint8_t {\n    kInvalid,\n    kTagged,\n    kInt32,\n    kInt64,\n    kInt64ToBigInt,\n    kUint64ToBigInt,\n    kUint32,\n    kUint64,\n    kBoolBit,\n    kFloat,\n    kDouble,\n    kHoleyDouble,\n    kSimd128,\n    kCapturedObject,    // Object captured by the escape analysis.\n                        // The number of nested objects can be obtained\n                        // with the DeferredObjectLength() method\n                        // (the values of the nested objects follow\n                        // this value in the depth-first order.)\n    kDuplicatedObject,  // Duplicated object of a deferred object.\n    kCapturedStringConcat\n  };\n\n  enum MaterializationState : uint8_t {\n    kUninitialized,\n    kAllocated,  // Storage for the object has been allocated (or\n                 // enqueued for allocation).\n    kFinished,   // The object has been initialized (or enqueued for\n                 // initialization).\n  };\n\n  TranslatedValue(TranslatedState* container, Kind kind)\n      : kind_(kind), container_(container) {}\n  Kind kind() const { return kind_; }\n  MaterializationState materialization_state() const {\n    return materialization_state_;\n  }\n  void Handlify();\n  int GetChildrenCount() const;\n\n  static TranslatedValue NewDeferredObject(TranslatedState* container,\n                                           int length, int object_index);\n  static TranslatedValue NewDuplicateObject(TranslatedState* container, int id);\n  static TranslatedValue NewStringConcat(TranslatedState* container, int id);\n  static TranslatedValue NewFloat(TranslatedState* container, Float32 value);\n  static TranslatedValue NewDouble(TranslatedState* container, Float64 value);\n  static TranslatedValue NewHoleyDouble(TranslatedState* container,\n                                        Float64 value);\n  static TranslatedValue NewSimd128(TranslatedState* container, Simd128 value);\n  static TranslatedValue NewInt32(TranslatedState* container, int32_t value);\n  static TranslatedValue NewInt64(TranslatedState* container, int64_t value);\n  static TranslatedValue NewInt64ToBigInt(TranslatedState* container,\n                                          int64_t value);\n  static TranslatedValue NewUint64ToBigInt(TranslatedState* container,\n                                           uint64_t value);\n  static TranslatedValue NewUint32(TranslatedState* container, uint32_t value);\n  static TranslatedValue NewUint64(TranslatedState* container, uint64_t value);\n  static TranslatedValue NewBool(TranslatedState* container, uint32_t value);\n  static TranslatedValue NewTagged(TranslatedState* container,\n                                   Tagged<Object> literal);\n  static TranslatedValue NewInvalid(TranslatedState* container);\n\n  Isolate* isolate() const;\n\n  void set_storage(Handle<HeapObject> storage) { storage_ = storage; }\n  void set_initialized_storage(Handle<HeapObject> storage);\n  void mark_finished() { materialization_state_ = kFinished; }\n  void mark_allocated() { materialization_state_ = kAllocated; }\n\n  Handle<HeapObject> storage() {\n    DCHECK_NE(materialization_state(), kUninitialized);\n    return storage_;\n  }\n\n  void ReplaceElementsArrayWithCopy();\n\n  Kind kind_;\n  MaterializationState materialization_state_ = kUninitialized;\n  TranslatedState* container_;  // This is only needed for materialization of\n                                // objects and constructing handles (to get\n                                // to the isolate).\n\n  Handle<HeapObject> storage_;  // Contains the materialized value or the\n                                // byte-array that will be later morphed into\n                                // the materialized object.\n\n  struct MaterializedObjectInfo {\n    int id_;\n    int length_;  // Applies only to kCapturedObject kinds.\n  };\n\n  union {\n    // kind kTagged. After handlification it is always nullptr.\n    Tagged<Object> raw_literal_;\n    // kind is kUInt32 or kBoolBit.\n    uint32_t uint32_value_;\n    // kind is kInt32.\n    int32_t int32_value_;\n    // kind is kUint64ToBigInt.\n    uint64_t uint64_value_;\n    // kind is kInt64 or kInt64ToBigInt.\n    int64_t int64_value_;\n    // kind is kFloat\n    Float32 float_value_;\n    // kind is kDouble or kHoleyDouble\n    Float64 double_value_;\n    // kind is kDuplicatedObject or kCapturedObject.\n    MaterializedObjectInfo materialization_info_;\n    // kind is kSimd128.\n    Simd128 simd128_value_;\n  };\n\n  // Checked accessors for the union members.\n  Tagged<Object> raw_literal() const;\n  int32_t int32_value() const;\n  int64_t int64_value() const;\n  uint32_t uint32_value() const;\n  uint64_t uint64_value() const;\n  Float32 float_value() const;\n  Float64 double_value() const;\n  Simd128 simd_value() const;\n  int object_length() const;\n  int object_index() const;\n  // TODO(dmercadier): use object_index instead of string_concat_index.\n  int string_concat_index() const;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TranslatedFrame\",\n                \"about\": \"Represents a single translated frame in the deoptimized stack, containing information about the function, bytecode offset, and translated values.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind_\",\n                        \"type\": \"Kind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Specifies the kind of the translated frame (e.g., unoptimized function, builtin continuation).\"\n                    },\n                    {\n                        \"name\": \"bytecode_offset_\",\n                        \"type\": \"BytecodeOffset\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The bytecode offset within the function.\"\n                    },\n                    {\n                        \"name\": \"raw_shared_info_\",\n                        \"type\": \"Tagged<SharedFunctionInfo>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Raw pointer to the SharedFunctionInfo object (before handlification).\"\n                    },\n                    {\n                        \"name\": \"shared_info_\",\n                        \"type\": \"IndirectHandle<SharedFunctionInfo>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the SharedFunctionInfo object (after handlification).\"\n                    },\n                    {\n                        \"name\": \"raw_bytecode_array_\",\n                        \"type\": \"Tagged<BytecodeArray>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Raw pointer to the BytecodeArray object (before handlification).\"\n                    },\n                    {\n                        \"name\": \"bytecode_array_\",\n                        \"type\": \"IndirectHandle<BytecodeArray>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the BytecodeArray object (after handlification).\"\n                    },\n                    {\n                        \"name\": \"height_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stack frame height related value.\"\n                    },\n                    {\n                        \"name\": \"return_value_offset_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Offset to the return value.\"\n                    },\n                    {\n                        \"name\": \"return_value_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of return values.\"\n                    },\n                    {\n                        \"name\": \"formal_parameter_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of formal parameters. Only valid for kInlinedExtraArguments kind.\"\n                    },\n                    {\n                        \"name\": \"handle_state_\",\n                        \"type\": \"HandleState\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether object references are raw pointers or handles.\"\n                    },\n                    {\n                        \"name\": \"values_\",\n                        \"type\": \"ValuesContainer\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Container for the TranslatedValue objects.\"\n                    },\n                    {\n                        \"name\": \"return_kind_\",\n                        \"type\": \"std::optional<wasm::ValueKind>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Return kind for Wasm function (only for kJSToWasmBuiltinContinuation).\"\n                    },\n                    {\n                        \"name\": \"wasm_function_index_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Index of the Wasm function (only for kLiftoffFunction).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TranslatedState\",\n                    \"Deoptimizer\",\n                    \"BytecodeOffset\",\n                    \"SharedFunctionInfo\",\n                    \"BytecodeArray\",\n                    \"TranslatedValue\",\n                    \"wasm::ValueKind\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass TranslatedFrame {\n public:\n  enum Kind {\n    kUnoptimizedFunction,\n    kInlinedExtraArguments,\n    kConstructCreateStub,\n    kConstructInvokeStub,\n    kBuiltinContinuation,\n#if V8_ENABLE_WEBASSEMBLY\n    kWasmInlinedIntoJS,\n    kJSToWasmBuiltinContinuation,\n    kLiftoffFunction,\n#endif  // V8_ENABLE_WEBASSEMBLY\n    kJavaScriptBuiltinContinuation,\n    kJavaScriptBuiltinContinuationWithCatch,\n    kInvalid\n  };\n\n  int GetValueCount() const;\n\n  Kind kind() const { return kind_; }\n  BytecodeOffset bytecode_offset() const { return bytecode_offset_; }\n  DirectHandle<SharedFunctionInfo> shared_info() const {\n    CHECK_EQ(handle_state_, kHandles);\n    return shared_info_;\n  }\n  DirectHandle<BytecodeArray> bytecode_array() const {\n    CHECK_EQ(handle_state_, kHandles);\n    return bytecode_array_;\n  }\n\n  // TODO(jgruber): Simplify/clarify the semantics of this field. The name\n  // `height` is slightly misleading. Yes, this value is related to stack frame\n  // height, but must undergo additional mutations to arrive at the real stack\n  // frame height (e.g.: addition/subtraction of context, accumulator, fixed\n  // frame sizes, padding).\n  uint32_t height() const { return height_; }\n\n  int return_value_offset() const { return return_value_offset_; }\n  int return_value_count() const { return return_value_count_; }\n  int formal_parameter_count() const {\n    DCHECK_EQ(kind(), kInlinedExtraArguments);\n    return formal_parameter_count_;\n  }\n\n  Tagged<SharedFunctionInfo> raw_shared_info() const {\n    CHECK_EQ(handle_state_, kRawPointers);\n    CHECK(!raw_shared_info_.is_null());\n    return raw_shared_info_;\n  }\n\n  Tagged<BytecodeArray> raw_bytecode_array() const {\n    CHECK_EQ(handle_state_, kRawPointers);\n    CHECK(!raw_bytecode_array_.is_null());\n    return raw_bytecode_array_;\n  }\n\n  class iterator {\n   public:\n    iterator& operator++() {\n      ++input_index_;\n      AdvanceIterator(&position_);\n      return *this;\n    }\n\n    iterator operator++(int) {\n      iterator original(position_, input_index_);\n      ++input_index_;\n      AdvanceIterator(&position_);\n      return original;\n    }\n\n    bool operator==(const iterator& other) const {\n      // Ignore {input_index_} for equality.\n      return position_ == other.position_;\n    }\n    bool operator!=(const iterator& other) const { return !(*this == other); }\n\n    TranslatedValue& operator*() { return (*position_); }\n    TranslatedValue* operator->() { return &(*position_); }\n    const TranslatedValue& operator*() const { return (*position_); }\n    const TranslatedValue* operator->() const { return &(*position_); }\n\n    int input_index() const { return input_index_; }\n\n   private:\n    friend TranslatedFrame;\n\n    explicit iterator(std::deque<TranslatedValue>::iterator position,\n                      int input_index = 0)\n        : position_(position), input_index_(input_index) {}\n\n    std::deque<TranslatedValue>::iterator position_;\n    int input_index_;\n  };\n\n  using reference = TranslatedValue&;\n  using const_reference = TranslatedValue const&;\n\n  iterator begin() { return iterator(values_.begin()); }\n  iterator end() { return iterator(values_.end()); }\n\n  reference front() { return values_.front(); }\n  const_reference front() const { return values_.front(); }\n\n#if V8_ENABLE_WEBASSEMBLY\n  // Only for Kind == kJSToWasmBuiltinContinuation\n  std::optional<wasm::ValueKind> wasm_call_return_kind() const {\n    DCHECK_EQ(kind(), kJSToWasmBuiltinContinuation);\n    return return_kind_;\n  }\n\n  int wasm_function_index() const {\n    DCHECK_EQ(kind(), kLiftoffFunction);\n    return wasm_function_index_;\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n private:\n  friend class TranslatedState;\n  friend class Deoptimizer;\n\n  // Constructor static methods.\n  static TranslatedFrame UnoptimizedJSFrame(\n      BytecodeOffset bytecode_offset, Tagged<SharedFunctionInfo> shared_info,\n      Tagged<BytecodeArray> bytecode_array, uint32_t height,\n      int return_value_offset, int return_value_count);\n  static TranslatedFrame AccessorFrame(Kind kind,\n                                       Tagged<SharedFunctionInfo> shared_info);\n  static TranslatedFrame InlinedExtraArguments(\n      Tagged<SharedFunctionInfo> shared_info, uint32_t height,\n      uint32_t formal_parameter_count);\n  static TranslatedFrame ConstructCreateStubFrame(\n      Tagged<SharedFunctionInfo> shared_info, uint32_t height);\n  static TranslatedFrame ConstructInvokeStubFrame(\n      Tagged<SharedFunctionInfo> shared_info);\n  static TranslatedFrame BuiltinContinuationFrame(\n      BytecodeOffset bailout_id, Tagged<SharedFunctionInfo> shared_info,\n      uint32_t height);\n#if V8_ENABLE_WEBASSEMBLY\n  static TranslatedFrame WasmInlinedIntoJSFrame(\n      BytecodeOffset bailout_id, Tagged<SharedFunctionInfo> shared_info,\n      uint32_t height);\n  static TranslatedFrame JSToWasmBuiltinContinuationFrame(\n      BytecodeOffset bailout_id, Tagged<SharedFunctionInfo> shared_info,\n      uint32_t height, std::optional<wasm::ValueKind> return_type);\n  static TranslatedFrame LiftoffFrame(BytecodeOffset bailout_id,\n                                      uint32_t height, uint32_t function_index);\n#endif  // V8_ENABLE_WEBASSEMBLY\n  static TranslatedFrame JavaScriptBuiltinContinuationFrame(\n      BytecodeOffset bailout_id, Tagged<SharedFunctionInfo> shared_info,\n      uint32_t height);\n  static TranslatedFrame JavaScriptBuiltinContinuationWithCatchFrame(\n      BytecodeOffset bailout_id, Tagged<SharedFunctionInfo> shared_info,\n      uint32_t height);\n  static TranslatedFrame InvalidFrame() {\n    return TranslatedFrame(kInvalid, {}, {}, 0);\n  }\n\n  static void AdvanceIterator(std::deque<TranslatedValue>::iterator* iter);\n\n  explicit TranslatedFrame(Kind kind,\n                           Tagged<SharedFunctionInfo> raw_shared_info,\n                           Tagged<BytecodeArray> raw_bytecode_array,\n                           uint32_t height, int return_value_offset = 0,\n                           int return_value_count = 0)\n      : kind_(kind),\n        raw_shared_info_(raw_shared_info),\n        raw_bytecode_array_(raw_bytecode_array),\n        height_(height),\n        return_value_offset_(return_value_offset),\n        return_value_count_(return_value_count),\n        handle_state_(kRawPointers) {}\n\n  void Add(const TranslatedValue& value) { values_.push_back(value); }\n  TranslatedValue* ValueAt(int index) { return &(values_[index]); }\n  void Handlify(Isolate* isolate);\n\n  Kind kind_;\n  BytecodeOffset bytecode_offset_ = BytecodeOffset::None();\n\n  // Object references are stored as either raw pointers (before Handlify is\n  // called) or handles (afterward).\n  union {\n    Tagged<SharedFunctionInfo> raw_shared_info_;\n    IndirectHandle<SharedFunctionInfo> shared_info_;\n  };\n  union {\n    Tagged<BytecodeArray> raw_bytecode_array_;\n    IndirectHandle<BytecodeArray> bytecode_array_;\n  };\n\n  uint32_t height_;\n  int return_value_offset_;\n  int return_value_count_;\n  int formal_parameter_count_ = -1;\n\n  enum HandleState { kRawPointers, kHandles } handle_state_;\n\n  using ValuesContainer = std::deque<TranslatedValue>;\n\n  ValuesContainer values_;\n\n#if V8_ENABLE_WEBASSEMBLY\n  // Only for Kind == kJSToWasmBuiltinContinuation\n  std::optional<wasm::ValueKind> return_kind_;\n  // Only for Kind == kLiftOffFunction\n  int wasm_function_index_ = -1;\n#endif  // V8_ENABLE_WEBASSEMBLY\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DeoptimizationLiteralProvider\",\n                \"about\": \"Provides access to deoptimization literals, either from an on-heap array or an off-heap vector.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"literals_on_heap_\",\n                        \"type\": \"Tagged<DeoptimizationLiteralArray>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The deoptimization literals stored on the heap.\"\n                    },\n                    {\n                        \"name\": \"literals_off_heap_\",\n                        \"type\": \"std::vector<DeoptimizationLiteral>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The deoptimization literals stored off the heap.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TranslatedState\",\n                    \"DeoptimizationLiteral\",\n                    \"DeoptimizationLiteralArray\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass DeoptimizationLiteralProvider {\n public:\n  explicit DeoptimizationLiteralProvider(\n      Tagged<DeoptimizationLiteralArray> literal_array);\n\n  explicit DeoptimizationLiteralProvider(\n      std::vector<DeoptimizationLiteral> literals);\n\n  ~DeoptimizationLiteralProvider();\n  // Prevent expensive copying.\n  DeoptimizationLiteralProvider(const DeoptimizationLiteralProvider&) = delete;\n  void operator=(const DeoptimizationLiteralProvider&) = delete;\n\n  TranslatedValue Get(TranslatedState* container, int literal_index) const;\n\n  Tagged<DeoptimizationLiteralArray> get_on_heap_literals() const {\n    DCHECK(!literals_on_heap_.is_null());\n    return literals_on_heap_;\n  }\n\n private:\n  Tagged<DeoptimizationLiteralArray> literals_on_heap_;\n  std::vector<DeoptimizationLiteral> literals_off_heap_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TranslatedState\",\n                \"about\": \"Manages the translation of the entire optimized frame's state during deoptimization, handling value materialization and storage.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"purpose_\",\n                        \"type\": \"Purpose\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the state is being translated for deoptimization or frame inspection.\"\n                    },\n                    {\n                        \"name\": \"frames_\",\n                        \"type\": \"std::vector<TranslatedFrame>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of TranslatedFrame objects, representing the translated stack frames.\"\n                    },\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Isolate.\"\n                    },\n                    {\n                        \"name\": \"stack_frame_pointer_\",\n                        \"type\": \"Address\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Address of the stack frame.\"\n                    },\n                    {\n                        \"name\": \"formal_parameter_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of formal parameters.\"\n                    },\n                    {\n                        \"name\": \"actual_argument_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of actual arguments.\"\n                    },\n                    {\n                        \"name\": \"object_positions_\",\n                        \"type\": \"std::deque<ObjectPosition>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Deque of ObjectPosition objects.\"\n                    },\n                    {\n                        \"name\": \"feedback_vector_handle_\",\n                        \"type\": \"Handle<FeedbackVector>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the FeedbackVector.\"\n                    },\n                    {\n                        \"name\": \"feedback_vector_\",\n                        \"type\": \"Tagged<FeedbackVector>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"FeedbackVector object.\"\n                    },\n                    {\n                        \"name\": \"feedback_slot_\",\n                        \"type\": \"FeedbackSlot\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Feedback slot.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TranslatedFrame\",\n                    \"TranslatedValue\",\n                    \"DeoptTranslationIterator\",\n                    \"ProtectedDeoptimizationLiteralArray\",\n                    \"DeoptimizationLiteralProvider\",\n                    \"RegisterValues\",\n                    \"JavaScriptFrame\",\n                    \"Isolate\",\n                    \"FeedbackVector\",\n                    \"FeedbackSlot\",\n                    \"Map\",\n                    \"ByteArray\",\n                    \"Object\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass TranslatedState {\n public:\n  // There are two constructors, each for a different purpose:\n\n  // The default constructor is for the purpose of deoptimizing an optimized\n  // frame (replacing it with one or several unoptimized frames). It is used by\n  // the Deoptimizer.\n  TranslatedState() : purpose_(kDeoptimization) {}\n\n  // This constructor is for the purpose of merely inspecting an optimized\n  // frame. It is used by stack trace generation and various debugging features.\n  explicit TranslatedState(const JavaScriptFrame* frame);\n\n  void Prepare(Address stack_frame_pointer);\n\n  // Store newly materialized values into the isolate.\n  void StoreMaterializedValuesAndDeopt(JavaScriptFrame* frame);\n\n  using iterator = std::vector<TranslatedFrame>::iterator;\n  iterator begin() { return frames_.begin(); }\n  iterator end() { return frames_.end(); }\n\n  using const_iterator = std::vector<TranslatedFrame>::const_iterator;\n  const_iterator begin() const { return frames_.begin(); }\n  const_iterator end() const { return frames_.end(); }\n\n  std::vector<TranslatedFrame>& frames() { return frames_; }\n\n  TranslatedFrame* GetFrameFromJSFrameIndex(int jsframe_index);\n  TranslatedFrame* GetArgumentsInfoFromJSFrameIndex(int jsframe_index,\n                                                    int* arguments_count);\n\n  Isolate* isolate() { return isolate_; }\n\n  void Init(Isolate* isolate, Address input_frame_pointer,\n            Address stack_frame_pointer, DeoptTranslationIterator* iterator,\n            Tagged<ProtectedDeoptimizationLiteralArray> protected_literal_array,\n            const DeoptimizationLiteralProvider& literal_array,\n            RegisterValues* registers, FILE* trace_file, int parameter_count,\n            int actual_argument_count);\n\n  void VerifyMaterializedObjects();\n  bool DoUpdateFeedback();\n\n private:\n  friend TranslatedValue;\n\n  // See the description of the constructors for an explanation of the two\n  // purposes. The only actual difference is that in the kFrameInspection case\n  // extra work is needed to not violate assumptions made by left-trimming.  For\n  // details, see the code around ReplaceElementsArrayWithCopy.\n  enum Purpose { kDeoptimization, kFrameInspection };\n\n  TranslatedFrame CreateNextTranslatedFrame(\n      DeoptTranslationIterator* iterator,\n      Tagged<ProtectedDeoptimizationLiteralArray> protected_literal_array,\n      const DeoptimizationLiteralProvider& literal_array, Address fp,\n      FILE* trace_file);\n  int CreateNextTranslatedValue(\n      int frame_index, DeoptTranslationIterator* iterator,\n      const DeoptimizationLiteralProvider& literal_array, Address fp,\n      RegisterValues* registers, FILE* trace_file);\n  Address DecompressIfNeeded(intptr_t value);\n  void CreateArgumentsElementsTranslatedValues(int frame_index,\n                                               Address input_frame_pointer,\n                                               CreateArgumentsType type,\n                                               FILE* trace_file);\n\n  void UpdateFromPreviouslyMaterializedObjects();\n  void MaterializeFixedDoubleArray(TranslatedFrame* frame, int* value_index,\n                                   TranslatedValue* slot,\n                                   DirectHandle<Map> map);\n  void MaterializeHeapNumber(TranslatedFrame* frame, int* value_index,\n                             TranslatedValue* slot);\n\n  void EnsureObjectAllocatedAt(TranslatedValue* slot);\n\n  void SkipSlots(int slots_to_skip, TranslatedFrame* frame, int* value_index);\n\n  Handle<ByteArray> AllocateStorageFor(TranslatedValue* slot);\n  void EnsureJSObjectAllocated(TranslatedValue* slot, DirectHandle<Map> map);\n  void EnsurePropertiesAllocatedAndMarked(TranslatedValue* properties_slot,\n                                          DirectHandle<Map> map);\n  void EnsureChildrenAllocated(int count, TranslatedFrame* frame,\n                               int* value_index, std::stack<int>* worklist);\n  void EnsureCapturedObjectAllocatedAt(int object_index,\n                                       std::stack<int>* worklist);\n  Handle<HeapObject> InitializeObjectAt(TranslatedValue* slot);\n  void InitializeCapturedObjectAt(int object_index, std::stack<int>* worklist,\n                                  const DisallowGarbageCollection& no_gc);\n  void InitializeJSObjectAt(TranslatedFrame* frame, int* value_index,\n                            TranslatedValue* slot, DirectHandle<Map> map,\n                            const DisallowGarbageCollection& no_gc);\n  void InitializeObjectWithTaggedFieldsAt(\n      TranslatedFrame* frame, int* value_index, TranslatedValue* slot,\n      DirectHandle<Map> map, const DisallowGarbageCollection& no_gc);\n\n  Handle<HeapObject> ResolveStringConcat(TranslatedValue* slot);\n\n  void ReadUpdateFeedback(DeoptTranslationIterator* iterator,\n                          Tagged<DeoptimizationLiteralArray> literal_array,\n                          FILE* trace_file);\n\n  TranslatedValue* ResolveCapturedObject(TranslatedValue* slot);\n  TranslatedValue* GetValueByObjectIndex(int object_index);\n  DirectHandle<Object> GetValueAndAdvance(TranslatedFrame* frame,\n                                          int* value_index);\n  TranslatedValue* GetResolvedSlot(TranslatedFrame* frame, int value_index);\n  TranslatedValue* GetResolvedSlotAndAdvance(TranslatedFrame* frame,\n                                             int* value_index);\n\n  static uint32_t GetUInt32Slot(Address fp, int slot_index);\n  static uint64_t GetUInt64Slot(Address fp, int slot_index);\n  static Float32 GetFloatSlot(Address fp, int slot_index);\n  static Float64 GetDoubleSlot(Address fp, int slot_index);\n  static Simd128 getSimd128Slot(Address fp, int slot_index);\n\n  Purpose const purpose_;\n  std::vector<TranslatedFrame> frames_;\n  Isolate* isolate_ = nullptr;\n  Address stack_frame_pointer_ = kNullAddress;\n  int formal_parameter_count_;\n  int actual_argument_count_;\n\n  struct"
}