{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/builtin-call-descriptors.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/builtin-call-descriptors.h\",\n        \"file_name\": \"builtin-call-descriptors.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the BuiltinCallDescriptor structure which contains descriptors for various built-in functions used in the Turboshaft compiler pipeline.  These descriptors specify argument types, return types, side effects, and other properties necessary for code generation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for built-in functions, code generation, interface descriptors, compiler frame management, global compiler settings, Turboshaft operations and representations, write barrier kinds, and JavaScript function objects.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/builtins/builtins.h\"\n#include \"src/codegen/callable.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/compiler/frame.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/compiler/write-barrier-kind.h\"\n#include \"src/objects/js-function.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"BuiltinCallDescriptor\",\n            \"about\": \"A structure that defines call descriptors for various built-in functions, used by the Turboshaft compiler.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"TSCallDescriptor\",\n                \"CallInterfaceDescriptor\",\n                \"Builtins\",\n                \"Linkage\",\n                \"CallDescriptor\",\n                \"OpIndex\",\n                \"V\",\n                \"Object\",\n                \"TurbofanType\",\n                \"Smi\",\n                \"Number\",\n                \"JSAnyNotNumber\",\n                \"Numeric\",\n                \"JSPrimitive\",\n                \"JSReceiver\",\n                \"ScopeInfo\",\n                \"Word32\",\n                \"Context\",\n                \"SharedFunctionInfo\",\n                \"FeedbackCell\",\n                \"JSFunction\",\n                \"String\",\n                \"PlainPrimitive\",\n                \"Boolean\",\n                \"FixedArray\",\n                \"WordPtr\",\n                \"Float64\",\n                \"Float32\",\n                \"TurboshaftWord32Type\",\n                \"Oddball\",\n                \"TurboshaftWord64Type\",\n                \"TurboshaftFloat64Type\",\n                \"ByteArray\",\n                \"HeapNumber\",\n                \"WasmFuncRef\",\n                \"Symbol\",\n                \"WasmArray\",\n                \"WasmStringRefNullable\",\n                \"WasmStringViewIter\",\n                \"JSDataView\",\n                \"BigInt\",\n                \"Map\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct BuiltinCallDescriptor {\n private:\n  template <typename Derived>\n  struct Descriptor {\n    static const TSCallDescriptor* Create(\n        StubCallMode call_mode, Zone* zone,\n        LazyDeoptOnThrow lazy_deopt_on_throw = LazyDeoptOnThrow::kNo) {\n      CallInterfaceDescriptor interface_descriptor =\n          Builtins::CallInterfaceDescriptorFor(Derived::kFunction);\n      auto descriptor = Linkage::GetStubCallDescriptor(\n          zone, interface_descriptor,\n          interface_descriptor.GetStackParameterCount(),\n          Derived::kNeedsFrameState ? CallDescriptor::kNeedsFrameState\n                                    : CallDescriptor::kNoFlags,\n          Derived::kProperties, call_mode);\n#ifdef DEBUG\n      Derived::Verify(descriptor);\n#endif  // DEBUG\n      bool can_throw = !(Derived::kProperties & Operator::kNoThrow);\n      return TSCallDescriptor::Create(\n          descriptor, can_throw ? CanThrow::kYes : CanThrow::kNo,\n          lazy_deopt_on_throw, zone);\n    }\n\n#ifdef DEBUG\n    static void Verify(const CallDescriptor* desc) {\n      using results_t = typename Derived::results_t;\n      using arguments_t = typename Derived::arguments_t;\n      DCHECK_EQ(desc->ReturnCount(), std::tuple_size_v<results_t>);\n      if constexpr (std::tuple_size_v<results_t> >= 1) {\n        using result0_t = std::tuple_element_t<0, results_t>;\n        DCHECK(AllowsRepresentation<result0_t>(\n            RegisterRepresentation::FromMachineRepresentation(\n                desc->GetReturnType(0).representation())));\n      }\n      if constexpr (std::tuple_size_v<results_t> >= 2) {\n        using result1_t = std::tuple_element_t<1, results_t>;\n        DCHECK(AllowsRepresentation<result1_t>(\n            RegisterRepresentation::FromMachineRepresentation(\n                desc->GetReturnType(1).representation())));\n      }\n      DCHECK_EQ(desc->NeedsFrameState(), Derived::kNeedsFrameState);\n      DCHECK_EQ(desc->properties(), Derived::kProperties);\n      DCHECK_EQ(desc->ParameterCount(), std::tuple_size_v<arguments_t> +\n                                            (Derived::kNeedsContext ? 1 : 0));\n      DCHECK(VerifyArguments<arguments_t>(desc));\n    }\n\n    template <typename Arguments>\n    static bool VerifyArguments(const CallDescriptor* desc) {\n      return VerifyArgumentsImpl<Arguments>(\n          desc, std::make_index_sequence<std::tuple_size_v<Arguments>>());\n    }\n\n   private:\n    template <typename T>\n    static bool AllowsRepresentation(RegisterRepresentation rep) {\n      if constexpr (std::is_same_v<T, OpIndex>) {\n        return true;\n      } else {\n        // T is V<...>\n        return T::allows_representation(rep);\n      }\n    }\n    template <typename Arguments, size_t... Indices>\n    static bool VerifyArgumentsImpl(const CallDescriptor* desc,\n                                    std::index_sequence<Indices...>) {\n      return (AllowsRepresentation<std::tuple_element_t<Indices, Arguments>>(\n                  RegisterRepresentation::FromMachineRepresentation(\n                      desc->GetParameterType(Indices).representation())) &&\n              ...);\n    }\n#endif  // DEBUG\n  };\n\n  static constexpr OpEffects base_effects = OpEffects().CanDependOnChecks();\n  // TODO(nicohartmann@): Unfortunately, we cannot define builtins with\n  // void/never return types properly (e.g. in Torque), but they typically have\n  // a JSAny dummy return type. Use Void/Never sentinels to express that in\n  // Turboshaft's descriptors. We should find a better way to model this.\n  using Void = std::tuple<OpIndex>;\n  using Never = std::tuple<OpIndex>;\n\n public:\n  struct CheckTurbofanType : public Descriptor<CheckTurbofanType> {\n    static constexpr auto kFunction = Builtin::kCheckTurbofanType;\n    using arguments_t = std::tuple<V<Object>, V<TurbofanType>, V<Smi>>;\n    using results_t = std::tuple<V<Object>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoThrow | Operator::kNoDeopt;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().RequiredWhenUnused();\n  };\n\n#define DECL_GENERIC_BINOP(Name)                                          \\\n  struct Name : public Descriptor<Name> {                                 \\\n    static constexpr auto kFunction = Builtin::k##Name;                   \\\n    using arguments_t = std::tuple<V<Object>, V<Object>>;                 \\\n    using results_t = std::tuple<V<Object>>;                              \\\n                                                                          \\\n    static constexpr bool kNeedsFrameState = true;                        \\\n    static constexpr bool kNeedsContext = true;                           \\\n    static constexpr Operator::Properties kProperties =                   \\\n        Operator::kNoProperties;                                          \\\n    static constexpr OpEffects kEffects = base_effects.CanCallAnything(); \\\n  };\n  GENERIC_BINOP_LIST(DECL_GENERIC_BINOP)\n#undef DECL_GENERIC_BINOP\n\n#define DECL_GENERIC_UNOP(Name)                                           \\\n  struct Name : public Descriptor<Name> {                                 \\\n    static constexpr auto kFunction = Builtin::k##Name;                   \\\n    using arguments_t = std::tuple<V<Object>>;                            \\\n    using results_t = std::tuple<V<Object>>;                              \\\n                                                                          \\\n    static constexpr bool kNeedsFrameState = true;                        \\\n    static constexpr bool kNeedsContext = true;                           \\\n    static constexpr Operator::Properties kProperties =                   \\\n        Operator::kNoProperties;                                          \\\n    static constexpr OpEffects kEffects = base_effects.CanCallAnything(); \\\n  };\n  GENERIC_UNOP_LIST(DECL_GENERIC_UNOP)\n#undef DECL_GENERIC_UNOP\n\n  struct ToNumber : public Descriptor<ToNumber> {\n    static constexpr auto kFunction = Builtin::kToNumber;\n    using arguments_t = std::tuple<V<Object>>;\n    using results_t = std::tuple<V<Number>>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n    static constexpr OpEffects kEffects = base_effects.CanCallAnything();\n  };\n\n  struct NonNumberToNumber : public Descriptor<NonNumberToNumber> {\n    static constexpr auto kFunction = Builtin::kNonNumberToNumber;\n    using arguments_t = std::tuple<V<JSAnyNotNumber>>;\n    using results_t = std::tuple<V<Number>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n    static constexpr OpEffects kEffects = base_effects.CanCallAnything();\n  };\n\n  struct ToNumeric : public Descriptor<ToNumeric> {\n    static constexpr auto kFunction = Builtin::kToNumeric;\n    using arguments_t = std::tuple<V<Object>>;\n    using results_t = std::tuple<V<Numeric>>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n    static constexpr OpEffects kEffects = base_effects.CanCallAnything();\n  };\n\n  struct NonNumberToNumeric : public Descriptor<NonNumberToNumeric> {\n    static constexpr auto kFunction = Builtin::kNonNumberToNumeric;\n    using arguments_t = std::tuple<V<JSAnyNotNumber>>;\n    using results_t = std::tuple<V<Numeric>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n    static constexpr OpEffects kEffects = base_effects.CanCallAnything();\n  };\n\n  struct CopyFastSmiOrObjectElements\n      : public Descriptor<CopyFastSmiOrObjectElements> {\n    static constexpr auto kFunction = Builtin::kCopyFastSmiOrObjectElements;\n    using arguments_t = std::tuple<V<Object>>;\n    using results_t = std::tuple<V<Object>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanWriteMemory().CanReadMemory().CanAllocate();\n  };\n\n  template <Builtin B, typename Input>\n  struct DebugPrint : public Descriptor<DebugPrint<B, Input>> {\n    static constexpr auto kFunction = B;\n    using arguments_t = std::tuple<V<Input>>;\n    using results_t = std::tuple<V<Object>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoThrow | Operator::kNoDeopt;\n    static constexpr OpEffects kEffects = base_effects.RequiredWhenUnused();\n  };\n  using DebugPrintFloat64 = DebugPrint<Builtin::kDebugPrintFloat64, Float64>;\n  using DebugPrintWordPtr = DebugPrint<Builtin::kDebugPrintWordPtr, WordPtr>;\n\n  template <Builtin B>\n  struct FindOrderedHashEntry : public Descriptor<FindOrderedHashEntry<B>> {\n    static constexpr auto kFunction = B;\n    using arguments_t = std::tuple<V<Object>, V<Smi>>;\n    using results_t = std::tuple<V<Smi>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.AssumesConsistentHeap().CanReadMemory().CanAllocate();\n  };\n  using FindOrderedHashMapEntry =\n      FindOrderedHashEntry<Builtin::kFindOrderedHashMapEntry>;\n  using FindOrderedHashSetEntry =\n      FindOrderedHashEntry<Builtin::kFindOrderedHashSetEntry>;\n\n  template <Builtin B>\n  struct GrowFastElements : public Descriptor<GrowFastElements<B>> {\n    static constexpr auto kFunction = B;\n    using arguments_t = std::tuple<V<Object>, V<Smi>>;\n    using results_t = std::tuple<V<Object>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanWriteMemory().CanReadMemory().CanAllocate();\n  };\n  using GrowFastDoubleElements =\n      GrowFastElements<Builtin::kGrowFastDoubleElements>;\n  using GrowFastSmiOrObjectElements =\n      GrowFastElements<Builtin::kGrowFastSmiOrObjectElements>;\n\n  template <Builtin B>\n  struct NewArgumentsElements : public Descriptor<NewArgumentsElements<B>> {\n    static constexpr auto kFunction = B;\n    // TODO(nicohartmann@): First argument should be replaced by a proper\n    // RawPtr.\n    using arguments_t = std::tuple<V<WordPtr>, V<WordPtr>, V<Smi>>;\n    using results_t = std::tuple<V<FixedArray>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects = base_effects.CanAllocate();\n  };\n  using NewSloppyArgumentsElements =\n      NewArgumentsElements<Builtin::kNewSloppyArgumentsElements>;\n  using NewStrictArgumentsElements =\n      NewArgumentsElements<Builtin::kNewStrictArgumentsElements>;\n  using NewRestArgumentsElements =\n      NewArgumentsElements<Builtin::kNewRestArgumentsElements>;\n\n  struct NumberToString : public Descriptor<NumberToString> {\n    static constexpr auto kFunction = Builtin::kNumberToString;\n    using arguments_t = std::tuple<V<Number>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct ToString : public Descriptor<ToString> {\n    static constexpr auto kFunction = Builtin::kToString;\n    using arguments_t = std::tuple<V<Object>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n    static constexpr OpEffects kEffects = base_effects.CanCallAnything();\n  };\n\n  struct PlainPrimitiveToNumber : public Descriptor<PlainPrimitiveToNumber> {\n    static constexpr auto kFunction = Builtin::kPlainPrimitiveToNumber;\n    using arguments_t = std::tuple<V<PlainPrimitive>>;\n    using results_t = std::tuple<V<Number>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct SameValue : public Descriptor<SameValue> {\n    static constexpr auto kFunction = Builtin::kSameValue;\n    using arguments_t = std::tuple<V<Object>, V<Object>>;\n    using results_t = std::tuple<V<Boolean>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocate();\n  };\n\n  struct SameValueNumbersOnly : public Descriptor<SameValueNumbersOnly> {\n    static constexpr auto kFunction = Builtin::kSameValueNumbersOnly;\n    using arguments_t = std::tuple<V<Object>, V<Object>>;\n    using results_t = std::tuple<V<Boolean>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects = base_effects.CanReadMemory();\n  };\n\n  struct StringAdd_CheckNone : public Descriptor<StringAdd_CheckNone> {\n    static constexpr auto kFunction = Builtin::kStringAdd_CheckNone;\n    using arguments_t = std::tuple<V<String>, V<String>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoWrite;\n    // This will only write in a fresh object, so the writes are not visible\n    // from Turboshaft, and CanAllocate is enough.\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct StringEqual : public Descriptor<StringEqual> {\n    static constexpr auto kFunction = Builtin::kStringEqual;\n    using arguments_t = std::tuple<V<String>, V<String>, V<WordPtr>>;\n    using results_t = std::tuple<V<Boolean>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    // If the strings aren't flat, StringEqual could flatten them, which will\n    // allocate new strings.\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct StringFromCodePointAt : public Descriptor<StringFromCodePointAt> {\n    static constexpr auto kFunction = Builtin::kStringFromCodePointAt;\n    using arguments_t = std::tuple<V<String>, V<WordPtr>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct StringIndexOf : public Descriptor<StringIndexOf> {\n    static constexpr auto kFunction = Builtin::kStringIndexOf;\n    using arguments_t = std::tuple<V<String>, V<String>, V<Smi>>;\n    using results_t = std::tuple<V<Smi>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    // StringIndexOf does a ToString on the receiver, which can allocate a new\n    // string.\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct StringCompare : public Descriptor<StringCompare> {\n    static constexpr auto kFunction = Builtin::kStringCompare;\n    using arguments_t = std::tuple<V<String>, V<String>>;\n    using results_t = std::tuple<V<Smi>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  template <Builtin B>\n  struct StringComparison : public Descriptor<StringComparison<B>> {\n    static constexpr auto kFunction = B;\n    using arguments_t = std::tuple<V<String>, V<String>>;\n    using results_t = std::tuple<V<Boolean>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n  using StringLessThan = StringComparison<Builtin::kStringLessThan>;\n  using StringLessThanOrEqual =\n      StringComparison<Builtin::kStringLessThanOrEqual>;\n\n  struct StringSubstring : public Descriptor<StringSubstring> {\n    static constexpr auto kFunction = Builtin::kStringSubstring;\n    using arguments_t = std::tuple<V<String>, V<WordPtr>, V<WordPtr>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n#ifdef V8_INTL_SUPPORT\n  struct StringToLowerCaseIntl : public Descriptor<StringToLowerCaseIntl> {\n    static constexpr auto kFunction = Builtin::kStringToLowerCaseIntl;\n    using arguments_t = std::tuple<V<String>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n#endif  // V8_INTL_SUPPORT\n\n  struct StringToNumber : public Descriptor<StringToNumber> {\n    static constexpr auto kFunction = Builtin::kStringToNumber;\n    using arguments_t = std::tuple<V<String>>;\n    using results_t = std::tuple<V<Number>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct ToBoolean : public Descriptor<ToBoolean> {\n    static constexpr auto kFunction = Builtin::kToBoolean;\n    using arguments_t = std::tuple<V<Object>>;\n    using results_t = std::tuple<V<Boolean>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects = base_effects.CanReadMemory();\n  };\n\n  struct ToObject : public Descriptor<ToObject> {\n    static constexpr auto kFunction = Builtin::kToObject;\n    using arguments_t = std::tuple<V<JSPrimitive>>;\n    using results_t = std::tuple<V<JSReceiver>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocate();\n  };\n\n  template <Builtin B>\n  struct CreateFunctionContext : public Descriptor<CreateFunctionContext<B>> {\n    static constexpr auto kFunction = B;\n    using arguments_t = std::tuple<V<ScopeInfo>, V<Word32>>;\n    using results_t = std::tuple<V<Context>>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocate();\n  };\n\n  using FastNewFunctionContextFunction =\n      CreateFunctionContext<Builtin::kFastNewFunctionContextFunction>;\n  using FastNewFunctionContextEval =\n      CreateFunctionContext<Builtin::kFastNewFunctionContextEval>;\n\n  struct FastNewClosure : public Descriptor<FastNewClosure> {\n    static constexpr auto kFunction = Builtin::kFastNewClosure;\n    using arguments_t = std::tuple<V<SharedFunctionInfo>, V<FeedbackCell>>;\n    using results_t = std::tuple<V<JSFunction>>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties =\n        Operator::kEliminatable | Operator::kNoThrow;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanWriteMemory().CanAllocate();\n  };\n\n  struct Typeof : public Descriptor<Typeof> {\n    static constexpr auto kFunction = Builtin::kTypeof;\n    using arguments_t = std::tuple<V<Object>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects = base_effects.CanReadMemory();\n  };\n\n  struct CheckTurboshaftWord32Type\n      : public Descriptor<CheckTurboshaftWord32Type> {\n    static constexpr auto kFunction = Builtin::kCheckTurboshaftWord32Type;\n    using arguments_t = std::tuple<V<Word32>, V<TurboshaftWord32Type>, V<Smi>>;\n    using results_t = std::tuple<V<Oddball>>;\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct CheckTurboshaftWord64Type\n      : public Descriptor<CheckTurboshaftWord64Type> {\n    static constexpr auto kFunction = Builtin::kCheckTurboshaftWord64Type;\n    using arguments_t =\n        std::tuple<V<Word32>, V<Word32>, V<TurboshaftWord64Type>, V<Smi>>;\n    using results_t = std::tuple<V<Oddball>>;\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct CheckTurboshaftFloat32Type\n      : public Descriptor<CheckTurboshaftFloat32Type> {\n    static constexpr auto kFunction = Builtin::kCheckTurboshaftFloat32Type;\n    using arguments_t =\n        std::tuple<V<Float32>, V<TurboshaftFloat64Type>, V<Smi>>;\n    using results_t = std::tuple<V<Oddball>>;\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct CheckTurboshaftFloat64Type\n      : public Descriptor<CheckTurboshaftFloat64Type> {\n    static constexpr auto kFunction = Builtin::kCheckTurboshaftFloat64Type;\n    using arguments_t =\n        std::tuple<V<Float64>, V<TurboshaftFloat64Type>, V<Smi>>;\n    using results_t = std::tuple<V<Oddball>>;\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n#ifdef V8_ENABLE_WEBASSEMBLY\n\n  struct WasmStringAsWtf8 : public Descriptor<WasmStringAsWtf8> {\n    static constexpr auto kFunction = Builtin::kWasmStringAsWtf8;\n    using arguments_t = std::tuple<V<String>>;\n    using results_t = std::tuple<V<ByteArray>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct WasmStringAsWtf16 : public Descriptor<WasmStringAsWtf16> {\n    static constexpr auto kFunction = Builtin::kWasmStringAsWtf16;\n    using arguments_t = std::tuple<V<String>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kEliminatable;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanAllocateWithoutIdentity();\n  };\n\n  struct WasmInt32ToHeapNumber : public Descriptor<WasmInt32ToHeapNumber> {\n    static constexpr auto kFunction = Builtin::kWasmInt32ToHeapNumber;\n    using arguments_t = std::tuple<V<Word32>>;\n    using results_t = std::tuple<V<HeapNumber>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kPure;\n    static constexpr OpEffects kEffects =\n        base_effects.CanAllocateWithoutIdentity();\n  };\n\n  struct WasmRefFunc : public Descriptor<WasmRefFunc> {\n    static constexpr auto kFunction = Builtin::kWasmRefFunc;\n    using arguments_t = std::tuple<V<Word32>, V<Word32>>;\n    using results_t = std::tuple<V<WasmFuncRef>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kNoThrow;\n    // TODO(nicohartmann@): Use more precise effects.\n    static constexpr OpEffects kEffects = base_effects.CanCallAnything();\n  };\n\n  struct WasmGetOwnProperty : public Descriptor<WasmGetOwnProperty> {\n    static constexpr auto kFunction = Builtin::kWasmGetOwnProperty;\n    using arguments_t = std::tuple<V<Object>, V<Symbol>>;\n    using results_t = std::tuple<V<Object>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoThrow;\n    static constexpr OpEffects kEffects = base_effects.CanReadHeapMemory();\n  };\n\n  struct WasmRethrow : public Descriptor<WasmRethrow> {\n    static constexpr auto kFunction = Builtin::kWasmRethrow;\n    using arguments_t = std::tuple<V<Object>>;\n    using results_t = std::tuple<OpIndex>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n    static constexpr OpEffects kEffects = base_effects.CanChangeControlFlow();\n  };\n\n  struct WasmThrowRef : public Descriptor<WasmThrowRef> {\n    static constexpr auto kFunction = Builtin::kWasmThrowRef;\n    using arguments_t = std::tuple<V<Object>>;\n    using results_t = std::tuple<OpIndex>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n    static constexpr OpEffects kEffects = base_effects.CanChangeControlFlow();\n  };\n\n  struct WasmMemoryGrow : public Descriptor<WasmMemoryGrow> {\n    static constexpr auto kFunction = Builtin::kWasmMemoryGrow;\n    using arguments_t = std::tuple<V<Word32>, V<Word32>>;\n    using results_t = std::tuple<V<Word32>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n    static constexpr OpEffects kEffects =\n        base_effects.CanReadMemory().CanWriteMemory();\n  };\n\n  struct WasmStringFromCodePoint : public Descriptor<WasmStringFromCodePoint> {\n    static constexpr auto kFunction = Builtin::kWasmStringFromCodePoint;\n    using arguments_t = std::tuple<V<Word32>>;\n    using results_t = std::tuple<V<String>>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr bool kNeedsContext = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoWrite;\n    static constexpr OpEffects kEffects =\n        base_effects.CanAllocateWithoutIdentity().CanLeaveCurrentFunction();\n  };\n\n  struct WasmStringNewWtf8Array : public Descriptor<WasmStringNewWtf8Array> {\n    static constexpr auto kFunction = Builtin::kWasmStringNewWtf8Array;\n    using arguments_t = std::tuple<V<Word3"
}