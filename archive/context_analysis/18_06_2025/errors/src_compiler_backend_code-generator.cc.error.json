{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/code-generator.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/code-generator.cc\",\n        \"file_name\": \"code-generator.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Generates machine code from an instruction sequence, including handling deoptimization, safepoints, and exception handlers.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for code generation, data structures, and utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/backend/code-generator.h\"\n\n#include <optional>\n\n#include \"src/base/bounds.h\"\n#include \"src/base/iterator.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/macro-assembler-inl.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/backend/code-generator-impl.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/pipeline.h\"\n#include \"src/deoptimizer/translated-state.h\"\n#include \"src/diagnostics/eh-frame.h\"\n#include \"src/execution/frames.h\"\n#include \"src/logging/counters.h\"\n#include \"src/logging/log.h\"\n#include \"src/objects/code-kind.h\"\n#include \"src/objects/smi.h\"\n#include \"src/utils/address-map.h\"\n#include \"src/utils/utils.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-deopt-data.h\"\n#endif\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CodeGenerator::JumpTable\",\n            \"extends\": \"ZoneObject\",\n            \"about\": \"Represents a jump table used for switch statements or similar control flow constructs.\",\n            \"attributes\": [\n                {\n                    \"name\": \"label_\",\n                    \"type\": \"Label\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The label associated with the jump table's entry point.\"\n                },\n                {\n                    \"name\": \"next_\",\n                    \"type\": \"JumpTable*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the next jump table in a linked list.\"\n                },\n                {\n                    \"name\": \"targets_\",\n                    \"type\": \"base::Vector<Label*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of labels representing the jump targets.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass CodeGenerator::JumpTable final : public ZoneObject {\n public:\n  JumpTable(JumpTable* next, const base::Vector<Label*>& targets)\n      : next_(next), targets_(targets) {}\n\n  Label* label() { return &label_; }\n  JumpTable* next() const { return next_; }\n  const base::Vector<Label*>& targets() const { return targets_; }\n\n private:\n  Label label_;\n  JumpTable* const next_;\n  base::Vector<Label*> const targets_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CodeGenerator\",\n            \"about\": \"The main class responsible for generating machine code from a high-level instruction sequence.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Frame\",\n                \"Linkage\",\n                \"InstructionSequence\",\n                \"OptimizedCompilationInfo\",\n                \"Isolate\",\n                \"OsrHelper\",\n                \"JumpOptimizationInfo\",\n                \"AssemblerOptions\",\n                \"Label\",\n                \"Assembler\",\n                \"ReferenceMap\",\n                \"HandlerTable\",\n                \"DeoptimizationExit\",\n                \"DeoptimizationLiteral\",\n                \"Translation\",\n                \"SourcePositionTableBuilder\",\n                \"CodeKind\",\n                \"DeoptimizeKind\",\n                \"DeoptimizeReason\",\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass CodeGenerator {\n public:\n  enum class CodeGenResult { kSuccess, kTooManyDeoptimizationBailouts };\n\n  using PushTypeFlags = int;\n  enum { kImmediatePush = 1 << 0, kRegisterPush = 1 << 1, kStackSlotPush = 1 << 2 };\n\n  // TODO(leszeks): Remove this once there is no code relying on it.\n  enum { kStackLimitSlackForDeoptimizationInBytes = 256 };\n\n  CodeGenerator(Zone* codegen_zone, Frame* frame, Linkage* linkage,\n                             InstructionSequence* instructions,\n                             OptimizedCompilationInfo* info, Isolate* isolate,\n                             std::optional<OsrHelper> osr_helper,\n                             int start_source_position,\n                             JumpOptimizationInfo* jump_opt,\n                             const AssemblerOptions& options, Builtin builtin,\n                             size_t max_unoptimized_frame_height,\n                             size_t max_pushed_argument_count,\n                             const char* debug_name);\n\n  void RecordProtectedInstruction(uint32_t instr_offset);\n\n  void CreateFrameAccessState(Frame* frame);\n\n  bool ShouldApplyOffsetToStackCheck(Instruction* instr,\n                                                  uint32_t* offset);\n\n  uint32_t GetStackCheckOffset();\n\n  CodeGenResult AssembleDeoptimizerCall(\n    DeoptimizationExit* exit);\n\n  void MaybeEmitOutOfLineConstantPool();\n\n  void AssembleCode();\n\n#ifndef V8_TARGET_ARCH_X64\n  void AssembleArchBinarySearchSwitchRange(\n    Register input, RpoNumber def_block, std::pair<int32_t, Label*>* begin,\n    std::pair<int32_t, Label*>* end);\n#endif  // V8_TARGET_ARCH_X64\n\n  void AssembleArchJump(RpoNumber target);\n\n  base::OwnedVector<uint8_t> GetSourcePositionTable();\n\n  base::OwnedVector<uint8_t> GetProtectedInstructionsData();\n\n  MaybeHandle<Code> FinalizeCode();\n\n  bool IsNextInAssemblyOrder(RpoNumber block) const;\n\n  void RecordSafepoint(ReferenceMap* references, int pc_offset);\n\n  bool IsMaterializableFromRoot(Handle<HeapObject> object,\n                                             RootIndex* index_return);\n\n  CodeGenResult AssembleBlock(\n    const InstructionBlock* block);\n\n  bool IsValidPush(InstructionOperand source,\n                                CodeGenerator::PushTypeFlags push_type);\n\n  void GetPushCompatibleMoves(Instruction* instr,\n                                           PushTypeFlags push_type,\n                                           ZoneVector<MoveOperands*>* pushes);\n\n  void RecordCallPosition(Instruction* instr);\n\n  void RecordDeoptInfo(Instruction* instr, int pc_offset);\n\n  int DefineProtectedDeoptimizationLiteral(\n    IndirectHandle<TrustedObject> object);\n\n  int DefineDeoptimizationLiteral(DeoptimizationLiteral literal);\n\n  bool HasProtectedDeoptimizationLiteral(\n    IndirectHandle<TrustedObject> object) const;\n\n  DeoptimizationEntry const& GetDeoptimizationEntry(\n    Instruction* instr, size_t frame_state_offset);\n\n  Label* AddJumpTable(base::Vector<Label*> targets);\n\n#ifndef V8_TARGET_ARCH_X64\n  void AssemblePlaceHolderForLazyDeopt(Instruction* instr);\n#endif\n\n  Zone* zone() const { return zone_; }\n  Isolate* isolate() const { return isolate_; }\n  FrameAccessState* frame_access_state() const { return frame_access_state_; }\n  Linkage* linkage() const { return linkage_; }\n  InstructionSequence* instructions() const { return instructions_; }\n  OptimizedCompilationInfo* info() const { return info_; }\n  Label* GetLabel(RpoNumber rpo) { return &labels_[rpo.ToInt()]; }\n  Frame* frame() const { return frame_access_state_->frame(); }\n  MacroAssembler* masm() { return &masm_; }\n  SafepointTableBuilder* safepoints() { return &safepoints_; }\n  ConstantPoolArrayBuilder* constant_pool_builder() {\n    return masm()->constant_pool_builder();\n  }\n  bool caller_registers_saved() const { return caller_registers_saved_; }\n  void set_caller_registers_saved(bool value) { caller_registers_saved_ = value; }\n\n  virtual void AssembleConstructFrame() = 0;\n  virtual void AssembleDeconstructFrame() = 0;\n  virtual void AssembleCodeStartRegisterCheck() = 0;\n  virtual void AssembleDispatchHandleRegisterCheck() = 0;\n  virtual CodeGenResult AssembleArchInstruction(Instruction* instr) = 0;\n  virtual void AssembleArchBranch(Instruction* instr, BranchInfo* branch) = 0;\n  virtual void AssembleArchConditionalBranch(Instruction* instr, BranchInfo* branch) = 0;\n  virtual void AssembleArchDeoptBranch(Instruction* instr, BranchInfo* branch) = 0;\n  virtual void AssembleArchBoolean(Instruction* instr, FlagsCondition condition) = 0;\n  virtual void AssembleArchConditionalBoolean(Instruction* instr) = 0;\n  virtual void AssembleArchSelect(Instruction* instr, FlagsCondition condition) = 0;\n  virtual void AssembleArchTrap(Instruction* instr, FlagsCondition condition) = 0;\n  virtual void AssembleArchJumpRegardlessOfAssemblyOrder(RpoNumber target) = 0;\n  virtual void AssembleJumpTable(const base::Vector<Label*>& targets) = 0;\n  virtual void BailoutIfDeoptimized() = 0;\n  virtual void FinishCode() = 0;\n  virtual void PrepareForDeoptimizationExits(\n      ZoneVector<DeoptimizationExit*>* exits) = 0;\n  virtual bool GetSlotAboveSPBeforeTailCall(Instruction* instr, int* slot) {\n    return false;\n  }\n  virtual void AssembleTailCallBeforeGap(Instruction* instr, int slot) {}\n  virtual void AssembleTailCallAfterGap(Instruction* instr, int slot) {}\n  virtual StubCallMode DetermineStubCallMode() const;\n\n protected:\n  Zone* const zone_;\n  Isolate* const isolate_;\n  FrameAccessState* frame_access_state_;\n  Linkage* const linkage_;\n  InstructionSequence* const instructions_;\n  EhFrameWriter unwinding_info_writer_;\n  OptimizedCompilationInfo* const info_;\n  Label* labels_;  // Indexed by RpoNumber::ToInt().\n  RpoNumber current_block_;\n  int const start_source_position_;\n  SourcePosition current_source_position_;\n  MacroAssembler masm_;\n  ParallelMoveResolver resolver_;\n  SafepointTableBuilder safepoints_;\n  ZoneVector<HandlerTable::Entry> handlers_;\n  ZoneVector<DeoptimizationExit*> deoptimization_exits_;\n  ZoneVector<IndirectHandle<TrustedObject>> protected_deoptimization_literals_;\n  ZoneVector<DeoptimizationLiteral> deoptimization_literals_;\n  DeoptimizationTranslationBuilder translations_;\n  size_t max_unoptimized_frame_height_;\n  size_t max_pushed_argument_count_;\n  bool caller_registers_saved_;\n  JumpTable* jump_tables_;\n  OutOfLineCode* ools_;\n  std::optional<OsrHelper> osr_helper_;\n  int osr_pc_offset_;\n  SourcePositionTableBuilder source_position_table_builder_;\n#if V8_ENABLE_WEBASSEMBLY\n  ZoneVector<ProtectedInstructionData> protected_instructions_;\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  CodeGenResult result_;\n  int parameter_count_ = 0;\n  int next_deoptimization_id_ = 0;\n  int eager_deopt_count_ = 0;\n  int lazy_deopt_count_ = 0;\n  int inlined_function_count_ = 0;\n  int deopt_exit_start_offset_ = 0;\n  int handler_table_offset_ = 0;\n  std::array<Label, static_cast<int>(kLastDeoptimizeKind) + 1>\n      jump_deoptimization_entry_labels_;\n  ZoneVector<int> block_starts_;\n  ZoneVector<ArchInstrStart> instr_starts_;\n  OffsetsInfo offsets_info_;\n  const char* debug_name_;\n\n private:\n  enum GapPosition {\n    kAnyGap = Instruction::kAnyGap,\n    kFirstGap = Instruction::kFirstGap,\n    kLastGap = Instruction::kLastGap\n  };\n\n  static constexpr int kBinarySearchSwitchMinimalCases = 4;\n\n  void TranslateStateValueDescriptor(\n    StateValueDescriptor* desc, StateValueList* nested,\n    InstructionOperandIterator* iter);\n\n  void TranslateFrameStateDescriptorOperands(\n    FrameStateDescriptor* desc, InstructionOperandIterator* iter);\n\n  void BuildTranslationForFrameStateDescriptor(\n    FrameStateDescriptor* descriptor, InstructionOperandIterator* iter,\n    OutputFrameStateCombine state_combine);\n\n  DeoptimizationExit* BuildTranslation(\n    Instruction* instr, int pc_offset, size_t frame_state_offset,\n    size_t immediate_args_count, OutputFrameStateCombine state_combine);\n\n  void AddTranslationForOperand(Instruction* instr,\n                                             InstructionOperand* op,\n                                             MachineType type);\n\n  DeoptimizationExit* AddDeoptimizationExit(\n    Instruction* instr, size_t frame_state_offset,\n    size_t immediate_args_count);\n\n  void AssembleGaps(Instruction* instr);\n  \n#if V8_ENABLE_WEBASSEMBLY\n  base::OwnedVector<uint8_t> GenerateWasmDeoptimizationData();\n#endif\n\n  class OutOfLineCode;\n  friend class OutOfLineCode;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CodeGenerator::OutOfLineCode\",\n            \"about\": \"A base class for generating code that is placed out-of-line, typically for handling uncommon cases or exceptions.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Frame\",\n                \"MacroAssembler\",\n                \"Label\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class OutOfLineCode {\n   public:\n    explicit OutOfLineCode(CodeGenerator* gen);\n    virtual ~OutOfLineCode();\n\n    Label* entry() { return &entry_; }\n    Label* exit() { return &exit_; }\n    OutOfLineCode* next() const { return next_; }\n\n   protected:\n    virtual void Generate() = 0;\n\n    Frame* frame() const { return frame_; }\n    MacroAssembler* masm() const { return masm_; }\n\n   private:\n    Frame* const frame_;\n    MacroAssembler* const masm_;\n    Label entry_;\n    Label exit_;\n    OutOfLineCode* next_;\n  };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CodeGenerator::CodeGenerator\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Constructor for the CodeGenerator class.\",\n            \"logic\": \"Initializes the CodeGenerator with necessary information for code generation, including frame setup, linkage details, and instruction sequence.\",\n            \"parameters\": [\n                {\n                    \"name\": \"codegen_zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory for code generation.\"\n                },\n                {\n                    \"name\": \"frame\",\n                    \"type\": \"Frame*\",\n                    \"purpose\": \"The frame descriptor for the generated code.\"\n                },\n                {\n                    \"name\": \"linkage\",\n                    \"type\": \"Linkage*\",\n                    \"purpose\": \"The linkage descriptor for the generated code.\"\n                },\n                {\n                    \"name\": \"instructions\",\n                    \"type\": \"InstructionSequence*\",\n                    \"purpose\": \"The sequence of instructions to be compiled.\"\n                },\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"Compilation information.\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate for the generated code.\"\n                },\n                {\n                    \"name\": \"osr_helper\",\n                    \"type\": \"std::optional<OsrHelper>\",\n                    \"purpose\": \"On-Stack Replacement helper.\"\n                },\n                {\n                    \"name\": \"start_source_position\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The starting source position.\"\n                },\n                {\n                    \"name\": \"jump_opt\",\n                    \"type\": \"JumpOptimizationInfo*\",\n                    \"purpose\": \"Jump optimization information.\"\n                },\n                {\n                    \"name\": \"options\",\n                    \"type\": \"const AssemblerOptions&\",\n                    \"purpose\": \"Assembler options.\"\n                },\n                {\n                    \"name\": \"builtin\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin being compiled (if applicable).\"\n                },\n                {\n                    \"name\": \"max_unoptimized_frame_height\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"Maximum height of unoptimized frames.\"\n                },\n                {\n                    \"name\": \"max_pushed_argument_count\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"Maximum number of pushed arguments.\"\n                },\n                {\n                    \"name\": \"debug_name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"Debug name for the generated code.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FrameAccessState\",\n                \"JumpOptimizationInfo\",\n                \"CodeKind\",\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCodeGenerator::CodeGenerator(Zone* codegen_zone, Frame* frame, Linkage* linkage,\n                             InstructionSequence* instructions,\n                             OptimizedCompilationInfo* info, Isolate* isolate,\n                             std::optional<OsrHelper> osr_helper,\n                             int start_source_position,\n                             JumpOptimizationInfo* jump_opt,\n                             const AssemblerOptions& options, Builtin builtin,\n                             size_t max_unoptimized_frame_height,\n                             size_t max_pushed_argument_count,\n                             const char* debug_name)\n    : zone_(codegen_zone),\n      isolate_(isolate),\n      frame_access_state_(nullptr),\n      linkage_(linkage),\n      instructions_(instructions),\n      unwinding_info_writer_(codegen_zone),\n      info_(info),\n      labels_(codegen_zone->AllocateArray<Label>(\n          instructions->InstructionBlockCount())),\n      current_block_(RpoNumber::Invalid()),\n      start_source_position_(start_source_position),\n      current_source_position_(SourcePosition::Unknown()),\n      masm_(isolate, codegen_zone, options, CodeObjectRequired::kNo,\n            std::unique_ptr<AssemblerBuffer>{}),\n      resolver_(this),\n      safepoints_(codegen_zone),\n      handlers_(codegen_zone),\n      deoptimization_exits_(codegen_zone),\n      protected_deoptimization_literals_(codegen_zone),\n      deoptimization_literals_(codegen_zone),\n      translations_(codegen_zone),\n      max_unoptimized_frame_height_(max_unoptimized_frame_height),\n      max_pushed_argument_count_(max_pushed_argument_count),\n      caller_registers_saved_(false),\n      jump_tables_(nullptr),\n      ools_(nullptr),\n      osr_helper_(std::move(osr_helper)),\n      osr_pc_offset_(-1),\n      source_position_table_builder_(\n          codegen_zone, SourcePositionTableBuilder::RECORD_SOURCE_POSITIONS),\n#if V8_ENABLE_WEBASSEMBLY\n      protected_instructions_(codegen_zone),\n#endif  // V8_ENABLE_WEBASSEMBLY\n      result_(kSuccess),\n      block_starts_(codegen_zone),\n      instr_starts_(codegen_zone),\n      debug_name_(debug_name) {\n  for (int i = 0; i < instructions->InstructionBlockCount(); ++i) {\n    new (&labels_[i]) Label;\n  }\n  CreateFrameAccessState(frame);\n  CHECK_EQ(info->is_osr(), osr_helper_.has_value());\n  masm_.set_jump_optimization_info(jump_opt);\n  CodeKind code_kind = info->code_kind();\n  if (code_kind == CodeKind::WASM_FUNCTION ||\n      code_kind == CodeKind::WASM_TO_CAPI_FUNCTION ||\n      code_kind == CodeKind::WASM_TO_JS_FUNCTION ||\n      code_kind == CodeKind::JS_TO_WASM_FUNCTION) {\n    masm_.set_abort_hard(true);\n  }\n  masm_.set_builtin(builtin);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CodeGenerator::RecordProtectedInstruction\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Records the offset of a protected instruction for WebAssembly.\",\n            \"logic\": \"Pushes the instruction offset onto the protected_instructions_ vector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr_offset\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The offset of the protected instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::RecordProtectedInstruction(uint32_t instr_offset) {\n#if V8_ENABLE_WEBASSEMBLY\n  protected_instructions_.push_back({instr_offset});\n#endif  // V8_ENABLE_WEBASSEMBLY\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CodeGenerator::CreateFrameAccessState\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Creates the FrameAccessState object.\",\n            \"logic\": \"Finishes the current frame setup and initializes the FrameAccessState.\",\n            \"parameters\": [\n                {\n                    \"name\": \"frame\",\n                    \"type\": \"Frame*\",\n                    \"purpose\": \"The frame descriptor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FrameAccessState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::CreateFrameAccessState(Frame* frame) {\n  FinishFrame(frame);\n  frame_access_state_ = zone()->New<FrameAccessState>(frame);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CodeGenerator::ShouldApplyOffsetToStackCheck\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Determines if an offset should be applied to a stack check instruction.\",\n            \"logic\": \"Checks if the stack check is a JS function entry stack check and if the stack check offset is greater than the allowed slack for deoptimization.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The stack check instruction.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"uint32_t*\",\n                    \"purpose\": \"A pointer to store the stack check offset.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the offset should be applied, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool CodeGenerator::ShouldApplyOffsetToStackCheck(Instruction* instr,\n                                                  uint32_t* offset) {\n  DCHECK_EQ(instr->arch_opcode(), kArchStackPointerGreaterThan);\n\n  StackCheckKind kind =\n      static_cast<StackCheckKind>(MiscField::decode(instr->opcode()));\n  if (kind != StackCheckKind::kJSFunctionEntry) return false;\n\n  uint32_t stack_check_offset = *offset = GetStackCheckOffset();\n  return stack_check_offset > kStackLimitSlackForDeoptimizationInBytes;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CodeGenerator::GetStackCheckOffset\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Calculates the offset to be applied to stack checks.\",\n            \"logic\": \"Computes the offset based on the difference between optimized and unoptimized frame heights, and the maximum number of bytes pushed for function calls.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"uint32_t\",\n                \"description\": \"The calculated stack check offset.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nuint32_t CodeGenerator::GetStackCheckOffset() {\n  if (!frame_access_state()->has_frame()) {\n    DCHECK_EQ(max_unoptimized_frame_height_, 0);\n    DCHECK_EQ(max_pushed_argument_count_, 0);\n    return 0;\n  }\n\n  size_t incoming_parameter_count =\n      linkage_->GetIncomingDescriptor()->ParameterSlotCount();\n  DCHECK(is_int32(incoming_parameter_count));\n  int32_t optimized_frame_height =\n      static_cast<int32_t>(incoming_parameter_count) * kSystemPointerSize +\n      frame()->GetTotalFrameSlotCount() * kSystemPointerSize;\n  DCHECK(is_int32(max_unoptimized_frame_height_));\n  int32_t signed_max_unoptimized_frame_height =\n      static_cast<int32_t>(max_unoptimized_frame_height_);\n\n  // The offset is either the delta between the optimized frames and the\n  // interpreted frame, or the maximal number of bytes pushed to the stack\n  // while preparing for function calls, whichever is bigger.\n  uint32_t frame_height_delta = static_cast<uint32_t>(std::max(\n      signed_max_unoptimized_frame_height - optimized_frame_height, 0));\n  uint32_t max_pushed_argument_bytes =\n      static_cast<uint32_t>(max_pushed_argument_count_ * kSystemPointerSize);\n  return std::max(frame_height_delta, max_pushed_argument_bytes);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CodeGenerator::AssembleDeoptimizerCall\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles a call to the deoptimizer.\",\n            \"logic\": \"Generates code to call the deoptimizer based on the deoptimization exit information, including recording the deoptimization reason and kind, and binding the exception handler label.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exit\",\n                    \"type\": \"DeoptimizationExit*\",\n                    \"purpose\": \"The deoptimization exit information.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CodeGenerator::CodeGenResult\",\n                \"description\": \"kSuccess if the deoptimizer call was successfully assembled, kTooManyDeoptimizationBailouts otherwise.\"\n            },\n            \"dependencies\": [\n                \"Deoptimizer\",\n                \"DeoptimizeKind\",\n                \"DeoptimizeReason\",\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCodeGenerator::CodeGenResult CodeGenerator::AssembleDeoptimizerCall(\n    DeoptimizationExit* exit) {\n  int deoptimization_id = exit->deoptimization_id();\n  if (deoptimization_id > Deoptimizer::kMaxNumberOfEntries) {\n    return kTooManyDeoptimizationBailouts;\n  }\n\n  DeoptimizeKind deopt_kind = exit->kind();\n  DeoptimizeReason deoptimization_reason = exit->reason();\n  Label* jump_deoptimization_entry_label =\n      &jump_deoptimization_entry_labels_[static_cast<int>(deopt_kind)];\n  if (info()->source_positions()) {\n    masm()->RecordDeoptReason(deoptimization_reason, exit->node_id(),\n                              exit->pos(), deoptimization_id);\n  }\n\n  if (deopt_kind == DeoptimizeKind::kLazy) {\n    ++lazy_deopt_count_;\n    masm()->BindExceptionHandler(exit->label());\n  } else {\n    ++eager_deopt_count_;\n    masm()->bind(exit->label());\n  }\n  Builtin target = Deoptimizer::GetDeoptimizationEntry(deopt_kind);\n  masm()->CallForDeoptimization(target, deoptimization_id, exit->label(),\n                                deopt_kind, exit->continue_label(),\n                                jump_deoptimization_entry_label);\n\n  exit->set_emitted();\n\n  return kSuccess;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CodeGenerator::MaybeEmitOutOfLineConstantPool\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Emits the out-of-line constant pool if necessary.\",\n            \"logic\": \"Delegates to the MacroAssembler's MaybeEmitOutOfLineConstantPool method.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::MaybeEmitOutOfLineConstantPool() {\n  masm()->MaybeEmitOutOfLineConstantPool();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CodeGenerator::AssembleCode\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the main code, including prologue, instruction blocks, out-of-line code, and deoptimization exits.\",\n            \"logic\": \"Orchestrates the entire code generation process by setting up the frame, assembling instruction blocks in assembly order, assembling out-of-line code, and handling deoptimization exits.  Also includes logic for stack checks, source position recording, and frame management.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FrameScope\",\n                \"Linkage\",\n                \"CodeKind\",\n                \"Builtins\",\n                \"Frame\",\n                \"InstructionBlock\",\n                \"OutOfLineCode\",\n                \"DeoptimizationExit\",\n                \"JumpTable\",\n                \"SourcePosition\",\n                \"EhFrameWriter\",\n                \"ConstantPoolUnavailableScope\",\n                \"SafepointTableBuilder\",\n                \"HandlerTable\",\n                \"BytecodeOffset\",\n                \"DeoptimizationData\",\n                \"Factory\",\n                \"CodeDesc\",\n                \"TrustedByteArray\",\n                \"InstructionStream\",\n                \"Log\",\n                \"DeoptimizeKind\",\n                \"wasm::BuiltinLookup\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleCode() {\n  OptimizedCompilationInfo* info = this->info();\n  auto call_descriptor = linkage()->GetIncomingDescriptor();\n\n  // Compute incoming parameter count for code using JS linkage. This will\n  // ultimately set the parameter count on the resulting Code object.\n  if (call_descriptor->IsJSFunctionCall()) {\n    parameter_count_ = call_descriptor->ParameterSlotCount();\n    if (Builtins::IsBuiltinId(info->builtin())) {\n      CHECK_EQ(parameter_count_,\n               Builtins::GetStackParameterCount(info->builtin()));\n    } else if (info->has_bytecode_array()) {\n      CHECK_EQ(parameter_count_, info->bytecode_array()->parameter_count());\n    }\n  }\n\n  // Open a frame scope to indicate that there is a frame on the stack.  The\n  // MANUAL indicates that the scope shouldn't actually generate code to set up\n  // the frame (that is done in AssemblePrologue).\n  FrameScope frame_scope(masm(), StackFrame::MANUAL);\n\n  if (info->source_positions()) {\n    AssembleSourcePosition(start_source_position());\n  }\n  offsets_info_.code_start_register_check = masm()->pc_offset();\n\n  masm()->CodeEntry();\n\n  // Check that {kJavaScriptCallCodeStartRegister} has been set correctly.\n  if (v8_flags.debug_code && info->called_with_code_start_register()) {\n    masm()->RecordComment(\"-- Prologue: check code start register --\");\n    AssembleCodeStartRegisterCheck();\n  }\n\n#ifdef V8_ENABLE_LEAPTIERING\n  // Check that {kJavaScriptCallDispatchHandleRegister} has been set correctly.\n  if (v8_flags.debug_code && call_descriptor->IsJSFunctionCall()) {\n    masm()->RecordComment(\"-- Prologue: check dispatch handle register --\");\n    AssembleDispatchHandleRegisterCheck();\n  }\n#endif\n\n#if V8_ENABLE_WEBASSEMBLY\n  if (info->code_kind() == CodeKind::WASM_TO_JS_FUNCTION ||\n      info->builtin() == Builtin::kWasmToJsWrapperCSA ||\n      wasm::BuiltinLookup::IsWasmBuiltinId(info->builtin())) {\n    // By default the code generator can convert slot IDs to SP-relative memory\n    // operands depending on the offset if the encoding is more efficient.\n    // However the SP may switch to the"
}