{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-fast-api-calls.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-fast-api-calls.h\",\n        \"file_name\": \"v8-fast-api-calls.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides API for making fast API calls from embedder C++ functions to optimized JavaScript code, with type checking done in the compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers for size definitions, integer types, tuple manipulation, type traits, and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stddef.h>\n            #include <stdint.h>\n\n            #include <tuple>\n            #include <type_traits>\n\n            #include \"v8-internal.h\"      // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-typed-array.h\"   // NOLINT(build/include_directory)\n            #include \"v8-value.h\"         // NOLINT(build/include_directory)\n            #include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CTypeInfo\",\n            \"about\": \"Provides type information for C++ types used in fast API calls.\",\n            \"attributes\": [\n                {\n                    \"name\": \"type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The type of the C++ value.\"\n                },\n                {\n                    \"name\": \"sequence_type_\",\n                    \"type\": \"SequenceType\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the type is a scalar, sequence, or ArrayBuffer.\"\n                },\n                {\n                    \"name\": \"flags_\",\n                    \"type\": \"Flags\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores flags for additional type information, like whether range enforcement or clamping should be applied.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class CTypeInfo {\n            public:\n            enum class Type : uint8_t {\n                kVoid,\n                kBool,\n                kUint8,\n                kInt32,\n                kUint32,\n                kInt64,\n                kUint64,\n                kFloat32,\n                kFloat64,\n                kPointer,\n                kV8Value,\n                kSeqOneByteString,\n                kApiObject,  // This will be deprecated once all users have\n                            // migrated from v8::ApiObject to v8::Local<v8::Value>.\n                kAny,        // This is added to enable untyped representation of fast\n                            // call arguments for test purposes. It can represent any of\n                            // the other types stored in the same memory as a union\n                            // (see AnyCType declared below). This allows for\n                            // uniform passing of arguments w.r.t. their location\n                            // (in a register or on the stack), independent of their\n                            // actual type. It's currently used by the arm64 simulator\n                            // and can be added to the other simulators as well when fast\n                            // calls having both GP and FP params need to be supported.\n            };\n\n            // kCallbackOptionsType is not part of the Type enum\n            // because it is only used internally. Use value 255 that is larger\n            // than any valid Type enum.\n            static constexpr Type kCallbackOptionsType = Type(255);\n\n            enum class V8_DEPRECATE_SOON(\n                \"There is no special support in V8 anymore, there is no need to\"\n                \"use a SequenceType\") SequenceType : uint8_t {\n                kScalar,\n                kIsSequence,    // sequence<T>\n                kIsArrayBuffer  // ArrayBuffer\n            };\n\n            enum class Flags : uint8_t {\n                kNone = 0,\n                kAllowSharedBit = 1 << 0,   // Must be an ArrayBuffer or TypedArray\n                kEnforceRangeBit = 1 << 1,  // T must be integral\n                kClampBit = 1 << 2,         // T must be integral\n                kIsRestrictedBit = 1 << 3,  // T must be float or double\n            };\n\n            explicit constexpr CTypeInfo(Type type, Flags flags = Flags::kNone)\n                : type_(type), sequence_type_(SequenceType::kScalar), flags_(flags) {}\n\n            V8_DEPRECATE_SOON(\"Use CTypeInfo(Type, Flags) instead\")\n            constexpr CTypeInfo(Type type, SequenceType sequence_type,\n                                Flags flags = Flags::kNone)\n                : type_(type), sequence_type_(sequence_type), flags_(flags) {}\n\n            typedef uint32_t Identifier;\n            explicit constexpr CTypeInfo(Identifier identifier)\n                : CTypeInfo(static_cast<Type>(identifier >> 16),\n                            static_cast<SequenceType>((identifier >> 8) & 255),\n                            static_cast<Flags>(identifier & 255)) {}\n            constexpr Identifier GetId() const {\n                return static_cast<uint8_t>(type_) << 16 |\n                    static_cast<uint8_t>(sequence_type_) << 8 |\n                    static_cast<uint8_t>(flags_);\n            }\n\n            constexpr Type GetType() const { return type_; }\n            V8_DEPRECATE_SOON(\"Use the constant SequenceType::kScalar instead\")\n            constexpr SequenceType GetSequenceType() const { return sequence_type_; }\n            constexpr Flags GetFlags() const { return flags_; }\n\n            static constexpr bool IsIntegralType(Type type) {\n                return type == Type::kUint8 || type == Type::kInt32 ||\n                    type == Type::kUint32 || type == Type::kInt64 ||\n                    type == Type::kUint64;\n            }\n\n            static constexpr bool IsFloatingPointType(Type type) {\n                return type == Type::kFloat32 || type == Type::kFloat64;\n            }\n\n            static constexpr bool IsPrimitive(Type type) {\n                return IsIntegralType(type) || IsFloatingPointType(type) ||\n                    type == Type::kBool;\n            }\n\n            private:\n            Type type_;\n            SequenceType sequence_type_;\n            Flags flags_;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"FastOneByteString\",\n            \"about\": \"Represents a fast one-byte string with a pointer to the data and the length.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct FastOneByteString {\n            const char* data;\n            uint32_t length;\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CFunctionInfo\",\n            \"about\": \"Stores type information for C++ functions used in fast API calls.\",\n            \"attributes\": [\n                {\n                    \"name\": \"return_info_\",\n                    \"type\": \"CTypeInfo\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The return type of the function.\"\n                },\n                {\n                    \"name\": \"repr_\",\n                    \"type\": \"Int64Representation\",\n                    \"access\": \"private\",\n                    \"purpose\": \"How 64 bit integers are represented (Number or BigInt).\"\n                },\n                {\n                    \"name\": \"arg_count_\",\n                    \"type\": \"unsigned int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of arguments to the function.\"\n                },\n                {\n                    \"name\": \"arg_info_\",\n                    \"type\": \"CTypeInfo*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"An array of CTypeInfo objects, one for each argument.\"\n                }\n            ],\n            \"dependencies\": [\n                \"CTypeInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CFunctionInfo {\n            public:\n            enum class Int64Representation : uint8_t {\n                kNumber = 0,  // Use numbers to represent 64 bit integers.\n                kBigInt = 1,  // Use BigInts to represent 64 bit integers.\n            };\n\n            // Construct a struct to hold a CFunction's type information.\n            // |return_info| describes the function's return type.\n            // |arg_info| is an array of |arg_count| CTypeInfos describing the\n            //   arguments. Only the last argument may be of the special type\n            //   CTypeInfo::kCallbackOptionsType.\n            CFunctionInfo(const CTypeInfo& return_info, unsigned int arg_count,\n                            const CTypeInfo* arg_info,\n                            Int64Representation repr = Int64Representation::kNumber);\n\n            const CTypeInfo& ReturnInfo() const { return return_info_; }\n\n            // The argument count, not including the v8::FastApiCallbackOptions\n            // if present.\n            unsigned int ArgumentCount() const {\n                return HasOptions() ? arg_count_ - 1 : arg_count_;\n            }\n\n            Int64Representation GetInt64Representation() const { return repr_; }\n\n            // |index| must be less than ArgumentCount().\n            //  Note: if the last argument passed on construction of CFunctionInfo\n            //  has type CTypeInfo::kCallbackOptionsType, it is not included in\n            //  ArgumentCount().\n            const CTypeInfo& ArgumentInfo(unsigned int index) const;\n\n            bool HasOptions() const {\n                // The options arg is always the last one.\n                return arg_count_ > 0 && arg_info_[arg_count_ - 1].GetType() ==\n                                    CTypeInfo::kCallbackOptionsType;\n            }\n\n            private:\n            const CTypeInfo return_info_;\n            const Int64Representation repr_;\n            const unsigned int arg_count_;\n            const CTypeInfo* arg_info_;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"FastApiCallbackOptions\",\n            \"about\": \"A struct which may be passed to a fast call callback to signal fallback or access isolate data.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct FastApiCallbackOptions {\n            /**\n            * Creates a new instance of FastApiCallbackOptions for testing purpose.  The\n            * returned instance may be filled with mock data.\n            */\n            static FastApiCallbackOptions CreateForTesting(Isolate* isolate) {\n                return {};\n            }\n\n            v8::Isolate* isolate = nullptr;\n\n            /**\n            * The `data` passed to the FunctionTemplate constructor, or `undefined`.\n            */\n            v8::Local<v8::Value> data;\n            };\n        ]]></code>\n    </struct>\n    <union>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"union\",\n            \"name\": \"AnyCType\",\n            \"about\": \"Union to represent any supported C type for testing purposes in fast API calls.\",\n            \"dependencies\": [\n                \"FastOneByteString\",\n                \"FastApiCallbackOptions\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            union V8_TRIVIAL_ABI AnyCType {\n            AnyCType() : int64_value(0) {}\n\n            #if defined(V8_ENABLE_LOCAL_OFF_STACK_CHECK) && V8_HAS_ATTRIBUTE_TRIVIAL_ABI\n            // In this case, Local<T> is not trivially copyable and the implicit\n            // copy constructor and copy assignment for the union are deleted.\n            AnyCType(const AnyCType& other) : int64_value(other.int64_value) {}\n            AnyCType& operator=(const AnyCType& other) {\n                int64_value = other.int64_value;\n                return *this;\n            }\n            #endif\n\n            bool bool_value;\n            int32_t int32_value;\n            uint32_t uint32_value;\n            int64_t int64_value;\n            uint64_t uint64_value;\n            float float_value;\n            double double_value;\n            void* pointer_value;\n            Local<Object> object_value;\n            Local<Array> sequence_value;\n            const FastOneByteString* string_value;\n            FastApiCallbackOptions* options_value;\n            };\n        ]]></code>\n    </union>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CFunction\",\n            \"about\": \"Represents a C++ function that can be called from JavaScript via the fast API.\",\n            \"attributes\": [\n                {\n                    \"name\": \"address_\",\n                    \"type\": \"const void*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The address of the C++ function.\"\n                },\n                {\n                    \"name\": \"type_info_\",\n                    \"type\": \"const CFunctionInfo*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Type information for the function's arguments and return type.\"\n                }\n            ],\n            \"dependencies\": [\n                \"CTypeInfo\",\n                \"CFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT CFunction {\n            public:\n            constexpr CFunction() : address_(nullptr), type_info_(nullptr) {}\n\n            const CTypeInfo& ReturnInfo() const { return type_info_->ReturnInfo(); }\n\n            const CTypeInfo& ArgumentInfo(unsigned int index) const {\n                return type_info_->ArgumentInfo(index);\n            }\n\n            unsigned int ArgumentCount() const { return type_info_->ArgumentCount(); }\n\n            const void* GetAddress() const { return address_; }\n            CFunctionInfo::Int64Representation GetInt64Representation() const {\n                return type_info_->GetInt64Representation();\n            }\n            const CFunctionInfo* GetTypeInfo() const { return type_info_; }\n\n            enum class OverloadResolution { kImpossible, kAtRuntime, kAtCompileTime };\n\n            template <typename F>\n            static CFunction Make(F* func,\n                                CFunctionInfo::Int64Representation int64_rep =\n                                    CFunctionInfo::Int64Representation::kNumber) {\n                CFunction result = ArgUnwrap<F*>::Make(func, int64_rep);\n                result.GetInt64Representation();\n                return result;\n            }\n\n            // Provided for testing purposes.\n            template <typename R, typename... Args, typename R_Patch,\n                        typename... Args_Patch>\n            static CFunction Make(R (*func)(Args...),\n                                R_Patch (*patching_func)(Args_Patch...),\n                                CFunctionInfo::Int64Representation int64_rep =\n                                    CFunctionInfo::Int64Representation::kNumber) {\n                CFunction c_func = ArgUnwrap<R (*)(Args...)>::Make(func, int64_rep);\n                static_assert(\n                    sizeof...(Args_Patch) == sizeof...(Args),\n                    \"The patching function must have the same number of arguments.\");\n                c_func.address_ = reinterpret_cast<void*>(patching_func);\n                return c_func;\n            }\n\n            CFunction(const void* address, const CFunctionInfo* type_info);\n\n            private:\n            const void* address_;\n            const CFunctionInfo* type_info_;\n\n            template <typename F>\n            class ArgUnwrap {\n                static_assert(sizeof(F) != sizeof(F),\n                            \"CFunction must be created from a function pointer.\");\n            };\n\n            template <typename R, typename... Args>\n            class ArgUnwrap<R (*)(Args...)> {\n            public:\n                static CFunction Make(R (*func)(Args...),\n                                    CFunctionInfo::Int64Representation int64_rep =\n                                        CFunctionInfo::Int64Representation::kNumber);\n            };\n            };\n        ]]></code>\n    </class>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"internal\",\n            \"about\": \"Internal helper templates and structs for implementing the CFunction and CTypeInfo APIs.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n\n            // Helper to count the number of occurances of `T` in `List`\n            template <typename T, typename... List>\n            struct count : std::integral_constant<int, 0> {};\n            template <typename T, typename... Args>\n            struct count<T, T, Args...>\n                : std::integral_constant<std::size_t, 1 + count<T, Args...>::value> {};\n            template <typename T, typename U, typename... Args>\n            struct count<T, U, Args...> : count<T, Args...> {};\n\n            template <CFunctionInfo::Int64Representation Representation,\n                    typename RetBuilder, typename... ArgBuilders>\n            class CFunctionInfoImpl : public CFunctionInfo {\n            static constexpr int kOptionsArgCount =\n                count<FastApiCallbackOptions&, ArgBuilders...>();\n            static constexpr int kReceiverCount = 1;\n\n            static_assert(kOptionsArgCount == 0 || kOptionsArgCount == 1,\n                            \"Only one options parameter is supported.\");\n\n            static_assert(sizeof...(ArgBuilders) >= kOptionsArgCount + kReceiverCount,\n                            \"The receiver or the options argument is missing.\");\n\n            public:\n            constexpr CFunctionInfoImpl()\n                : CFunctionInfo(RetBuilder::Build(), sizeof...(ArgBuilders),\n                                arg_info_storage_, Representation),\n                arg_info_storage_{ArgBuilders::Build()...} {\n                constexpr CTypeInfo::Type kReturnType = RetBuilder::Build().GetType();\n                static_assert(kReturnType == CTypeInfo::Type::kVoid ||\n                                    kReturnType == CTypeInfo::Type::kBool ||\n                                    kReturnType == CTypeInfo::Type::kInt32 ||\n                                    kReturnType == CTypeInfo::Type::kUint32 ||\n                                    kReturnType == CTypeInfo::Type::kInt64 ||\n                                    kReturnType == CTypeInfo::Type::kUint64 ||\n                                    kReturnType == CTypeInfo::Type::kFloat32 ||\n                                    kReturnType == CTypeInfo::Type::kFloat64 ||\n                                    kReturnType == CTypeInfo::Type::kPointer ||\n                                    kReturnType == CTypeInfo::Type::kAny,\n                                \"String and api object values are not currently \"\n                                \"supported return types.\");\n            }\n\n            private:\n            const CTypeInfo arg_info_storage_[sizeof...(ArgBuilders)];\n            };\n\n            template <typename T>\n            struct TypeInfoHelper {\n            static_assert(sizeof(T) != sizeof(T), \"This type is not supported\");\n            };\n\n            #define SPECIALIZE_GET_TYPE_INFO_HELPER_FOR(T, Enum)                          \\\n            template <>                                                                 \\\n            struct TypeInfoHelper<T> {                                                  \\\n                static constexpr CTypeInfo::Flags Flags() {                               \\\n                return CTypeInfo::Flags::kNone;                                         \\\n                }                                                                         \\\n                                                                                        \\\n                static constexpr CTypeInfo::Type Type() { return CTypeInfo::Type::Enum; } \\\n            };\n\n            template <CTypeInfo::Type type>\n            struct CTypeInfoTraits {};\n\n            #define DEFINE_TYPE_INFO_TRAITS(CType, Enum)      \\\n            template <>                                     \\\n            struct CTypeInfoTraits<CTypeInfo::Type::Enum> { \\\n                using ctype = CType;                          \\\n            };\n\n            #define PRIMITIVE_C_TYPES(V) \\\n            V(bool, kBool)             \\\n            V(uint8_t, kUint8)         \\\n            V(int32_t, kInt32)         \\\n            V(uint32_t, kUint32)       \\\n            V(int64_t, kInt64)         \\\n            V(uint64_t, kUint64)       \\\n            V(float, kFloat32)         \\\n            V(double, kFloat64)        \\\n            V(void*, kPointer)\n\n            // Same as above, but includes deprecated types for compatibility.\n            #define ALL_C_TYPES(V)               \\\n            PRIMITIVE_C_TYPES(V)               \\\n            V(void, kVoid)                     \\\n            V(v8::Local<v8::Value>, kV8Value)  \\\n            V(v8::Local<v8::Object>, kV8Value) \\\n            V(v8::Local<v8::Array>, kV8Value)  \\\n            V(AnyCType, kAny)\n\n            // ApiObject was a temporary solution to wrap the pointer to the v8::Value.\n            // Please use v8::Local<v8::Value> in new code for the arguments and\n            // v8::Local<v8::Object> for the receiver, as ApiObject will be deprecated.\n\n            ALL_C_TYPES(SPECIALIZE_GET_TYPE_INFO_HELPER_FOR)\n            PRIMITIVE_C_TYPES(DEFINE_TYPE_INFO_TRAITS)\n\n            #undef PRIMITIVE_C_TYPES\n            #undef ALL_C_TYPES\n\n            #undef TYPED_ARRAY_C_TYPES\n\n            template <>\n            struct TypeInfoHelper<FastApiCallbackOptions&> {\n            static constexpr CTypeInfo::Flags Flags() { return CTypeInfo::Flags::kNone; }\n\n            static constexpr CTypeInfo::Type Type() {\n                return CTypeInfo::kCallbackOptionsType;\n            }\n            };\n\n            template <>\n            struct TypeInfoHelper<const FastOneByteString&> {\n            static constexpr CTypeInfo::Flags Flags() { return CTypeInfo::Flags::kNone; }\n\n            static constexpr CTypeInfo::Type Type() {\n                return CTypeInfo::Type::kSeqOneByteString;\n            }\n            };\n\n            #define STATIC_ASSERT_IMPLIES(COND, ASSERTION, MSG) \\\n            static_assert(((COND) == 0) || (ASSERTION), MSG)\n\n            }  // namespace internal\n        ]]></code>\n    </namespace>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CTypeInfoBuilder\",\n            \"about\": \"A template class for building CTypeInfo objects with specific flags.\",\n            \"dependencies\": [\n                \"internal::TypeInfoHelper\",\n                \"CTypeInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, CTypeInfo::Flags... Flags>\n            class V8_EXPORT CTypeInfoBuilder {\n            public:\n            using BaseType = T;\n\n            static constexpr CTypeInfo Build() {\n                constexpr CTypeInfo::Flags kFlags =\n                    MergeFlags(internal::TypeInfoHelper<T>::Flags(), Flags...);\n                constexpr CTypeInfo::Type kType = internal::TypeInfoHelper<T>::Type();\n\n                STATIC_ASSERT_IMPLIES(\n                    uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kEnforceRangeBit),\n                    CTypeInfo::IsIntegralType(kType),\n                    \"kEnforceRangeBit is only allowed for integral types.\");\n                STATIC_ASSERT_IMPLIES(\n                    uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kClampBit),\n                    CTypeInfo::IsIntegralType(kType),\n                    \"kClampBit is only allowed for integral types.\");\n                STATIC_ASSERT_IMPLIES(\n                    uint8_t(kFlags) & uint8_t(CTypeInfo::Flags::kIsRestrictedBit),\n                    CTypeInfo::IsFloatingPointType(kType),\n                    \"kIsRestrictedBit is only allowed for floating point types.\");\n\n                // Return the same type with the merged flags.\n                return CTypeInfo(internal::TypeInfoHelper<T>::Type(), kFlags);\n            }\n\n            private:\n            template <typename... Rest>\n            static constexpr CTypeInfo::Flags MergeFlags(CTypeInfo::Flags flags,\n                                                        Rest... rest) {\n                return CTypeInfo::Flags(uint8_t(flags) | uint8_t(MergeFlags(rest...)));\n            }\n            static constexpr CTypeInfo::Flags MergeFlags() { return CTypeInfo::Flags(0); }\n            };\n        ]]></code>\n    </class>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"internal\",\n            \"about\": \"Internal namespace for CFunctionBuilder implementation details.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n            template <typename RetBuilder, typename... ArgBuilders>\n            class CFunctionBuilderWithFunction {\n            public:\n            explicit constexpr CFunctionBuilderWithFunction(const void* fn) : fn_(fn) {}\n\n            template <CTypeInfo::Flags... Flags>\n            constexpr auto Ret() {\n                return CFunctionBuilderWithFunction<\n                    CTypeInfoBuilder<typename RetBuilder::BaseType, Flags...>,\n                    ArgBuilders...>(fn_);\n            }\n\n            template <unsigned int N, CTypeInfo::Flags... Flags>\n            constexpr auto Arg() {\n                // Return a copy of the builder with the Nth arg builder merged with\n                // template parameter pack Flags.\n                return ArgImpl<N, Flags...>(\n                    std::make_index_sequence<sizeof...(ArgBuilders)>());\n            }\n\n            // Provided for testing purposes.\n            template <typename Ret, typename... Args>\n            auto Patch(Ret (*patching_func)(Args...)) {\n                static_assert(\n                    sizeof...(Args) == sizeof...(ArgBuilders),\n                    \"The patching function must have the same number of arguments.\");\n                fn_ = reinterpret_cast<void*>(patching_func);\n                return *this;\n            }\n\n            template <CFunctionInfo::Int64Representation Representation =\n                                CFunctionInfo::Int64Representation::kNumber>\n            auto Build() {\n                static CFunctionInfoImpl<Representation, RetBuilder, ArgBuilders...>\n                    instance;\n                return CFunction(fn_, &instance);\n            }\n\n            private:\n            template <bool Merge, unsigned int N, CTypeInfo::Flags... Flags>\n            struct GetArgBuilder;\n\n            // Returns the same ArgBuilder as the one at index N, including its flags.\n            // Flags in the template parameter pack are ignored.\n            template <unsigned int N, CTypeInfo::Flags... Flags>\n            struct GetArgBuilder<false, N, Flags...> {\n                using type =\n                    typename std::tuple_element<N, std::tuple<ArgBuilders...>>::type;\n            };\n\n            // Returns an ArgBuilder with the same base type as the one at index N,\n            // but merges the flags with the flags in the template parameter pack.\n            template <unsigned int N, CTypeInfo::Flags... Flags>\n            struct GetArgBuilder<true, N, Flags...> {\n                using type = CTypeInfoBuilder<\n                    typename std::tuple_element<N,\n                                                std::tuple<ArgBuilders...>>::type::BaseType,\n                    std::tuple_element<N, std::tuple<ArgBuilders...>>::type::Build()\n                        .GetFlags(),\n                    Flags...>;\n            };\n\n            // Return a copy of the CFunctionBuilder, but merges the Flags on\n            // ArgBuilder index N with the new Flags passed in the template parameter\n            // pack.\n            template <unsigned int N, CTypeInfo::Flags... Flags, size_t... I>\n            constexpr auto ArgImpl(std::index_sequence<I...>) {\n                return CFunctionBuilderWithFunction<\n                    RetBuilder, typename GetArgBuilder<N == I, I, Flags...>::type...>(fn_);\n            }\n\n            const void* fn_;\n            };\n\n            class CFunctionBuilder {\n            public:\n            constexpr CFunctionBuilder() {}\n\n            template <typename R, typename... Args>\n            constexpr auto Fn(R (*fn)(Args...)) {\n                return CFunctionBuilderWithFunction<CTypeInfoBuilder<R>,\n                                                    CTypeInfoBuilder<Args>...>(\n                    reinterpret_cast<const void*>(fn));\n            }\n            };\n\n            }  // namespace internal\n        ]]></code>\n    </namespace>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Make\",\n            \"parent\": \"CFunction::ArgUnwrap<R (*)(Args...)>\",\n            \"about\": \"Creates a CFunction object from a function pointer with the specified Int64Representation.\",\n            \"logic\": \"Creates a CFunction object from a function pointer using the internal CFunctionBuilder. It supports different Int64Representation (Number or BigInt).\",\n            \"parameters\": [\n                {\n                    \"name\": \"func\",\n                    \"type\": \"R (*)(Args...)\",\n                    \"purpose\": \"The function pointer to wrap.\"\n                },\n                {\n                    \"name\": \"int64_rep\",\n                    \"type\": \"CFunctionInfo::Int64Representation\",\n                    \"purpose\": \"The representation of 64-bit integers (Number or BigInt).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CFunction\",\n                \"description\": \"The created CFunction object.\"\n            },\n            \"dependencies\": [\n                \"internal::CFunctionBuilder\",\n                \"CFunction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename R, typename... Args>\n            CFunction CFunction::ArgUnwrap<R (*)(Args...)>::Make(\n                R (*func)(Args...), CFunctionInfo::Int64Representation int64_rep) {\n            if (int64_rep == CFunctionInfo::Int64Representation::kNumber) {\n                return internal::CFunctionBuilder().Fn(func).Build();\n            }\n            return internal::CFunctionBuilder()\n                .Fn(func)\n                .template Build<CFunctionInfo::Int64Representation::kBigInt>();\n            }\n        ]]></code>\n    </func>\n    <type_alias>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"CFunctionBuilder\",\n            \"about\": \"Alias for the internal CFunctionBuilder class.\",\n            \"type\": \"type alias\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using CFunctionBuilder = internal::CFunctionBuilder;\n        ]]></code>\n    </type_alias>\n    <variable>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"kTypeInfoInt32\",\n            \"type\": \"constexpr CTypeInfo\",\n            \"about\": \"Constant CTypeInfo object for int32_t type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            static constexpr CTypeInfo kTypeInfoInt32 = CTypeInfo(CTypeInfo::Type::kInt32);\n        ]]></code>\n    </variable>\n    <variable>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"kTypeInfoFloat64\",\n            \"type\": \"constexpr CTypeInfo\",\n            \"about\": \"Constant CTypeInfo object for double type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            static constexpr CTypeInfo kTypeInfoFloat64 =\n                CTypeInfo(CTypeInfo::Type::kFloat64);\n        ]]></code>\n    </variable>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryToCopyAndConvertArrayToCppBuffer\",\n            \"about\": \"Copies the contents of a JavaScript array to a C++ buffer, performing type conversion if necessary.\",\n            \"logic\": \"Attempts to copy and convert the elements of a JavaScript array to a C++ buffer. Fails if the array is too long or contains unsupported types.\",\n            \"parameters\": [\n                {\n                    \"name\": \"src\",\n                    \"type\": \"Local<Array>\",\n                    \"purpose\": \"The source JavaScript array.\"\n                },\n                {\n                    \"name\": \"dst\",\n                    \"type\": \"T*\",\n                    \"purpose\": \"The destination C++ buffer.\"\n                },\n                {\n                    \"name\": \"max_length\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The maximum length of the destination buffer.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True on success, false on failure.\"\n            },\n            \"dependencies\": [\n                \"CTypeInfo\",\n                \"CTypeInfoTraits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <CTypeInfo::Identifier type_info_id, typename T>\n            bool V8_EXPORT V8_WARN_UNUSED_RESULT TryToCopyAndConvertArrayToCppBuffer(\n                Local<Array> src, T* dst, uint32_t max_length);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryToCopyAndConvertArrayToCppBuffer\",\n            \"about\": \"Specialization of TryToCopyAndConvertArrayToCppBuffer for int32_t.\",\n            \"logic\": \"Attempts to copy and convert the elements of a JavaScript array to an int32_t C++ buffer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"src\",\n                    \"type\": \"Local<Array>\",\n                    \"purpose\": \"The source JavaScript array.\"\n                },\n                {\n                    \"name\": \"dst\",\n                    \"type\": \"int32_t*\",\n                    \"purpose\": \"The destination int32_t C++ buffer.\"\n                },\n                {\n                    \"name\": \"max_length\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The maximum length of the destination"
}