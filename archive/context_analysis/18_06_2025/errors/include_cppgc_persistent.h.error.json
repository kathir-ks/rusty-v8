{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/persistent.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 335, column 51",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/persistent.h\",\n        \"file_name\": \"persistent.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines persistent and weak_persistent handles for managing object lifetimes in cppgc.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library features and cppgc internal headers for type traits, pointer policies, sentinel pointers, source locations, visitor pattern, and build configuration.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <type_traits>\n\n#include \"cppgc/internal/persistent-node.h\"\n#include \"cppgc/internal/pointer-policies.h\"\n#include \"cppgc/sentinel-pointer.h\"\n#include \"cppgc/source-location.h\"\n#include \"cppgc/type-traits.h\"\n#include \"cppgc/visitor.h\"\n#include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PersistentBase\",\n            \"about\": \"Base class for persistent handles, managing the raw pointer and persistent node.\",\n            \"attributes\": [\n                {\n                    \"name\": \"raw_\",\n                    \"type\": \"const void*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Stores the raw pointer to the managed object.\"\n                },\n                {\n                    \"name\": \"node_\",\n                    \"type\": \"PersistentNode*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Stores the PersistentNode associated with this handle.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass PersistentBase {\n protected:\n  PersistentBase() = default;\n  explicit PersistentBase(const void* raw) : raw_(raw) {}\n\n  const void* GetValue() const { return raw_; }\n  void SetValue(const void* value) { raw_ = value; }\n\n  PersistentNode* GetNode() const { return node_; }\n  void SetNode(PersistentNode* node) { node_ = node; }\n\n  // Performs a shallow clear which assumes that internal persistent nodes are\n  // destroyed elsewhere.\n  void ClearFromGC() const {\n    raw_ = nullptr;\n    node_ = nullptr;\n  }\n\n protected:\n  mutable const void* raw_ = nullptr;\n  mutable PersistentNode* node_ = nullptr;\n\n  friend class PersistentRegionBase;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BasicPersistent\",\n            \"about\": \"A template class that implements the persistent handle with configurable weakness policy, location policy, and checking policy.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"PersistentBase\",\n                \"WeaknessPolicy\",\n                \"LocationPolicy\",\n                \"CheckingPolicy\",\n                \"SourceLocation\",\n                \"SentinelPointer\",\n                \"internal::BasicMember\",\n                \"RootVisitor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T, typename WeaknessPolicy, typename LocationPolicy,\n          typename CheckingPolicy>\nclass BasicPersistent final : public PersistentBase,\n                              public LocationPolicy,\n                              private WeaknessPolicy,\n                              private CheckingPolicy {\n public:\n  using typename WeaknessPolicy::IsStrongPersistent;\n  using PointeeType = T;\n\n  // Null-state/sentinel constructors.\n  BasicPersistent(  // NOLINT\n      const SourceLocation& loc = SourceLocation::Current())\n      : LocationPolicy(loc) {}\n\n  BasicPersistent(std::nullptr_t,  // NOLINT\n                  const SourceLocation& loc = SourceLocation::Current())\n      : LocationPolicy(loc) {}\n\n  BasicPersistent(  // NOLINT\n      SentinelPointer s, const SourceLocation& loc = SourceLocation::Current())\n      : PersistentBase(s), LocationPolicy(loc) {}\n\n  // Raw value constructors.\n  BasicPersistent(T* raw,  // NOLINT\n                  const SourceLocation& loc = SourceLocation::Current())\n      : PersistentBase(raw), LocationPolicy(loc) {\n    if (!IsValid()) return;\n    SetNode(WeaknessPolicy::GetPersistentRegion(GetValue())\n                .AllocateNode(this, &TraceAsRoot));\n    this->CheckPointer(Get());\n  }\n\n  BasicPersistent(T& raw,  // NOLINT\n                  const SourceLocation& loc = SourceLocation::Current())\n      : BasicPersistent(&raw, loc) {}\n\n  // Copy ctor.\n  BasicPersistent(const BasicPersistent& other,\n                  const SourceLocation& loc = SourceLocation::Current())\n      : BasicPersistent(other.Get(), loc) {}\n\n  // Heterogeneous ctor.\n  template <typename U, typename OtherWeaknessPolicy,\n            typename OtherLocationPolicy, typename OtherCheckingPolicy,\n            typename = std::enable_if_t<std::is_base_of<T, U>::value>>\n  // NOLINTNEXTLINE\n  BasicPersistent(\n      const BasicPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,\n                            OtherCheckingPolicy>& other,\n      const SourceLocation& loc = SourceLocation::Current())\n      : BasicPersistent(other.Get(), loc) {}\n\n  // Move ctor. The heterogeneous move ctor is not supported since e.g.\n  // persistent can't reuse persistent node from weak persistent.\n  BasicPersistent(\n      BasicPersistent&& other,\n      const SourceLocation& loc = SourceLocation::Current()) noexcept\n      : PersistentBase(std::move(other)), LocationPolicy(std::move(other)) {\n    if (!IsValid()) return;\n    GetNode()->UpdateOwner(this);\n    other.SetValue(nullptr);\n    other.SetNode(nullptr);\n    this->CheckPointer(Get());\n  }\n\n  // Constructor from member.\n  template <typename U, typename MemberBarrierPolicy,\n            typename MemberWeaknessTag, typename MemberCheckingPolicy,\n            typename MemberStorageType,\n            typename = std::enable_if_t<std::is_base_of<T, U>::value>>\n  // NOLINTNEXTLINE\n  BasicPersistent(const internal::BasicMember<\n                      U, MemberBarrierPolicy, MemberWeaknessTag,\n                      MemberCheckingPolicy, MemberStorageType>& member,\n                  const SourceLocation& loc = SourceLocation::Current())\n      : BasicPersistent(member.Get(), loc) {}\n\n  ~BasicPersistent() { Clear(); }\n\n  // Copy assignment.\n  BasicPersistent& operator=(const BasicPersistent& other) {\n    return operator=(other.Get());\n  }\n\n  template <typename U, typename OtherWeaknessPolicy,\n            typename OtherLocationPolicy, typename OtherCheckingPolicy,\n            typename = std::enable_if_t<std::is_base_of<T, U>::value>>\n  BasicPersistent& operator=(\n      const BasicPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,\n                            OtherCheckingPolicy>& other) {\n    return operator=(other.Get());\n  }\n\n  // Move assignment.\n  BasicPersistent& operator=(BasicPersistent&& other) noexcept {\n    if (this == &other) return *this;\n    Clear();\n    PersistentBase::operator=(std::move(other));\n    LocationPolicy::operator=(std::move(other));\n    if (!IsValid()) return *this;\n    GetNode()->UpdateOwner(this);\n    other.SetValue(nullptr);\n    other.SetNode(nullptr);\n    this->CheckPointer(Get());\n    return *this;\n  }\n\n  // Assignment from member.\n  template <typename U, typename MemberBarrierPolicy,\n            typename MemberWeaknessTag, typename MemberCheckingPolicy,\n            typename MemberStorageType,\n            typename = std::enable_if_t<std::is_base_of<T, U>::value>>\n  BasicPersistent& operator=(\n      const internal::BasicMember<U, MemberBarrierPolicy, MemberWeaknessTag,\n                                  MemberCheckingPolicy, MemberStorageType>&\n          member) {\n    return operator=(member.Get());\n  }\n\n  BasicPersistent& operator=(T* other) {\n    Assign(other);\n    return *this;\n  }\n\n  BasicPersistent& operator=(std::nullptr_t) {\n    Clear();\n    return *this;\n  }\n\n  BasicPersistent& operator=(SentinelPointer s) {\n    Assign(s);\n    return *this;\n  }\n\n  explicit operator bool() const { return Get(); }\n  // Historically we allow implicit conversions to T*.\n  // NOLINTNEXTLINE\n  operator T*() const { return Get(); }\n  T* operator->() const { return Get(); }\n  T& operator*() const { return *Get(); }\n\n  // CFI cast exemption to allow passing SentinelPointer through T* and support\n  // heterogeneous assignments between different Member and Persistent handles\n  // based on their actual types.\n  V8_CLANG_NO_SANITIZE(\"cfi-unrelated-cast\") T* Get() const {\n    // The const_cast below removes the constness from PersistentBase storage.\n    // The following static_cast re-adds any constness if specified through the\n    // user-visible template parameter T.\n    return static_cast<T*>(const_cast<void*>(GetValue()));\n  }\n\n  void Clear() {\n    // Simplified version of `Assign()` to allow calling without a complete type\n    // `T`.\n    if (IsValid()) {\n      WeaknessPolicy::GetPersistentRegion(GetValue()).FreeNode(GetNode());\n      SetNode(nullptr);\n    }\n    SetValue(nullptr);\n  }\n\n  T* Release() {\n    T* result = Get();\n    Clear();\n    return result;\n  }\n\n  template <typename U, typename OtherWeaknessPolicy = WeaknessPolicy,\n            typename OtherLocationPolicy = LocationPolicy,\n            typename OtherCheckingPolicy = CheckingPolicy>\n  BasicPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,\n                  OtherCheckingPolicy>\n  To() const {\n    return BasicPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,\n                           OtherCheckingPolicy>(static_cast<U*>(Get()));\n  }\n\n private:\n  static void TraceAsRoot(RootVisitor& root_visitor, const void* ptr) {\n    root_visitor.Trace(*static_cast<const BasicPersistent*>(ptr));\n  }\n\n  bool IsValid() const {\n    // Ideally, handling kSentinelPointer would be done by the embedder. On the\n    // other hand, having Persistent aware of it is beneficial since no node\n    // gets wasted.\n    return GetValue() != nullptr && GetValue() != kSentinelPointer;\n  }\n\n  void Assign(T* ptr) {\n    if (IsValid()) {\n      if (ptr && ptr != kSentinelPointer) {\n        // Simply assign the pointer reusing the existing node.\n        SetValue(ptr);\n        this->CheckPointer(ptr);\n        return;\n      }\n      WeaknessPolicy::GetPersistentRegion(GetValue()).FreeNode(GetNode());\n      SetNode(nullptr);\n    }\n    SetValue(ptr);\n    if (!IsValid()) return;\n    SetNode(WeaknessPolicy::GetPersistentRegion(GetValue())\n                .AllocateNode(this, &TraceAsRoot));\n    this->CheckPointer(Get());\n  }\n\n  void ClearFromGC() const {\n    if (IsValid()) {\n      WeaknessPolicy::GetPersistentRegion(GetValue()).FreeNode(GetNode());\n      PersistentBase::ClearFromGC();\n    }\n  }\n\n  // Set Get() for details.\n  V8_CLANG_NO_SANITIZE(\"cfi-unrelated-cast\")\n  T* GetFromGC() const {\n    return static_cast<T*>(const_cast<void*>(GetValue()));\n  }\n\n  friend class internal::RootVisitor;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for BasicPersistent handles.\",\n            \"parameters\": [\n                {\n                    \"name\": \"p1\",\n                    \"type\": \"const BasicPersistent&\",\n                    \"purpose\": \"First persistent handle.\"\n                },\n                {\n                    \"name\": \"p2\",\n                    \"type\": \"const BasicPersistent&\",\n                    \"purpose\": \"Second persistent handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handles point to the same object, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"BasicPersistent\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T1, typename WeaknessPolicy1, typename LocationPolicy1,\n          typename CheckingPolicy1, typename T2, typename WeaknessPolicy2,\n          typename LocationPolicy2, typename CheckingPolicy2>\nbool operator==(const BasicPersistent<T1, WeaknessPolicy1, LocationPolicy1,\n                                      CheckingPolicy1>& p1,\n                const BasicPersistent<T2, WeaknessPolicy2, LocationPolicy2,\n                                      CheckingPolicy2>& p2) {\n  return p1.Get() == p2.Get();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for BasicPersistent handles.\",\n            \"parameters\": [\n                {\n                    \"name\": \"p1\",\n                    \"type\": \"const BasicPersistent&\",\n                    \"purpose\": \"First persistent handle.\"\n                },\n                {\n                    \"name\": \"p2\",\n                    \"type\": \"const BasicPersistent&\",\n                    \"purpose\": \"Second persistent handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handles point to different objects, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"BasicPersistent\",\n                \"operator==\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T1, typename WeaknessPolicy1, typename LocationPolicy1,\n          typename CheckingPolicy1, typename T2, typename WeaknessPolicy2,\n          typename LocationPolicy2, typename CheckingPolicy2>\nbool operator!=(const BasicPersistent<T1, WeaknessPolicy1, LocationPolicy1,\n                                      CheckingPolicy1>& p1,\n                const BasicPersistent<T2, WeaknessPolicy2, LocationPolicy2,\n                                      CheckingPolicy2>& p2) {\n  return !(p1 == p2);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for BasicPersistent and BasicMember handles.\",\n            \"parameters\": [\n                {\n                    \"name\": \"p\",\n                    \"type\": \"const BasicPersistent&\",\n                    \"purpose\": \"Persistent handle.\"\n                },\n                {\n                    \"name\": \"m\",\n                    \"type\": \"const BasicMember&\",\n                    \"purpose\": \"Member handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handles point to the same object, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"BasicPersistent\",\n                \"BasicMember\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T1, typename PersistentWeaknessPolicy,\n          typename PersistentLocationPolicy, typename PersistentCheckingPolicy,\n          typename T2, typename MemberWriteBarrierPolicy,\n          typename MemberWeaknessTag, typename MemberCheckingPolicy,\n          typename MemberStorageType>\nbool operator==(\n    const BasicPersistent<T1, PersistentWeaknessPolicy,\n                          PersistentLocationPolicy, PersistentCheckingPolicy>&\n        p,\n    const BasicMember<T2, MemberWeaknessTag, MemberWriteBarrierPolicy,\n                      MemberCheckingPolicy, MemberStorageType>& m) {\n  return p.Get() == m.Get();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for BasicPersistent and BasicMember handles.\",\n            \"parameters\": [\n                {\n                    \"name\": \"p\",\n                    \"type\": \"const BasicPersistent&\",\n                    \"purpose\": \"Persistent handle.\"\n                },\n                {\n                    \"name\": \"m\",\n                    \"type\": \"const BasicMember&\",\n                    \"purpose\": \"Member handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handles point to different objects, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"BasicPersistent\",\n                \"BasicMember\",\n                \"operator==\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T1, typename PersistentWeaknessPolicy,\n          typename PersistentLocationPolicy, typename PersistentCheckingPolicy,\n          typename T2, typename MemberWriteBarrierPolicy,\n          typename MemberWeaknessTag, typename MemberCheckingPolicy,\n          typename MemberStorageType>\nbool operator!=(\n    const BasicPersistent<T1, PersistentWeaknessPolicy,\n                          PersistentLocationPolicy, PersistentCheckingPolicy>&\n        p,\n    const BasicMember<T2, MemberWeaknessTag, MemberWriteBarrierPolicy,\n                      MemberCheckingPolicy, MemberStorageType>& m) {\n  return !(p == m);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for BasicMember and BasicPersistent handles.\",\n            \"parameters\": [\n                {\n                    \"name\": \"m\",\n                    \"type\": \"const BasicMember&\",\n                    \"purpose\": \"Member handle.\"\n                },\n                {\n                    \"name\": \"p\",\n                    \"type\": \"const BasicPersistent&\",\n                    \"purpose\": \"Persistent handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handles point to the same object, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"BasicPersistent\",\n                \"BasicMember\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T1, typename MemberWriteBarrierPolicy,\n          typename MemberWeaknessTag, typename MemberCheckingPolicy,\n          typename MemberStorageType, typename T2,\n          typename PersistentWeaknessPolicy, typename PersistentLocationPolicy,\n          typename PersistentCheckingPolicy>\nbool operator==(\n    const BasicMember<T2, MemberWeaknessTag, MemberWriteBarrierPolicy,\n                      MemberCheckingPolicy, MemberStorageType>& m,\n    const BasicPersistent<T1, PersistentWeaknessPolicy,\n                          PersistentLocationPolicy, PersistentCheckingPolicy>&\n        p) {\n  return m.Get() == p.Get();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for BasicMember and BasicPersistent handles.\",\n            \"parameters\": [\n                {\n                    \"name\": \"m\",\n                    \"type\": \"const BasicMember&\",\n                    \"purpose\": \"Member handle.\"\n                },\n                {\n                    \"name\": \"p\",\n                    \"type\": \"const BasicPersistent&\",\n                    \"purpose\": \"Persistent handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handles point to different objects, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"BasicPersistent\",\n                \"BasicMember\",\n                \"operator==\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T1, typename MemberWriteBarrierPolicy,\n          typename MemberWeaknessTag, typename MemberCheckingPolicy,\n          typename MemberStorageType, typename T2,\n          typename PersistentWeaknessPolicy, typename PersistentLocationPolicy,\n          typename PersistentCheckingPolicy>\nbool operator!=(\n    const BasicMember<T2, MemberWeaknessTag, MemberWriteBarrierPolicy,\n                      MemberCheckingPolicy, MemberStorageType>& m,\n    const BasicPersistent<T1, PersistentWeaknessPolicy,\n                          PersistentLocationPolicy, PersistentCheckingPolicy>&\n        p) {\n  return !(m == p);\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"IsWeak\",\n            \"about\": \"Type trait to check if a BasicPersistent is a WeakPersistent.\",\n            \"dependencies\": [\n                \"BasicPersistent\",\n                \"internal::WeakPersistentPolicy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T, typename LocationPolicy, typename CheckingPolicy>\nstruct IsWeak<BasicPersistent<T, internal::WeakPersistentPolicy, LocationPolicy,\n                              CheckingPolicy>> : std::true_type {};\n        ]]></code>\n    </class>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Declaration of Persistent and WeakPersistent aliases\"\n        }\n        </metadata>\n        <code><![CDATA[\n/**\n * Persistent is a way to create a strong pointer from an off-heap object to\n * another on-heap object. As long as the Persistent handle is alive the GC will\n * keep the object pointed to alive. The Persistent handle is always a GC root\n * from the point of view of the GC. Persistent must be constructed and\n * destructed in the same thread.\n */\ntemplate <typename T>\nusing Persistent =\n    internal::BasicPersistent<T, internal::StrongPersistentPolicy>;\n\n/**\n * WeakPersistent is a way to create a weak pointer from an off-heap object to\n * an on-heap object. The pointer is automatically cleared when the pointee gets\n * collected. WeakPersistent must be constructed and destructed in the same\n * thread.\n */\ntemplate <typename T>\nusing WeakPersistent =\n    internal::BasicPersistent<T, internal::WeakPersistentPolicy>;\n        ]]></code>\n    </imports>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SourceLocation\",\n                \"about\": \"Represents the location in source code.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SourceLocation {\n                public:\n                    static SourceLocation Current();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SentinelPointer\",\n                \"about\": \"Represents a sentinel pointer value.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SentinelPointer {};\n                constexpr SentinelPointer kSentinelPointer;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PersistentNode\",\n                \"about\": \"Internal node used for GC tracking of persistent handles.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class PersistentNode {\n                public:\n                    void UpdateOwner(void* new_owner);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RootVisitor\",\n                \"about\": \"Visitor used for traversing the object graph during GC.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class RootVisitor {\n                public:\n                    void Trace(const BasicPersistent& persistent);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BasicMember\",\n                \"about\": \"Represents a member that is part of a garbage collected object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace internal {\n                template <typename T, typename MemberBarrierPolicy,\n                          typename MemberWeaknessTag, typename MemberCheckingPolicy,\n                          typename MemberStorageType>\n                class BasicMember {\n                public:\n                    T* Get() const;\n                };\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WeakPersistentPolicy\",\n                \"about\": \"Policy for weak persistence.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace internal {\n                class WeakPersistentPolicy {\n                public:\n                 using IsStrongPersistent = std::false_type;\n                 static PersistentRegionBase& GetPersistentRegion(const void* value);\n                };\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StrongPersistentPolicy\",\n                \"about\": \"Policy for strong persistence.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace internal {\n                class StrongPersistentPolicy {\n                public:\n                 using IsStrongPersistent = std::true_type;\n                };\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PersistentRegionBase\",\n                \"about\": \"Base class for persistent regions.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class PersistentRegionBase {\n                public:\n                    PersistentNode* AllocateNode(void* owner, void(*trace)(RootVisitor&, const void*));\n                    void FreeNode(PersistentNode* node);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocationPolicy\",\n                \"about\": \"Base class for persistent handles, managing the raw pointer and persistent node.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class LocationPolicy {\n                public:\n                LocationPolicy(const SourceLocation& loc) {}\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CheckingPolicy\",\n                \"about\": \"Base class for persistent handles, managing the raw pointer and persistent node.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class CheckingPolicy {\n                public:\n                    void CheckPointer(void* ptr) {}\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}