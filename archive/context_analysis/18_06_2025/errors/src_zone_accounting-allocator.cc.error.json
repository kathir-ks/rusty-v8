{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/accounting-allocator.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 149, column 44",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/accounting-allocator.cc\",\n        \"file_name\": \"accounting-allocator.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements an allocator that tracks memory usage for zones, supporting optional compression.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for allocator implementation, memory management, and utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/zone/accounting-allocator.h\"\n\n#include <memory>\n\n#include \"src/base/bounded-page-allocator.h\"\n#include \"src/base/logging.h\"\n#include \"src/base/macros.h\"\n#include \"src/utils/allocation.h\"\n#include \"src/zone/zone-compression.h\"\n#include \"src/zone/zone-segment.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AccountingAllocator\",\n            \"about\": \"An allocator that tracks memory usage, supporting optional compression for zone segments.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"VirtualMemory\",\n                \"BoundedPageAllocator\",\n                \"Segment\",\n                \"ZoneCompression\",\n                \"PageAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nclass AccountingAllocator {\n public:\n  AccountingAllocator();\n  ~AccountingAllocator();\n\n  Segment* AllocateSegment(size_t bytes, bool supports_compression);\n  void ReturnSegment(Segment* segment, bool supports_compression);\n\n private:\n  std::unique_ptr<VirtualMemory> reserved_area_;\n  std::unique_ptr<v8::base::BoundedPageAllocator> bounded_page_allocator_;\n  std::atomic<size_t> current_memory_usage_ {0};\n  std::atomic<size_t> max_memory_usage_ {0};\n};\n\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ReserveAddressSpace\",\n            \"about\": \"Reserves a virtual memory region for compressed zones.\",\n            \"logic\": \"Calculates aligned hint address and allocates virtual memory. Handles out-of-memory errors.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform_allocator\",\n                    \"type\": \"v8::PageAllocator*\",\n                    \"purpose\": \"The page allocator to use for reserving memory.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"VirtualMemory\",\n                \"description\": \"The reserved virtual memory region.\"\n            },\n            \"dependencies\": [\n                \"VirtualMemory\",\n                \"ZoneCompression\",\n                \"base::FatalOOM\",\n                \"base::OOMType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace {\n\nstatic constexpr size_t kZonePageSize = 256 * KB;\n\nVirtualMemory ReserveAddressSpace(v8::PageAllocator* platform_allocator) {\n  DCHECK(IsAligned(ZoneCompression::kReservationSize,\n                   platform_allocator->AllocatePageSize()));\n\n  void* hint = reinterpret_cast<void*>(RoundDown(\n      reinterpret_cast<uintptr_t>(platform_allocator->GetRandomMmapAddr()),\n      ZoneCompression::kReservationAlignment));\n\n  VirtualMemory memory(platform_allocator, ZoneCompression::kReservationSize,\n                       hint, ZoneCompression::kReservationAlignment);\n  if (memory.IsReserved()) {\n    CHECK(IsAligned(memory.address(), ZoneCompression::kReservationAlignment));\n    return memory;\n  }\n\n  base::FatalOOM(base::OOMType::kProcess,\n                 \"Failed to reserve memory for compressed zones\");\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CreateBoundedAllocator\",\n            \"about\": \"Creates a bounded page allocator within the reserved address space.\",\n            \"logic\": \"Creates a BoundedPageAllocator and excludes the first page to trap null pointer dereferences.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform_allocator\",\n                    \"type\": \"v8::PageAllocator*\",\n                    \"purpose\": \"The page allocator to use for bounded allocation.\"\n                },\n                {\n                    \"name\": \"reservation_start\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The starting address of the reserved memory region.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<v8::base::BoundedPageAllocator>\",\n                \"description\": \"A unique pointer to the created BoundedPageAllocator.\"\n            },\n            \"dependencies\": [\n                \"v8::base::BoundedPageAllocator\",\n                \"ZoneCompression\",\n                \"kZonePageSize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<v8::base::BoundedPageAllocator> CreateBoundedAllocator(\n    v8::PageAllocator* platform_allocator, Address reservation_start) {\n  CHECK(reservation_start);\n  CHECK(IsAligned(reservation_start, ZoneCompression::kReservationAlignment));\n\n  auto allocator = std::make_unique<v8::base::BoundedPageAllocator>(\n      platform_allocator, reservation_start, ZoneCompression::kReservationSize,\n      kZonePageSize,\n      base::PageInitializationMode::kAllocatedPagesCanBeUninitialized,\n      base::PageFreeingMode::kMakeInaccessible);\n\n  // Exclude first page from allocation to ensure that accesses through\n  // decompressed null pointer will seg-fault.\n  allocator->AllocatePagesAt(reservation_start, kZonePageSize,\n                             v8::PageAllocator::kNoAccess);\n  return allocator;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"AccountingAllocator\",\n            \"parent\": \"AccountingAllocator\",\n            \"about\": \"Constructor for AccountingAllocator. Reserves address space and creates a bounded page allocator if zone compression is enabled.\",\n            \"logic\": \"Conditionally reserves address space and initializes the bounded page allocator based on the COMPRESS_ZONES_BOOL flag.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"COMPRESS_ZONES_BOOL\",\n                \"GetPlatformPageAllocator\",\n                \"ReserveAddressSpace\",\n                \"CreateBoundedAllocator\",\n                \"VirtualMemory\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n}  // namespace\n\nAccountingAllocator::AccountingAllocator() {\n  if (COMPRESS_ZONES_BOOL) {\n    v8::PageAllocator* platform_page_allocator = GetPlatformPageAllocator();\n    VirtualMemory memory = ReserveAddressSpace(platform_page_allocator);\n    reserved_area_ = std::make_unique<VirtualMemory>(std::move(memory));\n    bounded_page_allocator_ = CreateBoundedAllocator(platform_page_allocator,\n                                                     reserved_area_->address());\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"destructor\",\n            \"name\": \"~AccountingAllocator\",\n            \"parent\": \"AccountingAllocator\",\n            \"about\": \"Destructor for AccountingAllocator (implicitly defined)\",\n            \"logic\": \"Default destructor\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nAccountingAllocator::~AccountingAllocator() = default;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllocateSegment\",\n            \"parent\": \"AccountingAllocator\",\n            \"about\": \"Allocates a segment of memory, either from the bounded page allocator (if compression is enabled) or using the system allocator.\",\n            \"logic\": \"Chooses allocation strategy based on compression support. Tracks memory usage atomically.\",\n            \"parameters\": [\n                {\n                    \"name\": \"bytes\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of bytes to allocate.\"\n                },\n                {\n                    \"name\": \"supports_compression\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the segment should support compression.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Segment*\",\n                \"description\": \"A pointer to the allocated segment, or nullptr if allocation fails.\"\n            },\n            \"dependencies\": [\n                \"COMPRESS_ZONES_BOOL\",\n                \"kZonePageSize\",\n                \"AllocatePages\",\n                \"bounded_page_allocator_\",\n                \"AllocAtLeastWithRetry\",\n                \"Segment\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nSegment* AccountingAllocator::AllocateSegment(size_t bytes,\n                                              bool supports_compression) {\n  void* memory;\n  if (COMPRESS_ZONES_BOOL && supports_compression) {\n    bytes = RoundUp(bytes, kZonePageSize);\n    memory = AllocatePages(bounded_page_allocator_.get(), nullptr, bytes,\n                           kZonePageSize, PageAllocator::kReadWrite);\n\n  } else {\n    auto result = AllocAtLeastWithRetry(bytes);\n    memory = result.ptr;\n    bytes = result.count;\n  }\n  if (memory == nullptr) return nullptr;\n\n  size_t current =\n      current_memory_usage_.fetch_add(bytes, std::memory_order_relaxed) + bytes;\n  size_t max = max_memory_usage_.load(std::memory_order_relaxed);\n  while (current > max && !max_memory_usage_.compare_exchange_weak(\n                              max, current, std::memory_order_relaxed)) {\n    // {max} was updated by {compare_exchange_weak}; retry.\n  }\n  DCHECK_LE(sizeof(Segment), bytes);\n  return new (memory) Segment(bytes);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReturnSegment\",\n            \"parent\": \"AccountingAllocator\",\n            \"about\": \"Returns a segment of memory to the appropriate allocator (bounded page allocator or system allocator).\",\n            \"logic\": \"Deallocates memory based on compression support. Tracks memory usage atomically.\",\n            \"parameters\": [\n                {\n                    \"name\": \"segment\",\n                    \"type\": \"Segment*\",\n                    \"purpose\": \"The segment to return.\"\n                },\n                {\n                    \"name\": \"supports_compression\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the segment supported compression when allocated.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"COMPRESS_ZONES_BOOL\",\n                \"bounded_page_allocator_\",\n                \"FreePages\",\n                \"Segment\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AccountingAllocator::ReturnSegment(Segment* segment,\n                                        bool supports_compression) {\n  segment->ZapContents();\n  size_t segment_size = segment->total_size();\n  current_memory_usage_.fetch_sub(segment_size, std::memory_order_relaxed);\n  segment->ZapHeader();\n  if (COMPRESS_ZONES_BOOL && supports_compression) {\n    FreePages(bounded_page_allocator_.get(), segment, segment_size);\n  } else {\n    free(segment);\n  }\n}\n        ]]></code>\n    </func>\n</file>\n```"
}