{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-revec-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-revec-reducer.cc\",\n            \"file_name\": \"wasm-revec-reducer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the WasmRevecReducer, which performs SIMD vectorization in the Turboshaft compiler for WebAssembly.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for the revectorization reducer, standard library, base logging, opcode masks, and SIMD shuffle operations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/wasm-revec-reducer.h\"\n\n#include <optional>\n\n#include \"src/base/logging.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/wasm/simd-shuffle.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsSameOpAndKind\",\n                \"about\": \"Checks if two operations have the same opcode and kind (relevant for SIMD operations).\",\n                \"logic\": \"Uses a switch statement to handle different SIMD opcodes (Simd128Unary, Simd128Binop, Simd128Shift, Simd128Ternary, Simd128Splat). If the opcodes match, it checks if the 'kind' of the operation is the same.  Returns true for opcodes it doesn't specifically handle.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op0\",\n                        \"type\": \"const Operation&\",\n                        \"purpose\": \"First operation.\"\n                    },\n                    {\n                        \"name\": \"op1\",\n                        \"type\": \"const Operation&\",\n                        \"purpose\": \"Second operation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the operations are of the same type and kind, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool IsSameOpAndKind(const Operation& op0, const Operation& op1) {\n#define CASE(operation)                                \\\n  case Opcode::k##operation: {                         \\\n    using Op = operation##Op;                          \\\n    return op0.Cast<Op>().kind == op1.Cast<Op>().kind; \\\n  }\n  if (op0.opcode != op1.opcode) {\n    return false;\n  }\n  switch (op0.opcode) {\n    CASE(Simd128Unary)\n    CASE(Simd128Binop)\n    CASE(Simd128Shift)\n    CASE(Simd128Ternary)\n    CASE(Simd128Splat)\n    default:\n      return true;\n  }\n#undef CASE\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetSimdOpcodeName\",\n                \"about\": \"Returns a string representation of a SIMD opcode, including the 'kind' for certain SIMD operations.\",\n                \"logic\": \"Uses an ostringstream to build the string. For Simd128Binop, Simd128Unary, Simd128Shift, Simd128Test and Simd128Ternary opcodes, it appends the opcode's options (which include the kind). For other opcodes, it simply returns the opcode name.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"Operation const&\",\n                        \"purpose\": \"The operation to get the name for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"The string representation of the SIMD opcode.\"\n                },\n                \"dependencies\": [\n                    \"OpcodeName\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::string GetSimdOpcodeName(Operation const& op) {\n  std::ostringstream oss;\n  if (op.Is<Simd128BinopOp>() || op.Is<Simd128UnaryOp>() ||\n      op.Is<Simd128ShiftOp>() || op.Is<Simd128TestOp>() ||\n      op.Is<Simd128TernaryOp>()) {\n    op.PrintOptions(oss);\n  } else {\n    oss << OpcodeName(op.opcode);\n  }\n  return oss.str();\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StoreLoadInfo\",\n                \"about\": \"A wrapper class for StoreOp, LoadOp, and Simd128LoadTransformOp, used to calculate the relative offset between two such operations.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Graph\",\n                    \"StoreOp\",\n                    \"LoadOp\",\n                    \"Simd128LoadTransformOp\",\n                    \"WordBinopOp\",\n                    \"ConstantOp\",\n                    \"ChangeOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Op,\n          typename = std::enable_if_t<\n              std::is_same_v<Op, StoreOp> || std::is_same_v<Op, LoadOp> ||\n              std::is_same_v<Op, Simd128LoadTransformOp>>>\nclass StoreLoadInfo {\n public:\n  StoreLoadInfo(const Graph* graph, const Op* op)\n      : op_(op), offset_(op->offset) {\n    base_ = &graph->Get(op->base());\n    if constexpr (std::is_same_v<Op, Simd128LoadTransformOp>) {\n      DCHECK_EQ(offset_, 0);\n      const WordBinopOp* add_op = base_->TryCast<WordBinopOp>();\n      if (!add_op || add_op->kind != WordBinopOp::Kind::kAdd ||\n          add_op->rep != WordRepresentation::Word64()) {\n        SetInvalid();\n        return;\n      }\n      base_ = &graph->Get(add_op->left());\n      const ConstantOp* const_op =\n          graph->Get(add_op->right()).TryCast<ConstantOp>();\n      if (!const_op) {\n        SetInvalid();\n        return;\n      }\n      offset_ = const_op->word64();\n      index_ = &(graph->Get(op->index()));\n    } else {\n      if (!op->index().has_value()) {\n        SetInvalid();\n        return;\n      }\n      index_ = &(graph->Get(op->index().value()));\n    }\n\n    if (const ChangeOp* change_op = index_->TryCast<ChangeOp>()) {\n      DCHECK_EQ(change_op->kind, ChangeOp::Kind::kZeroExtend);\n      index_ = &graph->Get(change_op->input());\n      // If index_ is constant, add the constant to offset_ and set index_ to\n      // nullptr\n      if (const ConstantOp* const_op = index_->TryCast<ConstantOp>()) {\n        DCHECK_EQ(const_op->kind, ConstantOp::Kind::kWord32);\n        int32_t new_offset;\n        if (base::bits::SignedAddOverflow32(\n                static_cast<int32_t>(const_op->word32()),\n                static_cast<int32_t>(offset_), &new_offset)) {\n          // offset is overflow\n          SetInvalid();\n          return;\n        }\n        offset_ = new_offset;\n        index_ = nullptr;\n      }\n    } else {  // memory64\n      if (const ConstantOp* const_op = index_->TryCast<ConstantOp>()) {\n        DCHECK_EQ(const_op->kind, ConstantOp::Kind::kWord64);\n        offset_ += const_op->word64();\n        index_ = nullptr;\n      }\n    }\n  }\n\n  std::optional<int> operator-(const StoreLoadInfo<Op>& rhs) const {\n    DCHECK(IsValid() && rhs.IsValid());\n    bool calculatable = base_ == rhs.base_ && index_ == rhs.index_;\n\n    if constexpr (std::is_same_v<Op, Simd128LoadTransformOp>) {\n      calculatable &= (op_->load_kind == rhs.op_->load_kind &&\n                       op_->transform_kind == rhs.op_->transform_kind);\n    } else {\n      calculatable &= (op_->kind == rhs.op_->kind);\n    }\n\n    if constexpr (std::is_same_v<Op, StoreOp>) {\n      // TODO(v8:12716) If one store has a full write barrier and the other has\n      // no write barrier, consider combine them with a full write barrier.\n      calculatable &= (op_->write_barrier == rhs.op_->write_barrier);\n    }\n\n    if (calculatable) {\n      return offset_ - rhs.offset_;\n    }\n    return {};\n  }\n\n  bool IsValid() const { return op_ != nullptr; }\n\n  const Operation* index() const { return index_; }\n  int64_t offset() const { return offset_; }\n  const Op* op() const { return op_; }\n\n private:\n  void SetInvalid() { op_ = nullptr; }\n\n  const Op* op_;\n  const Operation* base_ = nullptr;\n  const Operation* index_ = nullptr;\n  int64_t offset_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"StoreInfoCompare\",\n                \"about\": \"Functor to compare StoreLoadInfo<StoreOp> objects based on index and offset.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"StoreLoadInfo\",\n                    \"StoreOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct StoreInfoCompare {\n  bool operator()(const StoreLoadInfo<StoreOp>& lhs,\n                  const StoreLoadInfo<StoreOp>& rhs) const {\n    if (lhs.index() != rhs.index()) {\n      return lhs.index() < rhs.index();\n    }\n    return lhs.offset() < rhs.offset();\n  }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"alias\",\n                \"name\": \"StoreInfoSet\",\n                \"about\": \"A ZoneSet of StoreLoadInfo<StoreOp> objects, using StoreInfoCompare for ordering.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"ZoneSet\",\n                    \"StoreLoadInfo\",\n                    \"StoreOp\",\n                    \"StoreInfoCompare\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing StoreInfoSet = ZoneSet<StoreLoadInfo<StoreOp>, StoreInfoCompare>;\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"LoadStrideEqualTo\",\n                \"about\": \"Checks if the stride between loads in a NodeGroup is equal to a specific value.\",\n                \"logic\": \"Creates a SmallVector of `Info` objects (where `Info` is `StoreLoadInfo<Op>`) for each operation in the `node_group`. Then calculates the difference between the first two loads using the overloaded `-` operator of `StoreLoadInfo`. Returns true only if all loads are valid and the difference is equal to the given `stride`.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const Graph&\",\n                        \"purpose\": \"The graph containing the operations.\"\n                    },\n                    {\n                        \"name\": \"node_group\",\n                        \"type\": \"const NodeGroup&\",\n                        \"purpose\": \"The group of nodes to check.\"\n                    },\n                    {\n                        \"name\": \"stride\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The stride value to compare against.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the stride between the loads is equal to the specified value, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"StoreLoadInfo\",\n                    \"Graph\",\n                    \"NodeGroup\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Op, class Info>\nbool LoadStrideEqualTo(const Graph& graph, const NodeGroup& node_group,\n                       int stride) {\n  base::SmallVector<Info, 2> load_infos;\n  for (OpIndex op_idx : node_group) {\n    const Operation& op = graph.Get(op_idx);\n    const Op& load_op = op.Cast<Op>();\n    Info info(&graph, &load_op);\n    if (!info.IsValid()) {\n      return false;\n    }\n    load_infos.push_back(info);\n  }\n  return load_infos[1] - load_infos[0] == stride;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsSplat\",\n                \"about\": \"Checks if all nodes in a NodeGroup are identical.\",\n                \"logic\": \"Compares all elements in the given `node_group` to determine if they are the same. Intended for use with SIMD splat operations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node_group\",\n                        \"type\": \"const T&\",\n                        \"purpose\": \"The node group to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if all nodes in the group are identical, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"NodeGroup\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nbool IsSplat(const T& node_group) {\n  DCHECK_EQ(node_group.size(), 2);\n  return node_group[1] == node_group[0];\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PackNode\",\n                \"about\": \"Represents a packed node in the SLP (Superword Level Parallelism) tree.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Graph\",\n                    \"Operation\",\n                    \"OpIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid PackNode::Print(Graph* graph) const {\n  Operation& op = graph->Get(nodes_[0]);\n  TRACE(\"%s(#%d, #%d)\\n\", GetSimdOpcodeName(op).c_str(), nodes_[0].id(),\n        nodes_[1].id());\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SLPTree\",\n                \"about\": \"Represents the SLP (Superword Level Parallelism) tree.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Graph\",\n                    \"PackNode\",\n                    \"OpIndex\",\n                    \"ZoneUnorderedMap\",\n                    \"absl::flat_hash_set\",\n                    \"ZoneVector\",\n                    \"Operation\",\n                    \"NodeGroup\",\n                    \"Simd128BinopOp\",\n                    \"ConstantOp\",\n                    \"Simd128LoadTransformOp\",\n                    \"LoadOp\",\n                    \"PhiOp\",\n                    \"Simd128UnaryOp\",\n                    \"Simd128ShiftOp\",\n                    \"Simd128TernaryOp\",\n                    \"Simd128SplatOp\",\n                    \"Simd128ShuffleOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nPackNode* SLPTree::GetPackNode(OpIndex node) {\n  auto itr = node_to_packnode_.find(node);\n  if (itr != node_to_packnode_.end()) {\n    return itr->second;\n  }\n  return analyzer_->GetPackNode(node);\n}\n\nZoneVector<PackNode*>* SLPTree::GetIntersectPackNodes(OpIndex node) {\n  auto I = node_to_intersect_packnodes_.find(node);\n  if (I != node_to_intersect_packnodes_.end()) {\n    return &(I->second);\n  }\n  return nullptr;\n}\n\ntemplate <typename FunctionType>\nvoid ForEach(FunctionType callback,\n             const ZoneUnorderedMap<OpIndex, PackNode*>& node_map) {\n  absl::flat_hash_set<PackNode const*> visited;\n\n  for (auto& entry : node_map) {\n    PackNode const* pnode = entry.second;\n    if (!pnode || visited.find(pnode) != visited.end()) {\n      continue;\n    }\n    visited.insert(pnode);\n\n    callback(pnode);\n  }\n}\n\ntemplate <typename FunctionType>\nvoid ForEach(FunctionType callback,\n             const ZoneUnorderedMap<OpIndex, ZoneVector<PackNode*>>& node_map) {\n  absl::flat_hash_set<PackNode const*> visited;\n\n  for (auto entry : node_map) {\n    for (auto pnode : entry.second) {\n      if (visited.find(pnode) != visited.end()) {\n        continue;\n      }\n      visited.insert(pnode);\n      callback(pnode);\n    }\n  }\n}\n\nvoid SLPTree::Print(const char* info) {\n  TRACE(\"%s, %zu Packed node:\\n\", info, node_to_packnode_.size());\n  if (!v8_flags.trace_wasm_revectorize) {\n    return;\n  }\n\n  ForEach([this](PackNode const* pnode) { pnode->Print(&graph_); },\n          node_to_packnode_);\n  ForEach([this](PackNode const* pnode) { pnode->Print(&graph_); },\n          node_to_intersect_packnodes_);\n}\n\nbool SLPTree::HasInputDependencies(const NodeGroup& node_group) {\n  DCHECK_EQ(node_group.size(), 2);\n  if (node_group[0] == node_group[1]) return false;\n  OpIndex start, end;\n  if (node_group[0] < node_group[1]) {\n    start = node_group[0];\n    end = node_group[1];\n  } else {\n    start = node_group[1];\n    end = node_group[0];\n  }\n  // Do BFS from the end node and see if there is a path to the start node.\n  ZoneQueue<OpIndex> to_visit(phase_zone_);\n  to_visit.push(end);\n  while (!to_visit.empty()) {\n    OpIndex to_visit_node = to_visit.front();\n    Operation& op = graph_.Get(to_visit_node);\n    to_visit.pop();\n    for (OpIndex input : op.inputs()) {\n      if (input == start) {\n        return true;\n      } else if (input > start) {\n        // We should ensure that there is no back edge.\n        DCHECK_LT(input, to_visit_node);\n        to_visit.push(input);\n      }\n    }\n  }\n  return false;\n}\n\nPackNode* SLPTree::NewPackNode(const NodeGroup& node_group) {\n  TRACE(\"PackNode %s(#%d, #%d)\\n\",\n        GetSimdOpcodeName(graph_.Get(node_group[0])).c_str(),\n        node_group[0].id(), node_group[1].id());\n  PackNode* pnode = phase_zone_->New<PackNode>(phase_zone_, node_group);\n  for (OpIndex node : node_group) {\n    node_to_packnode_[node] = pnode;\n  }\n  return pnode;\n}\n\nPackNode* SLPTree::NewForcePackNode(const NodeGroup& node_group,\n                                    ForcePackNode::ForcePackType type,\n                                    const Graph& graph) {\n  // Currently we only support force packing two nodes.\n  DCHECK_EQ(node_group.size(), 2);\n  // We should guarantee that the one node in the NodeGroup does not rely on the\n  // result of the other. Because it is costly to force pack such candidates.\n  // For example, we have four nodes {A, B, C, D} which are connected by input\n  // edges: A <-- B <-- C <-- D. If {B} and {D} are already packed into a\n  // PackNode and we want to force pack {A} and {C}, we need to duplicate {B}\n  // and the result will be {A, B, C}, {B, D}. This increase the cost of\n  // ForcePack so currently we do not support it.\n  if (HasInputDependencies(node_group)) {\n    TRACE(\"ForcePackNode %s(#%d, #%d) failed due to input dependencies.\\n\",\n          GetSimdOpcodeName(graph_.Get(node_group[0])).c_str(),\n          node_group[0].id(), node_group[1].id());\n    return nullptr;\n  }\n\n  TRACE(\"ForcePackNode %s(#%d, #%d)\\n\",\n        GetSimdOpcodeName(graph_.Get(node_group[0])).c_str(),\n        node_group[0].id(), node_group[1].id());\n  ForcePackNode* pnode =\n      phase_zone_->New<ForcePackNode>(phase_zone_, node_group, type);\n  for (OpIndex node : node_group) {\n    node_to_packnode_[node] = pnode;\n  }\n\n  return pnode;\n}\n\nBundlePackNode* SLPTree::NewBundlePackNode(const NodeGroup& node_group,\n                                           OpIndex base, int8_t offset,\n                                           uint8_t lane_size,\n                                           bool is_sign_extract,\n                                           bool is_sign_convert) {\n  Operation& op = graph_.Get(node_group[0]);\n  TRACE(\"PackNode %s(#%d:, #%d)\\n\", GetSimdOpcodeName(op).c_str(),\n        node_group[0].id(), node_group[1].id());\n  BundlePackNode* pnode = phase_zone_->New<BundlePackNode>(\n      phase_zone_, node_group, base, offset, lane_size, is_sign_extract,\n      is_sign_convert);\n  for (OpIndex node : node_group) {\n    node_to_packnode_[node] = pnode;\n  }\n  return pnode;\n}\n\nPackNode* SLPTree::NewIntersectPackNode(const NodeGroup& node_group) {\n  // Similar as ForcePackNode, dependent inputs are not supported.\n  if (HasInputDependencies(node_group)) {\n    TRACE(\"IntersectPackNode %s(#%d, #%d) failed due to input dependencies.\\n\",\n          GetSimdOpcodeName(graph_.Get(node_group[0])).c_str(),\n          node_group[0].id(), node_group[1].id());\n    return nullptr;\n  }\n\n  TRACE(\"IntersectPackNode %s(#%d, #%d)\\n\",\n        GetSimdOpcodeName(graph_.Get(node_group[0])).c_str(),\n        node_group[0].id(), node_group[1].id());\n  PackNode* intersect_pnode = phase_zone_->New<PackNode>(\n      phase_zone_, node_group, PackNode::kIntersectPackNode);\n\n  for (int i = 0; i < static_cast<int>(node_group.size()); i++) {\n    OpIndex op_idx = node_group[i];\n    if (i > 0 && op_idx == node_group[0]) continue;\n    auto it = node_to_intersect_packnodes_.find(op_idx);\n    if (it == node_to_intersect_packnodes_.end()) {\n      bool result;\n      std::tie(it, result) = node_to_intersect_packnodes_.emplace(\n          op_idx, ZoneVector<PackNode*>(phase_zone_));\n      DCHECK(result);\n    }\n    it->second.push_back(intersect_pnode);\n  }\n\n  return intersect_pnode;\n}\n\nPackNode* SLPTree::NewCommutativePackNodeAndRecurs(const NodeGroup& node_group,\n                                                   unsigned depth) {\n  PackNode* pnode = NewPackNode(node_group);\n\n  const Simd128BinopOp& op0 = graph_.Get(node_group[0]).Cast<Simd128BinopOp>();\n  const Simd128BinopOp& op1 = graph_.Get(node_group[1]).Cast<Simd128BinopOp>();\n\n  bool same_kind =\n      (op0.left() == op1.left()) ||\n      IsSameOpAndKind(graph_.Get(op0.left()), graph_.Get(op1.left()));\n  bool need_swap = Simd128BinopOp::IsCommutative(op0.kind) && !same_kind;\n  if (need_swap) {\n    TRACE(\"Change the order of binop operands\\n\");\n  }\n  for (int i = 0; i < 2; ++i) {\n    // Swap the left and right input if necessary\n    unsigned node1_input_index = need_swap ? 1 - i : i;\n    NodeGroup operands(graph_.Get(node_group[0]).input(i),\n                       graph_.Get(node_group[1]).input(node1_input_index));\n\n    PackNode* child = BuildTreeRec(operands, depth + 1);\n    if (child) {\n      pnode->SetOperand(i, child);\n    } else {\n      return nullptr;\n    }\n  }\n  return pnode;\n}\n\nPackNode* SLPTree::NewPackNodeAndRecurs(const NodeGroup& node_group,\n                                        int start_index, int count,\n                                        unsigned depth) {\n  PackNode* pnode = NewPackNode(node_group);\n  for (int i = 0; i < count; ++i) {\n    // Prepare the operand vector.\n    int input_index = i + start_index;\n    NodeGroup operands(graph_.Get(node_group[0]).input(input_index),\n                       graph_.Get(node_group[1]).input(input_index));\n\n    PackNode* child = BuildTreeRec(operands, depth + 1);\n    if (child) {\n      pnode->SetOperand(i, child);\n    } else {\n      return nullptr;\n    }\n  }\n  return pnode;\n}\n\nShufflePackNode* SLPTree::NewShufflePackNode(\n    const NodeGroup& node_group, ShufflePackNode::SpecificInfo::Kind kind) {\n  Operation& op = graph_.Get(node_group[0]);\n  TRACE(\"PackNode %s(#%d:, #%d)\\n\", GetSimdOpcodeName(op).c_str(),\n        node_group[0].id(), node_group[1].id());\n  ShufflePackNode* pnode =\n      phase_zone_->New<ShufflePackNode>(phase_zone_, node_group, kind);\n  for (OpIndex node : node_group) {\n    node_to_packnode_[node] = pnode;\n  }\n  return pnode;\n}\n\nShufflePackNode* SLPTree::Try256ShuffleMatchLoad8x8U(\n    const NodeGroup& node_group, const uint8_t* shuffle0,\n    const uint8_t* shuffle1) {\n  uint8_t shuffle_copy0[kSimd128Size];\n  uint8_t shuffle_copy1[kSimd128Size];\n\n  V<Simd128> op_idx0 = node_group[0];\n  V<Simd128> op_idx1 = node_group[1];\n  const Simd128ShuffleOp& op0 = graph_.Get(op_idx0).Cast<Simd128ShuffleOp>();\n  const Simd128ShuffleOp& op1 = graph_.Get(op_idx1).Cast<Simd128ShuffleOp>();\n\n  if (op0.kind != Simd128ShuffleOp::Kind::kI8x16 ||\n      op1.kind != Simd128ShuffleOp::Kind::kI8x16) {\n    return nullptr;\n  }\n\n  if (op0.left() == op0.right() || op1.left() == op1.right()) {\n    // Here shuffle couldn't be swizzle\n    return nullptr;\n  }\n\n  CopyChars(shuffle_copy0, shuffle0, kSimd128Size);\n  CopyChars(shuffle_copy1, shuffle1, kSimd128Size);\n\n  bool need_swap, is_swizzle;\n\n#define CANONICALIZE_SHUFFLE(n)                                                \\\n  wasm::SimdShuffle::CanonicalizeShuffle(false, shuffle_copy##n, &need_swap,   \\\n                                         &is_swizzle);                         \\\n  if (is_swizzle) {                                                            \\\n    /* Here shuffle couldn't be swizzle*/                                      \\\n    return nullptr;                                                            \\\n  }                                                                            \\\n  V<Simd128> shuffle##n##_left_idx = need_swap ? op##n.right() : op##n.left(); \\\n  V<Simd128> shuffle##n##_right_idx = need_swap ? op##n.left() : op##n.right();\n\n  CANONICALIZE_SHUFFLE(0);\n  CANONICALIZE_SHUFFLE(1);\n\n#undef CANONICALIZE_SHUFFLE\n  if (shuffle0_left_idx != shuffle1_left_idx) {\n    // Not the same left\n    return nullptr;\n  }\n\n  const Simd128LoadTransformOp* load_transform =\n      graph_.Get(shuffle0_left_idx).TryCast<Simd128LoadTransformOp>();\n\n  if (!load_transform) {\n    // shuffle left is not Simd128LoadTransformOp\n    return nullptr;\n  }\n\n  Simd128ConstantOp* shuffle0_const =\n      graph_.Get(shuffle0_right_idx).TryCast<Simd128ConstantOp>();\n  Simd128ConstantOp* shuffle1_const =\n      graph_.Get(shuffle1_right_idx).TryCast<Simd128ConstantOp>();\n\n  if (!shuffle0_const || !shuffle1_const || !shuffle0_const->IsZero() ||\n      !shuffle1_const->IsZero()) {\n    // Shuffle right is not zero\n    return nullptr;\n  }\n\n  if (load_transform->transform_kind ==\n      Simd128LoadTransformOp::TransformKind::k64Zero) {\n    /*\n      should look like this:\n      shuffle0 = 0,x,x,x,  1,x,x,x  2,x,x,x  3,x,x,x\n      shuffle1 = 4,x,x,x,  5,x,x,x  6,x,x,x  7,x,x,x\n      x >= 16\n    */\n\n    for (int i = 0; i < kSimd128Size / 4; ++i) {\n      if (shuffle_copy0[i * 4] != i || shuffle_copy1[i * 4] != i + 4) {\n        // not match\n        return nullptr;\n      }\n\n      if (shuffle_copy0[i * 4 + 1] < kSimd128Size ||\n          shuffle_copy0[i * 4 + 2] < kSimd128Size ||\n          shuffle_copy0[i * 4 + 3] < kSimd128Size ||\n          shuffle_copy1[i * 4 + 1] < kSimd128Size ||\n          shuffle_copy1[i * 4 + 2] < kSimd128Size ||\n          shuffle_copy1[i * 4 + 3] < kSimd128Size) {\n        // not match\n        return nullptr;\n      }\n    }\n    TRACE(\"match load extend 8x8->32x8\\n\");\n    return NewShufflePackNode(\n        node_group, ShufflePackNode::SpecificInfo::Kind::kS256Load8x8U);\n  }\n  return nullptr;\n}\n\n#ifdef V8_TARGET_ARCH_X64\nShufflePackNode* SLPTree::X64TryMatch256Shuffle(const NodeGroup& node_group,\n                                                const uint8_t* shuffle0,\n                                                const uint8_t* shuffle1) {\n  DCHECK_EQ(node_group.size(), 2);\n  OpIndex op_idx0 = node_group[0];\n  OpIndex op_idx1 = node_group[1];\n  const Simd128ShuffleOp& op0 = graph_.Get(op_idx0).Cast<Simd128ShuffleOp>();\n  const Simd128ShuffleOp& op1 = graph_.Get(op_idx1).Cast<Simd128ShuffleOp>();\n  if (op0.kind != Simd128ShuffleOp::Kind::kI8x16 ||\n      op"
}