{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/block-instrumentation-reducer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/block-instrumentation-reducer.h\",\n            \"file_name\": \"block-instrumentation-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines a reducer that instruments blocks in the Turboshaft graph to count their execution frequency.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for assembler, index, operations, representations and uniform reducer adapter.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/compiler/turboshaft/uniform-reducer-adapter.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BlockInstrumentationReducer\",\n                \"extends\": \"UniformReducerAdapter<BlockInstrumentationReducer, Next>\",\n                \"about\": \"A reducer that adds instrumentation to count block executions.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The isolate associated with the compilation.\"\n                    },\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"BasicBlockProfilerData*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the block profiler data.\"\n                    },\n                    {\n                        \"name\": \"on_heap_counters_\",\n                        \"type\": \"const bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating if counters are stored on the heap.\"\n                    },\n                    {\n                        \"name\": \"operations_emitted_in_current_block_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counts the number of operations emitted in the current block.\"\n                    },\n                    {\n                        \"name\": \"counters_array_handle_\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the counters array.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"UniformReducerAdapter\",\n                    \"Block\",\n                    \"Isolate\",\n                    \"HeapObject\",\n                    \"BasicBlockProfilerData\",\n                    \"CreateCountersArray\",\n                    \"V\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Next>\nclass BlockInstrumentationReducer\n    : public UniformReducerAdapter<BlockInstrumentationReducer, Next> {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(BlockInstrumentation)\n  using Adapter = UniformReducerAdapter<BlockInstrumentationReducer, Next>;\n\n  BlockInstrumentationReducer() {\n    DCHECK_NOT_NULL(data_);\n    if (on_heap_counters_) {\n      counters_array_handle_ = detail::CreateCountersArray(isolate_);\n    }\n  }\n\n  void Bind(Block* new_block) {\n    Next::Bind(new_block);\n\n    const int block_number = new_block->index().id();\n    data_->SetBlockId(block_number, block_number);\n\n    // Reset counter.\n    operations_emitted_in_current_block_ = 0;\n  }\n\n  template <Opcode opcode, typename Continuation, typename... Args>\n  OpIndex ReduceOperation(Args... args) {\n    // Those operations must be skipped here because we want to keep them at the\n    // beginning of their blocks.\n    static_assert(opcode != Opcode::kCatchBlockBegin);\n    static_assert(opcode != Opcode::kDidntThrow);\n    static_assert(opcode != Opcode::kParameter);\n\n    if (0 == operations_emitted_in_current_block_++) {\n      // If this is the first (non-skipped) operation in this block, emit\n      // instrumentation.\n      const int block_number = __ current_block() -> index().id();\n      EmitBlockInstrumentation(block_number);\n    }\n    return Continuation{this}.Reduce(args...);\n  }\n\n  V<Object> REDUCE(Parameter)(int32_t parameter_index,\n                              RegisterRepresentation rep,\n                              const char* debug_name) {\n    // Skip generic callback as we don't want to emit instrumentation BEFORE\n    // this operation.\n    return Next::ReduceParameter(parameter_index, rep, debug_name);\n  }\n\n  V<Any> REDUCE(CatchBlockBegin)() {\n    // Skip generic callback as we don't want to emit instrumentation BEFORE\n    // this operation.\n    return Next::ReduceCatchBlockBegin();\n  }\n\n  V<Any> REDUCE(DidntThrow)(\n      V<Any> throwing_operation, bool has_catch_block,\n      const base::Vector<const RegisterRepresentation>* results_rep,\n      OpEffects throwing_op_effects) {\n    // Skip generic callback as we don't want to emit instrumentation BEFORE\n    // this operation.\n    return Next::ReduceDidntThrow(throwing_operation, has_catch_block,\n                                  results_rep, throwing_op_effects);\n  }\n\n  V<Word32> LoadCounterValue(int block_number) {\n    int offset_to_counter_value = block_number * kInt32Size;\n    if (on_heap_counters_) {\n      offset_to_counter_value += sizeof(ByteArray::Header);\n      // Allocation is disallowed here, so rather than referring to an actual\n      // counters array, create a reference to a special marker object. This\n      // object will get fixed up later in the constants table (see\n      // PatchBasicBlockCountersReference). An important and subtle point: we\n      // cannot use the root handle basic_block_counters_marker_handle() and\n      // must create a new separate handle. Otherwise\n      // MacroAssemblerBase::IndirectLoadConstant would helpfully emit a\n      // root-relative load rather than putting this value in the constants\n      // table where we expect it to be for patching.\n      V<HeapObject> counter_array = __ HeapConstant(counters_array_handle_);\n      return __ Load(counter_array, LoadOp::Kind::TaggedBase(),\n                     MemoryRepresentation::Uint32(), offset_to_counter_value);\n    } else {\n      V<WordPtr> counter_array =\n          __ WordPtrConstant(reinterpret_cast<uintptr_t>(data_->counts()));\n      return __ LoadOffHeap(counter_array, offset_to_counter_value,\n                            MemoryRepresentation::Uint32());\n    }\n  }\n\n  void StoreCounterValue(int block_number, V<Word32> value) {\n    int offset_to_counter_value = block_number * kInt32Size;\n    if (on_heap_counters_) {\n      offset_to_counter_value += sizeof(ByteArray::Header);\n      // Allocation is disallowed here, so rather than referring to an actual\n      // counters array, create a reference to a special marker object. This\n      // object will get fixed up later in the constants table (see\n      // PatchBasicBlockCountersReference). An important and subtle point: we\n      // cannot use the root handle basic_block_counters_marker_handle() and\n      // must create a new separate handle. Otherwise\n      // MacroAssemblerBase::IndirectLoadConstant would helpfully emit a\n      // root-relative load rather than putting this value in the constants\n      // table where we expect it to be for patching.\n      V<HeapObject> counter_array = __ HeapConstant(counters_array_handle_);\n      __ Store(counter_array, value, StoreOp::Kind::TaggedBase(),\n               MemoryRepresentation::Uint32(),\n               WriteBarrierKind::kNoWriteBarrier, offset_to_counter_value);\n    } else {\n      V<WordPtr> counter_array =\n          __ WordPtrConstant(reinterpret_cast<uintptr_t>(data_->counts()));\n      __ StoreOffHeap(counter_array, value, MemoryRepresentation::Uint32(),\n                      offset_to_counter_value);\n    }\n  }\n\n  void EmitBlockInstrumentation(int block_number) {\n    // Load the current counter value from the array.\n    V<Word32> value = LoadCounterValue(block_number);\n\n    // Increment the counter value.\n    V<Word32> incremented_value = __ Word32Add(value, 1);\n\n    // Branchless saturation, because we don't want to introduce additional\n    // control flow here.\n    V<Word32> overflow = __ Uint32LessThan(incremented_value, value);\n    V<Word32> overflow_mask = __ Word32Sub(0, overflow);\n    V<Word32> saturated_value =\n        __ Word32BitwiseOr(incremented_value, overflow_mask);\n\n    // Store the incremented counter value back into the array.\n    StoreCounterValue(block_number, saturated_value);\n  }\n\n  V<None> REDUCE_INPUT_GRAPH(Branch)(V<None> ig_index, const BranchOp& branch) {\n    const int true_id = branch.if_true->index().id();\n    const int false_id = branch.if_false->index().id();\n    data_->AddBranch(true_id, false_id);\n    return Next::ReduceInputGraphBranch(ig_index, branch);\n  }\n\n private:\n  Isolate* isolate_ = __ data() -> isolate();\n  BasicBlockProfilerData* data_ = __ data() -> info()->profiler_data();\n  const bool on_heap_counters_ =\n      isolate_ && isolate_->IsGeneratingEmbeddedBuiltins();\n  size_t operations_emitted_in_current_block_ = 0;\n  Handle<HeapObject> counters_array_handle_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CreateCountersArray\",\n                \"parent\": \"detail\",\n                \"about\": \"Creates an array to store the counters.\",\n                \"logic\": \"This function is responsible for allocating the necessary memory to store the block execution counters. The details of this function are not present in this file.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The isolate associated with the compilation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Handle<HeapObject>\",\n                    \"description\": \"A handle to the created counters array.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Handle\",\n                    \"HeapObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace detail {\nHandle<HeapObject> CreateCountersArray(Isolate* isolate);\n}  // namespace detail\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Bind\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Binds the reducer to a new block.\",\n                \"logic\": \"Sets the block ID in the profiler data and resets the operation counter for the block. Calls the `Bind` method of the next reducer in the chain.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"new_block\",\n                        \"type\": \"Block*\",\n                        \"purpose\": \"The block to bind to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"Block\",\n                    \"index\",\n                    \"SetBlockId\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void Bind(Block* new_block) {\n    Next::Bind(new_block);\n\n    const int block_number = new_block->index().id();\n    data_->SetBlockId(block_number, block_number);\n\n    // Reset counter.\n    operations_emitted_in_current_block_ = 0;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceOperation\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Reduces an operation by potentially emitting block instrumentation.\",\n                \"logic\": \"If it's the first (non-skipped) operation in the block, emits the block instrumentation. Skips operations like CatchBlockBegin, DidntThrow and Parameter, because we want to keep them at the beginning of their blocks. It calls `EmitBlockInstrumentation` to increment the counter. Then calls the `Reduce` method of the next reducer in the chain.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"args\",\n                        \"type\": \"Args...\",\n                        \"purpose\": \"Arguments for the operation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"EmitBlockInstrumentation\",\n                    \"Continuation\",\n                    \"Reduce\",\n                    \"OpIndex\",\n                    \"current_block\",\n                    \"index\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  template <Opcode opcode, typename Continuation, typename... Args>\n  OpIndex ReduceOperation(Args... args) {\n    // Those operations must be skipped here because we want to keep them at the\n    // beginning of their blocks.\n    static_assert(opcode != Opcode::kCatchBlockBegin);\n    static_assert(opcode != Opcode::kDidntThrow);\n    static_assert(opcode != Opcode::kParameter);\n\n    if (0 == operations_emitted_in_current_block_++) {\n      // If this is the first (non-skipped) operation in this block, emit\n      // instrumentation.\n      const int block_number = __ current_block() -> index().id();\n      EmitBlockInstrumentation(block_number);\n    }\n    return Continuation{this}.Reduce(args...);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE(Parameter)\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Reduces a Parameter operation.\",\n                \"logic\": \"Calls the `ReduceParameter` method of the next reducer in the chain, skipping instrumentation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"parameter_index\",\n                        \"type\": \"int32_t\",\n                        \"purpose\": \"The index of the parameter.\"\n                    },\n                    {\n                        \"name\": \"rep\",\n                        \"type\": \"RegisterRepresentation\",\n                        \"purpose\": \"The register representation of the parameter.\"\n                    },\n                    {\n                        \"name\": \"debug_name\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The debug name of the parameter.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<Object>\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"ReduceParameter\",\n                    \"V\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<Object> REDUCE(Parameter)(int32_t parameter_index,\n                              RegisterRepresentation rep,\n                              const char* debug_name) {\n    // Skip generic callback as we don't want to emit instrumentation BEFORE\n    // this operation.\n    return Next::ReduceParameter(parameter_index, rep, debug_name);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE(CatchBlockBegin)\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Reduces a CatchBlockBegin operation.\",\n                \"logic\": \"Calls the `ReduceCatchBlockBegin` method of the next reducer in the chain, skipping instrumentation.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"V<Any>\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"ReduceCatchBlockBegin\",\n                    \"V\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<Any> REDUCE(CatchBlockBegin)() {\n    // Skip generic callback as we don't want to emit instrumentation BEFORE\n    // this operation.\n    return Next::ReduceCatchBlockBegin();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE(DidntThrow)\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Reduces a DidntThrow operation.\",\n                \"logic\": \"Calls the `ReduceDidntThrow` method of the next reducer in the chain, skipping instrumentation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"throwing_operation\",\n                        \"type\": \"V<Any>\",\n                        \"purpose\": \"The throwing operation.\"\n                    },\n                    {\n                        \"name\": \"has_catch_block\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the operation has a catch block.\"\n                    },\n                    {\n                        \"name\": \"results_rep\",\n                        \"type\": \"const base::Vector<const RegisterRepresentation>*\",\n                        \"purpose\": \"The register representation of the results.\"\n                    },\n                    {\n                        \"name\": \"throwing_op_effects\",\n                        \"type\": \"OpEffects\",\n                        \"purpose\": \"The effects of the throwing operation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<Any>\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"ReduceDidntThrow\",\n                    \"V\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<Any> REDUCE(DidntThrow)(\n      V<Any> throwing_operation, bool has_catch_block,\n      const base::Vector<const RegisterRepresentation>* results_rep,\n      OpEffects throwing_op_effects) {\n    // Skip generic callback as we don't want to emit instrumentation BEFORE\n    // this operation.\n    return Next::ReduceDidntThrow(throwing_operation, has_catch_block,\n                                  results_rep, throwing_op_effects);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LoadCounterValue\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Loads the counter value for a given block number.\",\n                \"logic\": \"Calculates the offset to the counter value in the counter array.  If `on_heap_counters_` is true, loads the counter from a HeapObject; otherwise loads from off-heap memory. Contains logic to avoid allocation by creating a handle to a marker object rather than directly referencing the counters array.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block_number\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The block number.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<Word32>\",\n                    \"description\": \"The counter value.\"\n                },\n                \"dependencies\": [\n                    \"V\",\n                    \"HeapObject\",\n                    \"WordPtr\",\n                    \"ByteArray\",\n                    \"HeapConstant\",\n                    \"Load\",\n                    \"LoadOffHeap\",\n                    \"MemoryRepresentation\",\n                    \"kInt32Size\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<Word32> LoadCounterValue(int block_number) {\n    int offset_to_counter_value = block_number * kInt32Size;\n    if (on_heap_counters_) {\n      offset_to_counter_value += sizeof(ByteArray::Header);\n      // Allocation is disallowed here, so rather than referring to an actual\n      // counters array, create a reference to a special marker object. This\n      // object will get fixed up later in the constants table (see\n      // PatchBasicBlockCountersReference). An important and subtle point: we\n      // cannot use the root handle basic_block_counters_marker_handle() and\n      // must create a new separate handle. Otherwise\n      // MacroAssemblerBase::IndirectLoadConstant would helpfully emit a\n      // root-relative load rather than putting this value in the constants\n      // table where we expect it to be for patching.\n      V<HeapObject> counter_array = __ HeapConstant(counters_array_handle_);\n      return __ Load(counter_array, LoadOp::Kind::TaggedBase(),\n                     MemoryRepresentation::Uint32(), offset_to_counter_value);\n    } else {\n      V<WordPtr> counter_array =\n          __ WordPtrConstant(reinterpret_cast<uintptr_t>(data_->counts()));\n      return __ LoadOffHeap(counter_array, offset_to_counter_value,\n                            MemoryRepresentation::Uint32());\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StoreCounterValue\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Stores the counter value for a given block number.\",\n                \"logic\": \"Calculates the offset to the counter value in the counter array. If on_heap_counters_ is true, stores the counter to a HeapObject; otherwise stores to off-heap memory. Contains logic to avoid allocation by creating a handle to a marker object rather than directly referencing the counters array.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block_number\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The block number.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"V<Word32>\",\n                        \"purpose\": \"The counter value to store.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"V\",\n                    \"HeapObject\",\n                    \"WordPtr\",\n                    \"ByteArray\",\n                    \"HeapConstant\",\n                    \"Store\",\n                    \"StoreOffHeap\",\n                    \"MemoryRepresentation\",\n                    \"kInt32Size\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void StoreCounterValue(int block_number, V<Word32> value) {\n    int offset_to_counter_value = block_number * kInt32Size;\n    if (on_heap_counters_) {\n      offset_to_counter_value += sizeof(ByteArray::Header);\n      // Allocation is disallowed here, so rather than referring to an actual\n      // counters array, create a reference to a special marker object. This\n      // object will get fixed up later in the constants table (see\n      // PatchBasicBlockCountersReference). An important and subtle point: we\n      // cannot use the root handle basic_block_counters_marker_handle() and\n      // must create a new separate handle. Otherwise\n      // MacroAssemblerBase::IndirectLoadConstant would helpfully emit a\n      // root-relative load rather than putting this value in the constants\n      // table where we expect it to be for patching.\n      V<HeapObject> counter_array = __ HeapConstant(counters_array_handle_);\n      __ Store(counter_array, value, StoreOp::Kind::TaggedBase(),\n               MemoryRepresentation::Uint32(),\n               WriteBarrierKind::kNoWriteBarrier, offset_to_counter_value);\n    } else {\n      V<WordPtr> counter_array =\n          __ WordPtrConstant(reinterpret_cast<uintptr_t>(data_->counts()));\n      __ StoreOffHeap(counter_array, value, MemoryRepresentation::Uint32(),\n                      offset_to_counter_value);\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitBlockInstrumentation\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Emits the instrumentation code for a given block.\",\n                \"logic\": \"Loads the current counter value, increments it (with saturation to avoid overflow), and stores the updated value back into the counter array. It uses branchless saturation to avoid additional control flow. Loads, adds, checks for overflow with Uint32LessThan, and performs bitwise operations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block_number\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The block number.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"LoadCounterValue\",\n                    \"StoreCounterValue\",\n                    \"V\",\n                    \"Word32Add\",\n                    \"Uint32LessThan\",\n                    \"Word32Sub\",\n                    \"Word32BitwiseOr\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void EmitBlockInstrumentation(int block_number) {\n    // Load the current counter value from the array.\n    V<Word32> value = LoadCounterValue(block_number);\n\n    // Increment the counter value.\n    V<Word32> incremented_value = __ Word32Add(value, 1);\n\n    // Branchless saturation, because we don't want to introduce additional\n    // control flow here.\n    V<Word32> overflow = __ Uint32LessThan(incremented_value, value);\n    V<Word32> overflow_mask = __ Word32Sub(0, overflow);\n    V<Word32> saturated_value =\n        __ Word32BitwiseOr(incremented_value, overflow_mask);\n\n    // Store the incremented counter value back into the array.\n    StoreCounterValue(block_number, saturated_value);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(Branch)\",\n                \"parent\": \"BlockInstrumentationReducer\",\n                \"about\": \"Reduces a Branch operation in the input graph.\",\n                \"logic\": \"Adds the branch information (true and false block IDs) to the profiler data and then calls the ReduceInputGraphBranch method of the next reducer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_index\",\n                        \"type\": \"V<None>\",\n                        \"purpose\": \"The index of the input graph.\"\n                    },\n                    {\n                        \"name\": \"branch\",\n                        \"type\": \"const BranchOp&\",\n                        \"purpose\": \"The branch operation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<None>\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"ReduceInputGraphBranch\",\n                    \"V\",\n                    \"BranchOp\",\n                    \"index\",\n                    \"AddBranch\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<None> REDUCE_INPUT_GRAPH(Branch)(V<None> ig_index, const BranchOp& branch) {\n    const int true_id = branch.if_true->index().id();\n    const int false_id = branch.if_false->index().id();\n    data_->AddBranch(true_id, false_id);\n    return Next::ReduceInputGraphBranch(ig_index, branch);\n  }\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"UniformReducerAdapter\",\n                    \"about\": \"Base class for uniform reducers.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass UniformReducerAdapter {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Block\",\n                    \"about\": \"Represents a basic block in the control flow graph.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass Block {\n public:\n  Index index() const { return Index(); }\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Index\",\n                    \"about\": \"Represents an index.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass Index {\n public:\n  int id() const { return 0; }\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Isolate\",\n                    \"about\": \"Represents an isolate.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass Isolate {\n public:\n  bool IsGeneratingEmbeddedBuiltins() const { return false; }\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"HeapObject\",\n                    \"about\": \"Represents a heap object.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass HeapObject {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"BasicBlockProfilerData\",\n                    \"about\": \"Stores the profiler data for basic blocks.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass BasicBlockProfilerData {\n public:\n  void SetBlockId(int block_number, int id) {}\n  void AddBranch(int true_id, int false_id) {}\n  uint32_t* counts() { return nullptr; }\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Handle\",\n                    \"about\": \"A handle to a heap object.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\ntemplate <typename T>\nclass Handle {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"V\",\n                    \"about\": \"Represents a value.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\ntemplate <typename T>\nclass V {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Object\",\n                    \"about\": \"Represents a generic object.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass Object {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Any\",\n                    \"about\": \"Represents a value of any type.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass Any {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RegisterRepresentation\",\n                    \"about\": \"Represents a register representation.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass RegisterRepresentation {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"OpEffects\",\n                    \"about\": \"Represents operation effects.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass OpEffects {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Word32\",\n                    \"about\": \"Represents a 32 bit word.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass Word32 {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"WordPtr\",\n                    \"about\": \"Represents a pointer-sized word.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass WordPtr {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ByteArray\",\n                    \"about\": \"Represents a byte array.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nclass ByteArray {\n public:\n  struct Header {};\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"LoadOp::Kind\",\n                    \"about\": \"Represents kind of load operation.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\nnamespace LoadOp {\nenum Kind { TaggedBase };\n}\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language"
}