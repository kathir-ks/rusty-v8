{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/instructions.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/instructions.h\",\n            \"file_name\": \"instructions.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the instruction set for the Torque language, used in the V8 JavaScript engine for code generation.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary standard library headers and Torque-specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <memory>\n            #include <optional>\n\n            #include \"src/torque/ast.h\"\n            #include \"src/torque/source-positions.h\"\n            #include \"src/torque/types.h\"\n            #include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DefinitionLocation\",\n                \"about\": \"Represents the location where a value is defined within the Torque IR.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind_\",\n                        \"type\": \"Kind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates the type of definition location (Parameter, Phi, Instruction).\"\n                    },\n                    {\n                        \"name\": \"location_\",\n                        \"type\": \"const void*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the actual location (e.g., a Block or InstructionBase).\"\n                    },\n                    {\n                        \"name\": \"index_\",\n                        \"type\": \"std::size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An index providing further detail about the location.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class DefinitionLocation {\n            public:\n                enum class Kind {\n                    kInvalid,\n                    kParameter,\n                    kPhi,\n                    kInstruction,\n                };\n\n                DefinitionLocation() : kind_(Kind::kInvalid), location_(nullptr), index_(0) {}\n\n                static DefinitionLocation Parameter(std::size_t index);\n\n                static DefinitionLocation Phi(const Block* block, std::size_t index);\n\n                static DefinitionLocation Instruction(const InstructionBase* instruction,\n                                                        std::size_t index = 0);\n\n                Kind GetKind() const { return kind_; }\n                bool IsValid() const { return kind_ != Kind::kInvalid; }\n                bool IsParameter() const { return kind_ == Kind::kParameter; }\n                bool IsPhi() const { return kind_ == Kind::kPhi; }\n                bool IsInstruction() const { return kind_ == Kind::kInstruction; }\n\n                std::size_t GetParameterIndex() const;\n\n                const Block* GetPhiBlock() const;\n\n                bool IsPhiFromBlock(const Block* block) const;\n\n                std::size_t GetPhiIndex() const;\n\n                const InstructionBase* GetInstruction() const;\n\n                std::size_t GetInstructionIndex() const;\n\n                bool operator==(const DefinitionLocation& other) const;\n\n                bool operator!=(const DefinitionLocation& other) const;\n\n                bool operator<(const DefinitionLocation& other) const;\n\n            private:\n                DefinitionLocation(Kind kind, const void* location, std::size_t index)\n                    : kind_(kind), location_(location), index_(index) {}\n\n                Kind kind_;\n                const void* location_;\n                std::size_t index_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for DefinitionLocation to enable printing DefinitionLocation objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"stream\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"loc\",\n                        \"type\": \"const DefinitionLocation&\",\n                        \"purpose\": \"The DefinitionLocation to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"DefinitionLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(std::ostream& stream,\n                                            const DefinitionLocation& loc) {\n                switch (loc.GetKind()) {\n                    case DefinitionLocation::Kind::kInvalid:\n                        return stream << \"DefinitionLocation::Invalid()\";\n                    case DefinitionLocation::Kind::kParameter:\n                        return stream << \"DefinitionLocation::Parameter(\"\n                                    << loc.GetParameterIndex() << \")\";\n                    case DefinitionLocation::Kind::kPhi:\n                        return stream << \"DefinitionLocation::Phi(\" << std::hex\n                                    << loc.GetPhiBlock() << std::dec << \", \"\n                                    << loc.GetPhiIndex() << \")\";\n                    case DefinitionLocation::Kind::kInstruction:\n                        return stream << \"DefinitionLocation::Instruction(\" << std::hex\n                                    << loc.GetInstruction() << std::dec << \", \"\n                                    << loc.GetInstructionIndex() << \")\";\n                }\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"InstructionBase\",\n                \"about\": \"Base class for all Torque instructions. Provides common functionality like cloning and type checking.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"SourcePosition\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the source position of the instruction.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"ControlFlowGraph\",\n                    \"DefinitionLocation\",\n                    \"Block\",\n                    \"Worklist\",\n                    \"Stack\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct InstructionBase {\n                InstructionBase() : pos(CurrentSourcePosition::Get()) {}\n                virtual std::unique_ptr<InstructionBase> Clone() const = 0;\n                virtual void Assign(const InstructionBase& other) = 0;\n                virtual ~InstructionBase() = default;\n\n                virtual void TypeInstruction(Stack<const Type*>* stack,\n                                            ControlFlowGraph* cfg) const = 0;\n                virtual void RecomputeDefinitionLocations(\n                    Stack<DefinitionLocation>* locations,\n                    Worklist<Block*>* worklist) const = 0;\n                void InvalidateTransientTypes(Stack<const Type*>* stack) const;\n                virtual bool IsBlockTerminator() const { return false; }\n                virtual void AppendSuccessorBlocks(std::vector<Block*>* block_list) const {}\n\n                SourcePosition pos;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Instruction\",\n                \"about\": \"Wrapper around InstructionBase that manages the lifetime of the actual instruction object.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind_\",\n                        \"type\": \"InstructionKind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the kind of instruction.\"\n                    },\n                    {\n                        \"name\": \"instruction_\",\n                        \"type\": \"std::unique_ptr<InstructionBase>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A unique pointer to the InstructionBase object.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"InstructionKind\",\n                    \"Type\",\n                    \"ControlFlowGraph\",\n                    \"DefinitionLocation\",\n                    \"Block\",\n                    \"Worklist\",\n                    \"Stack\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class Instruction {\n            public:\n                template <class T>\n                Instruction(T instr)  // NOLINT(runtime/explicit)\n                    : kind_(T::kKind), instruction_(new T(std::move(instr))) {}\n\n                template <class T>\n                T& Cast() {\n                    DCHECK(Is<T>());\n                    return static_cast<T&>(*instruction_);\n                }\n\n                template <class T>\n                const T& Cast() const {\n                    DCHECK(Is<T>());\n                    return static_cast<const T&>(*instruction_);\n                }\n\n                template <class T>\n                bool Is() const {\n                    return kind_ == T::kKind;\n                }\n\n                template <class T>\n                T* DynamicCast() {\n                    if (Is<T>()) return &Cast<T>();\n                    return nullptr;\n                }\n\n                template <class T>\n                const T* DynamicCast() const {\n                    if (Is<T>()) return &Cast<T>();\n                    return nullptr;\n                }\n\n                Instruction(const Instruction& other) V8_NOEXCEPT\n                    : kind_(other.kind_),\n                        instruction_(other.instruction_->Clone()) {}\n                Instruction& operator=(const Instruction& other) V8_NOEXCEPT {\n                    if (kind_ == other.kind_) {\n                        instruction_->Assign(*other.instruction_);\n                    } else {\n                        kind_ = other.kind_;\n                        instruction_ = other.instruction_->Clone();\n                    }\n                    return *this;\n                }\n\n                InstructionKind kind() const { return kind_; }\n                const char* Mnemonic() const;\n                void TypeInstruction(Stack<const Type*>* stack, ControlFlowGraph* cfg) const;\n                void RecomputeDefinitionLocations(Stack<DefinitionLocation>* locations,\n                                                    Worklist<Block*>* worklist) const;\n\n                InstructionBase* operator->() { return instruction_.get(); }\n                const InstructionBase* operator->() const { return instruction_.get(); }\n\n            private:\n                InstructionKind kind_;\n                std::unique_ptr<InstructionBase> instruction_;\n            };\n        ]]></code>\n    </class>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"PeekInstruction\",\n                \"about\": \"Instruction to peek a value from the stack.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"slot\",\n                        \"type\": \"BottomOffset\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The stack slot to peek from.\"\n                    },\n                    {\n                        \"name\": \"widened_type\",\n                        \"type\": \"std::optional<const Type*>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"An optional type to widen the peeked value to.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"Type\",\n                    \"BottomOffset\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct PeekInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n\n                PeekInstruction(BottomOffset slot, std::optional<const Type*> widened_type)\n                    : slot(slot), widened_type(widened_type) {}\n\n                BottomOffset slot;\n                std::optional<const Type*> widened_type;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for PeekInstruction to enable printing PeekInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const PeekInstruction&\",\n                        \"purpose\": \"The PeekInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"PeekInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(std::ostream& os,\n                                            const PeekInstruction& instruction) {\n                os << \"Peek \" << instruction.slot;\n                if (instruction.widened_type) {\n                    os << \", \" << **instruction.widened_type;\n                }\n                return os;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"PokeInstruction\",\n                \"about\": \"Instruction to poke a value into the stack.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"slot\",\n                        \"type\": \"BottomOffset\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The stack slot to poke into.\"\n                    },\n                    {\n                        \"name\": \"widened_type\",\n                        \"type\": \"std::optional<const Type*>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"An optional type to widen the poked value to.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"Type\",\n                    \"BottomOffset\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct PokeInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n\n                PokeInstruction(BottomOffset slot, std::optional<const Type*> widened_type)\n                    : slot(slot), widened_type(widened_type) {}\n\n                BottomOffset slot;\n                std::optional<const Type*> widened_type;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for PokeInstruction to enable printing PokeInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const PokeInstruction&\",\n                        \"purpose\": \"The PokeInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"PokeInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(std::ostream& os,\n                                            const PokeInstruction& instruction) {\n                os << \"Poke \" << instruction.slot;\n                if (instruction.widened_type) {\n                    os << \", \" << **instruction.widened_type;\n                }\n                return os;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"DeleteRangeInstruction\",\n                \"about\": \"Instruction to delete a range of slots from the stack.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"range\",\n                        \"type\": \"StackRange\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The range of stack slots to delete.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"StackRange\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct DeleteRangeInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n                explicit DeleteRangeInstruction(StackRange range) : range(range) {}\n\n                StackRange range;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for DeleteRangeInstruction to enable printing DeleteRangeInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const DeleteRangeInstruction&\",\n                        \"purpose\": \"The DeleteRangeInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"DeleteRangeInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(std::ostream& os,\n                                            const DeleteRangeInstruction& instruction) {\n                return os << \"DeleteRange \" << instruction.range;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"PushUninitializedInstruction\",\n                \"about\": \"Instruction to push an uninitialized value of a given type onto the stack.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The type of the uninitialized value.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"Type\",\n                    \"DefinitionLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct PushUninitializedInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n                explicit PushUninitializedInstruction(const Type* type) : type(type) {}\n\n                DefinitionLocation GetValueDefinition() const;\n\n                const Type* type;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for PushUninitializedInstruction to enable printing PushUninitializedInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const PushUninitializedInstruction&\",\n                        \"purpose\": \"The PushUninitializedInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"PushUninitializedInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(\n                std::ostream& os, const PushUninitializedInstruction& instruction) {\n                return os << \"PushUninitialized \" << *instruction.type;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"PushBuiltinPointerInstruction\",\n                \"about\": \"Instruction to push a pointer to a builtin function onto the stack.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"external_name\",\n                        \"type\": \"std::string\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The name of the builtin function.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The type of the builtin pointer.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"Type\",\n                    \"DefinitionLocation\",\n                    \"BuiltinPointerType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct PushBuiltinPointerInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n                PushBuiltinPointerInstruction(std::string external_name, const Type* type)\n                    : external_name(std::move(external_name)), type(type) {\n                    DCHECK(type->IsBuiltinPointerType());\n                }\n\n                DefinitionLocation GetValueDefinition() const;\n\n                std::string external_name;\n                const Type* type;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for PushBuiltinPointerInstruction to enable printing PushBuiltinPointerInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const PushBuiltinPointerInstruction&\",\n                        \"purpose\": \"The PushBuiltinPointerInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"PushBuiltinPointerInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(\n                std::ostream& os, const PushBuiltinPointerInstruction& instruction) {\n                return os << \"PushBuiltinPointer \"\n                            << StringLiteralQuote(instruction.external_name) << \", \"\n                            << *instruction.type;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"NamespaceConstantInstruction\",\n                \"about\": \"Instruction to push a namespace constant onto the stack.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"constant\",\n                        \"type\": \"NamespaceConstant*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The namespace constant to push.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"NamespaceConstant\",\n                    \"DefinitionLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct NamespaceConstantInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n                explicit NamespaceConstantInstruction(NamespaceConstant* constant)\n                    : constant(constant) {}\n\n                std::size_t GetValueDefinitionCount() const;\n                DefinitionLocation GetValueDefinition(std::size_t index) const;\n\n                NamespaceConstant* constant;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for NamespaceConstantInstruction to enable printing NamespaceConstantInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const NamespaceConstantInstruction&\",\n                        \"purpose\": \"The NamespaceConstantInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"NamespaceConstantInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os,\n                                    const NamespaceConstantInstruction& instruction);\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"LoadReferenceInstruction\",\n                \"about\": \"Instruction to load a value from a reference.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The type of the loaded value.\"\n                    },\n                    {\n                        \"name\": \"synchronization\",\n                        \"type\": \"FieldSynchronization\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Specifies the synchronization semantics for the load.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"Type\",\n                    \"DefinitionLocation\",\n                    \"FieldSynchronization\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct LoadReferenceInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n                explicit LoadReferenceInstruction(const Type* type,\n                                                    FieldSynchronization synchronization)\n                    : type(type), synchronization(synchronization) {}\n\n                DefinitionLocation GetValueDefinition() const;\n\n                const Type* type;\n                FieldSynchronization synchronization;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for LoadReferenceInstruction to enable printing LoadReferenceInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const LoadReferenceInstruction&\",\n                        \"purpose\": \"The LoadReferenceInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"LoadReferenceInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(std::ostream& os,\n                                            const LoadReferenceInstruction& instruction) {\n                return os << \"LoadReference \" << *instruction.type;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"StoreReferenceInstruction\",\n                \"about\": \"Instruction to store a value into a reference.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The type of the stored value.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct StoreReferenceInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n                explicit StoreReferenceInstruction(const Type* type) : type(type) {}\n                const Type* type;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for StoreReferenceInstruction to enable printing StoreReferenceInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const StoreReferenceInstruction&\",\n                        \"purpose\": \"The StoreReferenceInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"StoreReferenceInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(std::ostream& os,\n                                            const StoreReferenceInstruction& instruction) {\n                return os << \"StoreReference \" << *instruction.type;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"LoadBitFieldInstruction\",\n                \"about\": \"Instruction to load a bitfield from a struct.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"bit_field_struct_type\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The type of the struct containing the bitfield.\"\n                    },\n                    {\n                        \"name\": \"bit_field\",\n                        \"type\": \"BitField\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The bitfield to load.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"Type\",\n                    \"BitField\",\n                    \"DefinitionLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct LoadBitFieldInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n                LoadBitFieldInstruction(const Type* bit_field_struct_type, BitField bit_field)\n                    : bit_field_struct_type(bit_field_struct_type),\n                        bit_field(std::move(bit_field)) {}\n\n                DefinitionLocation GetValueDefinition() const;\n\n                const Type* bit_field_struct_type;\n                BitField bit_field;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for LoadBitFieldInstruction to enable printing LoadBitFieldInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const LoadBitFieldInstruction&\",\n                        \"purpose\": \"The LoadBitFieldInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"LoadBitFieldInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(std::ostream& os,\n                                            const LoadBitFieldInstruction& instruction) {\n                return os << \"LoadBitField \" << *instruction.bit_field_struct_type << \", \"\n                            << instruction.bit_field.name_and_type.name;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"StoreBitFieldInstruction\",\n                \"about\": \"Instruction to store a bitfield into a struct.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"bit_field_struct_type\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The type of the struct containing the bitfield.\"\n                    },\n                    {\n                        \"name\": \"bit_field\",\n                        \"type\": \"BitField\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The bitfield to store.\"\n                    },\n                    {\n                        \"name\": \"starts_as_zero\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether the bitfield starts as zero, allowing for optimization.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InstructionBase\",\n                    \"Type\",\n                    \"BitField\",\n                    \"DefinitionLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct StoreBitFieldInstruction : InstructionBase {\n                TORQUE_INSTRUCTION_BOILERPLATE()\n                StoreBitFieldInstruction(const Type* bit_field_struct_type,\n                                            BitField bit_field, bool starts_as_zero)\n                    : bit_field_struct_type(bit_field_struct_type),\n                        bit_field(std::move(bit_field)),\n                        starts_as_zero(starts_as_zero) {}\n\n                DefinitionLocation GetValueDefinition() const;\n\n                const Type* bit_field_struct_type;\n                BitField bit_field;\n                // Allows skipping the mask step if we know the starting value is zero.\n                bool starts_as_zero;\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for StoreBitFieldInstruction to enable printing StoreBitFieldInstruction objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const StoreBitFieldInstruction&\",\n                        \"purpose\": \"The StoreBitFieldInstruction to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"StoreBitFieldInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline std::ostream& operator<<(std::ostream& os,\n                                            const StoreBitFieldInstruction& instruction) {\n                os << \"StoreBitField \" << *instruction.bit_field_struct_type << \", \"\n                    << instruction.bit_field.name_and_type.name;\n                if (instruction.starts_as_zero) {\n                    os << \", starts_as_zero\";\n                }\n                return os;\n            }\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"CallIntrinsicInstruction\",\n                \"about\": \"Instruction to call an intrinsic function.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"intrinsic\",\n                        \"type\": \"Intrinsic*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The intrinsic function to call.\"\n                    },\n                    {\n                        \"name\": \"specialization_types\",\n                        \"type\": \"TypeVector\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The specialization types for the intrinsic.\"\n                    },\n                    {\n                        \"name\": \"constexpr_arguments\",\n                        \"type\": \"std::vector<std::string>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The constexpr arguments for the intrinsic.\"\n                    }\n                ],"
}