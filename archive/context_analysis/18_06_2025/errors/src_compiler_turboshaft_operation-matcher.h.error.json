{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/operation-matcher.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 64, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/operation-matcher.h\",\n            \"file_name\": \"operation-matcher.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the OperationMatcher class, which provides utilities for matching and inspecting operations within a Turboshaft graph. This is useful for simplifying graph traversals and pattern matching.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard library headers for limits, optional values, type traits, and variant.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <limits>\n            #include <optional>\n            #include <type_traits>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 specific headers for the Turboshaft graph, index, operations, and representations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/turboshaft/graph.h\"\n            #include \"src/compiler/turboshaft/index.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OperationMatcher\",\n                \"about\": \"Provides methods for matching specific operation types and properties within a Turboshaft graph.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Graph\",\n                    \"Operation\",\n                    \"ConstantOp\",\n                    \"ChangeOp\",\n                    \"WordBinopOp\",\n                    \"ComparisonOp\",\n                    \"FloatUnaryOp\",\n                    \"FloatBinopOp\",\n                    \"ShiftOp\",\n                    \"PhiOp\",\n                    \"WordRepresentation\",\n                    \"FloatRepresentation\",\n                    \"RegisterRepresentation\",\n                    \"ExternalReference\",\n                    \"Handle<HeapObject>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class OperationMatcher {\n            public:\n                template <typename T>\n                using IMatch = detail::IndexMatch<T, const_or_v_exists_v<T>>;\n                template <typename T>\n                using VMatch = detail::ValueMatch<T>;\n\n                explicit OperationMatcher(const Graph& graph) : graph_(graph) {}\n\n                template <class Op>\n                bool Is(V<AnyOrNone> op_idx) const {\n                    return graph_.Get(op_idx).Is<Op>();\n                }\n\n                template <class Op>\n                const underlying_operation_t<Op>* TryCast(V<AnyOrNone> op_idx) const {\n                    return graph_.Get(op_idx).TryCast<Op>();\n                }\n\n                template <class Op>\n                const underlying_operation_t<Op>& Cast(V<AnyOrNone> op_idx) const {\n                    return graph_.Get(op_idx).Cast<Op>();\n                }\n\n                const Operation& Get(V<AnyOrNone> op_idx) const { return graph_.Get(op_idx); }\n\n                V<AnyOrNone> Index(const Operation& op) const { return graph_.Index(op); }\n\n                bool MatchZero(V<Any> matched) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    switch (op->kind) {\n                      case ConstantOp::Kind::kWord32:\n                      case ConstantOp::Kind::kWord64:\n                        return op->integral() == 0;\n                      case ConstantOp::Kind::kFloat32:\n                        return op->float32().get_scalar() == 0;\n                      case ConstantOp::Kind::kFloat64:\n                        return op->float64().get_scalar() == 0;\n                      case ConstantOp::Kind::kSmi:\n                        return op->smi().value() == 0;\n                      default:\n                        return false;\n                    }\n                }\n\n                bool MatchIntegralZero(V<Any> matched) const {\n                    int64_t constant;\n                    return MatchSignedIntegralConstant(matched, &constant) && constant == 0;\n                }\n\n                bool MatchSmiZero(V<Any> matched) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (op->kind != ConstantOp::Kind::kSmi) return false;\n                    return op->smi().value() == 0;\n                }\n\n                bool MatchFloat32Constant(V<Any> matched, float* constant) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (op->kind != ConstantOp::Kind::kFloat32) return false;\n                    *constant = op->storage.float32.get_scalar();\n                    return true;\n                }\n\n                bool MatchFloat32Constant(V<Any> matched, i::Float32* constant) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (op->kind != ConstantOp::Kind::kFloat32) return false;\n                    *constant = op->storage.float32;\n                    return true;\n                }\n\n                bool MatchFloat64Constant(V<Any> matched, double* constant) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (op->kind != ConstantOp::Kind::kFloat64) return false;\n                    *constant = op->storage.float64.get_scalar();\n                    return true;\n                }\n\n                bool MatchFloat64Constant(V<Any> matched, i::Float64* constant) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (op->kind != ConstantOp::Kind::kFloat64) return false;\n                    *constant = op->storage.float64;\n                    return true;\n                }\n\n                bool MatchFloat(V<Any> matched, double* value) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (op->kind == ConstantOp::Kind::kFloat64) {\n                        *value = op->storage.float64.get_scalar();\n                        return true;\n                    } else if (op->kind == ConstantOp::Kind::kFloat32) {\n                        *value = op->storage.float32.get_scalar();\n                        return true;\n                    }\n                    return false;\n                }\n\n                bool MatchFloat(V<Any> matched, double value) const {\n                    double k;\n                    if (!MatchFloat(matched, &k)) return false;\n                    return base::bit_cast<uint64_t>(value) == base::bit_cast<uint64_t>(k) ||\n                           (std::isnan(k) && std::isnan(value));\n                }\n\n                bool MatchNaN(V<Float> matched) const {\n                    double k;\n                    return MatchFloat(matched, &k) && std::isnan(k);\n                }\n\n                bool MatchHeapConstant(V<Any> matched,\n                                        Handle<HeapObject>* tagged = nullptr) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (!(op->kind == any_of(ConstantOp::Kind::kHeapObject,\n                                             ConstantOp::Kind::kCompressedHeapObject))) {\n                      return false;\n                    }\n                    if (tagged) {\n                      *tagged = op->handle();\n                    }\n                    return true;\n                }\n\n                bool MatchIntegralWordConstant(V<Any> matched, WordRepresentation rep,\n                                                uint64_t* unsigned_constant,\n                                                int64_t* signed_constant = nullptr) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    switch (op->kind) {\n                      case ConstantOp::Kind::kWord32:\n                      case ConstantOp::Kind::kWord64:\n                      case ConstantOp::Kind::kRelocatableWasmCall:\n                      case ConstantOp::Kind::kRelocatableWasmStubCall:\n                        if (rep.value() == WordRepresentation::Word32()) {\n                          if (unsigned_constant) {\n                            *unsigned_constant = static_cast<uint32_t>(op->integral());\n                          }\n                          if (signed_constant) {\n                            *signed_constant = static_cast<int32_t>(op->signed_integral());\n                          }\n                          return true;\n                        } else if (rep.value() == WordRepresentation::Word64()) {\n                          if (unsigned_constant) {\n                            *unsigned_constant = op->integral();\n                          }\n                          if (signed_constant) {\n                            *signed_constant = op->signed_integral();\n                          }\n                          return true;\n                        }\n                        return false;\n                      default:\n                        return false;\n                    }\n                    UNREACHABLE();\n                }\n\n                bool MatchIntegralWordConstant(V<Any> matched, WordRepresentation rep,\n                                                int64_t* signed_constant) const {\n                    return MatchIntegralWordConstant(matched, rep, nullptr, signed_constant);\n                }\n\n                bool MatchIntegralWord32Constant(V<Any> matched, uint32_t* constant) const {\n                    if (uint64_t value; MatchIntegralWordConstant(\n                            matched, WordRepresentation::Word32(), &value)) {\n                      *constant = static_cast<uint32_t>(value);\n                      return true;\n                    }\n                    return false;\n                }\n\n                bool MatchIntegralWord64Constant(V<Any> matched, uint64_t* constant) const {\n                    return MatchIntegralWordConstant(matched, WordRepresentation::Word64(),\n                                                     constant);\n                }\n\n                bool MatchIntegralWord32Constant(V<Any> matched, uint32_t constant) const {\n                    if (uint64_t value; MatchIntegralWordConstant(\n                            matched, WordRepresentation::Word32(), &value)) {\n                      return static_cast<uint32_t>(value) == constant;\n                    }\n                    return false;\n                }\n\n                bool MatchIntegralWord64Constant(V<Any> matched, int64_t* constant) const {\n                    return MatchIntegralWordConstant(matched, WordRepresentation::Word64(),\n                                                     constant);\n                }\n\n                bool MatchIntegralWord32Constant(V<Any> matched, int32_t* constant) const {\n                    if (int64_t value; MatchIntegralWordConstant(\n                            matched, WordRepresentation::Word32(), &value)) {\n                      *constant = static_cast<int32_t>(value);\n                      return true;\n                    }\n                    return false;\n                }\n\n                template <typename T = intptr_t>\n                bool MatchIntegralWordPtrConstant(V<Any> matched, T* constant) const {\n                    if constexpr (Is64()) {\n                      static_assert(sizeof(T) == sizeof(int64_t));\n                      int64_t v;\n                      if (!MatchIntegralWord64Constant(matched, &v)) return false;\n                      *constant = static_cast<T>(v);\n                      return true;\n                    } else {\n                      static_assert(sizeof(T) == sizeof(int32_t));\n                      int32_t v;\n                      if (!MatchIntegralWord32Constant(matched, &v)) return false;\n                      *constant = static_cast<T>(v);\n                      return true;\n                    }\n                }\n\n                bool MatchSignedIntegralConstant(V<Any> matched, int64_t* constant) const {\n                    if (const ConstantOp* c = TryCast<ConstantOp>(matched)) {\n                      if (c->kind == ConstantOp::Kind::kWord32 ||\n                          c->kind == ConstantOp::Kind::kWord64) {\n                        *constant = c->signed_integral();\n                        return true;\n                      }\n                    }\n                    return false;\n                }\n\n                bool MatchUnsignedIntegralConstant(V<Any> matched, uint64_t* constant) const {\n                    if (const ConstantOp* c = TryCast<ConstantOp>(matched)) {\n                      if (c->kind == ConstantOp::Kind::kWord32 ||\n                          c->kind == ConstantOp::Kind::kWord64) {\n                        *constant = c->integral();\n                        return true;\n                      }\n                    }\n                    return false;\n                }\n\n                bool MatchExternalConstant(V<Any> matched,\n                                             ExternalReference* reference) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (op->kind != ConstantOp::Kind::kExternal) return false;\n                    *reference = op->storage.external;\n                    return true;\n                }\n\n                bool MatchWasmStubCallConstant(V<Any> matched, uint64_t* stub_id) const {\n                    const ConstantOp* op = TryCast<ConstantOp>(matched);\n                    if (!op) return false;\n                    if (op->kind != ConstantOp::Kind::kRelocatableWasmStubCall) {\n                      return false;\n                    }\n                    *stub_id = op->integral();\n                    return true;\n                }\n\n                template <typename T>\n                bool MatchChange(V<Any> matched, IMatch<T> input,\n                                 VMatch<ChangeOp::Kind> kind = {},\n                                 VMatch<ChangeOp::Assumption> assumption = {},\n                                 VMatch<RegisterRepresentation> from = {},\n                                 VMatch<RegisterRepresentation> to = {}) const {\n                    const ChangeOp* op = TryCast<ChangeOp>(matched);\n                    if (!op) return false;\n                    return input.matches(op->input(), this) && kind.matches(op->kind) &&\n                           assumption.matches(op->assumption) && from.matches(op->from) &&\n                           to.matches(op->to);\n                }\n\n                bool MatchTruncateWord64ToWord32(V<Any> matched, IMatch<Word64> input) const {\n                    return MatchChange<Word64>(matched, input, ChangeOp::Kind::kTruncate, {},\n                                                RegisterRepresentation::Word64(),\n                                                RegisterRepresentation::Word32());\n                }\n\n                template <typename T>\n                  requires(IsWord<T>())\n                bool MatchWordBinop(V<Any> matched, IMatch<T> left, IMatch<T> right,\n                                      VMatch<WordBinopOp::Kind> kind = {},\n                                      VMatch<WordRepresentation> rep = {}) const {\n                    const WordBinopOp* op = TryCast<WordBinopOp>(matched);\n                    if (!op) return false;\n                    return left.matches(op->left(), this) && right.matches(op->right(), this) &&\n                           kind.matches(op->kind) && rep.matches(op->rep);\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchWordAdd(V<Any> matched, V<T>* left, V<T>* right,\n                                    WordRepresentation rep) const {\n                    return MatchWordBinop<T>(matched, left, right, WordBinopOp::Kind::kAdd,\n                                             rep);\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchWordSub(V<Any> matched, V<T>* left, V<T>* right,\n                                    WordRepresentation rep) const {\n                    return MatchWordBinop<T>(matched, left, right, WordBinopOp::Kind::kSub,\n                                             rep);\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchWordMul(V<Any> matched, V<T>* left, V<T>* right,\n                                    WordRepresentation rep) const {\n                    return MatchWordBinop<T>(matched, left, right, WordBinopOp::Kind::kMul,\n                                             rep);\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchBitwiseAnd(V<Any> matched, V<T>* left, V<T>* right,\n                                       WordRepresentation rep) const {\n                    return MatchWordBinop<T>(matched, left, right,\n                                             WordBinopOp::Kind::kBitwiseAnd, rep);\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchBitwiseAndWithConstant(V<Any> matched, V<T>* value,\n                                                    uint64_t* constant,\n                                                    WordRepresentation rep) const {\n                    V<T> left, right;\n                    if (!MatchBitwiseAnd(matched, &left, &right, rep)) return false;\n                    if (MatchIntegralWordConstant(right, rep, constant)) {\n                      *value = left;\n                      return true;\n                    } else if (MatchIntegralWordConstant(left, rep, constant)) {\n                      *value = right;\n                      return true;\n                    }\n                    return false;\n                }\n\n                template <typename T>\n                bool MatchEqual(V<Any> matched, V<T>* left, V<T>* right) const {\n                    const ComparisonOp* op = TryCast<ComparisonOp>(matched);\n                    if (!op || op->kind != ComparisonOp::Kind::kEqual || op->rep != V<T>::rep) {\n                      return false;\n                    }\n                    *left = V<T>::Cast(op->left());\n                    *right = V<T>::Cast(op->right());\n                    return true;\n                }\n\n                bool MatchFloatUnary(V<Any> matched, V<Float>* input, FloatUnaryOp::Kind kind,\n                                      FloatRepresentation rep) const {\n                    const FloatUnaryOp* op = TryCast<FloatUnaryOp>(matched);\n                    if (!op || op->kind != kind || op->rep != rep) return false;\n                    *input = op->input();\n                    return true;\n                }\n\n                bool MatchFloatRoundDown(V<Any> matched, V<Float>* input,\n                                         FloatRepresentation rep) const {\n                    return MatchFloatUnary(matched, input, FloatUnaryOp::Kind::kRoundDown, rep);\n                }\n\n                bool MatchFloatBinary(V<Any> matched, V<Float>* left, V<Float>* right,\n                                        FloatBinopOp::Kind kind,\n                                        FloatRepresentation rep) const {\n                    const FloatBinopOp* op = TryCast<FloatBinopOp>(matched);\n                    if (!op || op->kind != kind || op->rep != rep) return false;\n                    *left = op->left();\n                    *right = op->right();\n                    return true;\n                }\n\n                bool MatchFloatSub(V<Any> matched, V<Float>* left, V<Float>* right,\n                                     FloatRepresentation rep) const {\n                    return MatchFloatBinary(matched, left, right, FloatBinopOp::Kind::kSub,\n                                            rep);\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchConstantShift(V<Any> matched, V<T>* input, ShiftOp::Kind* kind,\n                                          WordRepresentation* rep, int* amount) const {\n                    const ShiftOp* op = TryCast<ShiftOp>(matched);\n                    if (uint32_t rhs_constant;\n                        op && MatchIntegralWord32Constant(op->right(), &rhs_constant) &&\n                        rhs_constant < static_cast<uint64_t>(op->rep.bit_width())) {\n                      *input = op->left<T>();\n                      *kind = op->kind;\n                      *rep = op->rep;\n                      *amount = static_cast<int>(rhs_constant);\n                      return true;\n                    }\n                    return false;\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchConstantShift(V<Any> matched, V<T>* input, ShiftOp::Kind kind,\n                                          WordRepresentation rep, int* amount) const {\n                    DCHECK(IsValidTypeFor<T>(rep));\n                    const ShiftOp* op = TryCast<ShiftOp>(matched);\n                    if (uint32_t rhs_constant;\n                        op && op->kind == kind &&\n                        (op->rep == rep || (ShiftOp::AllowsWord64ToWord32Truncation(kind) &&\n                                            rep == WordRepresentation::Word32() &&\n                                            op->rep == WordRepresentation::Word64())) &&\n                        MatchIntegralWord32Constant(op->right(), &rhs_constant) &&\n                        rhs_constant < static_cast<uint64_t>(rep.bit_width())) {\n                      *input = op->left<T>();\n                      *amount = static_cast<int>(rhs_constant);\n                      return true;\n                    }\n                    return false;\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchConstantRightShift(V<Any> matched, V<T>* input,\n                                               WordRepresentation rep, int* amount) const {\n                    DCHECK(IsValidTypeFor<T>(rep));\n                    const ShiftOp* op = TryCast<ShiftOp>(matched);\n                    if (uint32_t rhs_constant;\n                        op && ShiftOp::IsRightShift(op->kind) && op->rep == rep &&\n                        MatchIntegralWord32Constant(op->right(), &rhs_constant) &&\n                        rhs_constant < static_cast<uint32_t>(rep.bit_width())) {\n                      *input = op->left<T>();\n                      *amount = static_cast<int>(rhs_constant);\n                      return true;\n                    }\n                    return false;\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchConstantLeftShift(V<Any> matched, V<T>* input,\n                                              WordRepresentation rep, int* amount) const {\n                    DCHECK(IsValidTypeFor<T>(rep));\n                    const ShiftOp* op = TryCast<ShiftOp>(matched);\n                    if (uint32_t rhs_constant;\n                        op && op->kind == ShiftOp::Kind::kShiftLeft && op->rep == rep &&\n                        MatchIntegralWord32Constant(op->right(), &rhs_constant) &&\n                        rhs_constant < static_cast<uint32_t>(rep.bit_width())) {\n                      *input = op->left<T>();\n                      *amount = static_cast<int>(rhs_constant);\n                      return true;\n                    }\n                    return false;\n                }\n\n                template <class T>\n                  requires(IsWord<T>())\n                bool MatchConstantShiftRightArithmeticShiftOutZeros(V<Any> matched,\n                                                                    V<T>* input,\n                                                                    WordRepresentation rep,\n                                                                    uint16_t* amount) const {\n                    DCHECK(IsValidTypeFor<T>(rep));\n                    const ShiftOp* op = TryCast<ShiftOp>(matched);\n                    if (uint32_t rhs_constant;\n                        op && op->kind == ShiftOp::Kind::kShiftRightArithmeticShiftOutZeros &&\n                        op->rep == rep &&\n                        MatchIntegralWord32Constant(op->right(), &rhs_constant) &&\n                        rhs_constant < static_cast<uint64_t>(rep.bit_width())) {\n                      *input = op->left<T>();\n                      *amount = static_cast<uint16_t>(rhs_constant);\n                      return true;\n                    }\n                    return false;\n                }\n\n                bool MatchPhi(V<Any> matched,\n                              std::optional<int> input_count = std::nullopt) const {\n                    if (const PhiOp* phi = TryCast<PhiOp>(matched)) {\n                      return !input_count.has_value() || phi->input_count == *input_count;\n                    }\n                    return false;\n                }\n\n                bool MatchPowerOfTwoWordConstant(V<Any> matched, int64_t* ret_cst,\n                                                   WordRepresentation rep) const {\n                    int64_t loc_cst;\n                    if (MatchIntegralWordConstant(matched, rep, &loc_cst)) {\n                      if (base::bits::IsPowerOfTwo(loc_cst)) {\n                        *ret_cst = loc_cst;\n                        return true;\n                      }\n                    }\n                    return false;\n                }\n\n                bool MatchPowerOfTwoWord32Constant(V<Any> matched, int32_t* divisor) const {\n                    int64_t cst;\n                    if (MatchPowerOfTwoWordConstant(matched, &cst,\n                                                    WordRepresentation::Word32())) {\n                      DCHECK_LE(cst, std::numeric_limits<int32_t>().max());\n                      *divisor = static_cast<int32_t>(cst);\n                      return true;\n                    }\n                    return false;\n                }\n\n            private:\n                const Graph& graph_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"detail::IndexMatch\",\n                \"about\": \"Helper struct for matching OpIndex values. Provides different constructors and a matches method for checking equality or assigning the matched OpIndex.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OpIndex\",\n                    \"OperationMatcher\",\n                    \"v_traits\",\n                    \"ConstantOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace detail {\n            template <typename T, bool HasConstexpr>\n            struct IndexMatch {\n              struct Wildcard {};\n              using constexpr_type = typename v_traits<T>::constexpr_type;\n\n              IndexMatch() : v_(Wildcard{}) {}\n              IndexMatch(OpIndex index) : v_(index) {}   // NOLINT(runtime/explicit)\n              IndexMatch(OpIndex* index) : v_(index) {}  // NOLINT(runtime/explicit)\n              IndexMatch(V<T>* index) : v_(index) {}     // NOLINT(runtime/explicit)\n              IndexMatch(constexpr_type constant)        // NOLINT(runtime/explicit)\n                  : v_(constant) {}\n\n              inline bool matches(OpIndex matched, const OperationMatcher* matcher);\n\n              std::variant<Wildcard, OpIndex, OpIndex*, constexpr_type> v_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"detail::IndexMatch<T, false>\",\n                \"about\": \"Specialization of IndexMatch struct when constexpr is not available. It provides constructors and a matches method for checking equality or assigning the matched OpIndex.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OpIndex\",\n                    \"OperationMatcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct IndexMatch<T, false> {\n              struct Wildcard {};\n\n              IndexMatch() : v_(Wildcard{}) {}\n              IndexMatch(OpIndex index) : v_(index) {}   // NOLINT(runtime/explicit)\n              IndexMatch(OpIndex* index) : v_(index) {}  // NOLINT(runtime/explicit)\n              IndexMatch(V<T>* index) : v_(index) {}     // NOLINT(runtime/explicit)\n\n              inline bool matches(OpIndex matched, const OperationMatcher* matcher) {\n                switch (v_.index()) {\n                  case 0:\n                    return true;\n                  case 1:\n                    return std::get<1>(v_) == matched;\n                  case 2:\n                    *std::get<2>(v_) = matched;\n                    return true;\n                }\n                // unreachable\n                return false;\n              }\n\n              std::variant<Wildcard, OpIndex, OpIndex*> v_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"detail::ValueMatch\",\n                \"about\": \"Helper struct for matching values of a specific type. Provides constructors for wildcard matching, direct value matching and pointer assignment.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct ValueMatch {\n              struct Wildcard {};\n\n              ValueMatch() : v_(Wildcard{}) {}\n              ValueMatch(const T& value) : v_(value) {}  // NOLINT(runtime/explicit)\n              ValueMatch(T* value) : v_(value) {}        // NOLINT(runtime/explicit)\n\n              std::variant<Wildcard, T, T*> v_;\n\n              bool matches(const T& matched) {\n                switch (v_.index()) {\n                  case 0:\n                    return true;\n                  case 1:\n                    return std::get<1>(v_) == matched;\n                  case 2:\n                    *std::get<2>(v_) = matched;\n                    return true;\n                }\n                // unreachable\n                return false;\n              }\n            };\n        ]]></code>\n    </class>\n</file>\n```"
}