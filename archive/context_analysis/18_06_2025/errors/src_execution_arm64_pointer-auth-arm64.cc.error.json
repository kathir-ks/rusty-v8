{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm64/pointer-auth-arm64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm64/pointer-auth-arm64.cc\",\n            \"file_name\": \"pointer-auth-arm64.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides pointer authentication functionality for ARM64 architecture within the V8 simulator.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the ARM64 simulator header file, providing access to simulator-specific functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/arm64/simulator-arm64.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Simulator\",\n                \"about\": \"Provides simulation functionalities for ARM64 architecture.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\n// Randomly generated example key for simulating only.\nconst Simulator::PACKey Simulator::kPACKeyIB = {0xeebb163b474e04c8,\n                                                0x5267ac6fc280fb7c, 1};\n\nnamespace {\n\nuint64_t GetNibble(uint64_t in_data, int position);\nuint64_t PACCellShuffle(uint64_t in_data);\nuint64_t PACCellInvShuffle(uint64_t in_data);\nuint64_t RotCell(uint64_t in_cell, int amount);\nuint64_t PACMult(uint64_t s_input);\nuint64_t PACSub(uint64_t t_input);\nuint64_t PACInvSub(uint64_t t_input);\nuint64_t TweakCellInvRot(uint64_t in_cell);\nuint64_t TweakInvShuffle(uint64_t in_data);\nuint64_t TweakCellRot(uint64_t in_cell);\nuint64_t TweakShuffle(uint64_t in_data);\n\n}  // namespace\n\n// For a description of QARMA see:\n// The QARMA Block Cipher Family, Roberto Avanzi, Qualcomm Product Security\n// Initiative.\n// The pseudocode is available in ARM DDI 0487D.b, J1-6946.\nuint64_t Simulator::ComputePAC(uint64_t data, uint64_t context, PACKey key);\n\n// The TTBR is selected by bit 63 or 55 depending on TBI for pointers without\n// codes, but is always 55 once a PAC code is added to a pointer. For this\n// reason, it must be calculated at the call site.\nuint64_t Simulator::CalculatePACMask(uint64_t ptr, PointerType type, int ttbr);\n\nuint64_t Simulator::AuthPAC(uint64_t ptr, uint64_t context, PACKey key,\n                            PointerType type);\n\nuint64_t Simulator::AddPAC(uint64_t ptr, uint64_t context, PACKey key,\n                           PointerType type);\n\nuint64_t Simulator::StripPAC(uint64_t ptr, PointerType type);\n\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetNibble\",\n                \"about\": \"Extracts a nibble (4 bits) from a 64-bit integer at a specified position.\",\n                \"logic\": \"Right-shifts the input data by the given position, then performs a bitwise AND with 0xf to isolate the nibble.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_data\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The 64-bit integer from which to extract the nibble.\"\n                    },\n                    {\n                        \"name\": \"position\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The bit position to start extracting the nibble from.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The extracted nibble (a value between 0 and 15).\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nuint64_t GetNibble(uint64_t in_data, int position) {\n  return (in_data >> position) & 0xf;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PACCellShuffle\",\n                \"about\": \"Shuffles the nibbles within a 64-bit integer according to a predefined permutation.\",\n                \"logic\": \"Uses a static array 'in_positions' to determine the new position of each nibble. Iterates through the nibbles, extracting each one using GetNibble and placing it in its new position in the output data.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_data\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The 64-bit integer to shuffle.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The shuffled 64-bit integer.\"\n                },\n                \"dependencies\": [\n                    \"GetNibble\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t PACCellShuffle(uint64_t in_data) {\n  static int in_positions[16] = {52, 24, 44, 0,  28, 48, 4,  40,\n                                 32, 12, 56, 20, 8,  36, 16, 60};\n  uint64_t out_data = 0;\n  for (int i = 0; i < 16; ++i) {\n    out_data |= GetNibble(in_data, in_positions[i]) << (4 * i);\n  }\n  return out_data;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PACCellInvShuffle\",\n                \"about\": \"Performs the inverse shuffle operation of PACCellShuffle.\",\n                \"logic\": \"Similar to PACCellShuffle, but uses a different static array 'in_positions' to reverse the nibble permutation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_data\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The 64-bit integer to inverse shuffle.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The inverse shuffled 64-bit integer.\"\n                },\n                \"dependencies\": [\n                    \"GetNibble\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t PACCellInvShuffle(uint64_t in_data) {\n  static int in_positions[16] = {12, 24, 48, 36, 56, 44, 4,  16,\n                                 32, 52, 28, 8,  20, 0,  40, 60};\n  uint64_t out_data = 0;\n  for (int i = 0; i < 16; ++i) {\n    out_data |= GetNibble(in_data, in_positions[i]) << (4 * i);\n  }\n  return out_data;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RotCell\",\n                \"about\": \"Rotates the bits of a 4-bit cell (nibble) by a specified amount.\",\n                \"logic\": \"Shifts the nibble left and ORs with original nibble to creates a value with repeating pattern. Shifts right, masking to get rotated value\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_cell\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The nibble to rotate.\"\n                    },\n                    {\n                        \"name\": \"amount\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of bits to rotate by (must be between 1 and 3).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The rotated nibble.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t RotCell(uint64_t in_cell, int amount) {\n  DCHECK((amount >= 1) && (amount <= 3));\n\n  in_cell &= 0xf;\n  uint8_t temp = in_cell << 4 | in_cell;\n  return static_cast<uint64_t>((temp >> (4 - amount)) & 0xf);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PACMult\",\n                \"about\": \"Performs a multiplication operation on the nibbles of a 64-bit integer using rotations and XORs.\",\n                \"logic\": \"Divides the input into four 16-bit segments. Applies a sequence of RotCell and XOR operations on each segment to produce a new segment. Combines the processed segments into the output.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"s_input\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The input 64-bit integer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The resulting 64-bit integer after the multiplication operation.\"\n                },\n                \"dependencies\": [\n                    \"RotCell\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t PACMult(uint64_t s_input) {\n  uint8_t t0;\n  uint8_t t1;\n  uint8_t t2;\n  uint8_t t3;\n  uint64_t s_output = 0;\n\n  for (int i = 0; i < 4; ++i) {\n    uint8_t s12 = (s_input >> (4 * (i + 12))) & 0xf;\n    uint8_t s8 = (s_input >> (4 * (i + 8))) & 0xf;\n    uint8_t s4 = (s_input >> (4 * (i + 4))) & 0xf;\n    uint8_t s0 = (s_input >> (4 * (i + 0))) & 0xf;\n\n    t0 = RotCell(s8, 1) ^ RotCell(s4, 2) ^ RotCell(s0, 1);\n    t1 = RotCell(s12, 1) ^ RotCell(s4, 1) ^ RotCell(s0, 2);\n    t2 = RotCell(s12, 2) ^ RotCell(s8, 1) ^ RotCell(s0, 1);\n    t3 = RotCell(s12, 1) ^ RotCell(s8, 2) ^ RotCell(s4, 1);\n\n    s_output |= static_cast<uint64_t>(t3) << (4 * (i + 0));\n    s_output |= static_cast<uint64_t>(t2) << (4 * (i + 4));\n    s_output |= static_cast<uint64_t>(t1) << (4 * (i + 8));\n    s_output |= static_cast<uint64_t>(t0) << (4 * (i + 12));\n  }\n  return s_output;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PACSub\",\n                \"about\": \"Performs a substitution operation on the nibbles of a 64-bit integer using a predefined substitution box (S-box).\",\n                \"logic\": \"Iterates through the nibbles of the input.  Each nibble is used as an index into the 'substitutions' array, and the value at that index replaces the original nibble in the output.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"t_input\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The input 64-bit integer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The resulting 64-bit integer after the substitution operation.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t PACSub(uint64_t t_input) {\n  uint64_t t_output = 0;\n  uint8_t substitutions[16] = {0xb, 0x6, 0x8, 0xf, 0xc, 0x0, 0x9, 0xe,\n                               0x3, 0x7, 0x4, 0x5, 0xd, 0x2, 0x1, 0xa};\n  for (int i = 0; i < 16; ++i) {\n    unsigned index = ((t_input >> (4 * i)) & 0xf);\n    t_output |= static_cast<uint64_t>(substitutions[index]) << (4 * i);\n  }\n  return t_output;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PACInvSub\",\n                \"about\": \"Performs the inverse substitution operation of PACSub.\",\n                \"logic\": \"Similar to PACSub, but uses a different 'substitutions' array to reverse the substitution.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"t_input\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The input 64-bit integer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The resulting 64-bit integer after the inverse substitution operation.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t PACInvSub(uint64_t t_input) {\n  uint64_t t_output = 0;\n  uint8_t substitutions[16] = {0x5, 0xe, 0xd, 0x8, 0xa, 0xb, 0x1, 0x9,\n                               0x2, 0x6, 0xf, 0x0, 0x4, 0xc, 0x7, 0x3};\n  for (int i = 0; i < 16; ++i) {\n    unsigned index = ((t_input >> (4 * i)) & 0xf);\n    t_output |= static_cast<uint64_t>(substitutions[index]) << (4 * i);\n  }\n  return t_output;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TweakCellInvRot\",\n                \"about\": \"Rotates and XORs bits within a small 'cell' (less than a full nibble) for tweak value manipulation.\",\n                \"logic\": \"Performs a specific bitwise rotation and XOR operation on the input cell.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_cell\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The input cell.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The resulting cell after the rotation and XOR operation.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t TweakCellInvRot(uint64_t in_cell) {\n  uint64_t out_cell = 0;\n  out_cell |= (in_cell & 0x7) << 1;\n  out_cell |= (in_cell & 0x1) ^ ((in_cell >> 3) & 0x1);\n  return out_cell;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TweakInvShuffle\",\n                \"about\": \"Applies an inverse shuffling to a tweak value used within the QARMA algorithm.\",\n                \"logic\": \"Rearranges portions of the 64-bit input based on bitwise shifts and masking, incorporating the TweakCellInvRot operation in specific locations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_data\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The input tweak value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The resulting 64-bit tweak value after the inverse shuffling.\"\n                },\n                \"dependencies\": [\n                    \"TweakCellInvRot\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t TweakInvShuffle(uint64_t in_data) {\n  uint64_t out_data = 0;\n  out_data |= TweakCellInvRot(in_data >> 48) << 0;\n  out_data |= ((in_data >> 52) & 0xf) << 4;\n  out_data |= ((in_data >> 20) & 0xff) << 8;\n  out_data |= ((in_data >> 0) & 0xff) << 16;\n  out_data |= TweakCellInvRot(in_data >> 8) << 24;\n  out_data |= ((in_data >> 12) & 0xf) << 28;\n  out_data |= TweakCellInvRot(in_data >> 28) << 32;\n  out_data |= TweakCellInvRot(in_data >> 60) << 36;\n  out_data |= TweakCellInvRot(in_data >> 56) << 40;\n  out_data |= TweakCellInvRot(in_data >> 16) << 44;\n  out_data |= ((in_data >> 32) & 0xfff) << 48;\n  out_data |= TweakCellInvRot(in_data >> 44) << 60;\n  return out_data;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TweakCellRot\",\n                \"about\": \"Rotates and XORs bits within a small 'cell' (less than a full nibble) for tweak value manipulation.\",\n                \"logic\": \"Performs a specific bitwise rotation and XOR operation on the input cell.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_cell\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The input cell.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The resulting cell after the rotation and XOR operation.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t TweakCellRot(uint64_t in_cell) {\n  uint64_t out_cell = 0;\n  out_cell |= ((in_cell & 0x1) ^ ((in_cell >> 1) & 0x1)) << 3;\n  out_cell |= (in_cell >> 0x1) & 0x7;\n  return out_cell;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TweakShuffle\",\n                \"about\": \"Applies a shuffling to a tweak value used within the QARMA algorithm.\",\n                \"logic\": \"Rearranges portions of the 64-bit input based on bitwise shifts and masking, incorporating the TweakCellRot operation in specific locations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_data\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The input tweak value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The resulting 64-bit tweak value after the shuffling.\"\n                },\n                \"dependencies\": [\n                    \"TweakCellRot\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t TweakShuffle(uint64_t in_data) {\n  uint64_t out_data = 0;\n  out_data |= ((in_data >> 16) & 0xff) << 0;\n  out_data |= TweakCellRot(in_data >> 24) << 8;\n  out_data |= ((in_data >> 28) & 0xf) << 12;\n  out_data |= TweakCellRot(in_data >> 44) << 16;\n  out_data |= ((in_data >> 8) & 0xff) << 20;\n  out_data |= TweakCellRot(in_data >> 32) << 28;\n  out_data |= ((in_data >> 48) & 0xfff) << 32;\n  out_data |= TweakCellRot(in_data >> 60) << 44;\n  out_data |= TweakCellRot(in_data >> 0) << 48;\n  out_data |= ((in_data >> 4) & 0xf) << 52;\n  out_data |= TweakCellRot(in_data >> 40) << 56;\n  out_data |= TweakCellRot(in_data >> 36) << 60;\n  return out_data;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ComputePAC\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Computes the Pointer Authentication Code (PAC) using the QARMA algorithm.\",\n                \"logic\": \"Implements the QARMA block cipher algorithm to generate a PAC.  The algorithm involves multiple rounds of substitution, shuffling, multiplication, and XOR operations with round keys derived from the provided key and context.  The core of the algorithm is a symmetric encryption/decryption process utilizing the QARMA cipher.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"data\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The data to be authenticated (typically a pointer value).\"\n                    },\n                    {\n                        \"name\": \"context\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The context value, which provides additional entropy to the PAC computation.\"\n                    },\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"PACKey\",\n                        \"purpose\": \"The pointer authentication key.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The computed Pointer Authentication Code (PAC).\"\n                },\n                \"dependencies\": [\n                    \"PACCellShuffle\",\n                    \"PACMult\",\n                    \"PACSub\",\n                    \"TweakShuffle\",\n                    \"PACCellInvShuffle\",\n                    \"PACInvSub\",\n                    \"TweakInvShuffle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t Simulator::ComputePAC(uint64_t data, uint64_t context, PACKey key) {\n  uint64_t key0 = key.high;\n  uint64_t key1 = key.low;\n  const uint64_t RC[5] = {0x0000000000000000, 0x13198a2e03707344,\n                          0xa4093822299f31d0, 0x082efa98ec4e6c89,\n                          0x452821e638d01377};\n  const uint64_t Alpha = 0xc0ac29B7c97c50dd;\n\n  uint64_t modk0 = ((key0 & 0x1) << 63) | ((key0 >> 2) << 1) |\n                   ((key0 >> 63) ^ ((key0 >> 1) & 0x1));\n  uint64_t running_mod = context;\n  uint64_t working_val = data ^ key0;\n  uint64_t round_key;\n  for (int i = 0; i < 5; ++i) {\n    round_key = key1 ^ running_mod;\n    working_val ^= round_key;\n    working_val ^= RC[i];\n    if (i > 0) {\n      working_val = PACCellShuffle(working_val);\n      working_val = PACMult(working_val);\n    }\n    working_val = PACSub(working_val);\n    running_mod = TweakShuffle(running_mod);\n  }\n\n  round_key = modk0 ^ running_mod;\n  working_val ^= round_key;\n  working_val = PACCellShuffle(working_val);\n  working_val = PACMult(working_val);\n  working_val = PACSub(working_val);\n  working_val = PACCellShuffle(working_val);\n  working_val = PACMult(working_val);\n  working_val ^= key1;\n  working_val = PACCellInvShuffle(working_val);\n  working_val = PACInvSub(working_val);\n  working_val = PACMult(working_val);\n  working_val = PACCellInvShuffle(working_val);\n  working_val ^= key0;\n  working_val ^= running_mod;\n\n  for (int i = 0; i < 5; ++i) {\n    working_val = PACInvSub(working_val);\n    if (i < 4) {\n      working_val = PACMult(working_val);\n      working_val = PACCellInvShuffle(working_val);\n    }\n    running_mod = TweakInvShuffle(running_mod);\n    round_key = key1 ^ running_mod;\n    working_val ^= RC[4 - i];\n    working_val ^= round_key;\n    working_val ^= Alpha;\n  }\n\n  return working_val ^ modk0;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CalculatePACMask\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Calculates the mask used to isolate the Pointer Authentication Code (PAC) bits within a pointer.\",\n                \"logic\": \"Determines the bit range occupied by the PAC based on the provided pointer, pointer type, and Translation Table Base Register (TTBR) value.  It then creates a mask that covers only these PAC bits.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ptr\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The pointer value.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"PointerType\",\n                        \"purpose\": \"An enum determining the type of pointer.\"\n                    },\n                    {\n                        \"name\": \"ttbr\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The Translation Table Base Register (TTBR) value used for address translation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The calculated PAC mask.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t Simulator::CalculatePACMask(uint64_t ptr, PointerType type, int ttbr) {\n  int bottom_pac_bit = GetBottomPACBit(ptr, ttbr);\n  int top_pac_bit = GetTopPACBit(ptr, type);\n  return unsigned_bitextract_64(top_pac_bit, bottom_pac_bit,\n                                0xffffffffffffffff & ~kTTBRMask)\n         << bottom_pac_bit;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AuthPAC\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Authenticates a pointer by verifying its Pointer Authentication Code (PAC).\",\n                \"logic\": \"Calculates the PAC mask and extracts the original pointer. Then re-computes the PAC. Checks that the PAC stored in the pointer matches the re-computed PAC. If they match, the original pointer is returned. Otherwise the original pointer with an error code is returned\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ptr\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The pointer to authenticate.\"\n                    },\n                    {\n                        \"name\": \"context\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The context value for PAC computation.\"\n                    },\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"PACKey\",\n                        \"purpose\": \"The pointer authentication key.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"PointerType\",\n                        \"purpose\": \"The type of pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The original pointer if authentication is successful, or a corrupted pointer (with an error code) if authentication fails.\"\n                },\n                \"dependencies\": [\n                    \"CalculatePACMask\",\n                    \"ComputePAC\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nuint64_t Simulator::AuthPAC(uint64_t ptr, uint64_t context, PACKey key,\n                            PointerType type) {\n  DCHECK((key.number == 0) || (key.number == 1));\n\n  uint64_t pac_mask = CalculatePACMask(ptr, type, (ptr >> 55) & 1);\n  uint64_t original_ptr =\n      ((ptr & kTTBRMask) == 0) ? (ptr & ~pac_mask) : (ptr | pac_mask);\n\n  uint64_t pac = ComputePAC(original_ptr, context, key);\n\n  uint64_t error_code = UINT64_C(1) << key.number;\n  if ((pac & pac_mask) == (ptr & pac_mask)) {\n    return original_ptr;\n  } else {\n    int error_lsb = GetTopPACBit(ptr, type) - 2;\n    uint64_t error_mask = UINT64_C(0x3) << error_lsb;\n    if (v8_flags.sim_abort_on_bad_auth) {\n      FATAL(\"Pointer authentication failure.\");\n    }\n    return (original_ptr & ~error_mask) | (error_code << error_lsb);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddPAC\",\n                \"parent\": \"Simulator\",\n                \"about\": \"Adds a Pointer Authentication Code (PAC) to a pointer.\",\n                \"logic\": \"Calculates the PAC mask, extracts the extended pointer, computes the PAC using the provided data, context, and key, and then inserts the computed PAC into the pointer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ptr\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The pointer to add the PAC to.\"\n                    },\n                    {\n                        \"name\": \"context\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The context value for PAC computation.\"\n                    },\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"PACKey\",\n                        \"purpose\": \"The pointer authentication key.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"PointerType\",\n                        \"purpose\": \"The type of pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint64_t\",\n                    \"description\": \"The pointer with the PAC added.\"\n                },\n                \"dependencies\": [\n                    \"CalculatePACMask\",\n                    \"ComputePAC\"\n                ]\n            }\n        "
}