{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-promise.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 253, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-promise.h\",\n        \"file_name\": \"v8-promise.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the v8::Promise class and related interfaces for Promise functionality in JavaScript.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary V8 headers for handle management, object representation, and configuration.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n#include \"v8-object.h\"        // NOLINT(build/include_directory)\n#include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Promise\",\n            \"extends\": \"Object\",\n            \"about\": \"Represents a JavaScript Promise object.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Object\",\n                \"Context\",\n                \"Value\",\n                \"Function\",\n                \"MaybeLocal\",\n                \"Maybe\",\n                \"Resolver\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT Promise : public Object {\n public:\n  /**\n   * State of the promise. Each value corresponds to one of the possible values\n   * of the [[PromiseState]] field.\n   */\n  enum PromiseState { kPending, kFulfilled, kRejected };\n\n  class V8_EXPORT Resolver : public Object {\n   public:\n    /**\n     * Create a new resolver, along with an associated promise in pending state.\n     */\n    static V8_WARN_UNUSED_RESULT MaybeLocal<Resolver> New(\n        Local<Context> context);\n\n    /**\n     * Extract the associated promise.\n     */\n    Local<Promise> GetPromise();\n\n    /**\n     * Resolve/reject the associated promise with a given value.\n     * Ignored if the promise is no longer pending.\n     */\n    V8_WARN_UNUSED_RESULT Maybe<bool> Resolve(Local<Context> context,\n                                              Local<Value> value);\n\n    V8_WARN_UNUSED_RESULT Maybe<bool> Reject(Local<Context> context,\n                                             Local<Value> value);\n\n    V8_INLINE static Resolver* Cast(Value* value) {\n#ifdef V8_ENABLE_CHECKS\n      CheckCast(value);\n#endif\n      return static_cast<Promise::Resolver*>(value);\n    }\n\n   private:\n    Resolver();\n    static void CheckCast(Value* obj);\n  };\n\n  /**\n   * Register a resolution/rejection handler with a promise.\n   * The handler is given the respective resolution/rejection value as\n   * an argument. If the promise is already resolved/rejected, the handler is\n   * invoked at the end of turn.\n   */\n  V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Catch(Local<Context> context,\n                                                  Local<Function> handler);\n\n  V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Then(Local<Context> context,\n                                                 Local<Function> handler);\n\n  V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Then(Local<Context> context,\n                                                 Local<Function> on_fulfilled,\n                                                 Local<Function> on_rejected);\n\n  /**\n   * Returns true if the promise has at least one derived promise, and\n   * therefore resolve/reject handlers (including default handler).\n   */\n  bool HasHandler() const;\n\n  /**\n   * Returns the content of the [[PromiseResult]] field. The Promise must not\n   * be pending.\n   */\n  Local<Value> Result();\n\n  /**\n   * Returns the value of the [[PromiseState]] field.\n   */\n  PromiseState State();\n\n  /**\n   * Marks this promise as handled to avoid reporting unhandled rejections.\n   */\n  void MarkAsHandled();\n\n  /**\n   * Marks this promise as silent to prevent pausing the debugger when the\n   * promise is rejected.\n   */\n  void MarkAsSilent();\n\n  V8_INLINE static Promise* Cast(Value* value) {\n#ifdef V8_ENABLE_CHECKS\n    CheckCast(value);\n#endif\n    return static_cast<Promise*>(value);\n  }\n\n  static constexpr int kEmbedderFieldCount = V8_PROMISE_INTERNAL_FIELD_COUNT;\n\n private:\n  Promise();\n  static void CheckCast(Value* obj);\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Promise::Resolver\",\n            \"extends\": \"Object\",\n            \"about\": \"Represents the resolver object associated with a Promise.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Object\",\n                \"Context\",\n                \"Value\",\n                \"Promise\",\n                \"MaybeLocal\",\n                \"Maybe\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class V8_EXPORT Resolver : public Object {\n   public:\n    /**\n     * Create a new resolver, along with an associated promise in pending state.\n     */\n    static V8_WARN_UNUSED_RESULT MaybeLocal<Resolver> New(\n        Local<Context> context);\n\n    /**\n     * Extract the associated promise.\n     */\n    Local<Promise> GetPromise();\n\n    /**\n     * Resolve/reject the associated promise with a given value.\n     * Ignored if the promise is no longer pending.\n     */\n    V8_WARN_UNUSED_RESULT Maybe<bool> Resolve(Local<Context> context,\n                                              Local<Value> value);\n\n    V8_WARN_UNUSED_RESULT Maybe<bool> Reject(Local<Context> context,\n                                             Local<Value> value);\n\n    V8_INLINE static Resolver* Cast(Value* value) {\n#ifdef V8_ENABLE_CHECKS\n      CheckCast(value);\n#endif\n      return static_cast<Promise::Resolver*>(value);\n    }\n\n   private:\n    Resolver();\n    static void CheckCast(Value* obj);\n  };\n        ]]></code>\n    </class>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"Promise::PromiseState\",\n            \"about\": \"Represents the state of a Promise (pending, fulfilled, or rejected).\",\n            \"values\": [\n                \"kPending\",\n                \"kFulfilled\",\n                \"kRejected\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  enum PromiseState { kPending, kFulfilled, kRejected };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"PromiseHookType\",\n            \"about\": \"Represents different types of promise hooks.\",\n            \"values\": [\n                \"kInit\",\n                \"kResolve\",\n                \"kBefore\",\n                \"kAfter\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nenum class PromiseHookType { kInit, kResolve, kBefore, kAfter };\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"PromiseHook\",\n            \"about\": \"Defines a function pointer type for promise hooks.\",\n            \"base_type\": \"void (*)(PromiseHookType type, Local<Promise> promise, Local<Value> parent)\"\n        }\n        </metadata>\n        <code><![CDATA[\nusing PromiseHook = void (*)(PromiseHookType type, Local<Promise> promise,\n                             Local<Value> parent);\n        ]]></code>\n    </typedef>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"PromiseRejectEvent\",\n            \"about\": \"Represents different types of promise rejection events.\",\n            \"values\": [\n                \"kPromiseRejectWithNoHandler\",\n                \"kPromiseHandlerAddedAfterReject\",\n                \"kPromiseRejectAfterResolved\",\n                \"kPromiseResolveAfterResolved\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nenum PromiseRejectEvent {\n  kPromiseRejectWithNoHandler = 0,\n  kPromiseHandlerAddedAfterReject = 1,\n  kPromiseRejectAfterResolved = 2,\n  kPromiseResolveAfterResolved = 3,\n};\n        ]]></code>\n    </enum>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PromiseRejectMessage\",\n            \"about\": \"Represents a message associated with a promise rejection.\",\n            \"attributes\": [\n                {\n                    \"name\": \"promise_\",\n                    \"type\": \"Local<Promise>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The promise that was rejected.\"\n                },\n                {\n                    \"name\": \"event_\",\n                    \"type\": \"PromiseRejectEvent\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The type of rejection event.\"\n                },\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"Local<Value>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The rejection value.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Local\",\n                \"Promise\",\n                \"Value\",\n                \"PromiseRejectEvent\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass PromiseRejectMessage {\n public:\n  PromiseRejectMessage(Local<Promise> promise, PromiseRejectEvent event,\n                       Local<Value> value)\n      : promise_(promise), event_(event), value_(value) {}\n\n  V8_INLINE Local<Promise> GetPromise() const { return promise_; }\n  V8_INLINE PromiseRejectEvent GetEvent() const { return event_; }\n  V8_INLINE Local<Value> GetValue() const { return value_; }\n\n private:\n  Local<Promise> promise_;\n  PromiseRejectEvent event_;\n  Local<Value> value_;\n};\n        ]]></code>\n    </class>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"PromiseRejectCallback\",\n            \"about\": \"Defines a function pointer type for promise rejection callbacks.\",\n            \"base_type\": \"void (*)(PromiseRejectMessage message)\"\n        }\n        </metadata>\n        <code><![CDATA[\nusing PromiseRejectCallback = void (*)(PromiseRejectMessage message);\n        ]]></code>\n    </typedef>\n</file>\n```"
}