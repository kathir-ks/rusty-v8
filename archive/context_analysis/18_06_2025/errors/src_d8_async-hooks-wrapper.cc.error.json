{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/d8/async-hooks-wrapper.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 43, column 63",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/d8/async-hooks-wrapper.cc\",\n        \"file_name\": \"async-hooks-wrapper.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the AsyncHooks API for the D8 shell, providing a way to tap into the lifecycle of asynchronous operations (Promises).\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary V8 headers for API interaction, data structures, and internal functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/d8/async-hooks-wrapper.h\"\n\n#include \"include/v8-function.h\"\n#include \"include/v8-local-handle.h\"\n#include \"include/v8-primitive.h\"\n#include \"include/v8-template.h\"\n#include \"src/api/api-inl.h\"\n#include \"src/api/api.h\"\n#include \"src/d8/d8.h\"\n#include \"src/execution/isolate-inl.h\"\n#include \"src/objects/managed-inl.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"UnwrapHook\",\n            \"about\": \"Unwraps the AsyncHooksWrap object from a v8::FunctionCallbackInfo.\",\n            \"logic\": \"Retrieves the AsyncHooksWrap instance from the internal field of the v8::Object. It also validates the 'this' object to ensure it's an instance of AsyncHook.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"const v8::FunctionCallbackInfo<v8::Value>&\",\n                    \"purpose\": \"The callback info from V8, providing access to arguments and the isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::shared_ptr<AsyncHooksWrap>\",\n                \"description\": \"A shared pointer to the AsyncHooksWrap object, or nullptr if unwrapping fails.\"\n            },\n            \"dependencies\": [\n                \"AsyncHooksWrap\",\n                \"PerIsolateData\",\n                \"AsyncHooks\",\n                \"i::ValidateCallbackInfo\",\n                \"Utils::OpenDirectHandle\",\n                \"Cast<i::Managed<AsyncHooksWrap>>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::shared_ptr<AsyncHooksWrap> UnwrapHook(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  DCHECK(i::ValidateCallbackInfo(info));\n  v8::Isolate* v8_isolate = info.GetIsolate();\n  HandleScope scope(v8_isolate);\n  Local<Object> hook = info.This();\n\n  AsyncHooks* hooks = PerIsolateData::Get(v8_isolate)->GetAsyncHooks();\n\n  if (!hooks->async_hook_ctor.Get(v8_isolate)->HasInstance(hook)) {\n    v8_isolate->ThrowError(\n        \"Invalid 'this' passed instead of AsyncHooks instance\");\n    return nullptr;\n  }\n\n  i::DirectHandle<i::Object> handle =\n      Utils::OpenDirectHandle(*hook->GetInternalField(0));\n  return Cast<i::Managed<AsyncHooksWrap>>(handle)->get();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"EnableHook\",\n            \"about\": \"Enables the AsyncHook.\",\n            \"logic\": \"Calls the Enable method on the AsyncHooksWrap object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"const v8::FunctionCallbackInfo<v8::Value>&\",\n                    \"purpose\": \"The callback info from V8.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"UnwrapHook\",\n                \"AsyncHooksWrap::Enable\",\n                \"i::ValidateCallbackInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EnableHook(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  DCHECK(i::ValidateCallbackInfo(info));\n  auto wrap = UnwrapHook(info);\n  if (wrap) wrap->Enable();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DisableHook\",\n            \"about\": \"Disables the AsyncHook.\",\n            \"logic\": \"Calls the Disable method on the AsyncHooksWrap object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"const v8::FunctionCallbackInfo<v8::Value>&\",\n                    \"purpose\": \"The callback info from V8.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"UnwrapHook\",\n                \"AsyncHooksWrap::Disable\",\n                \"i::ValidateCallbackInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid DisableHook(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  DCHECK(i::ValidateCallbackInfo(info));\n  auto wrap = UnwrapHook(info);\n  if (wrap) wrap->Disable();\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsyncHooks\",\n            \"about\": \"Manages async hooks and their contexts within a V8 isolate.\",\n            \"attributes\": [\n                {\n                    \"name\": \"v8_isolate_\",\n                    \"type\": \"v8::Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 isolate.\"\n                },\n                {\n                    \"name\": \"asyncContexts\",\n                    \"type\": \"std::stack<AsyncContext>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stack of async contexts to track execution flow.\"\n                },\n                {\n                    \"name\": \"current_async_id\",\n                    \"type\": \"async_id_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current async id, incremented for each new async operation.\"\n                },\n                {\n                    \"name\": \"async_hook_ctor\",\n                    \"type\": \"Persistent<FunctionTemplate>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the AsyncHook constructor function template.\"\n                },\n                {\n                    \"name\": \"async_hooks_templ\",\n                    \"type\": \"Persistent<ObjectTemplate>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the AsyncHook object template.\"\n                },\n                {\n                    \"name\": \"async_id_symbol\",\n                    \"type\": \"Persistent<Private>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Symbol used as a private property for storing async ID.\"\n                },\n                {\n                    \"name\": \"trigger_id_symbol\",\n                    \"type\": \"Persistent<Private>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Symbol used as a private property for storing trigger ID.\"\n                },\n                {\n                    \"name\": \"async_wraps_\",\n                    \"type\": \"std::vector<std::shared_ptr<AsyncHooksWrap>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A list of registered async hook wrappers.\"\n                },\n                {\n                    \"name\": \"skip_after_termination_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to prevent after hooks from running after termination.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AsyncContext\",\n                \"AsyncHooksWrap\",\n                \"ShellPromiseHook\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nAsyncHooks::AsyncHooks(v8::Isolate* v8_isolate) : v8_isolate_(v8_isolate) {\n  AsyncContext ctx;\n  ctx.execution_async_id = 1;\n  ctx.trigger_async_id = 0;\n  asyncContexts.push(ctx);\n  current_async_id = 1;\n\n  HandleScope handle_scope(v8_isolate_);\n\n  async_hook_ctor.Reset(v8_isolate_, FunctionTemplate::New(v8_isolate_));\n  async_hook_ctor.Get(v8_isolate_)\n      ->SetClassName(String::NewFromUtf8Literal(v8_isolate_, \"AsyncHook\"));\n\n  async_hooks_templ.Reset(v8_isolate_,\n                          async_hook_ctor.Get(v8_isolate_)->InstanceTemplate());\n  async_hooks_templ.Get(v8_isolate_)->SetInternalFieldCount(1);\n  async_hooks_templ.Get(v8_isolate_)\n      ->Set(v8_isolate_, \"enable\",\n            FunctionTemplate::New(v8_isolate_, EnableHook));\n  async_hooks_templ.Get(v8_isolate_)\n      ->Set(v8_isolate_, \"disable\",\n            FunctionTemplate::New(v8_isolate_, DisableHook));\n\n  async_id_symbol.Reset(v8_isolate_, Private::New(v8_isolate_));\n  trigger_id_symbol.Reset(v8_isolate_, Private::New(v8_isolate_));\n\n  v8_isolate_->SetPromiseHook(ShellPromiseHook);\n}\n\nAsyncHooks::~AsyncHooks() {\n  v8_isolate_->SetPromiseHook(nullptr);\n  async_wraps_.clear();\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsyncHooksWrap\",\n            \"about\": \"Wraps the JavaScript async hook functions (init, before, after, promiseResolve) and manages their state.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"v8::Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 isolate.\"\n                },\n                {\n                    \"name\": \"init_function_\",\n                    \"type\": \"Persistent<Function>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the init function.\"\n                },\n                {\n                    \"name\": \"before_function_\",\n                    \"type\": \"Persistent<Function>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the before function.\"\n                },\n                {\n                    \"name\": \"after_function_\",\n                    \"type\": \"Persistent<Function>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the after function.\"\n                },\n                {\n                    \"name\": \"promiseResolve_function_\",\n                    \"type\": \"Persistent<Function>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the promiseResolve function.\"\n                },\n                {\n                    \"name\": \"enabled_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the hook is enabled.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AsyncHooksWrap::Enable() { enabled_ = true; }\n\nvoid AsyncHooksWrap::Disable() { enabled_ = false; }\n\nv8::Local<v8::Function> AsyncHooksWrap::init_function() const {\n  return init_function_.Get(isolate_);\n}\nvoid AsyncHooksWrap::set_init_function(v8::Local<v8::Function> value) {\n  init_function_.Reset(isolate_, value);\n}\nv8::Local<v8::Function> AsyncHooksWrap::before_function() const {\n  return before_function_.Get(isolate_);\n}\nvoid AsyncHooksWrap::set_before_function(v8::Local<v8::Function> value) {\n  before_function_.Reset(isolate_, value);\n}\nv8::Local<v8::Function> AsyncHooksWrap::after_function() const {\n  return after_function_.Get(isolate_);\n}\nvoid AsyncHooksWrap::set_after_function(v8::Local<v8::Function> value) {\n  after_function_.Reset(isolate_, value);\n}\nv8::Local<v8::Function> AsyncHooksWrap::promiseResolve_function() const {\n  return promiseResolve_function_.Get(isolate_);\n}\nvoid AsyncHooksWrap::set_promiseResolve_function(\n    v8::Local<v8::Function> value) {\n  promiseResolve_function_.Reset(isolate_, value);\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetExecutionAsyncId\",\n            \"parent\": \"AsyncHooks\",\n            \"about\": \"Gets the execution async ID of the current context.\",\n            \"logic\": \"Retrieves the execution_async_id from the top of the asyncContexts stack.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"async_id_t\",\n                \"description\": \"The execution async ID.\"\n            },\n            \"dependencies\": [\n                \"AsyncContext\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nasync_id_t AsyncHooks::GetExecutionAsyncId() const {\n  return asyncContexts.top().execution_async_id;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetTriggerAsyncId\",\n            \"parent\": \"AsyncHooks\",\n            \"about\": \"Gets the trigger async ID of the current context.\",\n            \"logic\": \"Retrieves the trigger_async_id from the top of the asyncContexts stack.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"async_id_t\",\n                \"description\": \"The trigger async ID.\"\n            },\n            \"dependencies\": [\n                \"AsyncContext\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nasync_id_t AsyncHooks::GetTriggerAsyncId() const {\n  return asyncContexts.top().trigger_async_id;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CreateHook\",\n            \"parent\": \"AsyncHooks\",\n            \"about\": \"Creates a new AsyncHook object in JavaScript.\",\n            \"logic\": \"Creates an AsyncHooksWrap, associates it with a JavaScript object, and stores it in the async_wraps_ vector. It retrieves the hook functions (init, before, after, promiseResolve) from the input object and sets them on the AsyncHooksWrap instance.  It also manages V8 TryCatch for exception handling when retrieving hook functions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"const v8::FunctionCallbackInfo<v8::Value>&\",\n                    \"purpose\": \"The callback info from V8.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Local<Object>\",\n                \"description\": \"The newly created AsyncHook object.\"\n            },\n            \"dependencies\": [\n                \"AsyncHooksWrap\",\n                \"i::ValidateCallbackInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nLocal<Object> AsyncHooks::CreateHook(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  DCHECK(i::ValidateCallbackInfo(info));\n  v8::Isolate* v8_isolate = info.GetIsolate();\n  EscapableHandleScope handle_scope(v8_isolate);\n\n  if (v8_isolate->IsExecutionTerminating()) {\n    return Local<Object>();\n  }\n\n  Local<Context> currentContext = v8_isolate->GetCurrentContext();\n\n  if (info.Length() != 1 || !info[0]->IsObject()) {\n    v8_isolate->ThrowError(\"Invalid arguments passed to createHook\");\n    return Local<Object>();\n  }\n\n  std::shared_ptr<AsyncHooksWrap> wrap =\n      std::make_shared<AsyncHooksWrap>(v8_isolate);\n\n  Local<Object> fn_obj = info[0].As<Object>();\n\n  v8::TryCatch try_catch(v8_isolate);\n#define SET_HOOK_FN(name)                                                     \\\n  MaybeLocal<Value> name##_maybe_func = fn_obj->Get(                          \\\n      currentContext, String::NewFromUtf8Literal(v8_isolate, #name));         \\\n  Local<Value> name##_func;                                                   \\\n  if (name##_maybe_func.ToLocal(&name##_func) && name##_func->IsFunction()) { \\\n    wrap->set_##name##_function(name##_func.As<Function>());                  \\\n  } else {                                                                    \\\n    try_catch.ReThrow();                                                      \\\n  }\n\n  SET_HOOK_FN(init);\n  SET_HOOK_FN(before);\n  SET_HOOK_FN(after);\n  SET_HOOK_FN(promiseResolve);\n#undef SET_HOOK_FN\n\n  Local<Object> obj = async_hooks_templ.Get(v8_isolate)\n                          ->NewInstance(currentContext)\n                          .ToLocalChecked();\n  i::DirectHandle<i::Object> managed = i::Managed<AsyncHooksWrap>::From(\n      reinterpret_cast<i::Isolate*>(v8_isolate), sizeof(AsyncHooksWrap), wrap);\n  obj->SetInternalField(0, Utils::ToLocal(managed));\n\n  async_wraps_.push_back(std::move(wrap));\n\n  return handle_scope.Escape(obj);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ShellPromiseHook\",\n            \"parent\": \"AsyncHooks\",\n            \"about\": \"The promise hook function that is called by V8 during promise lifecycle events.\",\n            \"logic\": \"This function is triggered by V8's promise hook mechanism. It manages async IDs, context stacks, and dispatches to the individual hook functions (init, before, after, resolve) within each AsyncHooksWrap instance. The function also takes care of exception handling and stack overflow checks.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"PromiseHookType\",\n                    \"purpose\": \"The type of promise hook event (init, before, after, resolve).\"\n                },\n                {\n                    \"name\": \"promise\",\n                    \"type\": \"Local<Promise>\",\n                    \"purpose\": \"The promise object.\"\n                },\n                {\n                    \"name\": \"parent\",\n                    \"type\": \"Local<Value>\",\n                    \"purpose\": \"The parent value (e.g., the value that triggered the promise).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AsyncHooks\",\n                \"AsyncHooksWrap\",\n                \"PromiseHookDispatch\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AsyncHooks::ShellPromiseHook(PromiseHookType type, Local<Promise> promise,\n                                  Local<Value> parent) {\n  v8::Isolate* v8_isolate = promise->GetIsolate();\n  AsyncHooks* hooks = PerIsolateData::Get(v8_isolate)->GetAsyncHooks();\n  if (v8_isolate->IsExecutionTerminating() || hooks->skip_after_termination_) {\n    hooks->skip_after_termination_ = true;\n    return;\n  }\n  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n\n  HandleScope handle_scope(v8_isolate);\n  i::DirectHandle<i::Object> exception;\n  // Keep track of any previously thrown exception.\n  if (i_isolate->has_exception()) {\n    exception = direct_handle(i_isolate->exception(), i_isolate);\n  }\n  {\n    TryCatch try_catch(v8_isolate);\n    try_catch.SetVerbose(true);\n\n    Local<Context> currentContext = v8_isolate->GetCurrentContext();\n    DCHECK(!currentContext.IsEmpty());\n\n    if (type == PromiseHookType::kInit) {\n      ++hooks->current_async_id;\n      Local<Integer> async_id =\n          Integer::New(v8_isolate, hooks->current_async_id);\n      CHECK(!promise\n                 ->HasPrivate(currentContext,\n                              hooks->async_id_symbol.Get(v8_isolate))\n                 .ToChecked());\n      promise->SetPrivate(currentContext,\n                          hooks->async_id_symbol.Get(v8_isolate), async_id);\n\n      if (parent->IsPromise()) {\n        Local<Promise> parent_promise = parent.As<Promise>();\n        Local<Value> parent_async_id =\n            parent_promise\n                ->GetPrivate(currentContext,\n                             hooks->async_id_symbol.Get(v8_isolate))\n                .ToLocalChecked();\n        promise->SetPrivate(currentContext,\n                            hooks->trigger_id_symbol.Get(v8_isolate),\n                            parent_async_id);\n      } else {\n        CHECK(parent->IsUndefined());\n        promise->SetPrivate(currentContext,\n                            hooks->trigger_id_symbol.Get(v8_isolate),\n                            Integer::New(v8_isolate, 0));\n      }\n    } else if (type == PromiseHookType::kBefore) {\n      AsyncContext ctx;\n      ctx.execution_async_id =\n          promise\n              ->GetPrivate(currentContext,\n                           hooks->async_id_symbol.Get(v8_isolate))\n              .ToLocalChecked()\n              .As<Integer>()\n              ->Value();\n      ctx.trigger_async_id =\n          promise\n              ->GetPrivate(currentContext,\n                           hooks->trigger_id_symbol.Get(v8_isolate))\n              .ToLocalChecked()\n              .As<Integer>()\n              ->Value();\n      hooks->asyncContexts.push(ctx);\n    } else if (type == PromiseHookType::kAfter) {\n      hooks->asyncContexts.pop();\n    }\n    if (!i::StackLimitCheck{i_isolate}.HasOverflowed()) {\n      for (size_t i = 0; i < hooks->async_wraps_.size(); ++i) {\n        std::shared_ptr<AsyncHooksWrap> wrap = hooks->async_wraps_[i];\n        PromiseHookDispatch(type, promise, parent, *wrap, hooks);\n        if (try_catch.HasCaught()) break;\n      }\n      if (try_catch.HasCaught()) Shell::ReportException(v8_isolate, try_catch);\n    }\n  }\n  if (!exception.is_null()) {\n    i_isolate->set_exception(*exception);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PromiseHookDispatch\",\n            \"parent\": \"AsyncHooks\",\n            \"about\": \"Dispatches a promise hook event to a specific AsyncHooksWrap instance.\",\n            \"logic\": \"This function checks if the given AsyncHooksWrap is enabled and then calls the corresponding hook function (init, before, after, resolve) based on the PromiseHookType.  It uses the V8 API to call the JavaScript functions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"PromiseHookType\",\n                    \"purpose\": \"The type of promise hook event.\"\n                },\n                {\n                    \"name\": \"promise\",\n                    \"type\": \"Local<Promise>\",\n                    \"purpose\": \"The promise object.\"\n                },\n                {\n                    \"name\": \"parent\",\n                    \"type\": \"Local<Value>\",\n                    \"purpose\": \"The parent value.\"\n                },\n                {\n                    \"name\": \"wrap\",\n                    \"type\": \"const AsyncHooksWrap&\",\n                    \"purpose\": \"The AsyncHooksWrap instance to dispatch to.\"\n                },\n                {\n                    \"name\": \"hooks\",\n                    \"type\": \"AsyncHooks*\",\n                    \"purpose\": \"Pointer to the AsyncHooks instance.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AsyncHooksWrap\",\n                \"AsyncHooks\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AsyncHooks::PromiseHookDispatch(PromiseHookType type,\n                                     Local<Promise> promise,\n                                     Local<Value> parent,\n                                     const AsyncHooksWrap& wrap,\n                                     AsyncHooks* hooks) {\n  if (!wrap.IsEnabled()) return;\n  v8::Isolate* v8_isolate = hooks->v8_isolate_;\n  if (v8_isolate->IsExecutionTerminating()) return;\n  HandleScope handle_scope(v8_isolate);\n\n  Local<Value> rcv = Undefined(v8_isolate);\n  Local<Context> context = v8_isolate->GetCurrentContext();\n  Local<Value> async_id =\n      promise->GetPrivate(context, hooks->async_id_symbol.Get(v8_isolate))\n          .ToLocalChecked();\n  Local<Value> args[1] = {async_id};\n\n  switch (type) {\n    case PromiseHookType::kInit:\n      if (!wrap.init_function().IsEmpty()) {\n        Local<Value> initArgs[4] = {\n            async_id, String::NewFromUtf8Literal(v8_isolate, \"PROMISE\"),\n            promise\n                ->GetPrivate(context, hooks->trigger_id_symbol.Get(v8_isolate))\n                .ToLocalChecked(),\n            promise};\n        USE(wrap.init_function()->Call(context, rcv, 4, initArgs));\n      }\n      break;\n    case PromiseHookType::kBefore:\n      if (!wrap.before_function().IsEmpty()) {\n        USE(wrap.before_function()->Call(context, rcv, 1, args));\n      }\n      break;\n    case PromiseHookType::kAfter:\n      if (!wrap.after_function().IsEmpty()) {\n        USE(wrap.after_function()->Call(context, rcv, 1, args));\n      }\n      break;\n    case PromiseHookType::kResolve:\n      if (!wrap.promiseResolve_function().IsEmpty()) {\n        USE(wrap.promiseResolve_function()->Call(context, rcv, 1, args));\n      }\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"AsyncContext\",\n            \"about\": \"Struct representing async context containing execution and trigger async ids.\",\n            \"attributes\": [\n                {\n                    \"name\": \"execution_async_id\",\n                    \"type\": \"async_id_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The async id of the current execution.\"\n                },\n                {\n                    \"name\": \"trigger_async_id\",\n                    \"type\": \"async_id_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The async id that triggered the current execution.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\n\nnamespace {\n\n}  // namespace\n\nAsyncHooks::AsyncHooks(v8::Isolate* v8_isolate) : v8_isolate_(v8_isolate) {\n  AsyncContext ctx;\n  ctx.execution_async_id = 1;\n  ctx.trigger_async_id = 0;\n  asyncContexts.push(ctx);\n  current_async_id = 1;\n        ]]></code>\n    </class>\n</file>\n```"
}