{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ppc/unwinding-info-writer-ppc.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 38, column 62",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ppc/unwinding-info-writer-ppc.cc\",\n            \"file_name\": \"unwinding-info-writer-ppc.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the UnwindingInfoWriter class for the PPC architecture, responsible for generating unwinding information for stack frames to support exception handling and debugging.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for the UnwindingInfoWriterPPC class and instruction processing.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/backend/ppc/unwinding-info-writer-ppc.h\"\n#include \"src/compiler/backend/instruction.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UnwindingInfoWriter\",\n                \"about\": \"Writes unwinding information for PPC architecture. It tracks changes to the link register (LR) and frame pointer (FP) during function execution to enable stack unwinding.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"eh_frame_writer_\",\n                        \"type\": \"EHFrameWriter\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handles the writing of the actual eh_frame data.\"\n                    },\n                    {\n                        \"name\": \"block_initial_states_\",\n                        \"type\": \"std::vector<BlockInitialState*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the initial state (saved LR) of each basic block.\"\n                    },\n                    {\n                        \"name\": \"saved_lr_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the link register (LR) is currently saved on the stack.\"\n                    },\n                    {\n                        \"name\": \"block_will_exit_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A flag to indicate if the current block will exit.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating BlockInitialState objects.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"EHFrameWriter\",\n                    \"InstructionBlock\",\n                    \"BlockInitialState\",\n                    \"RpoNumber\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\nvoid UnwindingInfoWriter::BeginInstructionBlock(int pc_offset,\n                                                const InstructionBlock* block) {\n  if (!enabled()) return;\n\n  block_will_exit_ = false;\n\n  DCHECK_LT(block->rpo_number().ToInt(),\n            static_cast<int>(block_initial_states_.size()));\n  const BlockInitialState* initial_state =\n      block_initial_states_[block->rpo_number().ToInt()];\n  if (!initial_state) return;\n  if (initial_state->saved_lr_ != saved_lr_) {\n    eh_frame_writer_.AdvanceLocation(pc_offset);\n    if (initial_state->saved_lr_) {\n      eh_frame_writer_.RecordRegisterSavedToStack(kLrDwarfCode,\n                                                  kSystemPointerSize);\n      eh_frame_writer_.RecordRegisterSavedToStack(fp, 0);\n    } else {\n      eh_frame_writer_.RecordRegisterFollowsInitialRule(kLrDwarfCode);\n    }\n    saved_lr_ = initial_state->saved_lr_;\n  }\n}\n\nvoid UnwindingInfoWriter::EndInstructionBlock(const InstructionBlock* block) {\n  if (!enabled() || block_will_exit_) return;\n\n  for (const RpoNumber& successor : block->successors()) {\n    int successor_index = successor.ToInt();\n    DCHECK_LT(successor_index, static_cast<int>(block_initial_states_.size()));\n    const BlockInitialState* existing_state =\n        block_initial_states_[successor_index];\n\n    // If we already had an entry for this BB, check that the values are the\n    // same we are trying to insert.\n    if (existing_state) {\n      DCHECK_EQ(existing_state->saved_lr_, saved_lr_);\n    } else {\n      block_initial_states_[successor_index] =\n          zone_->New<BlockInitialState>(saved_lr_);\n    }\n  }\n}\n\nvoid UnwindingInfoWriter::MarkFrameConstructed(int at_pc) {\n  if (!enabled()) return;\n\n  // Regardless of the type of frame constructed, the relevant part of the\n  // layout is always the one in the diagram:\n  //\n  // |   ....   |         higher addresses\n  // +----------+               ^\n  // |    LR    |               |            |\n  // +----------+               |            |\n  // | saved FP |               |            |\n  // +----------+ <-- FP                     v\n  // |   ....   |                       stack growth\n  //\n  // The LR is pushed on the stack, and we can record this fact at the end of\n  // the construction, since the LR itself is not modified in the process.\n  eh_frame_writer_.AdvanceLocation(at_pc);\n  eh_frame_writer_.RecordRegisterSavedToStack(kLrDwarfCode,\n                                              kSystemPointerSize);\n  eh_frame_writer_.RecordRegisterSavedToStack(fp, 0);\n  saved_lr_ = true;\n}\n\nvoid UnwindingInfoWriter::MarkFrameDeconstructed(int at_pc) {\n  if (!enabled()) return;\n\n  // The lr is restored by the last operation in LeaveFrame().\n  eh_frame_writer_.AdvanceLocation(at_pc);\n  eh_frame_writer_.RecordRegisterFollowsInitialRule(kLrDwarfCode);\n  saved_lr_ = false;\n}\n\nvoid UnwindingInfoWriter::MarkLinkRegisterOnTopOfStack(int pc_offset) {\n  if (!enabled()) return;\n\n  eh_frame_writer_.AdvanceLocation(pc_offset);\n  eh_frame_writer_.SetBaseAddressRegisterAndOffset(sp, 0);\n  eh_frame_writer_.RecordRegisterSavedToStack(kLrDwarfCode, 0);\n}\n\nvoid UnwindingInfoWriter::MarkPopLinkRegisterFromTopOfStack(int pc_offset) {\n  if (!enabled()) return;\n\n  eh_frame_writer_.AdvanceLocation(pc_offset);\n  eh_frame_writer_.SetBaseAddressRegisterAndOffset(fp, 0);\n  eh_frame_writer_.RecordRegisterFollowsInitialRule(kLrDwarfCode);\n}\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BeginInstructionBlock\",\n                \"parent\": \"UnwindingInfoWriter\",\n                \"about\": \"Handles the start of an instruction block, checks for changes in saved LR state, and records unwinding information if necessary.\",\n                \"logic\": \"Checks if the LR saving status has changed since the previous block. If it has, it updates the EHFrameWriter to record the change. Uses eh_frame_writer_.AdvanceLocation to update the current PC offset. Uses eh_frame_writer_.RecordRegisterSavedToStack or eh_frame_writer_.RecordRegisterFollowsInitialRule based on the LR saving status.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pc_offset\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The program counter offset at the beginning of the block.\"\n                    },\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"const InstructionBlock*\",\n                        \"purpose\": \"A pointer to the instruction block.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"enabled\",\n                    \"InstructionBlock\",\n                    \"RpoNumber\",\n                    \"BlockInitialState\",\n                    \"EHFrameWriter::AdvanceLocation\",\n                    \"EHFrameWriter::RecordRegisterSavedToStack\",\n                    \"EHFrameWriter::RecordRegisterFollowsInitialRule\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::BeginInstructionBlock(int pc_offset,\n                                                const InstructionBlock* block) {\n  if (!enabled()) return;\n\n  block_will_exit_ = false;\n\n  DCHECK_LT(block->rpo_number().ToInt(),\n            static_cast<int>(block_initial_states_.size()));\n  const BlockInitialState* initial_state =\n      block_initial_states_[block->rpo_number().ToInt()];\n  if (!initial_state) return;\n  if (initial_state->saved_lr_ != saved_lr_) {\n    eh_frame_writer_.AdvanceLocation(pc_offset);\n    if (initial_state->saved_lr_) {\n      eh_frame_writer_.RecordRegisterSavedToStack(kLrDwarfCode,\n                                                  kSystemPointerSize);\n      eh_frame_writer_.RecordRegisterSavedToStack(fp, 0);\n    } else {\n      eh_frame_writer_.RecordRegisterFollowsInitialRule(kLrDwarfCode);\n    }\n    saved_lr_ = initial_state->saved_lr_;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EndInstructionBlock\",\n                \"parent\": \"UnwindingInfoWriter\",\n                \"about\": \"Handles the end of an instruction block, saves the LR state for successor blocks.\",\n                \"logic\": \"Iterates over successor blocks of the current block. For each successor, it either checks that the existing LR saving status matches the current status, or it creates a new BlockInitialState to store the LR saving status for that block.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"const InstructionBlock*\",\n                        \"purpose\": \"A pointer to the instruction block.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"enabled\",\n                    \"InstructionBlock\",\n                    \"RpoNumber\",\n                    \"BlockInitialState\",\n                    \"Zone::New\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::EndInstructionBlock(const InstructionBlock* block) {\n  if (!enabled() || block_will_exit_) return;\n\n  for (const RpoNumber& successor : block->successors()) {\n    int successor_index = successor.ToInt();\n    DCHECK_LT(successor_index, static_cast<int>(block_initial_states_.size()));\n    const BlockInitialState* existing_state =\n        block_initial_states_[successor_index];\n\n    // If we already had an entry for this BB, check that the values are the\n    // same we are trying to insert.\n    if (existing_state) {\n      DCHECK_EQ(existing_state->saved_lr_, saved_lr_);\n    } else {\n      block_initial_states_[successor_index] =\n          zone_->New<BlockInitialState>(saved_lr_);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MarkFrameConstructed\",\n                \"parent\": \"UnwindingInfoWriter\",\n                \"about\": \"Marks the point where a stack frame is constructed, recording the saving of the LR and FP on the stack.\",\n                \"logic\": \"Records the saving of the LR and FP registers when a stack frame is constructed. Updates the EHFrameWriter with the appropriate information. Uses eh_frame_writer_.AdvanceLocation to update the PC offset. Uses eh_frame_writer_.RecordRegisterSavedToStack to record the saving of LR and FP. Sets saved_lr_ to true.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"at_pc\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The program counter value at the point of frame construction.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"enabled\",\n                    \"EHFrameWriter::AdvanceLocation\",\n                    \"EHFrameWriter::RecordRegisterSavedToStack\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::MarkFrameConstructed(int at_pc) {\n  if (!enabled()) return;\n\n  // Regardless of the type of frame constructed, the relevant part of the\n  // layout is always the one in the diagram:\n  //\n  // |   ....   |         higher addresses\n  // +----------+               ^\n  // |    LR    |               |            |\n  // +----------+               |            |\n  // | saved FP |               |            |\n  // +----------+ <-- FP                     v\n  // |   ....   |                       stack growth\n  //\n  // The LR is pushed on the stack, and we can record this fact at the end of\n  // the construction, since the LR itself is not modified in the process.\n  eh_frame_writer_.AdvanceLocation(at_pc);\n  eh_frame_writer_.RecordRegisterSavedToStack(kLrDwarfCode,\n                                              kSystemPointerSize);\n  eh_frame_writer_.RecordRegisterSavedToStack(fp, 0);\n  saved_lr_ = true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MarkFrameDeconstructed\",\n                \"parent\": \"UnwindingInfoWriter\",\n                \"about\": \"Marks the point where a stack frame is deconstructed, recording the restoration of the LR.\",\n                \"logic\": \"Records the restoration of the LR register when a stack frame is deconstructed.  Uses eh_frame_writer_.AdvanceLocation to update the PC offset.  Uses eh_frame_writer_.RecordRegisterFollowsInitialRule to indicate that LR follows the initial rule. Sets saved_lr_ to false.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"at_pc\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The program counter value at the point of frame deconstruction.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"enabled\",\n                    \"EHFrameWriter::AdvanceLocation\",\n                    \"EHFrameWriter::RecordRegisterFollowsInitialRule\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::MarkFrameDeconstructed(int at_pc) {\n  if (!enabled()) return;\n\n  // The lr is restored by the last operation in LeaveFrame().\n  eh_frame_writer_.AdvanceLocation(at_pc);\n  eh_frame_writer_.RecordRegisterFollowsInitialRule(kLrDwarfCode);\n  saved_lr_ = false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MarkLinkRegisterOnTopOfStack\",\n                \"parent\": \"UnwindingInfoWriter\",\n                \"about\": \"Marks that the Link Register (LR) is currently located on the top of the stack.\",\n                \"logic\": \"Updates the EHFrameWriter to record the LR on top of the stack by setting the base address register to the stack pointer (sp) with an offset of 0. Uses eh_frame_writer_.AdvanceLocation to update the PC offset. Uses eh_frame_writer_.SetBaseAddressRegisterAndOffset to set SP as the base register. Uses eh_frame_writer_.RecordRegisterSavedToStack to indicate LR is saved at offset 0 from SP.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pc_offset\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The program counter offset.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"enabled\",\n                    \"EHFrameWriter::AdvanceLocation\",\n                    \"EHFrameWriter::SetBaseAddressRegisterAndOffset\",\n                    \"EHFrameWriter::RecordRegisterSavedToStack\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::MarkLinkRegisterOnTopOfStack(int pc_offset) {\n  if (!enabled()) return;\n\n  eh_frame_writer_.AdvanceLocation(pc_offset);\n  eh_frame_writer_.SetBaseAddressRegisterAndOffset(sp, 0);\n  eh_frame_writer_.RecordRegisterSavedToStack(kLrDwarfCode, 0);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MarkPopLinkRegisterFromTopOfStack\",\n                \"parent\": \"UnwindingInfoWriter\",\n                \"about\": \"Marks that the Link Register (LR) is being popped from the top of the stack.\",\n                \"logic\": \"Updates the EHFrameWriter to record that the LR is popped from the top of the stack. It sets the base address register to the frame pointer (fp) with an offset of 0, and then records that the LR follows the initial rule. Uses eh_frame_writer_.AdvanceLocation to update the PC offset. Uses eh_frame_writer_.SetBaseAddressRegisterAndOffset to set FP as the base register. Uses eh_frame_writer_.RecordRegisterFollowsInitialRule to indicate LR follows initial rule.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pc_offset\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The program counter offset.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"enabled\",\n                    \"EHFrameWriter::AdvanceLocation\",\n                    \"EHFrameWriter::SetBaseAddressRegisterAndOffset\",\n                    \"EHFrameWriter::RecordRegisterFollowsInitialRule\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::MarkPopLinkRegisterFromTopOfStack(int pc_offset) {\n  if (!enabled()) return;\n\n  eh_frame_writer_.AdvanceLocation(pc_offset);\n  eh_frame_writer_.SetBaseAddressRegisterAndOffset(fp, 0);\n  eh_frame_writer_.RecordRegisterFollowsInitialRule(kLrDwarfCode);\n}\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"InstructionBlock\",\n                    \"about\": \"Represents a basic block of instructions.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class InstructionBlock {\n                public:\n                    RpoNumber rpo_number() const;\n                    const ZoneVector<RpoNumber>& successors() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"EHFrameWriter\",\n                    \"about\": \"Writes exception handling frame information.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class EHFrameWriter {\n                public:\n                    void AdvanceLocation(int pc_offset);\n                    void RecordRegisterSavedToStack(int reg, int offset);\n                    void RecordRegisterFollowsInitialRule(int reg);\n                    void SetBaseAddressRegisterAndOffset(int reg, int offset);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"BlockInitialState\",\n                    \"about\": \"Represents the initial state of a basic block for unwinding.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class BlockInitialState {\n                public:\n                    BlockInitialState(bool saved_lr) : saved_lr_(saved_lr) {}\n                    bool saved_lr_;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RpoNumber\",\n                    \"about\": \"Represents the reverse postorder number of a basic block.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class RpoNumber {\n                 public:\n                  int ToInt() const;\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}