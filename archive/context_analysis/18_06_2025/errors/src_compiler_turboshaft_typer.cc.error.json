{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/typer.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 95, column 37",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/typer.cc\",\n      \"file_name\": \"typer.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Implements the Typer class for type refinement in Turboshaft compiler.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes the header file for the Typer class.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/compiler/turboshaft/typer.h\"\n    ]]></code>\n  </imports>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"Typer\",\n        \"about\": \"Base class for type refinement in Turboshaft.\",\n        \"attributes\": [],\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nnamespace v8::internal::compiler::turboshaft {\n\nclass Typer {\n public:\n  class BranchRefinements {\n   public:\n    using TypeGetter = std::function<Type(Value)>;\n    using TypeRefiner = std::function<void(Value, Type)>;\n    BranchRefinements(TypeGetter type_getter, TypeRefiner type_refiner)\n        : type_getter_(type_getter), type_refiner_(type_refiner) {}\n\n    void RefineTypes(const Operation& condition, bool then_branch, Zone* zone);\n\n   private:\n    TypeGetter type_getter_;\n    TypeRefiner type_refiner_;\n  };\n};\n\n}  // namespace v8::internal::compiler::turboshaft\n    ]]></code>\n  </class>\n  <class>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"class\",\n          \"name\": \"BranchRefinements\",\n          \"parent\": \"Typer\",\n          \"about\": \"Helper class for refining types based on branch conditions.\",\n          \"attributes\": [],\n          \"dependencies\": []\n        }\n      </metadata>\n      <code><![CDATA[\nclass BranchRefinements {\n public:\n  using TypeGetter = std::function<Type(Value)>;\n  using TypeRefiner = std::function<void(Value, Type)>;\n  BranchRefinements(TypeGetter type_getter, TypeRefiner type_refiner)\n      : type_getter_(type_getter), type_refiner_(type_refiner) {}\n\n  void RefineTypes(const Operation& condition, bool then_branch, Zone* zone);\n\n private:\n  TypeGetter type_getter_;\n  TypeRefiner type_refiner_;\n};\n      ]]></code>\n    </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"RefineTypes\",\n        \"parent\": \"BranchRefinements\",\n        \"about\": \"Refines types based on a condition and branch taken.\",\n        \"logic\": \"Analyzes comparison operations to refine types of operands based on branch outcome. Supports signed/unsigned less than/less than or equal comparisons for Word32 and Float64 types.  Truncates inputs for Word32. Uses helper classes WordOperationTyper and FloatOperationTyper to get restrictions based on operation and branch.  Intersects existing types with new restrictions. Special handling for word32 restriction, because the inputs might have been truncated from word64 implicitly. Keeps old type if the refined type is not a subtype of it.\",\n        \"parameters\": [\n          {\n            \"name\": \"condition\",\n            \"type\": \"const Operation&\",\n            \"purpose\": \"The condition operation.\"\n          },\n          {\n            \"name\": \"then_branch\",\n            \"type\": \"bool\",\n            \"purpose\": \"Indicates if the then branch is taken.\"\n          },\n          {\n            \"name\": \"zone\",\n            \"type\": \"Zone*\",\n            \"purpose\": \"Memory zone for allocations.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"ComparisonOp\",\n          \"Type\",\n          \"Word32Type\",\n          \"Float64Type\",\n          \"WordOperationTyper\",\n          \"FloatOperationTyper\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid Typer::BranchRefinements::RefineTypes(const Operation& condition,\n                                           bool then_branch, Zone* zone) {\n  if (const ComparisonOp* comparison = condition.TryCast<ComparisonOp>()) {\n    Type lhs = type_getter_(comparison->left());\n    Type rhs = type_getter_(comparison->right());\n\n    bool is_signed, is_less_than;\n    switch (comparison->kind) {\n      case ComparisonOp::Kind::kEqual:\n        // TODO(nicohartmann@): Add support for equality.\n        return;\n      case ComparisonOp::Kind::kSignedLessThan:\n        is_signed = true;\n        is_less_than = true;\n        break;\n      case ComparisonOp::Kind::kSignedLessThanOrEqual:\n        is_signed = true;\n        is_less_than = false;\n        break;\n      case ComparisonOp::Kind::kUnsignedLessThan:\n        is_signed = false;\n        is_less_than = true;\n        break;\n      case ComparisonOp::Kind::kUnsignedLessThanOrEqual:\n        is_signed = false;\n        is_less_than = false;\n        break;\n    }\n\n    Type l_refined;\n    Type r_refined;\n\n    if (lhs.IsNone() || rhs.IsNone()) {\n      type_refiner_(comparison->left(), Type::None());\n      type_refiner_(comparison->right(), Type::None());\n      return;\n    } else if (lhs.IsAny() || rhs.IsAny()) {\n      // If either side has any type, there is not much we can do.\n      return;\n    }\n\n    switch (comparison->rep.value()) {\n      case RegisterRepresentation::Word32(): {\n        if (is_signed) {\n          // TODO(nicohartmann@): Support signed comparison.\n          return;\n        }\n        Word32Type l = Typer::TruncateWord32Input(lhs, true, zone).AsWord32();\n        Word32Type r = Typer::TruncateWord32Input(rhs, true, zone).AsWord32();\n        Type l_restrict, r_restrict;\n        using OpTyper = WordOperationTyper<32>;\n        if (is_less_than) {\n          std::tie(l_restrict, r_restrict) =\n              then_branch\n                  ? OpTyper::RestrictionForUnsignedLessThan_True(l, r, zone)\n                  : OpTyper::RestrictionForUnsignedLessThan_False(l, r, zone);\n        } else {\n          std::tie(l_restrict, r_restrict) =\n              then_branch\n                  ? OpTyper::RestrictionForUnsignedLessThanOrEqual_True(l, r,\n                                                                        zone)\n                  : OpTyper::RestrictionForUnsignedLessThanOrEqual_False(l, r,\n                                                                         zone);\n        }\n\n        // Special handling for word32 restriction, because the inputs might\n        // have been truncated from word64 implicitly.\n        l_refined = RefineWord32Type<true>(lhs, l_restrict, zone);\n        r_refined = RefineWord32Type<true>(rhs, r_restrict, zone);\n        break;\n      }\n      case RegisterRepresentation::Float64(): {\n        Float64Type l = lhs.AsFloat64();\n        Float64Type r = rhs.AsFloat64();\n        Type l_restrict, r_restrict;\n        using OpTyper = FloatOperationTyper<64>;\n        if (is_less_than) {\n          std::tie(l_restrict, r_restrict) =\n              then_branch ? OpTyper::RestrictionForLessThan_True(l, r, zone)\n                          : OpTyper::RestrictionForLessThan_False(l, r, zone);\n        } else {\n          std::tie(l_restrict, r_restrict) =\n              then_branch\n                  ? OpTyper::RestrictionForLessThanOrEqual_True(l, r, zone)\n                  : OpTyper::RestrictionForLessThanOrEqual_False(l, r, zone);\n        }\n\n        l_refined = l_restrict.IsNone() ? Type::None()\n                                        : Float64Type::Intersect(\n                                              l, l_restrict.AsFloat64(), zone);\n        r_refined = r_restrict.IsNone() ? Type::None()\n                                        : Float64Type::Intersect(\n                                              r, r_restrict.AsFloat64(), zone);\n        break;\n      }\n      default:\n        return;\n    }\n\n    // In some cases, the refined type is not a subtype of the old type,\n    // because it cannot be represented precisely. In this case we keep the\n    // old type to be stable.\n    if (l_refined.IsSubtypeOf(lhs)) {\n      type_refiner_(comparison->left(), l_refined);\n    }\n    if (r_refined.IsSubtypeOf(rhs)) {\n      type_refiner_(comparison->right(), r_refined);\n    }\n  }\n}\n    ]]></code>\n  </func>\n  <dependencies>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"ComparisonOp\",\n              \"about\": \"Represents a comparison operation.\"\n          }\n          </metadata>\n          <code><![CDATA[\n              class ComparisonOp {\n              public:\n                  enum class Kind {\n                      kEqual,\n                      kSignedLessThan,\n                      kSignedLessThanOrEqual,\n                      kUnsignedLessThan,\n                      kUnsignedLessThanOrEqual\n                  };\n\n                  Kind kind;\n                  Value left();\n                  Value right();\n              };\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"Type\",\n              \"about\": \"Represents a data type.\"\n          }\n          </metadata>\n          <code><![CDATA[\n              class Type {\n              public:\n                  bool IsNone() const;\n                  bool IsAny() const;\n                  bool IsSubtypeOf(Type other) const;\n                  Type AsFloat64() const;\n                  static Type None();\n              };\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"Word32Type\",\n              \"about\": \"Represents a 32-bit word type.\"\n          }\n          </metadata>\n          <code><![CDATA[\n              class Word32Type : public Type {\n              public:\n                  static Word32Type Intersect(Word32Type a, Word32Type b, Zone* zone);\n              };\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"Float64Type\",\n              \"about\": \"Represents a 64-bit floating point type.\"\n          }\n          </metadata>\n          <code><![CDATA[\n              class Float64Type : public Type {\n              public:\n                  static Float64Type Intersect(Float64Type a, Float64Type b, Zone* zone);\n              };\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"WordOperationTyper\",\n              \"about\": \"Helper class for typing word operations.\"\n          }\n          </metadata>\n          <code><![CDATA[\n              template <int bits>\n              class WordOperationTyper {};\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"FloatOperationTyper\",\n              \"about\": \"Helper class for typing float operations.\"\n          }\n          </metadata>\n          <code><![CDATA[\n              template <int bits>\n              class FloatOperationTyper {};\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"RegisterRepresentation\",\n              \"about\": \"Represents the register representation of a value.\"\n          }\n          </metadata>\n          <code><![CDATA[\n              class RegisterRepresentation {\n              public:\n                  enum class Value {\n                      Word32,\n                      Float64\n                  };\n                  Value value() const;\n              };\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"Value\",\n              \"about\": \"Represents a value in the Turboshaft graph.\"\n          }\n          </metadata>\n          <code><![CDATA[\n            class Value {};\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"Operation\",\n              \"about\": \"Represents an operation in the Turboshaft graph.\"\n          }\n          </metadata>\n          <code><![CDATA[\n            class Operation {\n              public:\n               template <typename T>\n               const T* TryCast() const;\n            };\n          ]]></code>\n      </class>\n      <class>\n          <metadata>\n          {\n              \"language\": \"cpp\",\n              \"type\": \"class\",\n              \"name\": \"Zone\",\n              \"about\": \"Represents a memory allocation zone.\"\n          }\n          </metadata>\n          <code><![CDATA[\n            class Zone {};\n          ]]></code>\n      </class>\n      <func>\n        <metadata>\n            {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TruncateWord32Input\",\n            \"about\": \"Truncates a value to Word32 type.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Word32Type\",\n                \"description\": \"Truncated Word32Type\"\n            }\n            }\n        </metadata>\n        <code><![CDATA[\n            Word32Type Typer::TruncateWord32Input(Type type, bool hint, Zone* zone) {\n                return Word32Type();\n            }\n        ]]></code>\n      </func>\n       <func>\n        <metadata>\n            {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"RefineWord32Type\",\n            \"about\": \"Refines a type to Word32 type.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Type\",\n                \"description\": \"Refined Type\"\n            }\n            }\n        </metadata>\n        <code><![CDATA[\n            Type Typer::RefineWord32Type(Type original, Type refined, Zone* zone) {\n                return Type();\n            }\n        ]]></code>\n      </func>\n  </dependencies>\n</file>\n```"
}