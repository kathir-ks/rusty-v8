{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/escape-analysis-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/escape-analysis-reducer.cc\",\n        \"file_name\": \"escape-analysis-reducer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Escape Analysis reduction phase in the V8 compiler pipeline. It identifies objects that do not escape the local scope and performs optimizations based on this information.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for compiler, node manipulation, operation typing, simplified operators, and frame constants.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/escape-analysis-reducer.h\"\n\n#include \"src/compiler/all-nodes.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/operation-typer.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/execution/frame-constants.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EscapeAnalysisReducer\",\n            \"extends\": \"AdvancedReducer\",\n            \"about\": \"Performs escape analysis reductions on the graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The JSGraph for accessing the graph and common nodes.\"\n                },\n                {\n                    \"name\": \"broker_\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Broker to query JS heap objects.\"\n                },\n                {\n                    \"name\": \"analysis_result_\",\n                    \"type\": \"EscapeAnalysisResult\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The result of the escape analysis.\"\n                },\n                {\n                    \"name\": \"object_id_cache_\",\n                    \"type\": \"ZoneVector<Node*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Cache for ObjectId nodes.\"\n                },\n                {\n                    \"name\": \"node_cache_\",\n                    \"type\": \"NodeHashCache\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Cache for storing and reusing nodes.\"\n                },\n                {\n                    \"name\": \"arguments_elements_\",\n                    \"type\": \"ZoneSet<Node*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Set of NewArgumentsElements nodes.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone for allocating memory.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"JSGraph\",\n                \"JSHeapBroker\",\n                \"EscapeAnalysisResult\",\n                \"Zone\",\n                \"Node\",\n                \"VirtualObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nEscapeAnalysisReducer::EscapeAnalysisReducer(\n    Editor* editor, JSGraph* jsgraph, JSHeapBroker* broker,\n    EscapeAnalysisResult analysis_result, Zone* zone)\n    : AdvancedReducer(editor),\n      jsgraph_(jsgraph),\n      broker_(broker),\n      analysis_result_(analysis_result),\n      object_id_cache_(zone),\n      node_cache_(jsgraph->graph(), zone),\n      arguments_elements_(zone),\n      zone_(zone) {}\n\nReduction EscapeAnalysisReducer::ReplaceNode(Node* original,\n                                             Node* replacement) {\n  const VirtualObject* vobject =\n      analysis_result().GetVirtualObject(replacement);\n  if (replacement->opcode() == IrOpcode::kDead ||\n      (vobject && !vobject->HasEscaped())) {\n    RelaxEffectsAndControls(original);\n    return Replace(replacement);\n  }\n  Type const replacement_type = NodeProperties::GetType(replacement);\n  Type const original_type = NodeProperties::GetType(original);\n  if (replacement_type.Is(original_type)) {\n    RelaxEffectsAndControls(original);\n    return Replace(replacement);\n  }\n\n  // We need to guard the replacement if we would widen the type otherwise.\n  DCHECK_EQ(1, original->op()->EffectOutputCount());\n  DCHECK_EQ(1, original->op()->EffectInputCount());\n  DCHECK_EQ(1, original->op()->ControlInputCount());\n  Node* effect = NodeProperties::GetEffectInput(original);\n  Node* control = NodeProperties::GetControlInput(original);\n  original->TrimInputCount(0);\n  original->AppendInput(jsgraph()->zone(), replacement);\n  original->AppendInput(jsgraph()->zone(), effect);\n  original->AppendInput(jsgraph()->zone(), control);\n  NodeProperties::SetType(\n      original,\n      Type::Intersect(original_type, replacement_type, jsgraph()->zone()));\n  NodeProperties::ChangeOp(original,\n                           jsgraph()->common()->TypeGuard(original_type));\n  ReplaceWithValue(original, original, original, control);\n  return NoChange();\n}\n\nNode* EscapeAnalysisReducer::ObjectIdNode(const VirtualObject* vobject) {\n  VirtualObject::Id id = vobject->id();\n  if (id >= object_id_cache_.size()) object_id_cache_.resize(id + 1);\n  if (!object_id_cache_[id]) {\n    Node* node = jsgraph()->graph()->NewNode(jsgraph()->common()->ObjectId(id));\n    NodeProperties::SetType(node, Type::Object());\n    object_id_cache_[id] = node;\n  }\n  return object_id_cache_[id];\n}\n\nReduction EscapeAnalysisReducer::Reduce(Node* node) {\n  if (Node* replacement = analysis_result().GetReplacementOf(node)) {\n    DCHECK(node->opcode() != IrOpcode::kAllocate &&\n           node->opcode() != IrOpcode::kFinishRegion);\n    DCHECK_NE(replacement, node);\n    return ReplaceNode(node, replacement);\n  }\n\n  switch (node->opcode()) {\n    case IrOpcode::kAllocate:\n    case IrOpcode::kTypeGuard: {\n      const VirtualObject* vobject = analysis_result().GetVirtualObject(node);\n      if (vobject && !vobject->HasEscaped()) {\n        RelaxEffectsAndControls(node);\n      }\n      return NoChange();\n    }\n    case IrOpcode::kFinishRegion: {\n      Node* effect = NodeProperties::GetEffectInput(node, 0);\n      if (effect->opcode() == IrOpcode::kBeginRegion) {\n        RelaxEffectsAndControls(effect);\n        RelaxEffectsAndControls(node);\n      }\n      return NoChange();\n    }\n    case IrOpcode::kNewArgumentsElements:\n      arguments_elements_.insert(node);\n      return NoChange();\n    default: {\n      // TODO(sigurds): Change this to GetFrameStateInputCount once\n      // it is working. For now we use EffectInputCount > 0 to determine\n      // whether a node might have a frame state input.\n      if (node->op()->EffectInputCount() > 0) {\n        ReduceFrameStateInputs(node);\n      }\n      return NoChange();\n    }\n  }\n}\n\n// While doing DFS on the FrameState tree, we have to recognize duplicate\n// occurrences of virtual objects.\nclass Deduplicator {\n public:\n  explicit Deduplicator(Zone* zone) : zone_(zone) {}\n  bool SeenBefore(const VirtualObject* vobject) {\n    DCHECK_LE(vobject->id(), std::numeric_limits<int>::max());\n    int id = static_cast<int>(vobject->id());\n    if (id >= is_duplicate_.length()) {\n      is_duplicate_.Resize(id + 1, zone_);\n    }\n    bool is_duplicate = is_duplicate_.Contains(id);\n    is_duplicate_.Add(id);\n    return is_duplicate;\n  }\n\n private:\n  Zone* zone_;\n  BitVector is_duplicate_;\n};\n\nvoid EscapeAnalysisReducer::ReduceFrameStateInputs(Node* node) {\n  DCHECK_GE(node->op()->EffectInputCount(), 1);\n  for (int i = 0; i < node->InputCount(); ++i) {\n    Node* input = node->InputAt(i);\n    if (input->opcode() == IrOpcode::kFrameState) {\n      Deduplicator deduplicator(zone());\n      if (Node* ret = ReduceDeoptState(input, node, &deduplicator)) {\n        node->ReplaceInput(i, ret);\n      }\n    }\n  }\n}\n\nNode* EscapeAnalysisReducer::ReduceDeoptState(Node* node, Node* effect,\n                                              Deduplicator* deduplicator) {\n  if (node->opcode() == IrOpcode::kFrameState) {\n    NodeHashCache::Constructor new_node(&node_cache_, node);\n    // This input order is important to match the DFS traversal used in the\n    // instruction selector. Otherwise, the instruction selector might find a\n    // duplicate node before the original one.\n    for (int input_id : {FrameState::kFrameStateOuterStateInput,\n                         FrameState::kFrameStateFunctionInput,\n                         FrameState::kFrameStateParametersInput,\n                         FrameState::kFrameStateContextInput,\n                         FrameState::kFrameStateLocalsInput,\n                         FrameState::kFrameStateStackInput}) {\n      Node* input = node->InputAt(input_id);\n      new_node.ReplaceInput(ReduceDeoptState(input, effect, deduplicator),\n                            input_id);\n    }\n    return new_node.Get();\n  } else if (node->opcode() == IrOpcode::kStateValues) {\n    NodeHashCache::Constructor new_node(&node_cache_, node);\n    for (int i = 0; i < node->op()->ValueInputCount(); ++i) {\n      Node* input = NodeProperties::GetValueInput(node, i);\n      new_node.ReplaceValueInput(ReduceDeoptState(input, effect, deduplicator),\n                                 i);\n    }\n    return new_node.Get();\n  } else if (const VirtualObject* vobject = analysis_result().GetVirtualObject(\n                 SkipValueIdentities(node))) {\n    if (vobject->HasEscaped()) return node;\n    if (deduplicator->SeenBefore(vobject)) {\n      return ObjectIdNode(vobject);\n    } else {\n      std::vector<Node*> inputs;\n      for (int offset = 0; offset < vobject->size(); offset += kTaggedSize) {\n        Node* field =\n            analysis_result().GetVirtualObjectField(vobject, offset, effect);\n        CHECK_NOT_NULL(field);\n        if (field != jsgraph()->Dead()) {\n          inputs.push_back(ReduceDeoptState(field, effect, deduplicator));\n        }\n      }\n      int num_inputs = static_cast<int>(inputs.size());\n      NodeHashCache::Constructor new_node(\n          &node_cache_,\n          jsgraph()->common()->ObjectState(vobject->id(), num_inputs),\n          num_inputs, &inputs.front(), NodeProperties::GetType(node));\n      return new_node.Get();\n    }\n  } else {\n    return node;\n  }\n}\n\nvoid EscapeAnalysisReducer::VerifyReplacement() const {\n  AllNodes all(zone(), jsgraph()->graph());\n  for (Node* node : all.reachable) {\n    if (node->opcode() == IrOpcode::kAllocate) {\n      if (const VirtualObject* vobject =\n              analysis_result().GetVirtualObject(node)) {\n        if (!vobject->HasEscaped()) {\n          FATAL(\"Escape analysis failed to remove node %s#%d\\n\",\n                node->op()->mnemonic(), node->id());\n        }\n      }\n    }\n  }\n}\n\nvoid EscapeAnalysisReducer::Finalize() {\n  OperationTyper op_typer(broker_, jsgraph()->graph()->zone());\n  for (Node* node : arguments_elements_) {\n    const NewArgumentsElementsParameters& params =\n        NewArgumentsElementsParametersOf(node->op());\n    ArgumentsStateType type = params.arguments_type();\n    int mapped_count = type == CreateArgumentsType::kMappedArguments\n                           ? params.formal_parameter_count()\n                           : 0;\n\n    Node* arguments_length = NodeProperties::GetValueInput(node, 0);\n    if (arguments_length->opcode() != IrOpcode::kArgumentsLength) continue;\n\n    Node* arguments_length_state = nullptr;\n    for (Edge edge : arguments_length->use_edges()) {\n      Node* use = edge.from();\n      switch (use->opcode()) {\n        case IrOpcode::kObjectState:\n        case IrOpcode::kTypedObjectState:\n        case IrOpcode::kStateValues:\n        case IrOpcode::kTypedStateValues:\n          if (!arguments_length_state) {\n            arguments_length_state = jsgraph()->graph()->NewNode(\n                jsgraph()->common()->ArgumentsLengthState());\n            NodeProperties::SetType(arguments_length_state,\n                                    Type::OtherInternal());\n          }\n          edge.UpdateTo(arguments_length_state);\n          break;\n        default:\n          break;\n      }\n    }\n\n    bool escaping_use = false;\n    ZoneVector<Node*> loads(zone());\n    for (Edge edge : node->use_edges()) {\n      Node* use = edge.from();\n      if (!NodeProperties::IsValueEdge(edge)) continue;\n      if (use->use_edges().empty()) {\n        // A node without uses is dead, so we don't have to care about it.\n        continue;\n      }\n      switch (use->opcode()) {\n        case IrOpcode::kStateValues:\n        case IrOpcode::kTypedStateValues:\n        case IrOpcode::kObjectState:\n        case IrOpcode::kTypedObjectState:\n          break;\n        case IrOpcode::kLoadElement:\n          if (mapped_count == 0) {\n            loads.push_back(use);\n          } else {\n            escaping_use = true;\n          }\n          break;\n        case IrOpcode::kLoadField:\n          if (FieldAccessOf(use->op()).offset ==\n              offsetof(FixedArray, length_)) {\n            loads.push_back(use);\n          } else {\n            escaping_use = true;\n          }\n          break;\n        default:\n          // If the arguments elements node node is used by an unhandled node,\n          // then we cannot remove this allocation.\n          escaping_use = true;\n          break;\n      }\n      if (escaping_use) break;\n    }\n    if (!escaping_use) {\n      Node* arguments_elements_state = jsgraph()->graph()->NewNode(\n          jsgraph()->common()->ArgumentsElementsState(type));\n      NodeProperties::SetType(arguments_elements_state, Type::OtherInternal());\n      ReplaceWithValue(node, arguments_elements_state);\n\n      for (Node* load : loads) {\n        switch (load->opcode()) {\n          case IrOpcode::kLoadElement: {\n            Node* index = NodeProperties::GetValueInput(load, 1);\n            Node* formal_parameter_count =\n                jsgraph()->ConstantNoHole(params.formal_parameter_count());\n            NodeProperties::SetType(\n                formal_parameter_count,\n                Type::Constant(params.formal_parameter_count(),\n                               jsgraph()->graph()->zone()));\n            Node* offset_to_first_elem = jsgraph()->ConstantNoHole(\n                CommonFrameConstants::kFixedSlotCountAboveFp);\n            if (!NodeProperties::IsTyped(offset_to_first_elem)) {\n              NodeProperties::SetType(\n                  offset_to_first_elem,\n                  Type::Constant(CommonFrameConstants::kFixedSlotCountAboveFp,\n                                 jsgraph()->graph()->zone()));\n            }\n\n            Node* offset = jsgraph()->graph()->NewNode(\n                jsgraph()->simplified()->NumberAdd(), index,\n                offset_to_first_elem);\n            Type offset_type = op_typer.NumberAdd(\n                NodeProperties::GetType(index),\n                NodeProperties::GetType(offset_to_first_elem));\n            NodeProperties::SetType(offset, offset_type);\n            if (type == CreateArgumentsType::kRestParameter) {\n              // In the case of rest parameters we should skip the formal\n              // parameters.\n              offset = jsgraph()->graph()->NewNode(\n                  jsgraph()->simplified()->NumberAdd(), offset,\n                  formal_parameter_count);\n              NodeProperties::SetType(\n                  offset, op_typer.NumberAdd(\n                              offset_type,\n                              NodeProperties::GetType(formal_parameter_count)));\n            }\n            Node* frame = jsgraph()->graph()->NewNode(\n                jsgraph()->machine()->LoadFramePointer());\n            NodeProperties::SetType(frame, Type::ExternalPointer());\n            NodeProperties::ReplaceValueInput(load, frame, 0);\n            NodeProperties::ReplaceValueInput(load, offset, 1);\n            NodeProperties::ChangeOp(\n                load, jsgraph()->simplified()->LoadStackArgument());\n            break;\n          }\n          case IrOpcode::kLoadField: {\n            DCHECK_EQ(FieldAccessOf(load->op()).offset,\n                      offsetof(FixedArray, length_));\n            Node* length = NodeProperties::GetValueInput(node, 0);\n            ReplaceWithValue(load, length);\n            break;\n          }\n          default:\n            UNREACHABLE();\n        }\n      }\n    }\n  }\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Deduplicator\",\n            \"about\": \"Helper class to detect duplicate virtual objects during FrameState tree traversal.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone for allocating memory.\"\n                },\n                {\n                    \"name\": \"is_duplicate_\",\n                    \"type\": \"BitVector\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Bit vector to track seen virtual object IDs.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"BitVector\",\n                \"VirtualObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// While doing DFS on the FrameState tree, we have to recognize duplicate\n// occurrences of virtual objects.\nclass Deduplicator {\n public:\n  explicit Deduplicator(Zone* zone) : zone_(zone) {}\n  bool SeenBefore(const VirtualObject* vobject) {\n    DCHECK_LE(vobject->id(), std::numeric_limits<int>::max());\n    int id = static_cast<int>(vobject->id());\n    if (id >= is_duplicate_.length()) {\n      is_duplicate_.Resize(id + 1, zone_);\n    }\n    bool is_duplicate = is_duplicate_.Contains(id);\n    is_duplicate_.Add(id);\n    return is_duplicate;\n  }\n\n private:\n  Zone* zone_;\n  BitVector is_duplicate_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeHashCache\",\n            \"about\": \"Cache to store and reuse nodes during FrameState reduction.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Node\",\n                \"Operator\",\n                \"Type\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* NodeHashCache::Query(Node* node) {\n  auto it = cache_.find(node);\n  if (it != cache_.end()) {\n    return *it;\n  } else {\n    return nullptr;\n  }\n}\n\nNodeHashCache::Constructor::Constructor(NodeHashCache* cache,\n                                        const Operator* op, int input_count,\n                                        Node** inputs, Type type)\n    : node_cache_(cache), from_(nullptr) {\n  if (!node_cache_->temp_nodes_.empty()) {\n    tmp_ = node_cache_->temp_nodes_.back();\n    node_cache_->temp_nodes_.pop_back();\n    int tmp_input_count = tmp_->InputCount();\n    if (input_count <= tmp_input_count) {\n      tmp_->TrimInputCount(input_count);\n    }\n    for (int i = 0; i < input_count; ++i) {\n      if (i < tmp_input_count) {\n        tmp_->ReplaceInput(i, inputs[i]);\n      } else {\n        tmp_->AppendInput(node_cache_->graph_->zone(), inputs[i]);\n      }\n    }\n    NodeProperties::ChangeOp(tmp_, op);\n  } else {\n    tmp_ = node_cache_->graph_->NewNode(op, input_count, inputs);\n  }\n  NodeProperties::SetType(tmp_, type);\n}\n\nNode* NodeHashCache::Constructor::Get() {\n  DCHECK(tmp_ || from_);\n  Node* node;\n  if (!tmp_) {\n    node = node_cache_->Query(from_);\n    if (!node) node = from_;\n  } else {\n    node = node_cache_->Query(tmp_);\n    if (node) {\n      node_cache_->temp_nodes_.push_back(tmp_);\n    } else {\n      node = tmp_;\n      node_cache_->Insert(node);\n    }\n  }\n  tmp_ = from_ = nullptr;\n  return node;\n}\n\nNode* NodeHashCache::Constructor::MutableNode() {\n  DCHECK(tmp_ || from_);\n  if (!tmp_) {\n    if (node_cache_->temp_nodes_.empty()) {\n      tmp_ = node_cache_->graph_->CloneNode(from_);\n    } else {\n      tmp_ = node_cache_->temp_nodes_.back();\n      node_cache_->temp_nodes_.pop_back();\n      int from_input_count = from_->InputCount();\n      int tmp_input_count = tmp_->InputCount();\n      if (from_input_count <= tmp_input_count) {\n        tmp_->TrimInputCount(from_input_count);\n      }\n      for (int i = 0; i < from_input_count; ++i) {\n        if (i < tmp_input_count) {\n          tmp_->ReplaceInput(i, from_->InputAt(i));\n        } else {\n          tmp_->AppendInput(node_cache_->graph_->zone(), from_->InputAt(i));\n        }\n      }\n      NodeProperties::SetType(tmp_, NodeProperties::GetType(from_));\n      NodeProperties::ChangeOp(tmp_, from_->op());\n    }\n  }\n  return tmp_;\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReplaceNode\",\n            \"parent\": \"EscapeAnalysisReducer\",\n            \"about\": \"Replaces a node with a replacement node, potentially inserting a TypeGuard if types differ.\",\n            \"logic\": \"If the replacement is dead or the associated virtual object has not escaped, replaces the original node. Otherwise, inserts a TypeGuard to narrow the type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"original\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The original node to be replaced.\"\n                },\n                {\n                    \"name\": \"replacement\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace the original node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The reduction result.\"\n            },\n            \"dependencies\": [\n                \"VirtualObject\",\n                \"analysis_result\",\n                \"RelaxEffectsAndControls\",\n                \"Replace\",\n                \"Type\",\n                \"NodeProperties\",\n                \"Type::Intersect\",\n                \"jsgraph\",\n                \"TypeGuard\",\n                \"ReplaceWithValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction EscapeAnalysisReducer::ReplaceNode(Node* original,\n                                             Node* replacement) {\n  const VirtualObject* vobject =\n      analysis_result().GetVirtualObject(replacement);\n  if (replacement->opcode() == IrOpcode::kDead ||\n      (vobject && !vobject->HasEscaped())) {\n    RelaxEffectsAndControls(original);\n    return Replace(replacement);\n  }\n  Type const replacement_type = NodeProperties::GetType(replacement);\n  Type const original_type = NodeProperties::GetType(original);\n  if (replacement_type.Is(original_type)) {\n    RelaxEffectsAndControls(original);\n    return Replace(replacement);\n  }\n\n  // We need to guard the replacement if we would widen the type otherwise.\n  DCHECK_EQ(1, original->op()->EffectOutputCount());\n  DCHECK_EQ(1, original->op()->EffectInputCount());\n  DCHECK_EQ(1, original->op()->ControlInputCount());\n  Node* effect = NodeProperties::GetEffectInput(original);\n  Node* control = NodeProperties::GetControlInput(original);\n  original->TrimInputCount(0);\n  original->AppendInput(jsgraph()->zone(), replacement);\n  original->AppendInput(jsgraph()->zone(), effect);\n  original->AppendInput(jsgraph()->zone(), control);\n  NodeProperties::SetType(\n      original,\n      Type::Intersect(original_type, replacement_type, jsgraph()->zone()));\n  NodeProperties::ChangeOp(original,\n                           jsgraph()->common()->TypeGuard(original_type));\n  ReplaceWithValue(original, original, original, control);\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ObjectIdNode\",\n            \"parent\": \"EscapeAnalysisReducer\",\n            \"about\": \"Retrieves or creates a Node representing the ObjectId of a virtual object.\",\n            \"logic\": \"Uses a cache to store and reuse ObjectId nodes. If the node is not in the cache, it is created and added to the cache.\",\n            \"parameters\": [\n                {\n                    \"name\": \"vobject\",\n                    \"type\": \"const VirtualObject*\",\n                    \"purpose\": \"The virtual object whose ObjectId is needed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The Node representing the ObjectId.\"\n            },\n            \"dependencies\": [\n                \"VirtualObject\",\n                \"object_id_cache_\",\n                \"jsgraph\",\n                \"Type::Object\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* EscapeAnalysisReducer::ObjectIdNode(const VirtualObject* vobject) {\n  VirtualObject::Id id = vobject->id();\n  if (id >= object_id_cache_.size()) object_id_cache_.resize(id + 1);\n  if (!object_id_cache_[id]) {\n    Node* node = jsgraph()->graph()->NewNode(jsgraph()->common()->ObjectId(id));\n    NodeProperties::SetType(node, Type::Object());\n    object_id_cache_[id] = node;\n  }\n  return object_id_cache_[id];\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"EscapeAnalysisReducer\",\n            \"about\": \"The main reduction function that processes nodes based on their opcode and escape analysis results.\",\n            \"logic\": \"Handles Allocate, TypeGuard, FinishRegion, and NewArgumentsElements nodes. Replaces nodes based on escape analysis results and reduces FrameState inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The reduction result.\"\n            },\n            \"dependencies\": [\n                \"analysis_result\",\n                \"ReplaceNode\",\n                \"VirtualObject\",\n                \"RelaxEffectsAndControls\",\n                \"ReduceFrameStateInputs\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction EscapeAnalysisReducer::Reduce(Node* node) {\n  if (Node* replacement = analysis_result().GetReplacementOf(node)) {\n    DCHECK(node->opcode() != IrOpcode::kAllocate &&\n           node->opcode() != IrOpcode::kFinishRegion);\n    DCHECK_NE(replacement, node);\n    return ReplaceNode(node, replacement);\n  }\n\n  switch (node->opcode()) {\n    case IrOpcode::kAllocate:\n    case IrOpcode::kTypeGuard: {\n      const VirtualObject* vobject = analysis_result().GetVirtualObject(node);\n      if (vobject && !vobject->HasEscaped()) {\n        RelaxEffectsAndControls(node);\n      }\n      return NoChange();\n    }\n    case IrOpcode::kFinishRegion: {\n      Node* effect = NodeProperties::GetEffectInput(node, 0);\n      if (effect->opcode() == IrOpcode::kBeginRegion) {\n        RelaxEffectsAndControls(effect);\n        RelaxEffectsAndControls(node);\n      }\n      return NoChange();\n    }\n    case IrOpcode::kNewArgumentsElements:\n      arguments_elements_.insert(node);\n      return NoChange();\n    default: {\n      // TODO(sigurds): Change this to GetFrameStateInputCount once\n      // it is working. For now we use EffectInputCount > 0 to determine\n      // whether a node might have a frame state input.\n      if (node->op()->EffectInputCount() > 0) {\n        ReduceFrameStateInputs(node);\n      }\n      return NoChange();\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceFrameStateInputs\",\n            \"parent\": \"EscapeAnalysisReducer\",\n            \"about\": \"Reduces the FrameState inputs of a node by traversing the FrameState tree and potentially replacing nodes with ObjectId nodes or ObjectState nodes.\",\n            \"logic\": \"Iterates through the inputs of a node, and if an input is a FrameState, it calls ReduceDeoptState to reduce the FrameState tree.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose FrameState inputs need to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReduceDeoptState\",\n                \"Deduplicator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EscapeAnalysisReducer::ReduceFrameStateInputs(Node* node) {\n  DCHECK_GE(node->op()->EffectInputCount(), 1);\n  for (int i = 0; i < node->InputCount(); ++i) {\n    Node* input = node->InputAt(i);\n    if (input->opcode() == IrOpcode::kFrameState) {\n      Deduplicator deduplicator(zone());\n      if (Node* ret = ReduceDeoptState(input, node, &deduplicator)) {\n        node->ReplaceInput(i, ret);\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceDeoptState\",\n            \"parent\": \"EscapeAnalysisReducer\",\n            \"about\": \"Recursively reduces the FrameState tree.\",\n            \"logic\": \"Traverses the FrameState tree, handling FrameState, StateValues, and VirtualObject nodes.  Replaces non-escaping virtual objects with ObjectState nodes.  Uses Deduplicator to handle duplicate VirtualObjects.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The current node in the FrameState tree.\"\n                },\n                {\n                    \"name\": \"effect\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The effect node.\"\n                },\n                {\n                    \"name\": \"deduplicator\",\n                    \"type\": \"Deduplicator*\",\n                    \"purpose\": \"The deduplicator object to track already seen virtual objects\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The reduced node.\"\n            },\n            \"dependencies\": [\n                \"FrameState\",\n                \"StateValues\",\n                \"VirtualObject\",\n                \"analysis_result\",\n                \"SeenBefore\",\n                \"ObjectIdNode\",\n                \"ObjectState\",\n                \"jsgraph\",\n                \"NodeHashCache\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* EscapeAnalysisReducer::ReduceDeoptState(Node* node, Node* effect,\n                                              Deduplicator* deduplicator) {\n  if (node->opcode() == IrOpcode::kFrameState) {\n    NodeHashCache::Constructor new_node(&node_cache_, node);\n    // This input order is important to match the DFS traversal used in the\n    // instruction selector. Otherwise, the instruction selector might find a\n    // duplicate node before the original one.\n    for (int input_id : {FrameState::kFrameStateOuterStateInput,\n                         FrameState::kFrameStateFunctionInput,\n                         FrameState::kFrameStateParametersInput,\n                         FrameState::kFrameStateContextInput,\n                         FrameState::kFrameStateLocalsInput,\n                         FrameState::kFrameStateStackInput}) {\n      Node* input = node->InputAt(input_id);\n      new_node.ReplaceInput(ReduceDeoptState(input, effect, deduplicator),\n                            input_id);\n    }\n    return new_node.Get();\n  } else if (node->opcode() == IrOpcode::kStateValues) {\n    NodeHashCache::Constructor new_node(&node"
}