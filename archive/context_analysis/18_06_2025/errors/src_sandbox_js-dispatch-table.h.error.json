{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/sandbox/js-dispatch-table.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 68, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/sandbox/js-dispatch-table.h\",\n            \"file_name\": \"js-dispatch-table.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the JSDispatchTable, which provides fine-grained forward-edge CFI for JavaScript function calls and enables cheap and fast tiering.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for configuration, atomic operations, memory management, globals, runtime functions, and external entity tables.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"include/v8config.h\"\n#include \"src/base/atomicops.h\"\n#include \"src/base/memory.h\"\n#include \"src/common/globals.h\"\n#include \"src/runtime/runtime.h\"\n#include \"src/sandbox/external-entity-table.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"JSDispatchEntry\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents an entry in the JSDispatchTable, containing information to call a JavaScript function in a sandbox-compatible way.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"entrypoint_\",\n                        \"type\": \"std::atomic<Address>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Atomic pointer to the executable entrypoint of the JS function.\"\n                    },\n                    {\n                        \"name\": \"encoded_word_\",\n                        \"type\": \"std::atomic<Address>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"On 64 bit architectures, this contains the pointer to the code object, a marking bit, and the 16-bit parameter count. On 32 bit architectures only the mark bit is shared with the pointer.\"\n                    },\n                    {\n                        \"name\": \"parameter_count_\",\n                        \"type\": \"std::atomic<uint16_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Only used on 32-bit architectures to store the parameter count.\"\n                    },\n                    {\n                        \"name\": \"next_free_entry_\",\n                        \"type\": \"std::atomic<uint32_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Only used on 32-bit architectures to store the index of the next free entry in the freelist.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Address\",\n                    \"Code\",\n                    \"Tagged\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct JSDispatchEntry {\n  // We write-protect the JSDispatchTable on platforms that support it for\n  // forward-edge CFI.\n  static constexpr bool IsWriteProtected = true;\n\n  inline void MakeJSDispatchEntry(Address object, Address entrypoint,\n                                  uint16_t parameter_count, bool mark_as_alive);\n\n  inline Address GetEntrypoint() const;\n  inline Address GetCodePointer() const;\n  inline Tagged<Code> GetCode() const;\n  inline uint16_t GetParameterCount() const;\n\n  inline void SetCodeAndEntrypointPointer(Address new_object,\n                                          Address new_entrypoint);\n  inline void SetEntrypointPointer(Address new_entrypoint);\n\n  // Make this entry a freelist entry, containing the index of the next entry\n  // on the freelist.\n  inline void MakeFreelistEntry(uint32_t next_entry_index);\n\n  // Returns true if this entry is a freelist entry.\n  inline bool IsFreelistEntry() const;\n\n  // Get the index of the next entry on the freelist. This method may be\n  // called even when the entry is not a freelist entry. However, the result\n  // is only valid if this is a freelist entry. This behaviour is required\n  // for efficient entry allocation, see TryAllocateEntryFromFreelist.\n  inline uint32_t GetNextFreelistEntryIndex() const;\n\n  // Mark this entry as alive during garbage collection.\n  inline void Mark();\n\n  // Unmark this entry during sweeping.\n  inline void Unmark();\n\n  // Test whether this entry is currently marked as alive.\n  inline bool IsMarked() const;\n\n  // Constants for access from generated code.\n  // These are static_assert'ed to be correct in CheckFieldOffsets().\n  static constexpr uintptr_t kEntrypointOffset = 0;\n  static constexpr uintptr_t kCodeObjectOffset = kSystemPointerSize;\n  static constexpr size_t kParameterCountSize = 2;\n\n#if defined(V8_TARGET_ARCH_64_BIT)\n  // Freelist entries contain the index of the next free entry in their lower 32\n  // bits and are tagged with this tag.\n  static constexpr Address kFreeEntryTag = 0xffff000000000000ull;\n#ifdef V8_TARGET_BIG_ENDIAN\n  // 2-byte parameter count is on the least significant side of encoded_word_.\n  static constexpr int kBigEndianParamCountOffset =\n      sizeof(Address) - sizeof(uint16_t);\n  static constexpr uintptr_t kParameterCountOffset =\n      kCodeObjectOffset + kBigEndianParamCountOffset;\n#else\n  static constexpr uintptr_t kParameterCountOffset = kCodeObjectOffset;\n#endif  // V8_TARGET_BIG_ENDIAN\n  static constexpr uint32_t kObjectPointerShift = 16;\n  static constexpr uint32_t kParameterCountMask = 0xffff;\n#elif defined(V8_TARGET_ARCH_32_BIT)\n  static constexpr uintptr_t kParameterCountOffset =\n      kCodeObjectOffset + kSystemPointerSize;\n  static constexpr uint32_t kObjectPointerShift = 0;\n  static constexpr uint32_t kParameterCountMask = 0x0;\n#else\n#error \"Unsupported Architecture\"\n#endif\n\n  static void CheckFieldOffsets();\n\n private:\n  friend class JSDispatchTable;\n\n  // The first word contains the pointer to the (executable) entrypoint.\n  std::atomic<Address> entrypoint_;\n\n  // On 64 bit architectures the second word of the entry contains (1) the\n  // pointer to the code object associated with this entry, (2) the marking bit\n  // of the entry in the LSB of the object pointer (which must be unused as the\n  // address must be aligned), and (3) the 16-bit parameter count. The parameter\n  // count is stored in the lower 16 bits and therefore the pointer is shifted\n  // to the left. The final format therefore looks as follows:\n  //\n  // +----------------------+---------------+-------------------+\n  // | Bits 63 ... 17       | Bit 16        | Bits 15 ... 0     |\n  // |  HeapObject pointer  |  Marking bit  |  Parameter count  |\n  // +----------------------+---------------+-------------------+\n  //\n  // On 32 bit architectures only the mark bit is shared with the pointer.\n  //\n  // +----------------------+---------------+\n  // | Bits 32 ... 1        | Bit 0         |\n  // |  HeapObject pointer  |  Marking bit  |\n  // +----------------------+---------------+\n  //\n  // TODO(olivf): Find a better format that allows us to write atomically to the\n  // individual parts and unify with 32 bit. For instance we could try to store\n  // the code pointer in some compressd format, such that it fits into 32 bits.\n\n  static constexpr Address kMarkingBit = 1 << kObjectPointerShift;\n  std::atomic<Address> encoded_word_;\n\n#ifdef V8_TARGET_ARCH_32_BIT\n  // TODO(olivf): Investigate if we could shrink the entry size on 32bit\n  // platforms to 12 bytes.\n  std::atomic<uint16_t> parameter_count_;\n  // 16 bits of padding\n  std::atomic<uint32_t> next_free_entry_;\n#endif  // V8_TARGET_ARCH_32_BIT\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSDispatchTable\",\n                \"extends\": \"ExternalEntityTable<JSDispatchEntry, kJSDispatchTableReservationSize>\",\n                \"implements\": [],\n                \"about\": \"Provides fine-grained forward-edge CFI for JavaScript function calls and enables cheap and fast tiering.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"JSDispatchEntry\",\n                    \"ExternalEntityTable\",\n                    \"JSDispatchHandle\",\n                    \"Code\",\n                    \"Tagged\",\n                    \"TieringBuiltin\",\n                    \"Isolate\",\n                    \"Counters\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE JSDispatchTable\n    : public ExternalEntityTable<JSDispatchEntry,\n                                 kJSDispatchTableReservationSize> {\n  using Base =\n      ExternalEntityTable<JSDispatchEntry, kJSDispatchTableReservationSize>;\n\n public:\n#ifdef V8_ENABLE_SANDBOX\n  static_assert(kMaxJSDispatchEntries == kMaxCapacity);\n#endif  // V8_ENABLE_SANDBOX\n  static_assert(!kSupportsCompaction);\n\n  JSDispatchTable() = default;\n  JSDispatchTable(const JSDispatchTable&) = delete;\n  JSDispatchTable& operator=(const JSDispatchTable&) = delete;\n\n  // The Spaces used by a JSDispatchTable.\n  using Space = Base::SpaceWithBlackAllocationSupport;\n\n  // Retrieves the entrypoint of the entry referenced by the given handle.\n  inline Address GetEntrypoint(JSDispatchHandle handle);\n\n  // Retrieves the Code stored in the entry referenced by the given handle.\n  //\n  // TODO(saelo): in the future, we might store either a Code or a\n  // BytecodeArray in the entries. At that point, this could be changed to\n  // return a Tagged<Union<Code, BytecodeArray>>.\n  inline Tagged<Code> GetCode(JSDispatchHandle handle);\n\n  // Returns the address of the Code object stored in the specified entry.\n  inline Address GetCodeAddress(JSDispatchHandle handle);\n\n  // Retrieves the parameter count of the entry referenced by the given handle.\n  inline uint16_t GetParameterCount(JSDispatchHandle handle);\n\n  // Updates the entry referenced by the given handle to the given Code and its\n  // entrypoint. The code must be compatible with the specified entry. In\n  // particular, the two must use the same parameter count.\n  // NB: Callee must emit JS_DISPATCH_HANDLE_WRITE_BARRIER if needed!\n  inline void SetCodeNoWriteBarrier(JSDispatchHandle handle,\n                                    Tagged<Code> new_code);\n\n  // Execute a tiering builtin instead of the actual code. Leaves the Code\n  // pointer untouched and changes only the entrypoint.\n  inline void SetTieringRequest(JSDispatchHandle handle, TieringBuiltin builtin,\n                                Isolate* isolate);\n  inline void SetCodeKeepTieringRequestNoWriteBarrier(JSDispatchHandle handle,\n                                                      Tagged<Code> new_code);\n  // Resets the entrypoint to the code's entrypoint.\n  inline void ResetTieringRequest(JSDispatchHandle handle);\n  // Check if and/or which tiering builtin is installed.\n  inline bool IsTieringRequested(JSDispatchHandle handle);\n  inline bool IsTieringRequested(JSDispatchHandle handle,\n                                 TieringBuiltin builtin, Isolate* isolate);\n\n  // Allocates a new entry in the table and initialize it.\n  //\n  // Note: If possible allocate dispatch handles through the factory.\n  //\n  // This method is atomic and can be called from background threads.\n  inline JSDispatchHandle AllocateAndInitializeEntry(Space* space,\n                                                     uint16_t parameter_count,\n                                                     Tagged<Code> code);\n  inline std::optional<JSDispatchHandle> TryAllocateAndInitializeEntry(\n      Space* space, uint16_t parameter_count, Tagged<Code> code);\n\n  // The following methods are used to pre allocate entries and then initialize\n  // them later.\n  JSDispatchHandle PreAllocateEntries(Space* space, int num,\n                                      bool ensure_static_handles);\n  bool PreAllocatedEntryNeedsInitialization(Space* space,\n                                            JSDispatchHandle handle);\n  void InitializePreAllocatedEntry(Space* space, JSDispatchHandle handle,\n                                   Tagged<Code> code, uint16_t parameter_count);\n\n  // Can be used to statically predict the handles if the pre allocated entries\n  // are in the overall first read only segment of the whole table.\n#if V8_STATIC_DISPATCH_HANDLES_BOOL\n  static JSDispatchHandle GetStaticHandleForReadOnlySegmentEntry(int index) {\n    return IndexToHandle(kInternalNullEntryIndex + 1 + index);\n  }\n#endif  // V8_STATIC_DISPATCH_HANDLES_BOOL\n  static bool InReadOnlySegment(JSDispatchHandle handle) {\n    return HandleToIndex(handle) <= kEndOfInternalReadOnlySegment;\n  }\n  static int OffsetOfEntry(JSDispatchHandle handle) {\n    return JSDispatchTable::HandleToIndex(handle)\n           << kJSDispatchTableEntrySizeLog2;\n  }\n\n  // Marks the specified entry as alive.\n  //\n  // This method is atomic and can be called from background threads.\n  inline void Mark(JSDispatchHandle handle);\n\n  // Frees all unmarked entries in the given space.\n  //\n  // This method must only be called while mutator threads are stopped as it is\n  // not safe to allocate table entries while a space is being swept.\n  //\n  // Returns the number of live entries after sweeping.\n  template <typename Callback>\n  uint32_t Sweep(Space* space, Counters* counters, Callback callback);\n\n  // Iterate over all active entries in the given space.\n  //\n  // The callback function will be invoked once for every entry that is\n  // currently in use, i.e. has been allocated and not yet freed, and will\n  // receive the handle of that entry.\n  template <typename Callback>\n  void IterateActiveEntriesIn(Space* space, Callback callback);\n\n  template <typename Callback>\n  void IterateMarkedEntriesIn(Space* space, Callback callback);\n\n  // The base address of this table, for use in JIT compilers.\n  Address base_address() const { return base(); }\n\n#ifdef DEBUG\n  bool IsMarked(JSDispatchHandle handle);\n#endif  // DEBUG\n#if defined(DEBUG) || defined(VERIFY_HEAP)\n  inline void VerifyEntry(JSDispatchHandle handle, Space* space,\n                          Space* ro_space);\n#endif  // defined(DEBUG) || defined(VERIFY_HEAP)\n\n  void PrintEntry(JSDispatchHandle handle);\n  void PrintCurrentTieringRequest(JSDispatchHandle handle, Isolate* isolate,\n                                  std::ostream& os);\n\n  static constexpr bool kWriteBarrierSetsEntryMarkBit = true;\n\n private:\n  static inline bool IsCompatibleCode(Tagged<Code> code,\n                                      uint16_t parameter_count);\n\n  inline void SetCodeAndEntrypointNoWriteBarrier(JSDispatchHandle handle,\n                                                 Tagged<Code> new_code,\n                                                 Address entrypoint);\n\n  static uint32_t HandleToIndex(JSDispatchHandle handle) {\n    uint32_t index = handle.value() >> kJSDispatchHandleShift;\n    DCHECK_EQ(handle.value(), index << kJSDispatchHandleShift);\n    return index;\n  }\n  static JSDispatchHandle IndexToHandle(uint32_t index) {\n    JSDispatchHandle handle(index << kJSDispatchHandleShift);\n    DCHECK_EQ(index, handle.value() >> kJSDispatchHandleShift);\n    return index;\n  }\n\n  friend class MarkCompactCollector;\n};\n        ]]></code>\n    </class>\n\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ExternalEntityTable\",\n                    \"about\": \"Base class for managing external entities.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename EntryType, size_t reservation_size>\n                class ExternalEntityTable {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Address\",\n                    \"about\": \"Represents a memory address.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Address {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Code\",\n                    \"about\": \"Represents compiled code.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Code {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Tagged\",\n                    \"about\": \"Represents a tagged pointer.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class Tagged {};\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"TieringBuiltin\",\n                    \"about\": \"Represents a tiering builtin.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class TieringBuiltin {};\n            ]]></code>\n        </enum>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Isolate\",\n                    \"about\": \"Represents an isolate.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Counters\",\n                    \"about\": \"Represents counters.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Counters {};\n            ]]></code>\n        </class>\n         <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSDispatchHandle\",\n                    \"about\": \"Handle for a JSDispatchTable entry.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class JSDispatchHandle {\n                public:\n                  explicit JSDispatchHandle(uint32_t value) : value_(value) {}\n                  uint32_t value() const { return value_; }\n                private:\n                  uint32_t value_;\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}