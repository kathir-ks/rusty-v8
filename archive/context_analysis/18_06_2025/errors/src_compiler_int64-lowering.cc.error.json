{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/int64-lowering.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/int64-lowering.cc\",\n            \"file_name\": \"int64-lowering.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"This file implements the Int64Lowering pass, which lowers 64-bit integer operations to 32-bit operations on 32-bit architectures.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for compiler components, data structures, and WASM support.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/int64-lowering.h\"\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/diamond.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/compiler/wasm-call-descriptors.h\"\n#include \"src/compiler/wasm-compiler.h\"\n#include \"src/wasm/wasm-engine.h\"\n// TODO(wasm): Remove this include.\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-subtyping.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Int64Lowering\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Lowers 64-bit integer operations to equivalent 32-bit operations for 32-bit architectures.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The Turbofan graph being lowered.\"\n                    },\n                    {\n                        \"name\": \"machine_\",\n                        \"type\": \"MachineOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Provides machine-specific operators.\"\n                    },\n                    {\n                        \"name\": \"common_\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Provides common operators.\"\n                    },\n                    {\n                        \"name\": \"simplified_\",\n                        \"type\": \"SimplifiedOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Provides simplified operators.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocations.\"\n                    },\n                    {\n                        \"name\": \"signature_\",\n                        \"type\": \"Signature<MachineRepresentation>*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Function signature.\"\n                    },\n                    {\n                        \"name\": \"state_\",\n                        \"type\": \"ZoneVector<State>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of the processing state of each node (unvisited, on stack, visited).\"\n                    },\n                    {\n                        \"name\": \"stack_\",\n                        \"type\": \"ZoneVector<NodeState>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The stack of nodes to be processed.\"\n                    },\n                    {\n                        \"name\": \"replacements_\",\n                        \"type\": \"Replacement*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps nodes to their 32-bit replacements (low and high parts).\"\n                    },\n                    {\n                        \"name\": \"placeholder_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A placeholder node used during phi node replacement to break cycles.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"MachineOperatorBuilder\",\n                    \"CommonOperatorBuilder\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"Zone\",\n                    \"Signature\",\n                    \"Node\",\n                    \"CallDescriptor\",\n                    \"Diamond\",\n                    \"Int32Matcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass Int64Lowering {\n public:\n  Int64Lowering(TFGraph* graph, MachineOperatorBuilder* machine,\n                 CommonOperatorBuilder* common,\n                 SimplifiedOperatorBuilder* simplified, Zone* zone,\n                 Signature<MachineRepresentation>* signature);\n\n  void LowerGraph();\n\n  // static\n  int GetParameterCountAfterLowering(\n      Signature<MachineRepresentation>* signature);\n\n private:\n  enum State { kUnvisited, kOnStack, kVisited };\n\n  struct NodeState {\n    Node* node;\n    int input_index;\n  };\n\n  struct Replacement {\n    Node* low;\n    Node* high;\n  };\n\n  TFGraph* graph_;\n  MachineOperatorBuilder* machine_;\n  CommonOperatorBuilder* common_;\n  SimplifiedOperatorBuilder* simplified_;\n  Zone* zone_;\n  Signature<MachineRepresentation>* signature_;\n  ZoneVector<State> state_;\n  ZoneVector<NodeState> stack_;\n  Replacement* replacements_;\n  Node* placeholder_;\n\n  void LowerNode(Node* node);\n  void LowerWord64AtomicBinop(Node* node, const Operator* op);\n  void LowerWord64AtomicNarrowOp(Node* node, const Operator* op);\n  void GetIndexNodes(Node* index, Node** index_low, Node** index_high);\n  void LowerLoadOperator(Node* node, MachineRepresentation rep,\n                         const Operator* load_op);\n  void LowerStoreOperator(Node* node, MachineRepresentation rep,\n                          const Operator* store_op);\n  void LowerComparison(Node* node, const Operator* high_word_op,\n                       const Operator* low_word_op);\n\n  bool DefaultLowering(Node* node, bool low_word_only = false);\n  const CallDescriptor* LowerCallDescriptor(const CallDescriptor* call_descriptor);\n\n  void ReplaceNode(Node* old, Node* new_low, Node* new_high);\n  bool HasReplacementLow(Node* node);\n  Node* GetReplacementLow(Node* node);\n  bool HasReplacementHigh(Node* node);\n  Node* GetReplacementHigh(Node* node);\n  void PreparePhiReplacement(Node* phi);\n  void ReplaceNodeWithProjections(Node* node);\n  void LowerMemoryBaseAndIndex(Node* node);\n};\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Int64Lowering\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Constructor for the Int64Lowering class.\",\n                \"logic\": \"Initializes the Int64Lowering object with the provided graph, operator builders, zone, and signature. Allocates memory for replacements and sets up the placeholder node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The Turbofan graph to be lowered.\"\n                    },\n                    {\n                        \"name\": \"machine\",\n                        \"type\": \"MachineOperatorBuilder*\",\n                        \"purpose\": \"The machine operator builder.\"\n                    },\n                    {\n                        \"name\": \"common\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"purpose\": \"The common operator builder.\"\n                    },\n                    {\n                        \"name\": \"simplified\",\n                        \"type\": \"SimplifiedOperatorBuilder*\",\n                        \"purpose\": \"The simplified operator builder.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone for allocations.\"\n                    },\n                    {\n                        \"name\": \"signature\",\n                        \"type\": \"Signature<MachineRepresentation>*\",\n                        \"purpose\": \"The function signature.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"MachineOperatorBuilder\",\n                    \"CommonOperatorBuilder\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"Zone\",\n                    \"Signature\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nInt64Lowering::Int64Lowering(TFGraph* graph, MachineOperatorBuilder* machine,\n                             CommonOperatorBuilder* common,\n                             SimplifiedOperatorBuilder* simplified, Zone* zone,\n                             Signature<MachineRepresentation>* signature)\n    : graph_(graph),\n      machine_(machine),\n      common_(common),\n      simplified_(simplified),\n      zone_(zone),\n      signature_(signature),\n      state_(graph->NodeCount(), State::kUnvisited),\n      stack_(zone),\n      replacements_(nullptr),\n      placeholder_(graph->NewNode(common->Dead())) {\n  DCHECK_NOT_NULL(graph);\n  DCHECK_NOT_NULL(graph->end());\n  replacements_ = zone->AllocateArray<Replacement>(graph->NodeCount());\n  memset(replacements_, 0, sizeof(Replacement) * graph->NodeCount());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LowerGraph\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Lowers the 64-bit operations in the graph.\",\n                \"logic\": \"Performs a depth-first traversal of the graph, lowering each node that uses 64-bit operations to its 32-bit equivalent. Uses a stack to keep track of the nodes to be processed and a state vector to avoid cycles.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Int64Lowering::LowerGraph() {\n  stack_.push_back({graph()->end(), 0});\n  state_[graph()->end()->id()] = State::kOnStack;\n\n  while (!stack_.empty()) {\n    NodeState& top = stack_.back();\n    if (top.input_index == top.node->InputCount()) {\n      // All inputs of top have already been lowered, now lower top.\n      Node* node = top.node;\n      stack_.pop_back();\n      state_[node->id()] = State::kVisited;\n      LowerNode(node);\n    } else {\n      // Push the next input onto the stack.\n      Node* input = top.node->InputAt(top.input_index++);\n      if (state_[input->id()] == State::kUnvisited) {\n        if (input->opcode() == IrOpcode::kPhi) {\n          // To break cycles with phi nodes we push phis on a separate stack so\n          // that they are processed after all other nodes.\n          PreparePhiReplacement(input);\n          stack_.push_front({input, 0});\n        } else if (input->opcode() == IrOpcode::kEffectPhi ||\n                   input->opcode() == IrOpcode::kLoop) {\n          stack_.push_front({input, 0});\n        } else {\n          stack_.push_back({input, 0});\n        }\n        state_[input->id()] = State::kOnStack;\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetReturnIndexAfterLowering\",\n                \"parent\": null,\n                \"about\": \"Helper function to determine the return index after lowering.\",\n                \"logic\": \"Adjusts the return index based on the presence of 64-bit return values that are split into two 32-bit values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"call_descriptor\",\n                        \"type\": \"const CallDescriptor*\",\n                        \"purpose\": \"The call descriptor.\"\n                    },\n                    {\n                        \"name\": \"old_index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The original return index.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The adjusted return index after lowering.\"\n                },\n                \"dependencies\": [\n                    \"CallDescriptor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nint GetReturnIndexAfterLowering(const CallDescriptor* call_descriptor,\n                                int old_index) {\n  int result = old_index;\n  for (int i = 0; i < old_index; i++) {\n    if (call_descriptor->GetReturnType(i).representation() ==\n        MachineRepresentation::kWord64) {\n      result++;\n    }\n  }\n  return result;\n}\n\nint GetReturnCountAfterLowering(const CallDescriptor* call_descriptor) {\n  return GetReturnIndexAfterLowering(\n      call_descriptor, static_cast<int>(call_descriptor->ReturnCount()));\n}\n\nint GetParameterIndexAfterLowering(\n    Signature<MachineRepresentation>* signature, int old_index) {\n  int result = old_index;\n  // Be robust towards special indexes (>= param count).\n  int max_to_check =\n      std::min(old_index, static_cast<int>(signature->parameter_count()));\n  for (int i = 0; i < max_to_check; i++) {\n    if (signature->GetParam(i) == MachineRepresentation::kWord64) {\n      result++;\n    }\n  }\n  return result;\n}\n\nint GetReturnCountAfterLowering(Signature<MachineRepresentation>* signature) {\n  int result = static_cast<int>(signature->return_count());\n  for (int i = 0; i < static_cast<int>(signature->return_count()); i++) {\n    if (signature->GetReturn(i) == MachineRepresentation::kWord64) {\n      result++;\n    }\n  }\n  return result;\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LowerWord64AtomicBinop\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Lowers a 64-bit atomic binary operation to its 32-bit pair equivalent.\",\n                \"logic\": \"Replaces the input value with its low word, inserts the high word as a new input, and changes the operator to the corresponding 32-bit pair atomic operator.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node representing the atomic binary operation.\"\n                    },\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The 32-bit pair atomic operator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Int64Lowering::LowerWord64AtomicBinop(Node* node, const Operator* op) {\n  DCHECK_EQ(5, node->InputCount());\n  LowerMemoryBaseAndIndex(node);\n  Node* value = node->InputAt(2);\n  node->ReplaceInput(2, GetReplacementLow(value));\n  node->InsertInput(zone(), 3, GetReplacementHigh(value));\n  NodeProperties::ChangeOp(node, op);\n  ReplaceNodeWithProjections(node);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LowerWord64AtomicNarrowOp\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Lowers a 64-bit atomic narrow operation to its 32-bit equivalent.\",\n                \"logic\": \"Performs default lowering, changes the operator to the corresponding 32-bit atomic operator, and replaces the node with itself and a zero constant.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node representing the atomic narrow operation.\"\n                    },\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The 32-bit atomic operator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Int64Lowering::LowerWord64AtomicNarrowOp(Node* node, const Operator* op) {\n  DefaultLowering(node, true);\n  NodeProperties::ChangeOp(node, op);\n  ReplaceNode(node, node, graph()->NewNode(common()->Int32Constant(0)));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetParameterCountAfterLowering\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Calculates the number of parameters after lowering.\",\n                \"logic\": \"Calls GetParameterIndexAfterLowering with the parameter count to determine the new parameter count.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"signature\",\n                        \"type\": \"Signature<MachineRepresentation>*\",\n                        \"purpose\": \"The function signature.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The number of parameters after lowering.\"\n                },\n                \"dependencies\": [\n                    \"Signature\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nint Int64Lowering::GetParameterCountAfterLowering(\n    Signature<MachineRepresentation>* signature) {\n  // GetParameterIndexAfterLowering(parameter_count) returns the parameter count\n  // after lowering.\n  return GetParameterIndexAfterLowering(\n      signature, static_cast<int>(signature->parameter_count()));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetIndexNodes\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Calculates the low and high index nodes for memory access.\",\n                \"logic\": \"Calculates the index of the high word by adding 4 to the original index. Handles both little-endian and big-endian architectures by swapping the low and high indices appropriately.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The original index node.\"\n                    },\n                    {\n                        \"name\": \"index_low\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Output: The low index node.\"\n                    },\n                    {\n                        \"name\": \"index_high\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Output: The high index node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Int32Matcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Int64Lowering::GetIndexNodes(Node* index, Node** index_low,\n                                  Node** index_high) {\n  // We want to transform constant indices into constant indices, because\n  // wasm-typer depends on them.\n  Int32Matcher m(index);\n  Node* index_second =\n      m.HasResolvedValue()\n          ? graph()->NewNode(common()->Int32Constant(m.ResolvedValue() + 4))\n          : graph()->NewNode(machine()->Int32Add(), index,\n                             graph()->NewNode(common()->Int32Constant(4)));\n#if defined(V8_TARGET_LITTLE_ENDIAN)\n  *index_low = index;\n  *index_high = index_second;\n#elif defined(V8_TARGET_BIG_ENDIAN)\n  *index_low = index_second;\n  *index_high = index;\n#endif\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LowerLoadOperator\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Lowers a load operator for 64-bit values by creating two load operations for the low and high words.\",\n                \"logic\": \"Calculates the low and high indices, creates a new load node for the high word, replaces the original node's index with the low index, and updates the original node to represent the low word load.  Handles effect and control dependencies.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The original load node.\"\n                    },\n                    {\n                        \"name\": \"rep\",\n                        \"type\": \"MachineRepresentation\",\n                        \"purpose\": \"The representation of the value being loaded.\"\n                    },\n                    {\n                        \"name\": \"load_op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The load operator to use for the 32-bit words.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Int64Lowering::LowerLoadOperator(Node* node, MachineRepresentation rep,\n                                      const Operator* load_op) {\n  if (rep == MachineRepresentation::kWord64) {\n    LowerMemoryBaseAndIndex(node);\n    Node* base = node->InputAt(0);\n    Node* index = node->InputAt(1);\n    Node* index_low;\n    Node* index_high;\n    GetIndexNodes(index, &index_low, &index_high);\n    Node* high_node;\n    if (node->InputCount() > 2) {\n      Node* effect_high = node->InputAt(2);\n      Node* control_high = node->InputAt(3);\n      high_node = graph()->NewNode(load_op, base, index_high, effect_high,\n                                   control_high);\n      // change the effect change from old_node --> old_effect to\n      // old_node --> high_node --> old_effect.\n      node->ReplaceInput(2, high_node);\n    } else {\n      high_node = graph()->NewNode(load_op, base, index_high);\n    }\n    node->ReplaceInput(1, index_low);\n    NodeProperties::ChangeOp(node, load_op);\n    ReplaceNode(node, node, high_node);\n  } else {\n    DefaultLowering(node);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LowerStoreOperator\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Lowers a store operator for 64-bit values by creating two store operations for the low and high words.\",\n                \"logic\": \"Calculates the low and high indices, creates a new store node for the high word, replaces the original node's index with the low index and the original nodes value with the low word's value and updates the original node to store the low word. Handles effect and control dependencies.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The original store node.\"\n                    },\n                    {\n                        \"name\": \"rep\",\n                        \"type\": \"MachineRepresentation\",\n                        \"purpose\": \"The representation of the value being stored.\"\n                    },\n                    {\n                        \"name\": \"store_op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The store operator to use for the 32-bit words.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Int64Lowering::LowerStoreOperator(Node* node, MachineRepresentation rep,\n                                       const Operator* store_op) {\n  if (rep == MachineRepresentation::kWord64) {\n    // We change the original store node to store the low word, and create\n    // a new store node to store the high word. The effect and control edges\n    // are copied from the original store to the new store node, the effect\n    // edge of the original store is redirected to the new store.\n    LowerMemoryBaseAndIndex(node);\n    Node* base = node->InputAt(0);\n    Node* index = node->InputAt(1);\n    Node* index_low;\n    Node* index_high;\n    GetIndexNodes(index, &index_low, &index_high);\n    Node* value = node->InputAt(2);\n    DCHECK(HasReplacementLow(value));\n    DCHECK(HasReplacementHigh(value));\n\n    Node* high_node;\n    if (node->InputCount() > 3) {\n      Node* effect_high = node->InputAt(3);\n      Node* control_high = node->InputAt(4);\n      high_node = graph()->NewNode(store_op, base, index_high,\n                                   GetReplacementHigh(value), effect_high,\n                                   control_high);\n      node->ReplaceInput(3, high_node);\n\n    } else {\n      high_node = graph()->NewNode(store_op, base, index_high,\n                                   GetReplacementHigh(value));\n    }\n\n    node->ReplaceInput(1, index_low);\n    node->ReplaceInput(2, GetReplacementLow(value));\n    NodeProperties::ChangeOp(node, store_op);\n    ReplaceNode(node, node, high_node);\n  } else {\n    DefaultLowering(node, true);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LowerNode\",\n                \"parent\": \"Int64Lowering\",\n                \"about\": \"Lowers a single node in the graph, handling different opcodes for 64-bit operations.\",\n                \"logic\": \"This function contains a large switch statement that handles lowering of different 64-bit operations (constants, loads, stores, arithmetic operations, comparisons, conversions, etc.) to their 32-bit equivalents. It uses helper functions to perform specific lowering tasks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to be lowered.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"CallDescriptor\",\n                    \"Diamond\",\n                    \"Int32Matcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Int64Lowering::LowerNode(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kInt64Constant: {\n      int64_t value = OpParameter<int64_t>(node->op());\n      Node* low_node = graph()->NewNode(\n          common()->Int32Constant(static_cast<int32_t>(value & 0xFFFFFFFF)));\n      Node* high_node = graph()->NewNode(\n          common()->Int32Constant(static_cast<int32_t>(value >> 32)));\n      ReplaceNode(node, low_node, high_node);\n      break;\n    }\n    case IrOpcode::kLoad: {\n      MachineRepresentation rep =\n          LoadRepresentationOf(node->op()).representation();\n      LowerLoadOperator(node, rep, machine()->Load(MachineType::Int32()));\n      break;\n    }\n    case IrOpcode::kUnalignedLoad: {\n      MachineRepresentation rep =\n          LoadRepresentationOf(node->op()).representation();\n      LowerLoadOperator(node, rep,\n                        machine()->UnalignedLoad(MachineType::Int32()));\n      break;\n    }\n    case IrOpcode::kLoadImmutable: {\n      MachineRepresentation rep =\n          LoadRepresentationOf(node->op()).representation();\n      LowerLoadOperator(node, rep,\n                        machine()->LoadImmutable(MachineType::Int32()));\n      break;\n    }\n    case IrOpcode::kLoadFromObject: {\n      ObjectAccess access = ObjectAccessOf(node->op());\n      LowerLoadOperator(node, access.machine_type.representation(),\n                        simplified()->LoadFromObject(ObjectAccess(\n                            MachineType::Int32(), access.write_barrier_kind)));\n      break;\n    }\n    case IrOpcode::kLoadImmutableFromObject: {\n      ObjectAccess access = ObjectAccessOf(node->op());\n      LowerLoadOperator(node, access.machine_type.representation(),\n                        simplified()->LoadImmutableFromObject(ObjectAccess(\n                            MachineType::Int32(), access.write_barrier_kind)));\n      break;\n    }\n    case IrOpcode::kStore: {\n      StoreRepresentation store_rep = StoreRepresentationOf(node->op());\n      LowerStoreOperator(\n          node, store_rep.representation(),\n          machine()->Store(StoreRepresentation(\n              MachineRepresentation::kWord32, store_rep.write_barrier_kind())));\n      break;\n    }\n    case IrOpcode::kUnalignedStore: {\n      UnalignedStoreRepresentation store_rep =\n          UnalignedStoreRepresentationOf(node->op());\n      LowerStoreOperator(\n          node, store_rep,\n          machine()->UnalignedStore(MachineRepresentation::kWord32));\n      break;\n    }\n    case IrOpcode::kStoreToObject: {\n      ObjectAccess access = ObjectAccessOf(node->op());\n      LowerStoreOperator(node, access.machine_type.representation(),\n                         simplified()->StoreToObject(ObjectAccess(\n                             MachineType::Int32(), access.write_barrier_kind)));\n      break;\n    }\n    case IrOpcode::kInitializeImmutableInObject: {\n      ObjectAccess access = ObjectAccessOf(node->op());\n      LowerStoreOperator(node, access.machine_type.representation(),\n                         simplified()->InitializeImmutableInObject(ObjectAccess(\n                             MachineType::Int32(), access.write_barrier_kind)));\n      break;\n    }\n    case IrOpcode::kStart: {\n      int parameter_count = GetParameterCountAfterLowering(signature());\n      // Only exchange the node if the parameter count actually changed.\n      if (parameter_count != static_cast<int>(signature()->parameter_count())) {\n        int delta =\n            parameter_count - static_cast<int>(signature()->parameter_count());\n        int new_output_count = node->op()->ValueOutputCount() + delta;\n        NodeProperties::ChangeOp(node, common()->Start(new_output_count));\n      }\n      break;\n    }\n    case IrOpcode::kParameter: {\n      DCHECK_EQ(1, node->InputCount());\n      int param_count = static_cast<int>(signature()->parameter_count());\n      // Only exchange the node if the parameter count actually changed. We do\n      // not even have to do the default lowering because the the start node,\n      // the only input of a parameter node, only changes if the parameter count\n      // changes.\n      if (GetParameterCountAfterLowering(signature()) != param_count) {\n        int old_index = ParameterIndexOf(node->op());\n        // Adjust old_index to be compliant with the signature.\n        --old_index;\n        int new_index = GetParameterIndexAfterLowering(signature(), old_index);\n        // Adjust new_index to consider the instance parameter.\n        ++new_index;\n        NodeProperties::ChangeOp(node, common()->Parameter(new_index));\n\n        if (old_index < 0 || old_index >= param_count) {\n          // Special parameters (JS closure/context) don't have kWord64\n          // representation anyway.\n          break;\n        }\n\n        if (signature()->GetParam(old_index) ==\n            MachineRepresentation::kWord64) {\n          Node* high_node = graph()->NewNode(common()->Parameter(new_index + 1),\n                                             graph()->start());\n          ReplaceNode(node, node, high_node);\n        }\n      }\n      break;\n    }\n    case IrOpcode::kReturn: {\n      int input_count = node->InputCount();\n      DefaultLowering(node);\n      if (input_count != node->InputCount()) {\n        int new_return_count = GetReturnCountAfterLowering(signature());\n        if (static_cast<int>(signature()->return_count()) != new_return_count) {\n          NodeProperties::ChangeOp(node, common()->Return(new_return_count));\n        }\n      }\n      break;\n    }\n    case IrOpcode::kTailCall: {\n      auto call_descriptor =\n          const_cast<CallDescriptor*>(CallDescriptorOf(node->op()));\n      bool returns_require_lowering =\n          GetReturnCountAfterLowering(call_descriptor) !=\n          static_cast<int>(call_descriptor->ReturnCount());\n      if (DefaultLowering(node) || returns_require_lowering) {\n        // Tail calls do not have return values, so adjusting the call\n        // descriptor is enough.\n        NodeProperties::ChangeOp("
}