{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/logging/runtime-call-stats.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 115, column 63",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/logging/runtime-call-stats.h\",\n        \"file_name\": \"runtime-call-stats.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines classes and macros for tracking runtime call statistics in V8.  This includes counters for GC, API calls, built-in functions, and handler functions, as well as timing information.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for various functionalities like optional values, macros, atomic operations, platform-specific features, built-in definitions, thread management, heap symbols, tracing, and runtime functions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/macros.h\"\n\n#ifdef V8_RUNTIME_CALL_STATS\n\n#include \"src/base/atomic-utils.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/platform/time.h\"\n#include \"src/builtins/builtins-definitions.h\"\n#include \"src/execution/thread-id.h\"\n#include \"src/init/heap-symbols.h\"\n#include \"src/logging/tracing-flags.h\"\n#include \"src/runtime/runtime.h\"\n#include \"src/tracing/traced-value.h\"\n#include \"src/tracing/tracing-category-observer.h\"\n\n#endif  // V8_RUNTIME_CALL_STATS\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RuntimeCallCounter\",\n            \"about\": \"A counter for tracking the number of calls and the total time spent in a specific runtime function or code section.\",\n            \"attributes\": [\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Name of the counter.\"\n                },\n                {\n                    \"name\": \"count_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of times the counter has been incremented.\"\n                },\n                {\n                    \"name\": \"time_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Total time in microseconds spent in the code section being tracked.\"\n                }\n            ],\n            \"dependencies\": [\n                \"v8::tracing::TracedValue\",\n                \"base::TimeDelta\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass RuntimeCallCounter final {\n public:\n  RuntimeCallCounter() : RuntimeCallCounter(nullptr) {}\n  explicit RuntimeCallCounter(const char* name)\n      : name_(name), count_(0), time_(0) {}\n  V8_NOINLINE void Reset();\n  V8_NOINLINE void Dump(v8::tracing::TracedValue* value);\n  void Add(RuntimeCallCounter* other);\n\n  const char* name() const { return name_; }\n  int64_t count() const { return count_; }\n  base::TimeDelta time() const {\n    return base::TimeDelta::FromMicroseconds(time_);\n  }\n  void Increment() { count_++; }\n  void Add(base::TimeDelta delta) { time_ += delta.InMicroseconds(); }\n\n private:\n  friend class RuntimeCallStats;\n\n  const char* name_;\n  int64_t count_;\n  // Stored as int64_t so that its initialization can be deferred.\n  int64_t time_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RuntimeCallTimer\",\n            \"about\": \"Used to track the stack of currently active timers and measure the own time of a RuntimeCallCounter.\",\n            \"attributes\": [\n                {\n                    \"name\": \"counter_\",\n                    \"type\": \"RuntimeCallCounter*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The counter associated with this timer.\"\n                },\n                {\n                    \"name\": \"parent_\",\n                    \"type\": \"base::AtomicValue<RuntimeCallTimer*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The parent timer in the stack.\"\n                },\n                {\n                    \"name\": \"start_ticks_\",\n                    \"type\": \"base::TimeTicks\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The time when the timer was started.\"\n                },\n                {\n                    \"name\": \"elapsed_\",\n                    \"type\": \"base::TimeDelta\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The elapsed time for this timer.\"\n                }\n            ],\n            \"dependencies\": [\n                \"RuntimeCallCounter\",\n                \"base::AtomicValue\",\n                \"base::TimeTicks\",\n                \"base::TimeDelta\",\n                \"TracingFlags\",\n                \"v8::tracing::TracingCategoryObserver\",\n                \"DCHECK\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// RuntimeCallTimer is used to keep track of the stack of currently active\n// timers used for properly measuring the own time of a RuntimeCallCounter.\nclass RuntimeCallTimer final {\n public:\n  RuntimeCallCounter* counter() { return counter_; }\n  void set_counter(RuntimeCallCounter* counter) { counter_ = counter; }\n  RuntimeCallTimer* parent() const { return parent_.Value(); }\n  void set_parent(RuntimeCallTimer* timer) { parent_.SetValue(timer); }\n  const char* name() const { return counter_->name(); }\n\n  inline bool IsStarted() const { return start_ticks_ != base::TimeTicks(); }\n\n  inline void Start(RuntimeCallCounter* counter, RuntimeCallTimer* parent) {\n    DCHECK(!IsStarted());\n    counter_ = counter;\n    parent_.SetValue(parent);\n    if (TracingFlags::runtime_stats.load(std::memory_order_relaxed) ==\n        v8::tracing::TracingCategoryObserver::ENABLED_BY_SAMPLING) {\n      return;\n    }\n    base::TimeTicks now = RuntimeCallTimer::Now();\n    if (parent) parent->Pause(now);\n    Resume(now);\n    DCHECK(IsStarted());\n  }\n\n  void Snapshot();\n\n  inline RuntimeCallTimer* Stop() {\n    if (!IsStarted()) return parent();\n    base::TimeTicks now = RuntimeCallTimer::Now();\n    Pause(now);\n    counter_->Increment();\n    CommitTimeToCounter();\n\n    RuntimeCallTimer* parent_timer = parent();\n    if (parent_timer) {\n      parent_timer->Resume(now);\n    }\n    return parent_timer;\n  }\n\n  // Make the time source configurable for testing purposes.\n  V8_EXPORT_PRIVATE static base::TimeTicks (*Now)();\n\n  // Helper to switch over to CPU time.\n  static base::TimeTicks NowCPUTime();\n\n private:\n  inline void Pause(base::TimeTicks now) {\n    DCHECK(IsStarted());\n    elapsed_ += (now - start_ticks_);\n    start_ticks_ = base::TimeTicks();\n  }\n\n  inline void Resume(base::TimeTicks now) {\n    DCHECK(!IsStarted());\n    start_ticks_ = now;\n  }\n\n  inline void CommitTimeToCounter() {\n    counter_->Add(elapsed_);\n    elapsed_ = base::TimeDelta();\n  }\n\n  RuntimeCallCounter* counter_ = nullptr;\n  base::AtomicValue<RuntimeCallTimer*> parent_;\n  base::TimeTicks start_ticks_;\n  base::TimeDelta elapsed_;\n};\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"RuntimeCallCounterId\",\n            \"about\": \"Enumerates all possible runtime call counters used in V8. Macros are used to define the enum entries based on different categories of counters like GC, API, Runtime, Builtin and Handler functions.\",\n            \"dependencies\": [\n                \"FOR_EACH_GC_COUNTER\",\n                \"FOR_EACH_MANUAL_COUNTER\",\n                \"FOR_EACH_INTRINSIC\",\n                \"BUILTIN_LIST_C\",\n                \"FOR_EACH_API_COUNTER\",\n                \"FOR_EACH_HANDLER_COUNTER\",\n                \"FOR_EACH_THREAD_SPECIFIC_COUNTER\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nenum class RuntimeCallCounterId {\n#define CALL_RUNTIME_COUNTER(name) kGC_##name,\n  FOR_EACH_GC_COUNTER(CALL_RUNTIME_COUNTER)\n#undef CALL_RUNTIME_COUNTER\n#define CALL_RUNTIME_COUNTER(name) k##name,\n      FOR_EACH_MANUAL_COUNTER(CALL_RUNTIME_COUNTER)\n#undef CALL_RUNTIME_COUNTER\n#define CALL_RUNTIME_COUNTER(name, nargs, ressize) kRuntime_##name,\n          FOR_EACH_INTRINSIC(CALL_RUNTIME_COUNTER)\n#undef CALL_RUNTIME_COUNTER\n#define CALL_BUILTIN_COUNTER(name, Argc) kBuiltin_##name,\n              BUILTIN_LIST_C(CALL_BUILTIN_COUNTER)\n#undef CALL_BUILTIN_COUNTER\n#define CALL_BUILTIN_COUNTER(name) kAPI_##name,\n                  FOR_EACH_API_COUNTER(CALL_BUILTIN_COUNTER)\n#undef CALL_BUILTIN_COUNTER\n#define CALL_BUILTIN_COUNTER(name) kHandler_##name,\n                      FOR_EACH_HANDLER_COUNTER(CALL_BUILTIN_COUNTER)\n#undef CALL_BUILTIN_COUNTER\n#define THREAD_SPECIFIC_COUNTER(name) k##name,\n                          FOR_EACH_THREAD_SPECIFIC_COUNTER(\n                              THREAD_SPECIFIC_COUNTER)\n#undef THREAD_SPECIFIC_COUNTER\n                              kNumberOfCounters,\n};\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RuntimeCallStats\",\n            \"about\": \"Collects and manages runtime call statistics. It maintains counters for various categories of functions and provides methods for starting, stopping, and aggregating the statistics.\",\n            \"attributes\": [\n                {\n                    \"name\": \"current_timer_\",\n                    \"type\": \"base::AtomicValue<RuntimeCallTimer*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The currently active timer.\"\n                },\n                {\n                    \"name\": \"current_counter_\",\n                    \"type\": \"base::AtomicValue<RuntimeCallCounter*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The counter associated with the currently active timer.\"\n                },\n                {\n                    \"name\": \"in_use_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the stats object is currently in use.\"\n                },\n                {\n                    \"name\": \"thread_type_\",\n                    \"type\": \"ThreadType\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the stats are for a main isolate thread or a worker thread.\"\n                },\n                {\n                    \"name\": \"thread_id_\",\n                    \"type\": \"ThreadId\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The ID of the thread for which the stats are collected.\"\n                },\n                {\n                    \"name\": \"counters_\",\n                    \"type\": \"RuntimeCallCounter[kNumberOfCounters]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of all runtime call counters.\"\n                }\n            ],\n            \"dependencies\": [\n                \"RuntimeCallTimer\",\n                \"RuntimeCallCounterId\",\n                \"RuntimeCallCounter\",\n                \"base::AtomicValue\",\n                \"ThreadId\",\n                \"v8::tracing::TracedValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass RuntimeCallStats final {\n public:\n  enum ThreadType { kMainIsolateThread, kWorkerThread };\n\n  // If kExact is chosen the counter will be use as given. With kThreadSpecific,\n  // if the RuntimeCallStats was created for a worker thread, then the\n  // background specific version of the counter will be used instead.\n  enum CounterMode { kExact, kThreadSpecific };\n\n  explicit V8_EXPORT_PRIVATE RuntimeCallStats(ThreadType thread_type);\n\n  // Starting measuring the time for a function. This will establish the\n  // connection to the parent counter for properly calculating the own times.\n  V8_EXPORT_PRIVATE void Enter(RuntimeCallTimer* timer,\n                               RuntimeCallCounterId counter_id);\n\n  // Leave a scope for a measured runtime function. This will properly add\n  // the time delta to the current_counter and subtract the delta from its\n  // parent.\n  V8_EXPORT_PRIVATE void Leave(RuntimeCallTimer* timer);\n\n  // Set counter id for the innermost measurement. It can be used to refine\n  // event kind when a runtime entry counter is too generic.\n  V8_EXPORT_PRIVATE void CorrectCurrentCounterId(\n      RuntimeCallCounterId counter_id, CounterMode mode = kExact);\n\n  V8_EXPORT_PRIVATE void Reset();\n  // Add all entries from another stats object.\n  void Add(RuntimeCallStats* other);\n  V8_EXPORT_PRIVATE void Print(std::ostream& os);\n  V8_EXPORT_PRIVATE void Print();\n  V8_NOINLINE void Dump(v8::tracing::TracedValue* value);\n\n  ThreadId thread_id() const { return thread_id_; }\n  RuntimeCallTimer* current_timer() { return current_timer_.Value(); }\n  RuntimeCallCounter* current_counter() { return current_counter_.Value(); }\n  bool InUse() { return in_use_; }\n  bool IsCalledOnTheSameThread();\n\n  V8_EXPORT_PRIVATE bool IsBackgroundThreadSpecificVariant(\n      RuntimeCallCounterId id);\n  V8_EXPORT_PRIVATE bool HasThreadSpecificCounterVariants(\n      RuntimeCallCounterId id);\n\n  // This should only be called for counters with a dual Background variant. If\n  // on the main thread, this just returns the counter. If on a worker thread,\n  // it returns Background variant of the counter.\n  RuntimeCallCounterId CounterIdForThread(RuntimeCallCounterId id) {\n    DCHECK(HasThreadSpecificCounterVariants(id));\n    // All thread specific counters are laid out with the main thread variant\n    // first followed by the background variant.\n    int idInt = static_cast<int>(id);\n    return thread_type_ == kWorkerThread\n               ? static_cast<RuntimeCallCounterId>(idInt + 1)\n               : id;\n  }\n\n  bool IsCounterAppropriateForThread(RuntimeCallCounterId id) {\n    // TODO(delphick): We should add background-only counters and ensure that\n    // all counters (not just the thread-specific variants) are only invoked on\n    // the correct thread.\n    if (!HasThreadSpecificCounterVariants(id)) return true;\n    return IsBackgroundThreadSpecificVariant(id) ==\n           (thread_type_ == kWorkerThread);\n  }\n\n  static const int kNumberOfCounters =\n      static_cast<int>(RuntimeCallCounterId::kNumberOfCounters);\n  RuntimeCallCounter* GetCounter(RuntimeCallCounterId counter_id) {\n    return &counters_[static_cast<int>(counter_id)];\n  }\n  RuntimeCallCounter* GetCounter(int counter_id) {\n    return &counters_[counter_id];\n  }\n\n private:\n  // Top of a stack of active timers.\n  base::AtomicValue<RuntimeCallTimer*> current_timer_;\n  // Active counter object associated with current timer.\n  base::AtomicValue<RuntimeCallCounter*> current_counter_;\n  // Used to track nested tracing scopes.\n  bool in_use_;\n  ThreadType thread_type_;\n  ThreadId thread_id_;\n  RuntimeCallCounter counters_[kNumberOfCounters];\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WorkerThreadRuntimeCallStats\",\n            \"about\": \"Manages runtime call statistics for worker threads. It provides a thread-local storage for statistics and aggregates them into a main table.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Protects access to the shared data structures.\"\n                },\n                {\n                    \"name\": \"tables_\",\n                    \"type\": \"std::vector<std::unique_ptr<RuntimeCallStats>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of unique pointers to runtime call stats tables.\"\n                },\n                {\n                    \"name\": \"tls_key_\",\n                    \"type\": \"std::optional<base::Thread::LocalStorageKey>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Thread local storage key.\"\n                },\n                {\n                    \"name\": \"isolate_thread_id_\",\n                    \"type\": \"ThreadId\",\n                    \"access\": \"private\",\n                    \"purpose\": \"ID of the main thread.\"\n                }\n            ],\n            \"dependencies\": [\n                \"RuntimeCallStats\",\n                \"base::Mutex\",\n                \"base::Thread\",\n                \"ThreadId\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass WorkerThreadRuntimeCallStats final {\n public:\n  WorkerThreadRuntimeCallStats();\n  ~WorkerThreadRuntimeCallStats();\n\n  // Returns the TLS key associated with this WorkerThreadRuntimeCallStats.\n  base::Thread::LocalStorageKey GetKey();\n\n  // Returns a new worker thread runtime call stats table managed by this\n  // WorkerThreadRuntimeCallStats.\n  RuntimeCallStats* NewTable();\n\n  // Adds the counters from the worker thread tables to |main_call_stats|.\n  void AddToMainTable(RuntimeCallStats* main_call_stats);\n\n private:\n  base::Mutex mutex_;\n  std::vector<std::unique_ptr<RuntimeCallStats>> tables_;\n  std::optional<base::Thread::LocalStorageKey> tls_key_;\n  // Since this is for creating worker thread runtime-call stats, record the\n  // main thread ID to ensure we never create a worker RCS table for the main\n  // thread.\n  ThreadId isolate_thread_id_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WorkerThreadRuntimeCallStatsScope\",\n            \"about\": \"Provides a thread-local runtime call stats table for worker threads, dumping the table to a trace event on destruction.\",\n            \"attributes\": [\n                {\n                    \"name\": \"table_\",\n                    \"type\": \"RuntimeCallStats*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the runtime call stats table.\"\n                }\n            ],\n            \"dependencies\": [\n                \"RuntimeCallStats\",\n                \"WorkerThreadRuntimeCallStats\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Creating a WorkerThreadRuntimeCallStatsScope will provide a thread-local\n// runtime call stats table, and will dump the table to an immediate trace event\n// when it is destroyed.\nclass V8_EXPORT_PRIVATE V8_NODISCARD WorkerThreadRuntimeCallStatsScope final {\n public:\n  WorkerThreadRuntimeCallStatsScope() = default;\n  explicit WorkerThreadRuntimeCallStatsScope(\n      WorkerThreadRuntimeCallStats* off_thread_stats);\n  ~WorkerThreadRuntimeCallStatsScope();\n\n  WorkerThreadRuntimeCallStatsScope(WorkerThreadRuntimeCallStatsScope&&) =\n      delete;\n  WorkerThreadRuntimeCallStatsScope(const WorkerThreadRuntimeCallStatsScope&) =\n      delete;\n\n  RuntimeCallStats* Get() const { return table_; }\n\n private:\n  RuntimeCallStats* table_ = nullptr;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RuntimeCallTimerScope\",\n            \"about\": \"A class that wraps a RuntimeCallTimer to measure the time spent in a C++ scope. It starts the timer upon construction and stops it upon destruction.\",\n            \"attributes\": [\n                {\n                    \"name\": \"stats_\",\n                    \"type\": \"RuntimeCallStats*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the runtime call statistics object.\"\n                },\n                {\n                    \"name\": \"timer_\",\n                    \"type\": \"RuntimeCallTimer\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The runtime call timer.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"LocalIsolate\",\n                \"RuntimeCallStats\",\n                \"RuntimeCallTimer\",\n                \"RuntimeCallCounterId\",\n                \"TracingFlags\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// A RuntimeCallTimerScopes wraps around a RuntimeCallTimer to measure the\n// the time of C++ scope.\nclass V8_NODISCARD RuntimeCallTimerScope {\n public:\n  inline RuntimeCallTimerScope(Isolate* isolate,\n                               RuntimeCallCounterId counter_id);\n  inline RuntimeCallTimerScope(LocalIsolate* isolate,\n                               RuntimeCallCounterId counter_id,\n                               RuntimeCallStats::CounterMode mode =\n                                   RuntimeCallStats::CounterMode::kExact);\n  inline RuntimeCallTimerScope(RuntimeCallStats* stats,\n                               RuntimeCallCounterId counter_id,\n                               RuntimeCallStats::CounterMode mode =\n                                   RuntimeCallStats::CounterMode::kExact) {\n    if (V8_LIKELY(!TracingFlags::is_runtime_stats_enabled() ||\n                  stats == nullptr)) {\n      return;\n    }\n    stats_ = stats;\n    if (mode == RuntimeCallStats::CounterMode::kThreadSpecific) {\n      counter_id = stats->CounterIdForThread(counter_id);\n    }\n\n    DCHECK(stats->IsCounterAppropriateForThread(counter_id));\n    stats_->Enter(&timer_, counter_id);\n  }\n\n  inline ~RuntimeCallTimerScope() {\n    if (V8_UNLIKELY(stats_ != nullptr)) {\n      stats_->Leave(&timer_);\n    }\n  }\n\n  RuntimeCallTimerScope(const RuntimeCallTimerScope&) = delete;\n  RuntimeCallTimerScope& operator=(const RuntimeCallTimerScope&) = delete;\n\n private:\n  RuntimeCallStats* stats_ = nullptr;\n  RuntimeCallTimer timer_;\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"ThreadType\",\n                \"about\": \"Enum defining thread types\",\n                \"parent\": \"RuntimeCallStats\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum ThreadType { kMainIsolateThread, kWorkerThread };\n            ]]></code>\n        </enum>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"CounterMode\",\n                \"about\": \"Enum defining counter modes\",\n                \"parent\": \"RuntimeCallStats\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum CounterMode { kExact, kThreadSpecific };\n            ]]></code>\n        </enum>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"V8's isolate class (forward declaration)\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalIsolate\",\n                \"about\": \"V8's LocalIsolate class (forward declaration)\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class LocalIsolate;\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}