{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/loop-unrolling-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/loop-unrolling-reducer.cc\",\n            \"file_name\": \"loop-unrolling-reducer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements loop unrolling optimization in the Turboshaft compiler.\"\n        }\n    </metadata>\n\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for loop unrolling reducer functionality, standard utilities, base utilities, Turboshaft index, and loop finding.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/loop-unrolling-reducer.h\"\n\n#include <optional>\n\n#include \"src/base/bits.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/loop-finder.h\"\n        ]]></code>\n    </imports>\n\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"TRACE\",\n                \"purpose\": \"Conditional tracing macro for debugging loop unrolling.  Enabled only in DEBUG mode when v8_flags.turboshaft_trace_unrolling is true.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\n#define TRACE(x)                                                               \\\n  do {                                                                         \\\n    if (v8_flags.turboshaft_trace_unrolling) StdoutStream() << x << std::endl; \\\n  } while (false)\n#else\n#define TRACE(x)\n#endif\n        ]]></code>\n    </macro>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoopUnrollingAnalyzer\",\n                \"about\": \"Analyzes loops to determine if they can be unrolled.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"LoopFinder\",\n                    \"IterationCount\",\n                    \"StaticCanonicalForLoopMatcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::compiler::turboshaft {\n\nusing CmpOp = StaticCanonicalForLoopMatcher::CmpOp;\nusing BinOp = StaticCanonicalForLoopMatcher::BinOp;\n\nclass LoopUnrollingAnalyzer {\n public:\n  explicit LoopUnrollingAnalyzer(const LoopFinder& loop_finder,\n                                 const InputGraph& input_graph)\n      : loop_finder_(loop_finder),\n        input_graph_(input_graph),\n        canonical_loop_matcher_(input_graph),\n        can_unroll_at_least_one_loop_(false) {}\n\n  void DetectUnrollableLoops();\n\n  bool CanUnrollAtLeastOneLoop() const { return can_unroll_at_least_one_loop_; }\n\n  const std::set<uint32_t>& StackChecksToRemove() const {\n    return stack_checks_to_remove_;\n  }\n\n  bool ShouldFullyUnrollLoop(const Block* header) const {\n    auto it = loop_iteration_count_.find(header);\n    return it != loop_iteration_count_.end() && it->second.IsExact() &&\n           it->second.exact_count() <= kMaxLoopIterationsForFullUnrolling;\n  }\n\n  bool ShouldPartiallyUnrollLoop(const Block* header) const {\n    auto it = loop_iteration_count_.find(header);\n    return it != loop_iteration_count_.end() && it->second.IsApprox() &&\n           it->second.approx_count() <= kMaxLoopIterationsForPartialUnrolling;\n  }\n\n private:\n  IterationCount GetLoopIterationCount(\n      const LoopFinder::LoopInfo& info) const;\n\n  const LoopFinder& loop_finder_;\n  const InputGraph& input_graph_;\n  StaticCanonicalForLoopMatcher canonical_loop_matcher_;\n\n  bool can_unroll_at_least_one_loop_;\n  std::set<uint32_t> stack_checks_to_remove_;\n  std::unordered_map<const Block*, IterationCount> loop_iteration_count_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DetectUnrollableLoops\",\n                \"parent\": \"LoopUnrollingAnalyzer\",\n                \"about\": \"Detects loops that are suitable for unrolling and stores iteration counts.\",\n                \"logic\": \"Iterates through loop headers, calculates iteration counts, determines if loops should be unrolled (fully or partially), and identifies stack checks to remove.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"GetLoopIterationCount\",\n                    \"ShouldFullyUnrollLoop\",\n                    \"ShouldPartiallyUnrollLoop\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LoopUnrollingAnalyzer::DetectUnrollableLoops() {\n  for (const auto& [start, info] : loop_finder_.LoopHeaders()) {\n    IterationCount iter_count = GetLoopIterationCount(info);\n    TRACE(\"LoopUnrollingAnalyzer: loop at \"\n          << start->index() << \" ==> iter_count=\" << iter_count);\n    loop_iteration_count_.insert({start, iter_count});\n\n    if (ShouldFullyUnrollLoop(start) || ShouldPartiallyUnrollLoop(start)) {\n      can_unroll_at_least_one_loop_ = true;\n    }\n\n    if (iter_count.IsSmallerThan(kMaxIterForStackCheckRemoval)) {\n      stack_checks_to_remove_.insert(start->index().id());\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetLoopIterationCount\",\n                \"parent\": \"LoopUnrollingAnalyzer\",\n                \"about\": \"Calculates the iteration count of a loop if it can be determined statically.\",\n                \"logic\": \"Checks if the loop condition is based on a static canonical for loop pattern and uses StaticCanonicalForLoopMatcher to get the iteration count.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"info\",\n                        \"type\": \"const LoopFinder::LoopInfo&\",\n                        \"purpose\": \"Information about the loop.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"IterationCount\",\n                    \"description\": \"The calculated iteration count, or an empty IterationCount if it cannot be determined.\"\n                },\n                \"dependencies\": [\n                    \"LoopFinder\",\n                    \"StaticCanonicalForLoopMatcher\",\n                    \"BranchOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nIterationCount LoopUnrollingAnalyzer::GetLoopIterationCount(\n    const LoopFinder::LoopInfo& info) const {\n  const Block* start = info.start;\n  DCHECK(start->IsLoop());\n\n  // Checking that the condition for the loop can be computed statically, and\n  // that the loop contains no more than kMaxLoopIterationsForFullUnrolling\n  // iterations.\n  const BranchOp* branch =\n      start->LastOperation(*input_graph_).TryCast<BranchOp>();\n  if (!branch) {\n    // This looks like an infinite loop, or like something weird is used to\n    // decide whether to loop or not.\n    return {};\n  }\n\n  // Checking that one of the successor of the loop header is indeed not in the\n  // loop (otherwise, the Branch that ends the loop header is not the Branch\n  // that decides to exit the loop).\n  const Block* if_true_header = loop_finder_.GetLoopHeader(branch->if_true);\n  const Block* if_false_header = loop_finder_.GetLoopHeader(branch->if_false);\n  if (if_true_header == if_false_header) {\n    return {};\n  }\n\n  // If {if_true} is in the loop, then we're looping if the condition is true,\n  // but if {if_false} is in the loop, then we're looping if the condition is\n  // false.\n  bool loop_if_cond_is = if_true_header == start;\n\n  return canonical_loop_matcher_.GetIterCountIfStaticCanonicalForLoop(\n      start, branch->condition(), loop_if_cond_is);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Matches and analyzes static canonical for loops to determine iteration counts.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"ComparisonOp\",\n                    \"PhiOp\",\n                    \"OverflowCheckedBinopOp\",\n                    \"WordBinopOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass StaticCanonicalForLoopMatcher {\n public:\n  explicit StaticCanonicalForLoopMatcher(const InputGraph& graph) : matcher_(graph) {}\n\n  // Returns the number of iterations, or {} if it can't be computed\n  // statically.\n  IterationCount GetIterCountIfStaticCanonicalForLoop(const Block* header,\n                                                      OpIndex cond_idx,\n                                                      bool loop_if_cond_is) const;\n\n  enum class CmpOp {\n    kEqual,\n    kSignedLessThan,\n    kSignedLessThanOrEqual,\n    kUnsignedLessThan,\n    kUnsignedLessThanOrEqual,\n    kSignedGreaterThan,\n    kSignedGreaterThanOrEqual,\n    kUnsignedGreaterThan,\n    kUnsignedGreaterThanOrEqual,\n  };\n  static constexpr CmpOp ComparisonKindToCmpOp(ComparisonOp::Kind kind);\n  static constexpr CmpOp InvertComparisonOp(CmpOp op);\n\n  enum class BinOp {\n    kAdd,\n    kMul,\n    kSub,\n    kBitwiseAnd,\n    kBitwiseOr,\n    kBitwiseXor,\n    kOverflowCheckedAdd,\n    kOverflowCheckedMul,\n    kOverflowCheckedSub,\n  };\n\n private:\n  bool MatchPhiCompareCst(OpIndex cond_idx, CmpOp* cmp_op, OpIndex* phi,\n                           uint64_t* cst) const;\n  bool MatchCheckedOverflowBinop(OpIndex idx, V<Word>* left, V<Word>* right,\n                                 BinOp* binop_op,\n                                 WordRepresentation* binop_rep) const;\n  bool MatchWordBinop(OpIndex idx, V<Word>* left, V<Word>* right,\n                      BinOp* binop_op, WordRepresentation* binop_rep) const;\n\n  static constexpr bool BinopKindIsSupported(WordBinopOp::Kind binop_kind);\n  static constexpr BinOp BinopFromWordBinopKind(WordBinopOp::Kind kind);\n  static constexpr BinOp BinopFromOverflowCheckedBinopKind(\n      OverflowCheckedBinopOp::Kind kind);\n\n  IterationCount CountIterations(uint64_t cmp_cst, CmpOp cmp_op,\n                                 uint64_t initial_input, uint64_t binop_cst,\n                                 BinOp binop_op, WordRepresentation binop_rep,\n                                 bool loop_if_cond_is) const;\n\n  template <class Int>\n  IterationCount CountIterationsImpl(Int init, Int max, CmpOp cmp_op, Int binop_cst,\n                                  BinOp binop_op, WordRepresentation binop_rep,\n                                  bool loop_if_cond_is) const;\n  const GraphMatcher& matcher_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MatchPhiCompareCst\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Tries to match the pattern `phi cmp cst` or `cst cmp phi` in a condition.\",\n                \"logic\": \"Checks if the condition is a ComparisonOp and one input is a Phi and the other is an unsigned integer constant. If the constant is on the left side, it inverts the comparison operator.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cond_idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the condition operation.\"\n                    },\n                    {\n                        \"name\": \"cmp_op\",\n                        \"type\": \"StaticCanonicalForLoopMatcher::CmpOp*\",\n                        \"purpose\": \"Output: The comparison operator.\"\n                    },\n                    {\n                        \"name\": \"phi\",\n                        \"type\": \"OpIndex*\",\n                        \"purpose\": \"Output: Index of the Phi operation.\"\n                    },\n                    {\n                        \"name\": \"cst\",\n                        \"type\": \"uint64_t*\",\n                        \"purpose\": \"Output: The constant value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the pattern is matched, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ComparisonOp\",\n                    \"GraphMatcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool StaticCanonicalForLoopMatcher::MatchPhiCompareCst(\n    OpIndex cond_idx, StaticCanonicalForLoopMatcher::CmpOp* cmp_op,\n    OpIndex* phi, uint64_t* cst) const {\n  const Operation& cond = matcher_.Get(cond_idx);\n\n  if (const ComparisonOp* cmp = cond.TryCast<ComparisonOp>()) {\n    *cmp_op = ComparisonKindToCmpOp(cmp->kind);\n  } else {\n    return false;\n  }\n\n  OpIndex left = cond.input(0);\n  OpIndex right = cond.input(1);\n\n  if (matcher_.MatchPhi(left, 2)) {\n    if (matcher_.MatchUnsignedIntegralConstant(right, cst)) {\n      *phi = left;\n      return true;\n    }\n  } else if (matcher_.MatchPhi(right, 2)) {\n    if (matcher_.MatchUnsignedIntegralConstant(left, cst)) {\n      *cmp_op = InvertComparisonOp(*cmp_op);\n      *phi = right;\n      return true;\n    }\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MatchCheckedOverflowBinop\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Matches a checked overflow binary operation.\",\n                \"logic\": \"Checks if the operation is a ProjectionOp with index kValueIndex of an OverflowCheckedBinopOp. Extracts the left and right inputs and the binary operation kind and representation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the operation.\"\n                    },\n                    {\n                        \"name\": \"left\",\n                        \"type\": \"V<Word>*\",\n                        \"purpose\": \"Output: The left input.\"\n                    },\n                    {\n                        \"name\": \"right\",\n                        \"type\": \"V<Word>*\",\n                        \"purpose\": \"Output: The right input.\"\n                    },\n                    {\n                        \"name\": \"binop_op\",\n                        \"type\": \"BinOp*\",\n                        \"purpose\": \"Output: The binary operation.\"\n                    },\n                    {\n                        \"name\": \"binop_rep\",\n                        \"type\": \"WordRepresentation*\",\n                        \"purpose\": \"Output: The word representation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the pattern is matched, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ProjectionOp\",\n                    \"OverflowCheckedBinopOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool StaticCanonicalForLoopMatcher::MatchCheckedOverflowBinop(\n    OpIndex idx, V<Word>* left, V<Word>* right, BinOp* binop_op,\n    WordRepresentation* binop_rep) const {\n  if (const ProjectionOp* proj = matcher_.TryCast<ProjectionOp>(idx)) {\n    if (proj->index != OverflowCheckedBinopOp::kValueIndex) return false;\n    if (const OverflowCheckedBinopOp* binop =\n            matcher_.TryCast<OverflowCheckedBinopOp>(proj->input())) {\n      *left = binop->left();\n      *right = binop->right();\n      *binop_op = BinopFromOverflowCheckedBinopKind(binop->kind);\n      *binop_rep = binop->rep;\n      return true;\n    }\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MatchWordBinop\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Matches a word binary operation.\",\n                \"logic\": \"Checks if the operation is a WordBinopOp and the kind is supported. Extracts the left and right inputs, the binary operation kind, and the word representation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the operation.\"\n                    },\n                    {\n                        \"name\": \"left\",\n                        \"type\": \"V<Word>*\",\n                        \"purpose\": \"Output: The left input.\"\n                    },\n                    {\n                        \"name\": \"right\",\n                        \"type\": \"V<Word>*\",\n                        \"purpose\": \"Output: The right input.\"\n                    },\n                    {\n                        \"name\": \"binop_op\",\n                        \"type\": \"BinOp*\",\n                        \"purpose\": \"Output: The binary operation.\"\n                    },\n                    {\n                        \"name\": \"binop_rep\",\n                        \"type\": \"WordRepresentation*\",\n                        \"purpose\": \"Output: The word representation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the pattern is matched, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"WordBinopOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool StaticCanonicalForLoopMatcher::MatchWordBinop(\n    OpIndex idx, V<Word>* left, V<Word>* right, BinOp* binop_op,\n    WordRepresentation* binop_rep) const {\n  WordBinopOp::Kind kind;\n  if (matcher_.MatchWordBinop<Word>(idx, left, right, &kind, binop_rep) &&\n      BinopKindIsSupported(kind)) {\n    *binop_op = BinopFromWordBinopKind(kind);\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetIterCountIfStaticCanonicalForLoop\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Attempts to determine the iteration count for a static canonical for loop.\",\n                \"logic\": \"Matches the loop condition against a Phi comparison pattern, then analyzes the Phi's inputs to identify the initialization and increment operations. If a recognizable pattern is found, calculates and returns the iteration count using CountIterations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"header\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The loop header block.\"\n                    },\n                    {\n                        \"name\": \"cond_idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index of the loop condition operation.\"\n                    },\n                    {\n                        \"name\": \"loop_if_cond_is\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether the loop continues when the condition is true or false.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"IterationCount\",\n                    \"description\": \"The calculated iteration count, or an empty IterationCount if the loop is not a static canonical for loop.\"\n                },\n                \"dependencies\": [\n                    \"MatchPhiCompareCst\",\n                    \"GraphMatcher\",\n                    \"PhiOp\",\n                    \"MatchWordBinop\",\n                    \"MatchCheckedOverflowBinop\",\n                    \"CountIterations\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nIterationCount\nStaticCanonicalForLoopMatcher::GetIterCountIfStaticCanonicalForLoop(\n    const Block* header, OpIndex cond_idx, bool loop_if_cond_is) const {\n  CmpOp cmp_op;\n  OpIndex phi_idx;\n  uint64_t cmp_cst;\n  if (!MatchPhiCompareCst(cond_idx, &cmp_op, &phi_idx, &cmp_cst)) {\n    return {};\n  }\n  if (!header->Contains(phi_idx)) {\n    // The termination condition for this loop is based on a Phi that is defined\n    // in another loop.\n    return {};\n  }\n\n  const PhiOp& phi = matcher_.Cast<PhiOp>(phi_idx);\n\n  // We have: phi(..., ...) cmp_op cmp_cst\n  // eg, for (i = ...; i < 42; ...)\n  uint64_t phi_cst;\n  if (matcher_.MatchUnsignedIntegralConstant(phi.input(0), &phi_cst)) {\n    // We have: phi(phi_cst, ...) cmp_op cmp_cst\n    // eg, for (i = 0; i < 42; ...)\n    V<Word> left, right;\n    BinOp binop_op;\n    WordRepresentation binop_rep;\n    if (MatchWordBinop(phi.input(1), &left, &right, &binop_op, &binop_rep) ||\n        MatchCheckedOverflowBinop(phi.input(1), &left, &right, &binop_op,\n                                  &binop_rep)) {\n      // We have: phi(phi_cst, ... binop_op ...) cmp_op cmp_cst\n      // eg, for (i = 0; i < 42; i = ... + ...)\n      if (left == phi_idx) {\n        // We have: phi(phi_cst, phi binop_op ...) cmp_op cmp_cst\n        // eg, for (i = 0; i < 42; i = i + ...)\n        uint64_t binop_cst;\n        if (matcher_.MatchUnsignedIntegralConstant(right, &binop_cst)) {\n          // We have: phi(phi_cst, phi binop_op binop_cst) cmp_op cmp_cst\n          // eg, for (i = 0; i < 42; i = i + 2)\n          return CountIterations(cmp_cst, cmp_op, phi_cst, binop_cst, binop_op,\n                                 binop_rep, loop_if_cond_is);\n        }\n      } else if (right == phi_idx) {\n        // We have: phi(phi_cst, ... binop_op phi) cmp_op cmp_cst\n        // eg, for (i = 0; i < 42; i = ... + i)\n        uint64_t binop_cst;\n        if (matcher_.MatchUnsignedIntegralConstant(left, &binop_cst)) {\n          // We have: phi(phi_cst, binop_cst binop_op phi) cmp_op cmp_cst\n          // eg, for (i = 0; i < 42; i = 2 + i)\n          return CountIterations(cmp_cst, cmp_op, phi_cst, binop_cst, binop_op,\n                                 binop_rep, loop_if_cond_is);\n        }\n      }\n    }\n  }\n\n  // The condition is not an operation that we support.\n  return {};\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BinopKindIsSupported\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Checks if a WordBinopOp::Kind is supported for loop unrolling.\",\n                \"logic\": \"Checks if the binop_kind is one of the supported kinds(Add, Mul, Sub, BitwiseAnd, BitwiseOr, BitwiseXor).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"binop_kind\",\n                        \"type\": \"WordBinopOp::Kind\",\n                        \"purpose\": \"The WordBinopOp::Kind to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the binop_kind is supported, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr bool StaticCanonicalForLoopMatcher::BinopKindIsSupported(\n    WordBinopOp::Kind binop_kind) {\n  switch (binop_kind) {\n    // This list needs to be kept in sync with the `Next` function that follows.\n    case WordBinopOp::Kind::kAdd:\n    case WordBinopOp::Kind::kMul:\n    case WordBinopOp::Kind::kSub:\n    case WordBinopOp::Kind::kBitwiseAnd:\n    case WordBinopOp::Kind::kBitwiseOr:\n    case WordBinopOp::Kind::kBitwiseXor:\n      return true;\n    default:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BinopFromWordBinopKind\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Converts a WordBinopOp::Kind to a StaticCanonicalForLoopMatcher::BinOp.\",\n                \"logic\": \"Maps the WordBinopOp::Kind to the corresponding BinOp.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"WordBinopOp::Kind\",\n                        \"purpose\": \"The WordBinopOp::Kind to convert.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"StaticCanonicalForLoopMatcher::BinOp\",\n                    \"description\": \"The corresponding BinOp.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr StaticCanonicalForLoopMatcher::BinOp\nStaticCanonicalForLoopMatcher::BinopFromWordBinopKind(WordBinopOp::Kind kind) {\n  DCHECK(BinopKindIsSupported(kind));\n  switch (kind) {\n    case WordBinopOp::Kind::kAdd:\n      return BinOp::kAdd;\n    case WordBinopOp::Kind::kMul:\n      return BinOp::kMul;\n    case WordBinopOp::Kind::kSub:\n      return BinOp::kSub;\n    case WordBinopOp::Kind::kBitwiseAnd:\n      return BinOp::kBitwiseAnd;\n    case WordBinopOp::Kind::kBitwiseOr:\n      return BinOp::kBitwiseOr;\n    case WordBinopOp::Kind::kBitwiseXor:\n      return BinOp::kBitwiseXor;\n    default:\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BinopFromOverflowCheckedBinopKind\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Converts a OverflowCheckedBinopOp::Kind to a StaticCanonicalForLoopMatcher::BinOp.\",\n                \"logic\": \"Maps the OverflowCheckedBinopOp::Kind to the corresponding BinOp.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"OverflowCheckedBinopOp::Kind\",\n                        \"purpose\": \"The OverflowCheckedBinopOp::Kind to convert.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"StaticCanonicalForLoopMatcher::BinOp\",\n                    \"description\": \"The corresponding BinOp.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr StaticCanonicalForLoopMatcher::BinOp\nStaticCanonicalForLoopMatcher::BinopFromOverflowCheckedBinopKind(\n    OverflowCheckedBinopOp::Kind kind) {\n  switch (kind) {\n    case OverflowCheckedBinopOp::Kind::kSignedAdd:\n      return BinOp::kOverflowCheckedAdd;\n    case OverflowCheckedBinopOp::Kind::kSignedMul:\n      return BinOp::kOverflowCheckedMul;\n    case OverflowCheckedBinopOp::Kind::kSignedSub:\n      return BinOp::kOverflowCheckedSub;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CountIterations\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Counts the number of iterations of a loop given the comparison constant, comparison operator, initial input, binary operation constant, binary operator, word representation and loop condition.\",\n                \"logic\": \"Uses a template function `CountIterationsImpl` to compute the iteration count based on whether the values are signed or unsigned and the bit width (32 or 64).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cmp_cst\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The constant value used in the loop condition.\"\n                    },\n                    {\n                        \"name\": \"cmp_op\",\n                        \"type\": \"CmpOp\",\n                        \"purpose\": \"The comparison operator used in the loop condition.\"\n                    },\n                    {\n                        \"name\": \"initial_input\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The initial value of the loop counter.\"\n                    },\n                    {\n                        \"name\": \"binop_cst\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The constant value used in the loop increment/decrement operation.\"\n                    },\n                    {\n                        \"name\": \"binop_op\",\n                        \"type\": \"BinOp\",\n                        \"purpose\": \"The binary operator used in the loop increment/decrement operation.\"\n                    },\n                    {\n                        \"name\": \"binop_rep\",\n                        \"type\": \"WordRepresentation\",\n                        \"purpose\": \"The word representation (32-bit or 64-bit) of the loop counter.\"\n                    },\n                    {\n                        \"name\": \"loop_if_cond_is\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether the loop continues when the condition is true or false.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"IterationCount\",\n                    \"description\": \"The calculated iteration count.\"\n                },\n                \"dependencies\": [\n                    \"CountIterationsImpl\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nIterationCount StaticCanonicalForLoopMatcher::CountIterations(\n    uint64_t cmp_cst, CmpOp cmp_op, uint64_t initial_input, uint64_t binop_cst,\n    BinOp binop_op, WordRepresentation binop_rep, bool loop_if_cond_is) const {\n  switch (cmp_op) {\n    case CmpOp::kSignedLessThan:\n    case CmpOp::kSignedLessThanOrEqual:\n    case CmpOp::kSignedGreaterThan:\n    case CmpOp::kSignedGreaterThanOrEqual:\n    case CmpOp::kEqual:\n      if (binop_rep == WordRepresentation::Word32()) {\n        return CountIterationsImpl<int32_t>(\n            static_cast<int32_t>(initial_input), static_cast<int32_t>(cmp_cst),\n            cmp_op, static_cast<int32_t>(binop_cst), binop_op, binop_rep,\n            loop_if_cond_is);\n      } else {\n        DCHECK_EQ(binop_rep, WordRepresentation::Word64());\n        return CountIterationsImpl<int64_t>(\n            static_cast<int64_t>(initial_input), static_cast<int64_t>(cmp_cst),\n            cmp_op, static_cast<int64_t>(binop_cst), binop_op, binop_rep,\n            loop_if_cond_is);\n      }\n    case CmpOp::kUnsignedLessThan:\n    case CmpOp::kUnsignedLessThanOrEqual:\n    case CmpOp::kUnsignedGreaterThan:\n    case CmpOp::kUnsignedGreaterThanOrEqual:\n      if (binop_rep == WordRepresentation::Word32()) {\n        return CountIterationsImpl<uint32_t>(\n            static_cast<uint32_t>(initial_input),\n            static_cast<uint32_t>(cmp_cst), cmp_op,\n            static_cast<uint32_t>(binop_cst), binop_op, binop_rep,\n            loop_if_cond_is);\n      } else {\n        DCHECK_EQ(binop_rep, WordRepresentation::Word64());\n        return CountIterationsImpl<uint64_t>(initial_input, cmp_cst, cmp_op,\n                                             binop_cst, binop_op, binop_rep,\n                                             loop_if_cond_is);\n      }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CountIterationsImpl\",\n                \"parent\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Counts the number of iterations of a loop using a simulation approach.\",\n                \"logic\": \"Simulates the loop execution up to a maximum number of iterations (`kMaxExactIter`) to accurately count iterations, taking into account potential overflows"
}