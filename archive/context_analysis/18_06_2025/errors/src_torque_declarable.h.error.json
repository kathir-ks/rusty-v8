{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/declarable.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/declarable.h\",\n        \"file_name\": \"declarable.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Declarable class hierarchy and related classes, used for representing named entities (namespaces, macros, functions, types, constants) within the Torque language.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and Torque-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <cassert>\n            #include <optional>\n            #include <string>\n            #include <unordered_map>\n\n            #include \"src/base/hashing.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/torque/ast.h\"\n            #include \"src/torque/types.h\"\n            #include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"QualifiedName\",\n            \"about\": \"Represents a qualified name, which may include a namespace qualification.\",\n            \"attributes\": [\n                {\n                    \"name\": \"namespace_qualification\",\n                    \"type\": \"std::vector<std::string>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The namespace qualification of the name.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"std::string\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The unqualified name.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct QualifiedName {\n            std::vector<std::string> namespace_qualification;\n            std::string name;\n\n            QualifiedName(std::vector<std::string> namespace_qualification,\n                            std::string name)\n                : namespace_qualification(std::move(namespace_qualification)),\n                name(std::move(name)) {}\n            explicit QualifiedName(std::string name)\n                : QualifiedName({}, std::move(name)) {}\n\n            static QualifiedName Parse(std::string qualified_name);\n\n            bool HasNamespaceQualification() const {\n                return !namespace_qualification.empty();\n            }\n\n            QualifiedName DropFirstNamespaceQualification() const {\n                return QualifiedName{\n                    std::vector<std::string>(namespace_qualification.begin() + 1,\n                                            namespace_qualification.end()),\n                    name};\n            }\n\n            friend std::ostream& operator<<(std::ostream& os, const QualifiedName& name);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Declarable\",\n            \"about\": \"Base class for all named entities in Torque. Provides common functionality for managing source positions and determining the kind of declarable.\",\n            \"attributes\": [\n                {\n                    \"name\": \"kind_\",\n                    \"type\": \"Kind\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The kind of declarable.\"\n                },\n                {\n                    \"name\": \"parent_scope_\",\n                    \"type\": \"Scope*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The scope in which this declarable is defined.\"\n                },\n                {\n                    \"name\": \"position_\",\n                    \"type\": \"SourcePosition\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The source position of the declarable.\"\n                },\n                {\n                    \"name\": \"identifier_position_\",\n                    \"type\": \"SourcePosition\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The source position of the identifier.\"\n                },\n                {\n                    \"name\": \"is_user_defined_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the declarable is user-defined.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Scope\",\n                \"SourcePosition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Declarable {\n            public:\n            virtual ~Declarable() = default;\n            enum Kind {\n                kNamespace,\n                kTorqueMacro,\n                kExternMacro,\n                kMethod,\n                kBuiltin,\n                kRuntimeFunction,\n                kIntrinsic,\n                kGenericCallable,\n                kGenericType,\n                kTypeAlias,\n                kExternConstant,\n                kNamespaceConstant\n            };\n            Kind kind() const { return kind_; }\n            bool IsNamespace() const { return kind() == kNamespace; }\n            bool IsMacro() const { return IsTorqueMacro() || IsExternMacro(); }\n            bool IsTorqueMacro() const { return kind() == kTorqueMacro || IsMethod(); }\n            bool IsMethod() const { return kind() == kMethod; }\n            bool IsExternMacro() const { return kind() == kExternMacro; }\n            bool IsIntrinsic() const { return kind() == kIntrinsic; }\n            bool IsBuiltin() const { return kind() == kBuiltin; }\n            bool IsRuntimeFunction() const { return kind() == kRuntimeFunction; }\n            bool IsGenericCallable() const { return kind() == kGenericCallable; }\n            bool IsGenericType() const { return kind() == kGenericType; }\n            bool IsTypeAlias() const { return kind() == kTypeAlias; }\n            bool IsExternConstant() const { return kind() == kExternConstant; }\n            bool IsNamespaceConstant() const { return kind() == kNamespaceConstant; }\n            bool IsValue() const { return IsExternConstant() || IsNamespaceConstant(); }\n            bool IsScope() const { return IsNamespace() || IsCallable(); }\n            bool IsCallable() const {\n                return IsMacro() || IsBuiltin() || IsRuntimeFunction() || IsIntrinsic() ||\n                    IsMethod();\n            }\n            virtual const char* type_name() const { return \"<<unknown>>\"; }\n            Scope* ParentScope() const { return parent_scope_; }\n\n            // The SourcePosition of the whole declarable. For example, for a macro\n            // this will encompass not only the signature, but also the body.\n            SourcePosition Position() const { return position_; }\n            void SetPosition(const SourcePosition& position) { position_ = position; }\n\n            // The SourcePosition of the identifying name of the declarable. For example,\n            // for a macro this will be the SourcePosition of the name.\n            // Note that this SourcePosition might not make sense for all kinds of\n            // declarables, in that case, the default SourcePosition is returned.\n            SourcePosition IdentifierPosition() const {\n                return identifier_position_.source.IsValid() ? identifier_position_\n                                                            : position_;\n            }\n            void SetIdentifierPosition(const SourcePosition& position) {\n                identifier_position_ = position;\n            }\n\n            bool IsUserDefined() const { return is_user_defined_; }\n            void SetIsUserDefined(bool is_user_defined) {\n                is_user_defined_ = is_user_defined;\n            }\n\n            protected:\n            explicit Declarable(Kind kind) : kind_(kind) {}\n\n            private:\n            const Kind kind_;\n            Scope* const parent_scope_ = CurrentScope::Get();\n            SourcePosition position_ = CurrentSourcePosition::Get();\n            SourcePosition identifier_position_ = SourcePosition::Invalid();\n            bool is_user_defined_ = true;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SpecializationRequester\",\n            \"about\": \"Stores information about the context which caused a generic specialization to exist.  Used for error reporting.\",\n            \"attributes\": [\n                {\n                    \"name\": \"position\",\n                    \"type\": \"SourcePosition\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The position of the expression that caused the specialization.\"\n                },\n                {\n                    \"name\": \"scope\",\n                    \"type\": \"Scope*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The scope containing the expression that caused the specialization.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"std::string\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The name of the specialization.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SourcePosition\",\n                \"Scope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct SpecializationRequester {\n            // The position of the expression that caused this specialization.\n            SourcePosition position;\n            // The Scope which contains the expression that caused this specialization.\n            // It may in turn also be within a specialization, which allows us to print\n            // the stack of requesters when an error occurs.\n            Scope* scope;\n            // The name of the specialization.\n            std::string name;\n\n            static SpecializationRequester None() {\n                return {SourcePosition::Invalid(), nullptr, \"\"};\n            }\n\n            bool IsNone() const {\n                return position == SourcePosition::Invalid() && scope == nullptr &&\n                    name == \"\";\n            }\n            SpecializationRequester(SourcePosition position, Scope* scope,\n                                    std::string name);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Scope\",\n            \"extends\": \"Declarable\",\n            \"about\": \"Represents a lexical scope in Torque.  Manages a set of Declarables.\",\n            \"attributes\": [\n                {\n                    \"name\": \"declarations_\",\n                    \"type\": \"std::unordered_map<std::string, std::vector<Declarable*>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A map of names to vectors of declarables.\"\n                },\n                {\n                    \"name\": \"requester_\",\n                    \"type\": \"SpecializationRequester\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the SpecializationRequester for this Scope if created for specializing a generic.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Declarable\",\n                \"QualifiedName\",\n                \"SpecializationRequester\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Scope : public Declarable {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(Scope, scope)\n            explicit Scope(Declarable::Kind kind) : Declarable(kind) {}\n\n            std::vector<Declarable*> LookupShallow(const QualifiedName& name) {\n                if (!name.HasNamespaceQualification()) return declarations_[name.name];\n                Scope* child = nullptr;\n                for (Declarable* declarable :\n                    declarations_[name.namespace_qualification.front()]) {\n                if (Scope* scope = Scope::DynamicCast(declarable)) {\n                    if (child != nullptr) {\n                    ReportError(\"ambiguous reference to scope \",\n                                name.namespace_qualification.front());\n                    }\n                    child = scope;\n                }\n                }\n                if (child == nullptr) return {};\n                return child->LookupShallow(name.DropFirstNamespaceQualification());\n            }\n\n            std::vector<Declarable*> Lookup(const QualifiedName& name);\n            template <class T>\n            T* AddDeclarable(const std::string& name, T* declarable) {\n                declarations_[name].push_back(declarable);\n                return declarable;\n            }\n\n            const SpecializationRequester& GetSpecializationRequester() const {\n                return requester_;\n            }\n            void SetSpecializationRequester(const SpecializationRequester& requester) {\n                requester_ = requester;\n            }\n\n            private:\n            std::unordered_map<std::string, std::vector<Declarable*>> declarations_;\n\n            // If this Scope was created for specializing a generic type or callable,\n            // then {requester_} refers to the place that caused the specialization so we\n            // can construct useful error messages.\n            SpecializationRequester requester_ = SpecializationRequester::None();\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Namespace\",\n            \"extends\": \"Scope\",\n            \"about\": \"Represents a namespace in Torque.\",\n            \"attributes\": [\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The name of the namespace.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Scope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Namespace : public Scope {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(Namespace, namespace)\n            explicit Namespace(const std::string& name)\n                : Scope(Declarable::kNamespace), name_(name) {}\n            const std::string& name() const { return name_; }\n            bool IsDefaultNamespace() const;\n            bool IsTestNamespace() const;\n\n            private:\n            std::string name_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CurrentNamespace\",\n            \"about\": \"Gets the current namespace.\",\n            \"logic\": \"Walks up the parent scopes until a Namespace is found.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Namespace*\",\n                \"description\": \"The current namespace.\"\n            },\n            \"dependencies\": [\n                \"Scope\",\n                \"Namespace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            inline Namespace* CurrentNamespace() {\n            Scope* scope = CurrentScope::Get();\n            while (true) {\n                if (Namespace* n = Namespace::DynamicCast(scope)) {\n                return n;\n                }\n                scope = scope->ParentScope();\n            }\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Value\",\n            \"extends\": \"Declarable\",\n            \"about\": \"Base class for constants in Torque.\",\n            \"attributes\": [\n                {\n                    \"name\": \"type_\",\n                    \"type\": \"const Type*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The type of the value.\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"Identifier*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The identifier of the value.\"\n                },\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"std::optional<VisitResult>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The value itself.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Declarable\",\n                \"Type\",\n                \"Identifier\",\n                \"VisitResult\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Value : public Declarable {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(Value, value)\n            const Identifier* name() const { return name_; }\n            virtual bool IsConst() const { return true; }\n            VisitResult value() const { return *value_; }\n            const Type* type() const { return type_; }\n\n            void set_value(VisitResult value) {\n                DCHECK(!value_);\n                value_ = value;\n            }\n\n            protected:\n            Value(Kind kind, const Type* type, Identifier* name)\n                : Declarable(kind), type_(type), name_(name) {}\n\n            private:\n            const Type* type_;\n            Identifier* name_;\n            std::optional<VisitResult> value_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NamespaceConstant\",\n            \"extends\": \"Value\",\n            \"about\": \"Represents a constant defined within a namespace.\",\n            \"attributes\": [\n                {\n                    \"name\": \"external_name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The external name of the constant.\"\n                },\n                {\n                    \"name\": \"body_\",\n                    \"type\": \"Expression*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The expression defining the constant's value.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Value\",\n                \"Identifier\",\n                \"Type\",\n                \"Expression\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class NamespaceConstant : public Value {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(NamespaceConstant, constant)\n\n            const std::string& external_name() const { return external_name_; }\n            Expression* body() const { return body_; }\n\n            private:\n            friend class Declarations;\n            explicit NamespaceConstant(Identifier* constant_name,\n                                        std::string external_name, const Type* type,\n                                        Expression* body)\n                : Value(Declarable::kNamespaceConstant, type, constant_name),\n                external_name_(std::move(external_name)),\n                body_(body) {}\n\n            std::string external_name_;\n            Expression* body_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExternConstant\",\n            \"extends\": \"Value\",\n            \"about\": \"Represents a constant defined externally.\",\n            \"dependencies\": [\n                \"Value\",\n                \"Identifier\",\n                \"Type\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ExternConstant : public Value {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(ExternConstant, constant)\n\n            private:\n            friend class Declarations;\n            explicit ExternConstant(Identifier* name, const Type* type, std::string value)\n                : Value(Declarable::kExternConstant, type, name) {\n                set_value(VisitResult(type, std::move(value)));\n            }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Callable\",\n            \"extends\": \"Scope\",\n            \"about\": \"Base class for callables (macros, builtins, runtime functions, intrinsics).\",\n            \"attributes\": [\n                {\n                    \"name\": \"external_name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The external name of the callable.\"\n                },\n                {\n                    \"name\": \"readable_name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The readable name of the callable.\"\n                },\n                {\n                    \"name\": \"signature_\",\n                    \"type\": \"Signature\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The signature of the callable.\"\n                },\n                {\n                    \"name\": \"returns_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of returns from this callable.\"\n                },\n                {\n                    \"name\": \"body_\",\n                    \"type\": \"std::optional<Statement*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The body of the callable (if it has one).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Scope\",\n                \"Signature\",\n                \"Statement\",\n                \"OutputType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Callable : public Scope {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(Callable, callable)\n            const std::string& ExternalName() const { return external_name_; }\n            const std::string& ReadableName() const { return readable_name_; }\n            const Signature& signature() const { return signature_; }\n            bool IsTransitioning() const { return signature().transitioning; }\n            const NameVector& parameter_names() const {\n                return signature_.parameter_names;\n            }\n            bool HasReturnValue() const {\n                return !signature_.return_type->IsVoidOrNever();\n            }\n            void IncrementReturns() { ++returns_; }\n            bool HasReturns() const { return returns_; }\n            std::optional<Statement*> body() const { return body_; }\n            bool IsExternal() const { return !body_.has_value(); }\n            virtual bool ShouldBeInlined(OutputType output_type) const {\n                // C++ output doesn't support exiting to labels, so functions with labels in\n                // the signature must be inlined.\n                return output_type == OutputType::kCC && !signature().labels.empty();\n            }\n            bool ShouldGenerateExternalCode(OutputType output_type) const {\n                return !ShouldBeInlined(output_type);\n            }\n\n            static std::string PrefixNameForCCOutput(const std::string& name) {\n                // If a Torque macro requires a C++ runtime function to be generated, then\n                // the generated function begins with this prefix to avoid any naming\n                // collisions with the generated CSA function for the same macro.\n                return \"TqRuntime\" + name;\n            }\n\n            static std::string PrefixNameForCCDebugOutput(const std::string& name) {\n                // If a Torque macro requires a C++ runtime function to be generated, then\n                // the generated function begins with this prefix to avoid any naming\n                // collisions with the generated CSA function for the same macro.\n                return \"TqDebug\" + name;\n            }\n\n            // Name to use in runtime C++ code.\n            virtual std::string CCName() const {\n                return PrefixNameForCCOutput(ExternalName());\n            }\n\n            // Name to use in debug C++ code.\n            virtual std::string CCDebugName() const {\n                return PrefixNameForCCDebugOutput(ExternalName());\n            }\n\n            protected:\n            Callable(Declarable::Kind kind, std::string external_name,\n                    std::string readable_name, Signature signature,\n                    std::optional<Statement*> body)\n                : Scope(kind),\n                external_name_(std::move(external_name)),\n\n                readable_name_(std::move(readable_name)),\n                signature_(std::move(signature)),\n                returns_(0),\n                body_(body) {\n                DCHECK(!body || *body);\n            }\n\n            private:\n            std::string external_name_;\n            std::string readable_name_;\n            Signature signature_;\n            size_t returns_;\n            std::optional<Statement*> body_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Macro\",\n            \"extends\": \"Callable\",\n            \"about\": \"Base class for Torque macros.\",\n            \"attributes\": [\n                {\n                    \"name\": \"used_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the macro is used.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Callable\",\n                \"Signature\",\n                \"Statement\",\n                \"OutputType\",\n                \"LabelDeclaration\",\n                \"Type\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Macro : public Callable {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(Macro, macro)\n            bool ShouldBeInlined(OutputType output_type) const override {\n                for (const LabelDeclaration& label : signature().labels) {\n                for (const Type* type : label.types) {\n                    if (type->StructSupertype()) return true;\n                }\n                }\n                // Intrinsics that are used internally in Torque and implemented as torque\n                // code should be inlined and not generate C++ definitions.\n                if (ReadableName()[0] == '%') return true;\n                return Callable::ShouldBeInlined(output_type);\n            }\n\n            void SetUsed() { used_ = true; }\n            bool IsUsed() const { return used_; }\n\n            protected:\n            Macro(Declarable::Kind kind, std::string external_name,\n                    std::string readable_name, const Signature& signature,\n                    std::optional<Statement*> body)\n                : Callable(kind, std::move(external_name), std::move(readable_name),\n                            signature, body),\n                used_(false) {\n                if (signature.parameter_types.var_args) {\n                ReportError(\"Varargs are not supported for macros.\");\n                }\n            }\n\n            private:\n            bool used_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExternMacro\",\n            \"extends\": \"Macro\",\n            \"about\": \"Represents an externally defined macro.\",\n            \"attributes\": [\n                {\n                    \"name\": \"external_assembler_name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The name of the external assembler function.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Macro\",\n                \"Signature\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ExternMacro : public Macro {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(ExternMacro, ExternMacro)\n\n            const std::string& external_assembler_name() const {\n                return external_assembler_name_;\n            }\n\n            std::string CCName() const override {\n                return \"TorqueRuntimeMacroShims::\" + external_assembler_name() +\n                    \"::\" + ExternalName();\n            }\n\n            std::string CCDebugName() const override {\n                return \"TorqueDebugMacroShims::\" + external_assembler_name() +\n                    \"::\" + ExternalName();\n            }\n\n            private:\n            friend class Declarations;\n            ExternMacro(const std::string& name, std::string external_assembler_name,\n                        Signature signature)\n                : Macro(Declarable::kExternMacro, name, name, std::move(signature),\n                        std::nullopt),\n                external_assembler_name_(std::move(external_assembler_name)) {}\n\n            std::string external_assembler_name_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TorqueMacro\",\n            \"extends\": \"Macro\",\n            \"about\": \"Represents a Torque-defined macro.\",\n            \"attributes\": [\n                {\n                    \"name\": \"exported_to_csa_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the macro is exported to CodeStubAssembler (CSA).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Macro\",\n                \"Signature\",\n                \"Statement\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class TorqueMacro : public Macro {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(TorqueMacro, TorqueMacro)\n            bool IsExportedToCSA() const { return exported_to_csa_; }\n            std::string CCName() const override {\n                // Exported functions must have unique and C++-friendly readable names, so\n                // prefer those wherever possible.\n                return PrefixNameForCCOutput(IsExportedToCSA() ? ReadableName()\n                                                                : ExternalName());\n            }\n            std::string CCDebugName() const override {\n                // Exported functions must have unique and C++-friendly readable names, so\n                // prefer those wherever possible.\n                return PrefixNameForCCDebugOutput(IsExportedToCSA() ? ReadableName()\n                                                                    : ExternalName());\n            }\n\n            protected:\n            TorqueMacro(Declarable::Kind kind, std::string external_name,\n                        std::string readable_name, const Signature& signature,\n                        std::optional<Statement*> body, bool is_user_defined,\n                        bool exported_to_csa)\n                : Macro(kind, std::move(external_name), std::move(readable_name),\n                        signature, body),\n                exported_to_csa_(exported_to_csa) {\n                SetIsUserDefined(is_user_defined);\n            }\n\n            private:\n            friend class Declarations;\n            TorqueMacro(std::string external_name, std::string readable_name,\n                        const Signature& signature, std::optional<Statement*> body,\n                        bool is_user_defined, bool exported_to_csa)\n                : TorqueMacro(Declarable::kTorqueMacro, std::move(external_name),\n                                std::move(readable_name), signature, body, is_user_defined,\n                                exported_to_csa) {}\n\n            bool exported_to_csa_ = false;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Method\",\n            \"extends\": \"TorqueMacro\",\n            \"about\": \"Represents a method in Torque.\",\n            \"attributes\": [\n                {\n                    \"name\": \"aggregate_type_\",\n                    \"type\": \"AggregateType*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The aggregate type the method belongs to.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TorqueMacro\",\n                \"Signature\",\n                \"Statement\",\n                \"AggregateType\",\n                \"OutputType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Method : public TorqueMacro {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(Method, Method)\n            bool ShouldBeInlined(OutputType output_type) const override {\n                return Macro::ShouldBeInlined(output_type) ||\n                    signature()\n                        .parameter_types.types[signature().implicit_count]\n                        ->IsStructType();\n            }\n            AggregateType* aggregate_type() const { return aggregate_type_; }\n\n            private:\n            friend class Declarations;\n            Method(AggregateType* aggregate_type, std::string external_name,\n                    std::string readable_name, const Signature& signature, Statement* body)\n                : TorqueMacro(Declarable::kMethod, std::move(external_name),\n                            std::move(readable_name), signature, body, true, false),\n                aggregate_type_(aggregate_type) {}\n            AggregateType* aggregate_type_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Builtin\",\n            \"extends\": \"Callable\",\n            \"about\": \"Represents a builtin function in Torque.\",\n            \"attributes\": [\n                {\n                    \"name\": \"kind_\",\n                    \"type\": \"Kind\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The kind of builtin.\"\n                },\n                {\n                    \"name\": \"flags_\",\n                    \"type\": \"Flags\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flags for the builtin.\"\n                },\n                {\n                    \"name\": \"use_counter_name_\",\n                    \"type\": \"std::optional<std::string>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The name of the use counter for the builtin.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Callable\",\n                \"Signature\",\n                \"Statement\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Builtin : public Callable {\n            public:\n            enum Kind { kStub, kFixedArgsJavaScript, kVarArgsJavaScript };\n            enum class Flag { kNone = 0, kCustomInterfaceDescriptor = 1 << 0 };\n            using Flags = base::Flags<Flag>;\n            DECLARE_DECLARABLE_BOILERPLATE(Builtin, builtin)\n            Kind kind() const { return kind_; }\n            Flags flags() const { return flags_; }\n            std::optional<std::string> use_counter_name() const {\n                return use_counter_name_;\n            }\n            bool IsStub() const { return kind_ == kStub; }\n            bool IsVarArgsJavaScript() const { return kind_ == kVarArgsJavaScript; }\n            bool IsFixedArgsJavaScript() const { return kind_ == kFixedArgsJavaScript; }\n            bool IsJavaScript() const {\n                return IsVarArgsJavaScript() || IsFixedArgsJavaScript();\n            }\n            bool HasCustomInterfaceDescriptor() const {\n                return flags_ & Flag::kCustomInterfaceDescriptor;\n            }\n\n            private:\n            friend class Declarations;\n            Builtin(std::string external_name, std::string readable_name,\n                    Builtin::Kind kind, Flags flags, const Signature& signature,\n                    std::optional<std::string> use_counter_name,\n                    std::optional<Statement*> body)\n                : Callable(Declarable::kBuiltin, std::move(external_name),\n                            std::move(readable_name), signature, body),\n                kind_(kind),\n                flags_(flags),\n                use_counter_name_(use_counter_name) {}\n\n            Kind kind_;\n            Flags flags_;\n            std::optional<std::string> use_counter_name_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RuntimeFunction\",\n            \"extends\": \"Callable\",\n            \"about\": \"Represents a runtime function in Torque.\",\n            \"dependencies\": [\n                \"Callable\",\n                \"Signature\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class RuntimeFunction : public Callable {\n            public:\n            DECLARE_DECLARABLE_BOILERPLATE(RuntimeFunction, runtime)\n\n            private:\n            friend class Declarations;\n            RuntimeFunction(const std::string& name, const Signature& signature)\n                : Callable(Declarable::kRuntimeFunction, name, name, signature,"
}