{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/s390/simulator-s390.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/s390/simulator-s390.h\",\n        \"file_name\": \"simulator-s390.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the S390 simulator used for running and debugging S390 code generation on non-S390 platforms.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for globals definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n    \n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers when the simulator is enabled (USE_SIMULATOR is defined).\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/hashmap.h\"\n            #include \"src/codegen/assembler.h\"\n            #include \"src/codegen/s390/constants-s390.h\"\n            #include \"src/execution/simulator-base.h\"\n            #include \"src/utils/allocation.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CachePage\",\n            \"about\": \"Represents a page in the instruction cache.\",\n            \"attributes\": [\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"char[kPageSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the cached data for the page.\"\n                },\n                {\n                    \"name\": \"validity_map_\",\n                    \"type\": \"char[kValidityMapSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the validity of each cache line in the page.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class CachePage {\n            public:\n            static const int LINE_VALID = 0;\n            static const int LINE_INVALID = 1;\n\n            static const int kPageShift = 12;\n            static const int kPageSize = 1 << kPageShift;\n            static const int kPageMask = kPageSize - 1;\n            static const int kLineShift = 2;  // The cache line is only 4 bytes right now.\n            static const int kLineLength = 1 << kLineShift;\n            static const int kLineMask = kLineLength - 1;\n\n            CachePage() { memset(&validity_map_, LINE_INVALID, sizeof(validity_map_)); }\n\n            char* ValidityByte(int offset) {\n                return &validity_map_[offset >> kLineShift];\n            }\n\n            char* CachedData(int offset) { return &data_[offset]; }\n\n            private:\n            char data_[kPageSize];  // The cached data.\n            static const int kValidityMapSize = kPageSize >> kLineShift;\n            char validity_map_[kValidityMapSize];  // One byte per line.\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ComputeRounding\",\n            \"about\": \"Computes the rounding of a floating-point value based on the specified rounding mode.\",\n            \"logic\": \"Uses `std::round`, `std::nearbyint`, `std::trunc`, `std::ceil`, and `std::floor` based on the rounding `mode`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The floating-point value to round.\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"The rounded floating-point value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            static T ComputeRounding(T a, int mode) {\n            switch (mode) {\n                case ROUND_TO_NEAREST_AWAY_FROM_0:\n                return std::round(a);\n                case ROUND_TO_NEAREST_TO_EVEN:\n                return std::nearbyint(a);\n                case ROUND_TOWARD_0:\n                return std::trunc(a);\n                case ROUND_TOWARD_POS_INF:\n                return std::ceil(a);\n                case ROUND_TOWARD_NEG_INF:\n                return std::floor(a);\n                default:\n                UNIMPLEMENTED();\n            }\n            return 0;\n            }\n        ]]></code>\n    </func>\n    \n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Simulator\",\n            \"extends\": \"SimulatorBase\",\n            \"about\": \"Simulates S390 instructions on other architectures.\",\n            \"attributes\": [\n                {\n                    \"name\": \"registers_\",\n                    \"type\": \"uint64_t[kNumGPRs]\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Stores the general-purpose registers.\"\n                },\n                {\n                    \"name\": \"fp_registers_\",\n                    \"type\": \"fpr_t[kNumFPRs]\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Stores the floating-point registers.\"\n                },\n                {\n                    \"name\": \"condition_reg_\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Stores the condition code register.\"\n                },\n                {\n                    \"name\": \"special_reg_pc_\",\n                    \"type\": \"intptr_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Stores the program counter.\"\n                },\n                {\n                    \"name\": \"stack_\",\n                    \"type\": \"uint8_t*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Points to the simulator stack.\"\n                },\n                {\n                    \"name\": \"pc_modified_\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates whether the PC has been modified.\"\n                },\n                {\n                    \"name\": \"icount_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Instruction counter.\"\n                },\n                {\n                    \"name\": \"last_debugger_input_\",\n                    \"type\": \"char*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Stores the last debugger input.\"\n                },\n                {\n                    \"name\": \"break_pc_\",\n                    \"type\": \"Instruction*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Breakpoint PC.\"\n                },\n                {\n                    \"name\": \"break_instr_\",\n                    \"type\": \"Instr\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Breakpoint instruction.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"v8::internal::Isolate*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Isolate pointer.\"\n                },\n                {\n                    \"name\": \"watched_stops_\",\n                    \"type\": \"StopCountAndDesc[kNumOfWatchedStops]\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Array of watched stops and associated counts and descriptions.\"\n                },\n                {\n                    \"name\": \"instruction_tracing_\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Flag to control instruction tracing. Initialized from v8_flags.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SimulatorBase\",\n                \"Isolate\",\n                \"base::CustomMatcherHashMap\",\n                \"Instruction\",\n                \"base::Vector\",\n                \"heap::base::StackVisitor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Simulator : public SimulatorBase {\n            public:\n            friend class S390Debugger;\n            enum Register {\n                no_reg = -1,\n                r0 = 0,\n                r1 = 1,\n                r2 = 2,\n                r3 = 3,\n                r4 = 4,\n                r5 = 5,\n                r6 = 6,\n                r7 = 7,\n                r8 = 8,\n                r9 = 9,\n                r10 = 10,\n                r11 = 11,\n                r12 = 12,\n                r13 = 13,\n                r14 = 14,\n                r15 = 15,\n                fp = r11,\n                ip = r12,\n                cp = r13,\n                ra = r14,\n                sp = r15,  // name aliases\n                kNumGPRs = 16,\n                d0 = 0,\n                d1,\n                d2,\n                d3,\n                d4,\n                d5,\n                d6,\n                d7,\n                d8,\n                d9,\n                d10,\n                d11,\n                d12,\n                d13,\n                d14,\n                d15,\n                kNumFPRs = 16\n            };\n\n            explicit Simulator(Isolate* isolate);\n            ~Simulator();\n\n            // The currently executing Simulator instance. Potentially there can be one\n            // for each native thread.\n            static Simulator* current(v8::internal::Isolate* isolate);\n\n            // Accessors for register state.\n            void set_register(int reg, uint64_t value);\n            const uint64_t& get_register(int reg) const;\n            uint64_t& get_register(int reg);\n            template <typename T>\n            T get_low_register(int reg) const;\n            template <typename T>\n            T get_high_register(int reg) const;\n            void set_low_register(int reg, uint32_t value);\n            void set_high_register(int reg, uint32_t value);\n\n            double get_double_from_register_pair(int reg);\n\n            // Unlike Integer values, Floating Point values are located on the left most\n            // side of a native 64 bit register. As FP registers are a subset of vector\n            // registers, 64 and 32 bit FP values need to be located on first lane (lane\n            // number 0) of a vector register.\n            template <class T>\n            T get_fpr(int dreg) {\n                DCHECK(dreg >= 0 && dreg < kNumFPRs);\n                return get_simd_register_by_lane<T>(dreg, 0);\n            }\n\n            template <class T>\n            void set_fpr(int dreg, const T val) {\n                DCHECK(dreg >= 0 && dreg < kNumFPRs);\n                set_simd_register_by_lane<T>(dreg, 0, val);\n            }\n\n            // Special case of set_register and get_register to access the raw PC value.\n            void set_pc(intptr_t value);\n            intptr_t get_pc() const;\n\n            Address get_sp() const { return static_cast<Address>(get_register(sp)); }\n\n            // Accessor to the internal simulator stack area. Adds a safety\n            // margin to prevent overflows.\n            uintptr_t StackLimit(uintptr_t c_limit) const;\n\n            uintptr_t StackBase() const;\n\n            // Return central stack view, without additional safety margins.\n            // Users, for example wasm::StackMemory, can add their own.\n            base::Vector<uint8_t> GetCentralStackView() const;\n\n            void IterateRegistersAndStack(::heap::base::StackVisitor* visitor);\n\n            // Executes S390 instructions until the PC reaches end_sim_pc.\n            void Execute();\n\n            template <typename Return, typename... Args>\n            Return Call(Address entry, Args... args) {\n                return VariadicCall<Return>(this, &Simulator::CallImpl, entry, args...);\n            }\n\n            // Alternative: call a 2-argument double function.\n            void CallFP(Address entry, double d0, double d1);\n            int32_t CallFPReturnsInt(Address entry, double d0, double d1);\n            double CallFPReturnsDouble(Address entry, double d0, double d1);\n\n            // Push an address onto the JS stack.\n            V8_EXPORT_PRIVATE uintptr_t PushAddress(uintptr_t address);\n\n            // Pop an address from the JS stack.\n            V8_EXPORT_PRIVATE uintptr_t PopAddress();\n\n            // Debugger input.\n            void set_last_debugger_input(char* input);\n            char* last_debugger_input() { return last_debugger_input_; }\n\n            // Redirection support.\n            static void SetRedirectInstruction(Instruction* instruction);\n\n            // ICache checking.\n            static bool ICacheMatch(void* one, void* two);\n            static void FlushICache(base::CustomMatcherHashMap* i_cache, void* start,\n                                    size_t size);\n\n            // Returns true if pc register contains one of the 'special_values' defined\n            // below (bad_lr, end_sim_pc).\n            bool has_bad_pc() const;\n\n            // Manage instruction tracing.\n            bool InstructionTracingEnabled();\n\n            void ToggleInstructionTracing();\n\n            enum special_values {\n                // Known bad pc value to ensure that the simulator does not execute\n                // without being properly setup.\n                bad_lr = -1,\n                // A pc value used to signal the simulator to stop execution.  Generally\n                // the lr is set to this value on transition from native C code to\n                // simulated execution, so that the simulator can \"return\" to the native\n                // C code.\n                end_sim_pc = -2\n            };\n\n            intptr_t CallImpl(Address entry, int argument_count,\n                                const intptr_t* arguments);\n\n            // Unsupported instructions use Format to print an error and stop execution.\n            void Format(Instruction* instr, const char* format);\n\n            // Helper functions to set the conditional flags in the architecture state.\n            bool CarryFrom(int32_t left, int32_t right, int32_t carry = 0);\n            bool BorrowFrom(int32_t left, int32_t right);\n            template <typename T1>\n            inline bool OverflowFromSigned(T1 alu_out, T1 left, T1 right, bool addition);\n\n            // Helper functions to decode common \"addressing\" modes\n            int32_t GetShiftRm(Instruction* instr, bool* carry_out);\n            int32_t GetImm(Instruction* instr, bool* carry_out);\n            void ProcessPUW(Instruction* instr, int num_regs, int operand_size,\n                            intptr_t* start_address, intptr_t* end_address);\n            void HandleRList(Instruction* instr, bool load);\n            void HandleVList(Instruction* inst);\n            void SoftwareInterrupt(Instruction* instr);\n            void DebugAtNextPC();\n\n            // Take a copy of v8 simulator tracing flag because flags are frozen after\n            // start.\n            bool instruction_tracing_ = v8_flags.trace_sim;\n\n            // Stop helper functions.\n            inline bool isStopInstruction(Instruction* instr);\n            inline bool isWatchedStop(uint32_t bkpt_code);\n            inline bool isEnabledStop(uint32_t bkpt_code);\n            inline void EnableStop(uint32_t bkpt_code);\n            inline void DisableStop(uint32_t bkpt_code);\n            inline void IncreaseStopCounter(uint32_t bkpt_code);\n            void PrintStopInfo(uint32_t code);\n\n            // Read and write memory.\n            inline uint8_t ReadBU(intptr_t addr);\n            inline int8_t ReadB(intptr_t addr);\n            inline void WriteB(intptr_t addr, uint8_t value);\n            inline void WriteB(intptr_t addr, int8_t value);\n\n            inline uint16_t ReadHU(intptr_t addr);\n            inline int16_t ReadH(intptr_t addr);\n            // Note: Overloaded on the sign of the value.\n            inline void WriteH(intptr_t addr, uint16_t value);\n            inline void WriteH(intptr_t addr, int16_t value);\n\n            inline uint32_t ReadWU(intptr_t addr);\n            inline int32_t ReadW(intptr_t addr);\n            inline int64_t ReadW64(intptr_t addr);\n            inline void WriteW(intptr_t addr, uint32_t value);\n            inline void WriteW(intptr_t addr, int32_t value);\n\n            inline int64_t ReadDW(intptr_t addr);\n            inline double ReadDouble(intptr_t addr);\n            inline float ReadFloat(intptr_t addr);\n            inline void WriteDW(intptr_t addr, int64_t value);\n\n            // S390\n            void Trace(Instruction* instr);\n\n            template <typename T>\n            void SetS390ConditionCode(T lhs, T rhs) {\n                condition_reg_ = 0;\n                if (lhs == rhs) {\n                condition_reg_ |= CC_EQ;\n                } else if (lhs < rhs) {\n                condition_reg_ |= CC_LT;\n                } else if (lhs > rhs) {\n                condition_reg_ |= CC_GT;\n                }\n\n                // We get down here only for floating point\n                // comparisons and the values are unordered\n                // i.e. NaN\n                if (condition_reg_ == 0) condition_reg_ = unordered;\n            }\n\n            // Used by arithmetic operations that use carry.\n            template <typename T>\n            void SetS390ConditionCodeCarry(T result, bool overflow) {\n                condition_reg_ = 0;\n                bool zero_result = (result == static_cast<T>(0));\n                if (zero_result && !overflow) {\n                condition_reg_ |= 8;\n                } else if (!zero_result && !overflow) {\n                condition_reg_ |= 4;\n                } else if (zero_result && overflow) {\n                condition_reg_ |= 2;\n                } else if (!zero_result && overflow) {\n                condition_reg_ |= 1;\n                }\n                if (condition_reg_ == 0) UNREACHABLE();\n            }\n\n            bool isNaN(double value) { return (value != value); }\n\n            // Set the condition code for bitwise operations\n            // CC0 is set if value == 0.\n            // CC1 is set if value != 0.\n            // CC2/CC3 are not set.\n            template <typename T>\n            void SetS390BitWiseConditionCode(T value) {\n                condition_reg_ = 0;\n\n                if (value == 0)\n                condition_reg_ |= CC_EQ;\n                else\n                condition_reg_ |= CC_LT;\n            }\n\n            void SetS390OverflowCode(bool isOF) {\n                if (isOF) condition_reg_ = CC_OF;\n            }\n\n            bool TestConditionCode(Condition mask) {\n                // Check for unconditional branch\n                if (mask == 0xf) return true;\n\n                return (condition_reg_ & mask) != 0;\n            }\n\n            // Executes one instruction.\n            void ExecuteInstruction(Instruction* instr, bool auto_incr_pc = true);\n\n            // ICache.\n            static void CheckICache(base::CustomMatcherHashMap* i_cache,\n                                    Instruction* instr);\n            static void FlushOnePage(base::CustomMatcherHashMap* i_cache, intptr_t start,\n                                    int size);\n            static CachePage* GetCachePage(base::CustomMatcherHashMap* i_cache,\n                                            void* page);\n\n            // Handle arguments and return value for runtime FP functions.\n            void GetFpArgs(double* x, double* y, intptr_t* z);\n            void SetFpResult(const double& result);\n            void TrashCallerSaveRegisters();\n\n            void CallInternal(Address entry, int reg_arg_count = 3);\n\n            // Architecture state.\n            // On z9 and higher and supported Linux on z Systems platforms, all registers\n            // are 64-bit, even in 31-bit mode.\n            uint64_t registers_[kNumGPRs];\n            union fpr_t {\n                int8_t int8[16];\n                uint8_t uint8[16];\n                int16_t int16[8];\n                uint16_t uint16[8];\n                int32_t int32[4];\n                uint32_t uint32[4];\n                int64_t int64[2];\n                uint64_t uint64[2];\n                float f32[4];\n                double f64[2];\n            };\n            fpr_t fp_registers_[kNumFPRs];\n\n            static constexpr fpr_t fp_zero = {{0}};\n\n            fpr_t get_simd_register(int reg) { return fp_registers_[reg]; }\n\n            void set_simd_register(int reg, const fpr_t& value) {\n                fp_registers_[reg] = value;\n            }\n\n            // Vector register lane numbers on IBM machines are reversed compared to\n            // x64. For example, doing an I32x4 extract_lane with lane number 0 on x64\n            // will be equal to lane number 3 on IBM machines. Vector registers are only\n            // used for compiling Wasm code at the moment. Wasm is also little endian\n            // enforced. On s390 native, we manually do a reverse byte whenever values are\n            // loaded/stored from memory to a Simd register. On the simulator however, we\n            // do not reverse the bytes and data is just copied as is from one memory\n            // location to another location which represents a register. To keep the Wasm\n            // simulation accurate, we need to make sure accessing a lane is correctly\n            // simulated and as such we reverse the lane number on the getters and setters\n            // below. We need to be careful when getting/setting values on the Low or High\n            // side of a simulated register. In the simulation, \"Low\" is equal to the MSB\n            // and \"High\" is equal to the LSB on memory. \"force_ibm_lane_numbering\" could\n            // be used to disabled automatic lane number reversal and help with accessing\n            // the Low or High side of a simulated register.\n            template <class T>\n            T get_simd_register_by_lane(int reg, int lane,\n                                        bool force_ibm_lane_numbering = true) {\n                if (force_ibm_lane_numbering) {\n                lane = (kSimd128Size / sizeof(T)) - 1 - lane;\n                }\n                CHECK_LE(lane, kSimd128Size / sizeof(T));\n                CHECK_LT(reg, kNumFPRs);\n                CHECK_GE(lane, 0);\n                CHECK_GE(reg, 0);\n                return (reinterpret_cast<T*>(&fp_registers_[reg]))[lane];\n            }\n\n            template <class T>\n            void set_simd_register_by_lane(int reg, int lane, const T& value,\n                                            bool force_ibm_lane_numbering = true) {\n                if (force_ibm_lane_numbering) {\n                lane = (kSimd128Size / sizeof(T)) - 1 - lane;\n                }\n                CHECK_LE(lane, kSimd128Size / sizeof(T));\n                CHECK_LT(reg, kNumFPRs);\n                CHECK_GE(lane, 0);\n                CHECK_GE(reg, 0);\n                (reinterpret_cast<T*>(&fp_registers_[reg]))[lane] = value;\n            }\n\n            // Condition Code register. In S390, the last 4 bits are used.\n            int32_t condition_reg_;\n            // Special register to track PC.\n            intptr_t special_reg_pc_;\n\n            // Simulator support for the stack.\n            uint8_t* stack_;\n            static const size_t kStackProtectionSize = 256 * kSystemPointerSize;\n            // This includes a protection margin at each end of the stack area.\n            static size_t AllocatedStackSize() {\n                size_t stack_size = v8_flags.sim_stack_size * KB;\n                return stack_size + (2 * kStackProtectionSize);\n            }\n            static size_t UsableStackSize() {\n                return AllocatedStackSize() - kStackProtectionSize;\n            }\n            bool pc_modified_;\n            int64_t icount_;\n\n            // Debugger input.\n            char* last_debugger_input_;\n\n            // Registered breakpoints.\n            Instruction* break_pc_;\n            Instr break_instr_;\n\n            v8::internal::Isolate* isolate_;\n\n            // A stop is watched if its code is less than kNumOfWatchedStops.\n            // Only watched stops support enabling/disabling and the counter feature.\n            static const uint32_t kNumOfWatchedStops = 256;\n\n            // Breakpoint is disabled if bit 31 is set.\n            static const uint32_t kStopDisabledBit = 1 << 31;\n\n            // A stop is enabled, meaning the simulator will stop when meeting the\n            // instruction, if bit 31 of watched_stops_[code].count is unset.\n            // The value watched_stops_[code].count & ~(1 << 31) indicates how many times\n            // the breakpoint was hit or gone through.\n            struct StopCountAndDesc {\n                uint32_t count;\n                char* desc;\n            };\n            StopCountAndDesc watched_stops_[kNumOfWatchedStops];\n            void DebugStart();\n\n            int DecodeInstructionOriginal(Instruction* instr);\n            int DecodeInstruction(Instruction* instr);\n            int Evaluate_Unknown(Instruction* instr);\n            #define MAX_NUM_OPCODES (1 << 16)\n            using EvaluateFuncType = int (Simulator::*)(Instruction*);\n\n            static EvaluateFuncType EvalTable[MAX_NUM_OPCODES];\n            static void EvalTableInit();\n\n            #define EVALUATE(name) int Evaluate_##name(Instruction* instr)\n            #define EVALUATE_VR_INSTRUCTIONS(name, op_name, op_value) EVALUATE(op_name);\n            S390_VRR_A_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRR_C_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRR_E_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRR_F_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRX_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRS_A_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRS_B_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRS_C_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRR_B_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRI_A_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            S390_VRI_C_OPCODE_LIST(EVALUATE_VR_INSTRUCTIONS)\n            #undef EVALUATE_VR_INSTRUCTIONS\n\n            EVALUATE(DUMY);\n            EVALUATE(BKPT);\n            EVALUATE(SPM);\n            EVALUATE(BALR);\n            EVALUATE(BCTR);\n            EVALUATE(BCR);\n            EVALUATE(SVC);\n            EVALUATE(BSM);\n            EVALUATE(BASSM);\n            EVALUATE(BASR);\n            EVALUATE(MVCL);\n            EVALUATE(CLCL);\n            EVALUATE(LPR);\n            EVALUATE(LNR);\n            EVALUATE(LTR);\n            EVALUATE(LCR);\n            EVALUATE(NR);\n            EVALUATE(CLR);\n            EVALUATE(OR);\n            EVALUATE(XR);\n            EVALUATE(LR);\n            EVALUATE(CR);\n            EVALUATE(AR);\n            EVALUATE(SR);\n            EVALUATE(MR);\n            EVALUATE(DR);\n            EVALUATE(ALR);\n            EVALUATE(SLR);\n            EVALUATE(LDR);\n            EVALUATE(CDR);\n            EVALUATE(LER);\n            EVALUATE(STH);\n            EVALUATE(LA);\n            EVALUATE(STC);\n            EVALUATE(IC_z);\n            EVALUATE(EX);\n            EVALUATE(BAL);\n            EVALUATE(BCT);\n            EVALUATE(BC);\n            EVALUATE(LH);\n            EVALUATE(CH);\n            EVALUATE(AH);\n            EVALUATE(SH);\n            EVALUATE(MH);\n            EVALUATE(BAS);\n            EVALUATE(CVD);\n            EVALUATE(CVB);\n            EVALUATE(ST);\n            EVALUATE(LAE);\n            EVALUATE(N);\n            EVALUATE(CL);\n            EVALUATE(O);\n            EVALUATE(X);\n            EVALUATE(L);\n            EVALUATE(C);\n            EVALUATE(A);\n            EVALUATE(S);\n            EVALUATE(M);\n            EVALUATE(D);\n            EVALUATE(AL);\n            EVALUATE(SL);\n            EVALUATE(STD);\n            EVALUATE(LD);\n            EVALUATE(CD);\n            EVALUATE(STE);\n            EVALUATE(MS);\n            EVALUATE(LE);\n            EVALUATE(BRXH);\n            EVALUATE(BRXLE);\n            EVALUATE(BXH);\n            EVALUATE(BXLE);\n            EVALUATE(SRL);\n            EVALUATE(SLL);\n            EVALUATE(SRA);\n            EVALUATE(SLA);\n            EVALUATE(SRDL);\n            EVALUATE(SLDL);\n            EVALUATE(SRDA);\n            EVALUATE(SLDA);\n            EVALUATE(STM);\n            EVALUATE(TM);\n            EVALUATE(MVI);\n            EVALUATE(TS);\n            EVALUATE(NI);\n            EVALUATE(CLI);\n            EVALUATE(OI);\n            EVALUATE(XI);\n            EVALUATE(LM);\n            EVALUATE(CS);\n            EVALUATE(MVCLE);\n            EVALUATE(CLCLE);\n            EVALUATE(MC);\n            EVALUATE(CDS);\n            EVALUATE(STCM);\n            EVALUATE(ICM);\n            EVALUATE(BPRP);\n            EVALUATE(BPP);\n            EVALUATE(TRTR);\n            EVALUATE(MVN);\n            EVALUATE(MVC);\n            EVALUATE(MVZ);\n            EVALUATE(NC);\n            EVALUATE(CLC);\n            EVALUATE(OC);\n            EVALUATE(XC);\n            EVALUATE(MVCP);\n            EVALUATE(TR);\n            EVALUATE(TRT);\n            EVALUATE(ED);\n            EVALUATE(EDMK);\n            EVALUATE(PKU);\n            EVALUATE(UNPKU);\n            EVALUATE(MVCIN);\n            EVALUATE(PKA);\n            EVALUATE(UNPKA);\n            EVALUATE(PLO);\n            EVALUATE(LMD);\n            EVALUATE(SRP);\n            EVALUATE(MVO);\n            EVALUATE(PACK);\n            EVALUATE(UNPK);\n            EVALUATE(ZAP);\n            EVALUATE(AP);\n            EVALUATE(SP);\n            EVALUATE(MP);\n            EVALUATE(DP);\n            EVALUATE(UPT);\n            EVALUATE(PFPO);\n            EVALUATE(IIHH);\n            EVALUATE(IIHL);\n            EVALUATE(IILH);\n            EVALUATE(IILL);\n            EVALUATE(NIHH);\n            EVALUATE(NIHL);\n            EVALUATE(NILH);\n            EVALUATE(NILL);\n            EVALUATE(OIHH);\n            EVALUATE(OIHL);\n            EVALUATE(OILH);\n            EVALUATE(OILL);\n            EVALUATE(LLIHH);\n            EVALUATE(LLIHL);\n            EVALUATE(LLILH);\n            EVALUATE(LLILL);\n            EVALUATE(TMLH);\n            EVALUATE(TMLL);\n            EVALUATE(TMHH);\n            EVALUATE(TMHL);\n            EVALUATE(BRC);"
}