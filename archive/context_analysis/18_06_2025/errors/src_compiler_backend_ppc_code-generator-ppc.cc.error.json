{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ppc/code-generator-ppc.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ppc/code-generator-ppc.cc\",\n        \"file_name\": \"code-generator-ppc.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"This file implements the PPC-specific code generator for the V8 compiler backend.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for base utilities, code generation, compilation information, and other compiler components.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/numbers/double.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/callable.h\"\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/backend/code-generator-impl.h\"\n#include \"src/compiler/backend/code-generator.h\"\n#include \"src/compiler/backend/gap-resolver.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/osr.h\"\n#include \"src/heap/mutable-page-metadata.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-objects.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CodeGenerator\",\n                \"about\": \"Abstract class for code generation\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class CodeGenerator {\n            public:\n                virtual void AssembleArchJump(RpoNumber target) = 0;\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Instruction\",\n                \"about\": \"Represents a single instruction in the compiler's instruction stream.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Instruction {\n            public:\n                size_t InputCount() const;\n                InstructionOperand* InputAt(size_t index) const;\n                int InputInt32(size_t index) const;\n                RpoNumber InputRpo(size_t index) const;\n                size_t OutputCount() const;\n                InstructionOperand* OutputAt(size_t index) const;\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"InstructionOperand\",\n                \"about\": \"Abstract class that represents an operand of an instruction.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class InstructionOperand {\n            public:\n                bool IsRegister() const;\n                bool IsImmediate() const;\n            };\n            ]]></code>\n        </class>\n    </dependencies>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PPCOperandConverter::OutputRCBit\",\n            \"parent\": \"PPCOperandConverter\",\n            \"about\": \"Determines the RC (Record Condition) bit setting based on the instruction's flags mode.\",\n            \"logic\": \"A switch statement checks the instruction's flag mode and returns the corresponding RC bit setting (SetRC or LeaveRC).\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"RCBit\",\n                \"description\": \"The RC bit setting (SetRC or LeaveRC) based on the instruction's flags mode.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  RCBit OutputRCBit() const {\n    switch (instr_->flags_mode()) {\n      case kFlags_branch:\n      case kFlags_conditional_branch:\n      case kFlags_deoptimize:\n      case kFlags_set:\n      case kFlags_conditional_set:\n      case kFlags_trap:\n      case kFlags_select:\n        return SetRC;\n      case kFlags_none:\n        return LeaveRC;\n    }\n    UNREACHABLE();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PPCOperandConverter::CompareLogical\",\n            \"parent\": \"PPCOperandConverter\",\n            \"about\": \"Determines if a comparison is logical (unsigned) based on the instruction's flags condition.\",\n            \"logic\": \"A switch statement checks the instruction's flag condition and returns true if it's an unsigned comparison (kUnsignedLessThan, kUnsignedGreaterThanOrEqual, etc.), otherwise returns false.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the comparison is logical (unsigned), false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  bool CompareLogical() const {\n    switch (instr_->flags_condition()) {\n      case kUnsignedLessThan:\n      case kUnsignedGreaterThanOrEqual:\n      case kUnsignedLessThanOrEqual:\n      case kUnsignedGreaterThan:\n        return true;\n      default:\n        return false;\n    }\n    UNREACHABLE();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PPCOperandConverter::InputImmediate\",\n            \"parent\": \"PPCOperandConverter\",\n            \"about\": \"Converts an instruction input at a given index to an immediate operand.\",\n            \"logic\": \"It retrieves the input as a Constant and then switches on the constant's type to construct an Operand. Handles different constant types such as Int32, Float32, Float64, Int64, ExternalReference, CompressedHeapObject and HeapObject.  For CompressedHeapObject it tries to resolve it as a root handle. If not a root handle it treats it as a HeapObject. Other cases are unreachable.  Compressed pointers require special handling.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the input in the instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Operand\",\n                \"description\": \"The immediate operand constructed from the constant.\"\n            },\n            \"dependencies\": [\n                \"Constant\",\n                \"Operand\",\n                \"RootIndex\",\n                \"MacroAssemblerBase::ReadOnlyRootPtr\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Operand InputImmediate(size_t index) {\n    Constant constant = ToConstant(instr_->InputAt(index));\n    switch (constant.type()) {\n      case Constant::kInt32:\n        return Operand(constant.ToInt32());\n      case Constant::kFloat32:\n        return Operand::EmbeddedNumber(constant.ToFloat32());\n      case Constant::kFloat64:\n        return Operand::EmbeddedNumber(constant.ToFloat64().value());\n      case Constant::kInt64:\n        return Operand(constant.ToInt64());\n      case Constant::kExternalReference:\n        return Operand(constant.ToExternalReference());\n      case Constant::kCompressedHeapObject: {\n        RootIndex root_index;\n        if (gen_->isolate()->roots_table().IsRootHandle(constant.ToHeapObject(),\n                                                        &root_index)) {\n          CHECK(COMPRESS_POINTERS_BOOL);\n          CHECK(V8_STATIC_ROOTS_BOOL || !gen_->isolate()->bootstrapper());\n          Tagged_t ptr =\n              MacroAssemblerBase::ReadOnlyRootPtr(root_index, gen_->isolate());\n          return Operand(ptr);\n        }\n        return Operand(constant.ToHeapObject());\n      }\n      case Constant::kHeapObject:\n      case Constant::kRpoNumber:\n        break;\n    }\n    UNREACHABLE();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PPCOperandConverter::MemoryOperand\",\n            \"parent\": \"PPCOperandConverter\",\n            \"about\": \"Constructs a MemOperand based on the instruction's addressing mode.\",\n            \"logic\": \"The function decodes addressing mode from the instruction.  Based on the mode it returns a MemOperand with the right base register and offset. Addressing modes supported are None, MRI (Memory Register Immediate), MRR (Memory Register Register), and Root. kMode_Root uses kRootRegister. Others are unreachable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"AddressingMode*\",\n                    \"purpose\": \"Pointer to store the addressing mode (optional).\"\n                },\n                {\n                    \"name\": \"first_index\",\n                    \"type\": \"size_t*\",\n                    \"purpose\": \"Pointer to the starting index for input operands.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The constructed MemOperand.\"\n            },\n            \"dependencies\": [\n                \"AddressingMode\",\n                \"MemOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  MemOperand MemoryOperand(AddressingMode* mode, size_t* first_index) {\n    const size_t index = *first_index;\n    AddressingMode addr_mode = AddressingModeField::decode(instr_->opcode());\n    if (mode) *mode = addr_mode;\n    switch (addr_mode) {\n      case kMode_None:\n        break;\n      case kMode_MRI:\n        *first_index += 2;\n        return MemOperand(InputRegister(index + 0), InputInt64(index + 1));\n      case kMode_MRR:\n        *first_index += 2;\n        return MemOperand(InputRegister(index + 0), InputRegister(index + 1));\n      case kMode_Root:\n        *first_index += 1;\n        return MemOperand(kRootRegister, InputRegister(index));\n    }\n    UNREACHABLE();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PPCOperandConverter::ToMemOperand\",\n            \"parent\": \"PPCOperandConverter\",\n            \"about\": \"Converts an InstructionOperand representing a stack slot to a MemOperand.\",\n            \"logic\": \"It checks if the operand is a stack slot or FP stack slot and then uses SlotToMemOperand to create the MemOperand.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"The instruction operand to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The MemOperand representing the stack slot.\"\n            },\n            \"dependencies\": [\n                \"MemOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  MemOperand ToMemOperand(InstructionOperand* op) const {\n    DCHECK_NOT_NULL(op);\n    DCHECK(op->IsStackSlot() || op->IsFPStackSlot());\n    return SlotToMemOperand(AllocatedOperand::cast(op)->index());\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PPCOperandConverter::SlotToMemOperand\",\n            \"parent\": \"PPCOperandConverter\",\n            \"about\": \"Converts a stack slot index to a MemOperand.\",\n            \"logic\": \"Gets the FrameOffset for the given slot. Then it constructs the MemOperand with sp or fp as base register depending on the from_stack_pointer() property of the offset.\",\n            \"parameters\": [\n                {\n                    \"name\": \"slot\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The MemOperand representing the stack slot.\"\n            },\n            \"dependencies\": [\n                \"MemOperand\",\n                \"FrameOffset\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  MemOperand SlotToMemOperand(int slot) const {\n    FrameOffset offset = frame_access_state()->GetFrameOffset(slot);\n    return MemOperand(offset.from_stack_pointer() ? sp : fp, offset.offset());\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"HasRegisterInput\",\n            \"about\": \"Checks if an instruction input at a given index is a register.\",\n            \"logic\": \"It calls the IsRegister() method on the InstructionOperand at the given index to determine if the input is a register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the input in the instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the input is a register, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Instruction\",\n                \"InstructionOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic inline bool HasRegisterInput(Instruction* instr, size_t index) {\n  return instr->InputAt(index)->IsRegister();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineRecordWrite\",\n            \"about\": \"Helper class for generating out-of-line code for record writes with write barriers.\",\n            \"attributes\": [\n                {\n                    \"name\": \"object_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The register containing the object being written to.\"\n                },\n                {\n                    \"name\": \"offset_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The register containing the offset into the object (or no_reg if immediate).\"\n                },\n                {\n                    \"name\": \"offset_immediate_\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The immediate offset into the object (valid if offset_ == no_reg).\"\n                },\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The register containing the value being written.\"\n                },\n                {\n                    \"name\": \"scratch0_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Scratch register 0.\"\n                },\n                {\n                    \"name\": \"scratch1_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Scratch register 1.\"\n                },\n                {\n                    \"name\": \"mode_\",\n                    \"type\": \"RecordWriteMode\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The record write mode.\"\n                },\n                {\n                    \"name\": \"stub_mode_\",\n                    \"type\": \"StubCallMode\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The stub call mode.\"\n                },\n                {\n                    \"name\": \"must_save_lr_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the link register must be saved.\"\n                },\n                {\n                    \"name\": \"unwinding_info_writer_\",\n                    \"type\": \"UnwindingInfoWriter* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to unwinding info writer.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone allocator.\"\n                },\n                {\n                    \"name\": \"indirect_pointer_tag_\",\n                    \"type\": \"IndirectPointerTag\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tag for indirect pointers.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineRecordWrite final : public OutOfLineCode {\n public:\n  OutOfLineRecordWrite(\n      CodeGenerator* gen, Register object, Register offset, Register value,\n      Register scratch0, Register scratch1, RecordWriteMode mode,\n      StubCallMode stub_mode, UnwindingInfoWriter* unwinding_info_writer,\n      IndirectPointerTag indirect_pointer_tag = kIndirectPointerNullTag)\n      : OutOfLineCode(gen),\n        object_(object),\n        offset_(offset),\n        offset_immediate_(0),\n        value_(value),\n        scratch0_(scratch0),\n        scratch1_(scratch1),\n        mode_(mode),\n#if V8_ENABLE_WEBASSEMBLY\n        stub_mode_(stub_mode),\n#endif  // V8_ENABLE_WEBASSEMBLY\n        must_save_lr_(!gen->frame_access_state()->has_frame()),\n        unwinding_info_writer_(unwinding_info_writer),\n        zone_(gen->zone()),\n        indirect_pointer_tag_(indirect_pointer_tag) {\n    DCHECK(!AreAliased(object, offset, scratch0, scratch1));\n    DCHECK(!AreAliased(value, offset, scratch0, scratch1));\n  }\n\n  OutOfLineRecordWrite(\n      CodeGenerator* gen, Register object, int32_t offset, Register value,\n      Register scratch0, Register scratch1, RecordWriteMode mode,\n      StubCallMode stub_mode, UnwindingInfoWriter* unwinding_info_writer,\n      IndirectPointerTag indirect_pointer_tag = kIndirectPointerNullTag)\n      : OutOfLineCode(gen),\n        object_(object),\n        offset_(no_reg),\n        offset_immediate_(offset),\n        value_(value),\n        scratch0_(scratch0),\n        scratch1_(scratch1),\n        mode_(mode),\n#if V8_ENABLE_WEBASSEMBLY\n        stub_mode_(stub_mode),\n#endif  // V8_ENABLE_WEBASSEMBLY\n        must_save_lr_(!gen->frame_access_state()->has_frame()),\n        unwinding_info_writer_(unwinding_info_writer),\n        zone_(gen->zone()),\n        indirect_pointer_tag_(indirect_pointer_tag) {\n  }\n\n  void Generate() final {\n    ConstantPoolUnavailableScope constant_pool_unavailable(masm());\n    // When storing an indirect pointer, the value will always be a\n    // full/decompressed pointer.\n    if (COMPRESS_POINTERS_BOOL &&\n        mode_ != RecordWriteMode::kValueIsIndirectPointer) {\n      __ DecompressTagged(value_, value_);\n    }\n    __ CheckPageFlag(value_, scratch0_,\n                     MemoryChunk::kPointersToHereAreInterestingMask, eq,\n                     exit());\n    if (offset_ == no_reg) {\n      __ addi(scratch1_, object_, Operand(offset_immediate_));\n    } else {\n      DCHECK_EQ(0, offset_immediate_);\n      __ add(scratch1_, object_, offset_);\n    }\n    SaveFPRegsMode const save_fp_mode = frame()->DidAllocateDoubleRegisters()\n                                            ? SaveFPRegsMode::kSave\n                                            : SaveFPRegsMode::kIgnore;\n    if (must_save_lr_) {\n      // We need to save and restore lr if the frame was elided.\n      __ mflr(scratch0_);\n      __ Push(scratch0_);\n      unwinding_info_writer_->MarkLinkRegisterOnTopOfStack(__ pc_offset());\n    }\n    if (mode_ == RecordWriteMode::kValueIsEphemeronKey) {\n      __ CallEphemeronKeyBarrier(object_, scratch1_, save_fp_mode);\n    } else if (mode_ == RecordWriteMode::kValueIsIndirectPointer) {\n      DCHECK(IsValidIndirectPointerTag(indirect_pointer_tag_));\n      __ CallIndirectPointerBarrier(object_, scratch1_, save_fp_mode,\n                                    indirect_pointer_tag_);\n#if V8_ENABLE_WEBASSEMBLY\n    } else if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n      __ CallRecordWriteStubSaveRegisters(object_, scratch1_, save_fp_mode,\n                                          StubCallMode::kCallWasmRuntimeStub);\n#endif  // V8_ENABLE_WEBASSEMBLY\n    } else {\n      __ CallRecordWriteStubSaveRegisters(object_, scratch1_, save_fp_mode);\n    }\n    if (must_save_lr_) {\n      // We need to save and restore lr if the frame was elided.\n      __ Pop(scratch0_);\n      __ mtlr(scratch0_);\n      unwinding_info_writer_->MarkPopLinkRegisterFromTopOfStack(__ pc_offset());\n    }\n  }\n\n private:\n  Register const object_;\n  Register const offset_;\n  int32_t const offset_immediate_;  // Valid if offset_ == no_reg.\n  Register const value_;\n  Register const scratch0_;\n  Register const scratch1_;\n  RecordWriteMode const mode_;\n#if V8_ENABLE_WEBASSEMBLY\n  StubCallMode stub_mode_;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  bool must_save_lr_;\n  UnwindingInfoWriter* const unwinding_info_writer_;\n  Zone* zone_;\n  IndirectPointerTag indirect_pointer_tag_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlagsConditionToCondition\",\n            \"about\": \"Converts a FlagsCondition to a Condition for branching.\",\n            \"logic\": \"It uses a switch statement to map FlagsCondition values (kEqual, kNotEqual, kSignedLessThan, etc.) to corresponding Condition values (eq, ne, lt, etc.). Handles specific cases like kOverflow and kNotOverflow only for add/sub opcodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"FlagsCondition\",\n                    \"purpose\": \"The flags condition to convert.\"\n                },\n                {\n                    \"name\": \"op\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The architecture opcode.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Condition\",\n                \"description\": \"The corresponding Condition value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nCondition FlagsConditionToCondition(FlagsCondition condition, ArchOpcode op) {\n  switch (condition) {\n    case kEqual:\n      return eq;\n    case kNotEqual:\n      return ne;\n    case kSignedLessThan:\n    case kUnsignedLessThan:\n      return lt;\n    case kSignedGreaterThanOrEqual:\n    case kUnsignedGreaterThanOrEqual:\n      return ge;\n    case kSignedLessThanOrEqual:\n    case kUnsignedLessThanOrEqual:\n      return le;\n    case kSignedGreaterThan:\n    case kUnsignedGreaterThan:\n      return gt;\n    case kOverflow:\n      // Overflow checked for add/sub only.\n      switch (op) {\n        case kPPC_Add32:\n        case kPPC_Add64:\n        case kPPC_Sub:\n        case kPPC_AddWithOverflow32:\n        case kPPC_SubWithOverflow32:\n          return lt;\n        default:\n          break;\n      }\n      break;\n    case kNotOverflow:\n      switch (op) {\n        case kPPC_Add32:\n        case kPPC_Add64:\n        case kPPC_Sub:\n        case kPPC_AddWithOverflow32:\n        case kPPC_SubWithOverflow32:\n          return ge;\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CodeGenerator::AssembleDeconstructFrame\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the code to deconstruct a stack frame.\",\n            \"logic\": \"It calls the LeaveFrame method to restore the stack pointer and base pointer, and then marks the frame deconstruction point for unwinding information.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleDeconstructFrame() {\n  __ LeaveFrame(StackFrame::MANUAL);\n  unwinding_info_writer_.MarkFrameDeconstructed(__ pc_offset());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CodeGenerator::AssemblePrepareTailCall\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Prepares the stack for a tail call.\",\n            \"logic\": \"If the current function has a frame, it restores the frame state. Then sets the frame access to SP relative.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssemblePrepareTailCall() {\n  if (frame_access_state()->has_frame()) {\n    __ RestoreFrameStateForTailCall();\n  }\n  frame_access_state()->SetFrameAccessToSP();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlushPendingPushRegisters\",\n            \"about\": \"Flushes pending register pushes to the stack.\",\n            \"logic\": \"Based on the number of pending pushes it emits the corresponding push instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"masm\",\n                    \"type\": \"MacroAssembler*\",\n                    \"purpose\": \"The macro assembler to use for emitting code.\"\n                },\n                {\n                    \"name\": \"frame_access_state\",\n                    \"type\": \"FrameAccessState*\",\n                    \"purpose\": \"The frame access state.\"\n                },\n                {\n                    \"name\": \"pending_pushes\",\n                    \"type\": \"ZoneVector<Register>*\",\n                    \"purpose\": \"The vector of registers to push.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid FlushPendingPushRegisters(MacroAssembler* masm,\n                               FrameAccessState* frame_access_state,\n                               ZoneVector<Register>* pending_pushes) {\n  switch (pending_pushes->size()) {\n    case 0:\n      break;\n    case 1:\n      masm->Push((*pending_pushes)[0]);\n      break;\n    case 2:\n      masm->Push((*pending_pushes)[0], (*pending_pushes)[1]);\n      break;\n    case 3:\n      masm->Push((*pending_pushes)[0], (*pending_pushes)[1],\n                 (*pending_pushes)[2]);\n      break;\n    default:\n      UNREACHABLE();\n  }\n  frame_access_state->IncreaseSPDelta(pending_pushes->size());\n  pending_pushes->clear();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AdjustStackPointerForTailCall\",\n            \"about\": \"Adjusts the stack pointer for a tail call.\",\n            \"logic\": \"Compares the current stack pointer offset with the desired offset and adjusts the stack pointer accordingly.  If stack_slot_delta is positive it increases the stack pointer. If allow_shrinkage is true and stack_slot_delta is negative it decreases the stack pointer. It calls FlushPendingPushRegisters if there are pending register pushes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"masm\",\n                    \"type\": \"MacroAssembler*\",\n                    \"purpose\": \"The macro assembler to use.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"FrameAccessState*\",\n                    \"purpose\": \"The frame access state.\"\n                },\n                {\n                    \"name\": \"new_slot_above_sp\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The new desired slot offset above the stack pointer.\"\n                },\n                {\n                    \"name\": \"pending_pushes\",\n                    \"type\": \"ZoneVector<Register>*\",\n                    \"purpose\": \"The vector of pending register pushes (optional).\"\n                },\n                {\n                    \"name\": \"allow_shrinkage\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Flag indicating if stack shrinkage is allowed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FlushPendingPushRegisters\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AdjustStackPointerForTailCall(\n    MacroAssembler* masm, FrameAccessState* state, int new_slot_above_sp,\n    ZoneVector<Register>* pending_pushes = nullptr,\n    bool allow_shrinkage = true) {\n  int current_sp_offset = state->GetSPToFPSlotCount() +\n                          StandardFrameConstants::kFixedSlotCountAboveFp;\n  int stack_slot_delta = new_slot_above_sp - current_sp_offset;\n  if (stack_slot_delta > 0) {\n    if (pending_pushes != nullptr) {\n      FlushPendingPushRegisters(masm, state, pending_pushes);\n    }\n    masm->AddS64(sp, sp, Operand(-stack_slot_delta * kSystemPointerSize), r0);\n    state->IncreaseSPDelta(stack_slot_delta);\n  } else if (allow_shrinkage && stack_slot_delta < 0) {\n    if (pending_pushes != nullptr) {\n      FlushPendingPushRegisters(masm, state, pending_pushes);\n    }\n    masm->AddS64(sp, sp, Operand(-stack_slot_delta * kSystemPointerSize), r0);\n    state->IncreaseSPDelta(stack_slot_delta);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CodeGenerator::AssembleTailCallBeforeGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles code for a tail call before a gap in the instruction sequence.\",\n            \"logic\": \"It optimizes tail calls by pushing registers directly to the stack if they are push-compatible. Then adjusts the stack pointer for the tail call.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The tail call instruction.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandConverter\",\n                \"AdjustStackPointerForTailCall\",\n                \"FlushPendingPushRegisters\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleTailCallBeforeGap(Instruction* instr,\n                                              int first_unused_slot_offset) {\n  ZoneVector<MoveOperands*> pushes(zone());\n  GetPushCompatibleMoves(instr, kRegisterPush, &pushes);\n\n  if (!pushes.empty() &&\n      (LocationOperand::cast(pushes.back()->destination()).index() + 1 ==\n       first_unused_slot_offset)) {\n    PPCOperandConverter g(this, instr);\n    ZoneVector<Register> pending_pushes(zone());\n    for (auto move : pushes) {\n      LocationOperand destination_location(\n          LocationOperand::cast(move->destination()));\n      InstructionOperand source(move->source());\n      AdjustStackPointerForTailCall(\n          masm(), frame_access_state(),\n          destination_location.index() - pending_pushes.size(),\n          &pending_pushes);\n      // Pushes of non-register data types are not supported.\n      DCHECK(source.IsRegister());\n      LocationOperand source_location(LocationOperand::cast(source));\n      pending_pushes.push_back(source_location.GetRegister());\n      // TODO(arm): We can push more than 3 registers at once. Add support in\n      // the macro-assembler for pushing a list of registers.\n      if (pending_pushes.size() == 3) {\n        FlushPendingPushRegisters(masm(), frame_access_state(),\n                                  &pending_pushes);\n      }\n"
}