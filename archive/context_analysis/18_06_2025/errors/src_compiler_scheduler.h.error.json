{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/scheduler.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 60, column 54",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/scheduler.h\",\n            \"file_name\": \"scheduler.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the Scheduler class, which computes a schedule from a graph, placing nodes into basic blocks and ordering them in special RPO order.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library and V8 specific headers for optional types, flags, node representation, scheduling, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/flags.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/schedule.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Scheduler\",\n                \"about\": \"Computes a schedule from a graph, placing nodes into basic blocks and ordering the basic blocks in the special RPO order.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocations.\"\n                    },\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The graph to be scheduled.\"\n                    },\n                    {\n                        \"name\": \"schedule_\",\n                        \"type\": \"Schedule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The schedule being computed.\"\n                    },\n                    {\n                        \"name\": \"flags_\",\n                        \"type\": \"Flags\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flags controlling the scheduling mode.\"\n                    },\n                    {\n                        \"name\": \"scheduled_nodes_\",\n                        \"type\": \"ZoneVector<NodeVector*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Per-block list of nodes in reverse order.\"\n                    },\n                    {\n                        \"name\": \"schedule_root_nodes_\",\n                        \"type\": \"NodeVector\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Fixed root nodes that seed the worklist.\"\n                    },\n                    {\n                        \"name\": \"schedule_queue_\",\n                        \"type\": \"ZoneQueue<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Worklist of schedulable nodes.\"\n                    },\n                    {\n                        \"name\": \"node_data_\",\n                        \"type\": \"ZoneVector<SchedulerData>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Per-node data tracked during scheduling.\"\n                    },\n                    {\n                        \"name\": \"control_flow_builder_\",\n                        \"type\": \"CFGBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builds basic blocks for controls.\"\n                    },\n                    {\n                        \"name\": \"special_rpo_\",\n                        \"type\": \"SpecialRPONumberer*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Special RPO numbering of blocks.\"\n                    },\n                    {\n                        \"name\": \"equivalence_\",\n                        \"type\": \"ControlEquivalence*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Control dependence equivalence.\"\n                    },\n                    {\n                        \"name\": \"tick_counter_\",\n                        \"type\": \"TickCounter* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counter for tracking execution time.\"\n                    },\n                    {\n                        \"name\": \"profile_data_\",\n                        \"type\": \"const ProfileDataFromFile*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Profile data from file.\"\n                    },\n                    {\n                        \"name\": \"common_dominator_cache_\",\n                        \"type\": \"CommonDominatorCache\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Cache for common dominator calculations.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"Schedule\",\n                    \"CFGBuilder\",\n                    \"SpecialRPONumberer\",\n                    \"ControlEquivalence\",\n                    \"TickCounter\",\n                    \"ProfileDataFromFile\",\n                    \"BasicBlock\",\n                    \"Node\",\n                    \"Zone\",\n                    \"ZoneVector\",\n                    \"NodeVector\",\n                    \"ZoneQueue\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE Scheduler {\n public:\n  // Flags that control the mode of operation.\n  enum Flag { kNoFlags = 0u, kSplitNodes = 1u << 1, kTempSchedule = 1u << 2 };\n  using Flags = base::Flags<Flag>;\n\n  // The complete scheduling algorithm. Creates a new schedule and places all\n  // nodes from the graph into it.\n  static Schedule* ComputeSchedule(Zone* temp_zone, TFGraph* graph, Flags flags,\n                                   TickCounter* tick_counter,\n                                   const ProfileDataFromFile* profile_data);\n\n  // Compute the RPO of blocks in an existing schedule.\n  static BasicBlockVector* ComputeSpecialRPO(Zone* zone, Schedule* schedule);\n\n  // Computes the dominator tree on an existing schedule that has RPO computed.\n  static void GenerateDominatorTree(Schedule* schedule);\n\n  const ProfileDataFromFile* profile_data() const { return profile_data_; }\n\n private:\n  // Placement of a node changes during scheduling. The placement state\n  // transitions over time while the scheduler is choosing a position:\n  //\n  //                   +---------------------+-----+----> kFixed\n  //                  /                     /     /\n  //    kUnknown ----+------> kCoupled ----+     /\n  //                  \\                         /\n  //                   +----> kSchedulable ----+--------> kScheduled\n  //\n  // 1) InitializePlacement(): kUnknown -> kCoupled|kSchedulable|kFixed\n  // 2) UpdatePlacement(): kCoupled|kSchedulable -> kFixed|kScheduled\n  //\n  // We maintain the invariant that all nodes that are not reachable\n  // from the end have kUnknown placement. After the PrepareUses phase runs,\n  // also the opposite is true - all nodes with kUnknown placement are not\n  // reachable from the end.\n  enum Placement { kUnknown, kSchedulable, kFixed, kCoupled, kScheduled };\n\n  // Implements a two-dimensional map: (int, int) -> BasicBlock*.\n  using CommonDominatorCache = ZoneMap<int, ZoneMap<int, BasicBlock*>*>;\n\n  // Per-node data tracked during scheduling.\n  struct SchedulerData {\n    BasicBlock* minimum_block_;  // Minimum legal RPO placement.\n    int unscheduled_count_;      // Number of unscheduled uses of this node.\n    Placement placement_;        // Whether the node is fixed, schedulable,\n                                 // coupled to another node, or not yet known.\n  };\n\n  Zone* zone_;\n  TFGraph* graph_;\n  Schedule* schedule_;\n  Flags flags_;\n  ZoneVector<NodeVector*>\n      scheduled_nodes_;                  // Per-block list of nodes in reverse.\n  NodeVector schedule_root_nodes_;       // Fixed root nodes seed the worklist.\n  ZoneQueue<Node*> schedule_queue_;      // Worklist of schedulable nodes.\n  ZoneVector<SchedulerData> node_data_;  // Per-node data for all nodes.\n  CFGBuilder* control_flow_builder_;     // Builds basic blocks for controls.\n  SpecialRPONumberer* special_rpo_;      // Special RPO numbering of blocks.\n  ControlEquivalence* equivalence_;      // Control dependence equivalence.\n  TickCounter* const tick_counter_;\n  const ProfileDataFromFile* profile_data_;\n  CommonDominatorCache common_dominator_cache_;\n\n  Scheduler(Zone* zone, TFGraph* graph, Schedule* schedule, Flags flags,\n            size_t node_count_hint_, TickCounter* tick_counter,\n            const ProfileDataFromFile* profile_data);\n\n  inline SchedulerData DefaultSchedulerData();\n  inline SchedulerData* GetData(Node* node);\n\n  Placement GetPlacement(Node* node);\n  Placement InitializePlacement(Node* node);\n  void UpdatePlacement(Node* node, Placement placement);\n  bool IsLive(Node* node);\n\n  // If the node is coupled, returns the coupled control edge index.\n  inline std::optional<int> GetCoupledControlEdge(Node* node);\n  void IncrementUnscheduledUseCount(Node* node, Node* from);\n  void DecrementUnscheduledUseCount(Node* node, Node* from);\n\n  static void PropagateImmediateDominators(BasicBlock* block);\n\n  // Uses {common_dominator_cache_} to speed up repeated calls.\n  BasicBlock* GetCommonDominator(BasicBlock* b1, BasicBlock* b2);\n  // Returns the common dominator of {b1} and {b2} if it can be found in\n  // {common_dominator_cache_}, or nullptr otherwise.\n  // Not meant to be called directly, only from {GetCommonDominator}.\n  BasicBlock* GetCommonDominatorIfCached(BasicBlock* b1, BasicBlock* b2);\n\n  // Phase 1: Build control-flow graph.\n  friend class CFGBuilder;\n  void BuildCFG();\n\n  // Phase 2: Compute special RPO and dominator tree.\n  friend class SpecialRPONumberer;\n  void ComputeSpecialRPONumbering();\n  void GenerateDominatorTree();\n\n  // Phase 3: Prepare use counts for nodes.\n  friend class PrepareUsesVisitor;\n  void PrepareUses();\n\n  // Phase 4: Schedule nodes early.\n  friend class ScheduleEarlyNodeVisitor;\n  void ScheduleEarly();\n\n  // Phase 5: Schedule nodes late.\n  friend class ScheduleLateNodeVisitor;\n  void ScheduleLate();\n\n  // Phase 6: Seal the final schedule.\n  void SealFinalSchedule();\n\n  void FuseFloatingControl(BasicBlock* block, Node* node);\n  void MovePlannedNodes(BasicBlock* from, BasicBlock* to);\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DEFINE_OPERATORS_FOR_FLAGS\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Defines operators for the Scheduler::Flags enum.\",\n                \"logic\": \"This is a macro invocation that defines operators like |, &, ^, ~, etc., for the Flags enum, allowing bitwise operations on the flags.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value, macro defines operators.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nDEFINE_OPERATORS_FOR_FLAGS(Scheduler::Flags)\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CFGBuilder\",\n                \"about\": \"Forward declaration for CFGBuilder class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass CFGBuilder;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ControlEquivalence\",\n                \"about\": \"Forward declaration for ControlEquivalence class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass ControlEquivalence;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TFGraph\",\n                \"about\": \"Forward declaration for TFGraph class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass TFGraph;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SpecialRPONumberer\",\n                \"about\": \"Forward declaration for SpecialRPONumberer class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass SpecialRPONumberer;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ProfileDataFromFile\",\n                \"about\": \"Forward declaration for ProfileDataFromFile class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass ProfileDataFromFile;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TickCounter\",\n                \"about\": \"Forward declaration for TickCounter class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass TickCounter;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BasicBlock\",\n                \"about\": \"Forward declaration for BasicBlock class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass BasicBlock;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Node\",\n                \"about\": \"Forward declaration for Node class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Node;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Schedule\",\n                \"about\": \"Forward declaration for Schedule class\",\n                 \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Schedule;\n        ]]></code>\n    </class>\n</file>\n```"
}