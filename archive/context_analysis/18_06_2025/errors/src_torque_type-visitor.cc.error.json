{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/type-visitor.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/type-visitor.cc\",\n        \"file_name\": \"type-visitor.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the TypeVisitor class, which computes the Type of a TypeDeclaration in Torque.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for type visiting and other Torque functionalities\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/torque/type-visitor.h\"\n\n            #include <optional>\n\n            #include \"src/common/globals.h\"\n            #include \"src/torque/declarable.h\"\n            #include \"src/torque/global-context.h\"\n            #include \"src/torque/kythe-data.h\"\n            #include \"src/torque/server-data.h\"\n            #include \"src/torque/type-inference.h\"\n            #include \"src/torque/type-oracle.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypeVisitor\",\n            \"about\": \"Visitor class responsible for computing the Type of a TypeDeclaration in Torque.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"TypeDeclaration\",\n                \"MaybeSpecializationKey\",\n                \"Scope\",\n                \"SourcePosition\",\n                \"TypeAlias\",\n                \"Declarations\",\n                \"AstNode\",\n                \"Type\",\n                \"QualifiedName\",\n                \"TypeOracle\",\n                \"ClassType\",\n                \"StructType\",\n                \"BitFieldStructType\",\n                \"CallableDeclaration\",\n                \"LabelDeclaration\",\n                \"Signature\",\n                \"ClassFieldExpression\",\n                \"ResidueClass\",\n                \"IntegerLiteralExpression\",\n                \"Field\",\n                \"TypeExpression\",\n                \"BasicTypeExpression\",\n                \"UnionTypeExpression\",\n                \"FunctionTypeExpression\",\n                \"TypeVector\",\n                \"LanguageServerData\",\n                \"GenericType\",\n                \"TypeArgumentInference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8::internal::torque {\n\n            class TypeVisitor {\n            public:\n              static const Type* ComputeType(TypeDeclaration* decl,\n                                                   MaybeSpecializationKey specialized_from,\n                                                   Scope* specialization_requester);\n              static const Type* ComputeType(TypeAliasDeclaration* decl,\n                                                   MaybeSpecializationKey specialized_from);\n              static const AbstractType* ComputeType(\n                  AbstractTypeDeclaration* decl, MaybeSpecializationKey specialized_from);\n              static const BitFieldStructType* ComputeType(\n                  BitFieldStructDeclaration* decl, MaybeSpecializationKey specialized_from);\n              static const StructType* ComputeType(\n                  StructDeclaration* decl, MaybeSpecializationKey specialized_from);\n              static const ClassType* ComputeType(\n                  ClassDeclaration* decl, MaybeSpecializationKey specialized_from);\n              static const Type* ComputeType(TypeExpression* type_expression);\n              static Signature MakeSignature(const CallableDeclaration* declaration);\n              static void VisitClassFieldsAndMethods(\n                  ClassType* class_type, const ClassDeclaration* class_declaration);\n              static void VisitStructMethods(\n                  StructType* struct_type, const StructDeclaration* struct_declaration);\n              static const Type* ComputeTypeForStructExpression(\n                  TypeExpression* type_expression,\n                  const std::vector<const Type*>& term_argument_types);\n            };\n\n            }  // namespace v8::internal::torque\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeType\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Computes the Type of a TypeDeclaration based on its kind.\",\n            \"logic\": \"The function uses a switch statement based on the AST node kind to dispatch to the appropriate ComputeType overload for each declaration type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"TypeDeclaration*\",\n                    \"purpose\": \"The type declaration to compute the type for.\"\n                },\n                {\n                    \"name\": \"specialized_from\",\n                    \"type\": \"MaybeSpecializationKey\",\n                    \"purpose\": \"Optional specialization key for generic types.\"\n                },\n                {\n                    \"name\": \"specialization_requester\",\n                    \"type\": \"Scope*\",\n                    \"purpose\": \"The scope requesting the specialization.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const Type*\",\n                \"description\": \"The computed type.\"\n            },\n            \"dependencies\": [\n                \"CurrentSourcePosition\",\n                \"CurrentScope\",\n                \"TypeOracle\",\n                \"Declarations\",\n                \"AST_TYPE_DECLARATION_NODE_KIND_LIST\",\n                \"UNIMPLEMENTED\",\n                \"Type\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const Type* TypeVisitor::ComputeType(TypeDeclaration* decl,\n                                                 MaybeSpecializationKey specialized_from,\n                                                 Scope* specialization_requester) {\n              SourcePosition requester_position = CurrentSourcePosition::Get();\n              CurrentSourcePosition::Scope scope(decl->pos);\n              Scope* current_scope = CurrentScope::Get();\n              if (specialized_from) {\n                current_scope = TypeOracle::CreateGenericTypeInstantiationNamespace();\n                current_scope->SetSpecializationRequester(\n                    {requester_position, specialization_requester,\n                     Type::ComputeName(decl->name->value, specialized_from)});\n              }\n              CurrentScope::Scope new_current_scope_scope(current_scope);\n              if (specialized_from) {\n                auto& params = specialized_from->generic->generic_parameters();\n                auto arg_types_iterator = specialized_from->specialized_types.begin();\n                for (auto param : params) {\n                  TypeAlias* alias =\n                      Declarations::DeclareType(param.name, *arg_types_iterator);\n                  alias->SetIsUserDefined(false);\n                  arg_types_iterator++;\n                }\n              }\n\n              switch (decl->kind) {\n            #define ENUM_ITEM(name)        \\\n              case AstNode::Kind::k##name: \\\n                return ComputeType(name::cast(decl), specialized_from);\n                AST_TYPE_DECLARATION_NODE_KIND_LIST(ENUM_ITEM)\n            #undef ENUM_ITEM\n                default:\n                  UNIMPLEMENTED();\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeType\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Computes the Type of a TypeAliasDeclaration.\",\n            \"logic\": \"Computes the type of the underlying type expression and adds the alias name to the type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"TypeAliasDeclaration*\",\n                    \"purpose\": \"The type alias declaration.\"\n                },\n                {\n                    \"name\": \"specialized_from\",\n                    \"type\": \"MaybeSpecializationKey\",\n                    \"purpose\": \"Optional specialization key for generic types.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const Type*\",\n                \"description\": \"The computed type.\"\n            },\n            \"dependencies\": [\n                \"Type\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const Type* TypeVisitor::ComputeType(TypeAliasDeclaration* decl,\n                                                 MaybeSpecializationKey specialized_from) {\n              const Type* type = ComputeType(decl->type);\n              type->AddAlias(decl->name->value);\n              return type;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeType\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Computes the Type of an AbstractTypeDeclaration.\",\n            \"logic\": \"Determines the generated type name, finds the parent type (if any), and retrieves the AbstractType from the TypeOracle.\",\n            \"parameters\": [\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"AbstractTypeDeclaration*\",\n                    \"purpose\": \"The abstract type declaration.\"\n                },\n                {\n                    \"name\": \"specialized_from\",\n                    \"type\": \"MaybeSpecializationKey\",\n                    \"purpose\": \"Optional specialization key for generic types.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const AbstractType*\",\n                \"description\": \"The computed abstract type.\"\n            },\n            \"dependencies\": [\n                \"ComputeGeneratesType\",\n                \"TypeVisitor\",\n                \"TypeOracle\",\n                \"QualifiedName\",\n                \"Declarations\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const AbstractType* TypeVisitor::ComputeType(\n                AbstractTypeDeclaration* decl, MaybeSpecializationKey specialized_from) {\n              std::string generates =\n                  ComputeGeneratesType(decl->generates, !decl->IsConstexpr());\n\n              const Type* parent_type = nullptr;\n              if (decl->extends) {\n                parent_type = TypeVisitor::ComputeType(*decl->extends);\n                if (parent_type->IsUnionType()) {\n                  // UnionType::IsSupertypeOf requires that types can only extend from non-\n                  // union types in order to work correctly.\n                  ReportError(\"type \\\"\", decl->name->value,\n                              \"\\\" cannot extend a type union\");\n                }\n              }\n\n              if (decl->IsConstexpr() && decl->IsTransient()) {\n                ReportError(\"cannot declare a transient type that is also constexpr\");\n              }\n\n              const Type* non_constexpr_version = nullptr;\n              if (decl->IsConstexpr()) {\n                QualifiedName non_constexpr_name{GetNonConstexprName(decl->name->value)};\n                if (auto type = Declarations::TryLookupType(non_constexpr_name)) {\n                  non_constexpr_version = *type;\n                }\n              }\n\n              return TypeOracle::GetAbstractType(parent_type, decl->name->value,\n                                                 decl->flags, generates,\n                                                 non_constexpr_version, specialized_from);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeType\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Computes the Type of a BitFieldStructDeclaration.\",\n            \"logic\": \"Verifies the parent type is an unsigned integer, calculates the size in bits, and registers the declared fields with their respective offsets and bit sizes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"BitFieldStructDeclaration*\",\n                    \"purpose\": \"The bitfield struct declaration.\"\n                },\n                {\n                    \"name\": \"specialized_from\",\n                    \"type\": \"MaybeSpecializationKey\",\n                    \"purpose\": \"Optional specialization key for generic types.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const BitFieldStructType*\",\n                \"description\": \"The computed bitfield struct type.\"\n            },\n            \"dependencies\": [\n                \"TypeVisitor\",\n                \"TypeOracle\",\n                \"IsAnyUnsignedInteger\",\n                \"SizeOf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const BitFieldStructType* TypeVisitor::ComputeType(\n                BitFieldStructDeclaration* decl, MaybeSpecializationKey specialized_from) {\n              CurrentSourcePosition::Scope position_scope(decl->pos);\n              if (specialized_from.has_value()) {\n                ReportError(\"Bitfield struct specialization is not supported\");\n              }\n              const Type* parent = TypeVisitor::ComputeType(decl->parent);\n              if (!IsAnyUnsignedInteger(parent)) {\n                ReportError(\n                    \"Bitfield struct must extend from an unsigned integer type, not \",\n                    parent->ToString());\n              }\n              auto opt_size = SizeOf(parent);\n              if (!opt_size.has_value()) {\n                ReportError(\"Cannot determine size of bitfield struct \", decl->name->value,\n                            \" because of unsized parent type \", parent->ToString());\n              }\n              const size_t size = 8 * std::get<0>(*opt_size);  // Convert bytes to bits.\n              BitFieldStructType* type = TypeOracle::GetBitFieldStructType(parent, decl);\n\n              // Iterate through all of the declared fields, checking their validity and\n              // registering them on the newly-constructed BitFieldStructType instance.\n              int offset = 0;\n              for (const auto& field : decl->fields) {\n                CurrentSourcePosition::Scope field_position_scope(\n                    field.name_and_type.type->pos);\n                const Type* field_type = TypeVisitor::ComputeType(field.name_and_type.type);\n                if (!IsAllowedAsBitField(field_type)) {\n                  ReportError(\"Type not allowed as bitfield: \",\n                              field.name_and_type.name->value);\n                }\n\n                // Compute the maximum number of bits that could be used for a field of this\n                // type. Booleans are a special case, not included in SizeOf, because their\n                // runtime size is 32 bits but they should only occupy 1 bit as a bitfield.\n                size_t field_type_size = 0;\n                if (field_type->IsSubtypeOf(TypeOracle::GetBoolType())) {\n                  field_type_size = 1;\n                } else {\n                  auto opt_field_type_size = SizeOf(field_type);\n                  if (!opt_field_type_size.has_value()) {\n                    ReportError(\"Size unknown for type \", field_type->ToString());\n                  }\n                  field_type_size = 8 * std::get<0>(*opt_field_type_size);\n                }\n\n                if (field.num_bits < 1 ||\n                    static_cast<size_t>(field.num_bits) > field_type_size) {\n                  ReportError(\"Invalid number of bits for \",\n                              field.name_and_type.name->value);\n                }\n                type->RegisterField({field.name_and_type.name->pos,\n                                     {field.name_and_type.name->value, field_type},\n                                     offset,\n                                     field.num_bits});\n                offset += field.num_bits;\n                if (static_cast<size_t>(offset) > size) {\n                  ReportError(\"Too many total bits in \", decl->name->value);\n                }\n              }\n\n              return type;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeType\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Computes the Type of a StructDeclaration.\",\n            \"logic\": \"Creates a StructType, iterates through the fields, computes their types, and registers them. Calculates offsets for the fields.\",\n            \"parameters\": [\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"StructDeclaration*\",\n                    \"purpose\": \"The struct declaration.\"\n                },\n                {\n                    \"name\": \"specialized_from\",\n                    \"type\": \"MaybeSpecializationKey\",\n                    \"purpose\": \"Optional specialization key for generic types.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const StructType*\",\n                \"description\": \"The computed struct type.\"\n            },\n            \"dependencies\": [\n                \"TypeVisitor\",\n                \"TypeOracle\",\n                \"SizeOf\",\n                \"ResidueClass\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const StructType* TypeVisitor::ComputeType(\n                StructDeclaration* decl, MaybeSpecializationKey specialized_from) {\n              StructType* struct_type = TypeOracle::GetStructType(decl, specialized_from);\n              CurrentScope::Scope struct_namespace_scope(struct_type->nspace());\n              CurrentSourcePosition::Scope decl_position_activator(decl->pos);\n\n              ResidueClass offset = 0;\n              for (auto& field : decl->fields) {\n                CurrentSourcePosition::Scope position_activator(\n                    field.name_and_type.type->pos);\n                const Type* field_type = TypeVisitor::ComputeType(field.name_and_type.type);\n                if (field_type->IsConstexpr()) {\n                  ReportError(\"struct field \\\"\", field.name_and_type.name->value,\n                              \"\\\" carries constexpr type \\\"\", *field_type, \"\\\"\");\n                }\n                Field f{field.name_and_type.name->pos,\n                        struct_type,\n                        std::nullopt,\n                        {field.name_and_type.name->value, field_type},\n                        offset.SingleValue(),\n                        false,\n                        field.const_qualified,\n                        FieldSynchronization::kNone};\n                auto optional_size = SizeOf(f.name_and_type.type);\n                struct_type->RegisterField(f);\n                // Offsets are assigned based on an assumption of no space between members.\n                // This might lead to invalid alignment in some cases, but most structs are\n                // never actually packed in memory together (they just represent a batch of\n                // CSA TNode values that should be passed around together). For any struct\n                // that is used as a class field, we verify its offsets when setting up the\n                // class type.\n                if (optional_size.has_value()) {\n                  size_t field_size = 0;\n                  std::tie(field_size, std::ignore) = *optional_size;\n                  offset += field_size;\n                } else {\n                  // Structs may contain fields that aren't representable in packed form. If\n                  // so, the offset of subsequent fields are marked as invalid.\n                  offset = ResidueClass::Unknown();\n                }\n              }\n              return struct_type;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeType\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Computes the Type of a ClassDeclaration.\",\n            \"logic\": \"Looks up the type alias, computes the super type, handles shape classes, and retrieves the ClassType from the TypeOracle.\",\n            \"parameters\": [\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"ClassDeclaration*\",\n                    \"purpose\": \"The class declaration.\"\n                },\n                {\n                    \"name\": \"specialized_from\",\n                    \"type\": \"MaybeSpecializationKey\",\n                    \"purpose\": \"Optional specialization key for generic types.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const ClassType*\",\n                \"description\": \"The computed class type.\"\n            },\n            \"dependencies\": [\n                \"TypeVisitor\",\n                \"TypeOracle\",\n                \"Declarations\",\n                \"ClassType\",\n                \"QualifiedName\",\n                \"ComputeGeneratesType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const ClassType* TypeVisitor::ComputeType(\n                ClassDeclaration* decl, MaybeSpecializationKey specialized_from) {\n              // TODO(sigurds): Remove this hack by introducing a declarable for classes.\n              const TypeAlias* alias =\n                  Declarations::LookupTypeAlias(QualifiedName(decl->name->value));\n              DCHECK_EQ(*alias->delayed_, decl);\n              ClassFlags flags = decl->flags;\n              bool is_shape = flags & ClassFlag::kIsShape;\n              std::string generates = decl->name->value;\n              const Type* super_type = TypeVisitor::ComputeType(decl->super);\n              if (is_shape) {\n                if (!(flags & ClassFlag::kExtern)) {\n                  ReportError(\"Shapes must be extern, add \\\"extern\\\" to the declaration.\");\n                }\n                if (flags & ClassFlag::kUndefinedLayout) {\n                  ReportError(\"Shapes need to define their layout.\");\n                }\n                const ClassType* super_class = ClassType::DynamicCast(super_type);\n                if (!super_class ||\n                    !super_class->IsSubtypeOf(TypeOracle::GetJSObjectType())) {\n                  Error(\"Shapes need to extend a subclass of \",\n                        *TypeOracle::GetJSObjectType())\n                      .Throw();\n                }\n                // Shapes use their super class in CSA code since they have incomplete\n                // support for type-checks on the C++ side.\n                generates = super_class->name();\n              }\n              if (super_type != TypeOracle::GetStrongTaggedType()) {\n                const ClassType* super_class = ClassType::DynamicCast(super_type);\n                if (!super_class) {\n                  ReportError(\n                      \"class \\\"\", decl->name->value,\n                      \"\\\" must extend either StrongTagged or an already declared class\");\n                }\n                if (super_class->HasUndefinedLayout() &&\n                    !(flags & ClassFlag::kUndefinedLayout)) {\n                  Error(\"Class \\\"\", decl->name->value,\n                        \"\\\" defines its layout but extends a class which does not\")\n                      .Position(decl->pos);\n                }\n                if ((flags & ClassFlag::kExport) &&\n                    !(super_class->ShouldExport() || super_class->IsExtern())) {\n                  Error(\"cannot export class \", decl->name,\n                        \" because superclass is neither @export or extern\");\n                }\n              }\n              if ((flags & ClassFlag::kGenerateBodyDescriptor ||\n                   flags & ClassFlag::kExport) &&\n                  flags & ClassFlag::kUndefinedLayout) {\n                Error(\"Class \\\"\", decl->name->value,\n                      \"\\\" requires a layout but doesn't have one\");\n              }\n              if (flags & ClassFlag::kGenerateUniqueMap) {\n                if (!(flags & ClassFlag::kExtern)) {\n                  Error(\"No need to specify \", ANNOTATION_GENERATE_UNIQUE_MAP,\n                        \", non-extern classes always have a unique map.\");\n                }\n                if (flags & ClassFlag::kAbstract) {\n                  Error(ANNOTATION_ABSTRACT, \" and \", ANNOTATION_GENERATE_UNIQUE_MAP,\n                        \" shouldn't be used together, because abstract classes are never \"\n                        \"instantiated.\");\n                }\n              }\n              if ((flags & ClassFlag::kGenerateFactoryFunction) &&\n                  (flags & ClassFlag::kAbstract)) {\n                Error(ANNOTATION_ABSTRACT, \" and \", ANNOTATION_GENERATE_FACTORY_FUNCTION,\n                      \" shouldn't be used together, because abstract classes are never \"\n                      \"instantiated.\");\n              }\n              if (flags & ClassFlag::kExtern) {\n                if (decl->generates) {\n                  bool enforce_tnode_type = true;\n                  std::string explicit_generates =\n                      ComputeGeneratesType(decl->generates, enforce_tnode_type);\n                  if (explicit_generates == generates) {\n                    Lint(\"Unnecessary 'generates' clause for class \", decl->name->value);\n                  }\n                  generates = explicit_generates;\n                }\n                if (flags & ClassFlag::kExport) {\n                  Error(\"cannot export a class that is marked extern\");\n                }\n              } else {\n                if (decl->generates) {\n                  ReportError(\"Only extern classes can specify a generated type.\");\n                }\n                if (super_type != TypeOracle::GetStrongTaggedType()) {\n                  if (flags & ClassFlag::kUndefinedLayout) {\n                    Error(\"non-external classes must have defined layouts\");\n                  }\n                }\n              }\n              if (!(flags & ClassFlag::kExtern) &&\n                  (flags & ClassFlag::kHasSameInstanceTypeAsParent)) {\n                Error(\"non-extern Torque-defined classes must have unique instance types\");\n              }\n              if ((flags & ClassFlag::kHasSameInstanceTypeAsParent) &&\n                  !(flags & ClassFlag::kDoNotGenerateCast || flags & ClassFlag::kIsShape)) {\n                Error(\n                    \"classes that inherit their instance type must be annotated with \"\n                    \"@doNotGenerateCast\");\n              }\n\n              return TypeOracle::GetClassType(super_type, decl->name->value, flags,\n                                              generates, decl, alias);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeType\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Computes the Type of a TypeExpression.\",\n            \"logic\": \"Handles different types of TypeExpression, including BasicTypeExpression, UnionTypeExpression, and FunctionTypeExpression.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type_expression\",\n                    \"type\": \"TypeExpression*\",\n                    \"purpose\": \"The type expression to compute the type for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const Type*\",\n                \"description\": \"The computed type.\"\n            },\n            \"dependencies\": [\n                \"BasicTypeExpression\",\n                \"UnionTypeExpression\",\n                \"FunctionTypeExpression\",\n                \"PrecomputedTypeExpression\",\n                \"Declarations\",\n                \"TypeOracle\",\n                \"LanguageServerData\",\n                \"TypeVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const Type* TypeVisitor::ComputeType(TypeExpression* type_expression) {\n              if (auto* basic = BasicTypeExpression::DynamicCast(type_expression)) {\n                QualifiedName qualified_name{basic->namespace_qualification,\n                                             basic->name->value};\n                auto& args = basic->generic_arguments;\n                const Type* type;\n                SourcePosition pos = SourcePosition::Invalid();\n\n                if (args.empty()) {\n                  auto* alias = Declarations::LookupTypeAlias(qualified_name);\n                  type = alias->type();\n                  pos = alias->GetDeclarationPosition();\n                  if (GlobalContext::collect_kythe_data()) {\n                    if (alias->IsUserDefined()) {\n                      KytheData::AddTypeUse(basic->name->pos, alias);\n                    }\n                  }\n                } else {\n                  auto* generic_type =\n                      Declarations::LookupUniqueGenericType(qualified_name);\n                  type = TypeOracle::GetGenericTypeInstance(generic_type,\n                                                            ComputeTypeVector(args));\n                  pos = generic_type->declaration()->name->pos;\n                  if (GlobalContext::collect_kythe_data()) {\n                    KytheData::AddTypeUse(basic->name->pos, generic_type);\n                  }\n                }\n\n                if (GlobalContext::collect_language_server_data()) {\n                  LanguageServerData::AddDefinition(type_expression->pos, pos);\n                }\n                return type;\n              }\n              if (auto* union_type = UnionTypeExpression::DynamicCast(type_expression)) {\n                return TypeOracle::GetUnionType(ComputeType(union_type->a),\n                                                ComputeType(union_type->b));\n              }\n              if (auto* function_type_exp =\n                      FunctionTypeExpression::DynamicCast(type_expression)) {\n                TypeVector argument_types;\n                for (TypeExpression* type_exp : function_type_exp->parameters) {\n                  argument_types.push_back(ComputeType(type_exp));\n                }\n                return TypeOracle::GetBuiltinPointerType(\n                    std::move(argument_types), ComputeType(function_type_exp->return_type));\n              }\n              auto* precomputed = PrecomputedTypeExpression::cast(type_expression);\n              return precomputed->type;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MakeSignature\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Constructs a Signature object from a CallableDeclaration.\",\n            \"logic\": \"Collects parameter types, return type, and label declarations to create the Signature.\",\n            \"parameters\": [\n                {\n                    \"name\": \"declaration\",\n                    \"type\": \"const CallableDeclaration*\",\n                    \"purpose\": \"The callable declaration to create the signature for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Signature\",\n                \"description\": \"The constructed signature.\"\n            },\n            \"dependencies\": [\n                \"LabelDeclaration\",\n                \"ComputeTypeVector\",\n                \"Signature\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Signature TypeVisitor::MakeSignature(const CallableDeclaration* declaration) {\n              LabelDeclarationVector definition_vector;\n              for (const auto& label : declaration->labels) {\n                LabelDeclaration def = {label.name, ComputeTypeVector(label.types)};\n                definition_vector.push_back(def);\n              }\n              std::optional<std::string> arguments_variable;\n              if (declaration->parameters.has_varargs)\n                arguments_variable = declaration->parameters.arguments_variable;\n              Signature result{declaration->parameters.names,\n                               arguments_variable,\n                               {ComputeTypeVector(declaration->parameters.types),\n                                declaration->parameters.has_varargs},\n                               declaration->parameters.implicit_count,\n                               ComputeType(declaration->return_type),\n                               definition_vector,\n                               declaration->transitioning};\n              return result;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitClassFieldsAndMethods\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Visits class fields and methods to perform type checking and register them with the ClassType.\",\n            \"logic\": \"Iterates through the fields, computes their types, and registers them, calculating offsets. Declares methods.\",\n            \"parameters\": [\n                {\n                    \"name\": \"class_type\",\n                    \"type\": \"ClassType*\",\n                    \"purpose\": \"The class type being visited.\"\n                },\n                {\n                    \"name\": \"class_declaration\",\n                    \"type\": \"const ClassDeclaration*\",\n                    \"purpose\": \"The class declaration.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ClassType\",\n                \"ClassDeclaration\",\n                \"TypeVisitor\",\n                \"ComputeType\",\n                \"TypeOracle\",\n                \"ResidueClass\",\n                \"IntegerLiteralExpression\",\n                \"DeclareMethods\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void TypeVisitor::VisitClassFieldsAndMethods(\n                ClassType* class_type, const ClassDeclaration* class_declaration) {\n              const ClassType* super_class = class_type->GetSuperClass();\n              ResidueClass class_offset = 0;\n              size_t header_size = 0;\n              if (super_class) {\n                class_offset = super_class->size();\n                header_size = super_class->header_size();\n              }\n\n              for (const ClassFieldExpression& field_expression :\n                   class_declaration->fields) {\n                CurrentSourcePosition::Scope position_activator(\n                    field_expression.name_and_type.type->pos);\n                const Type* field_type = ComputeType(field_expression.name_and_type.type);\n                if (class_type->IsShape()) {\n                  if (!field_type->IsSubtypeOf(TypeOracle::GetObjectType())) {\n                    ReportError(\n                        \"in-object properties only support subtypes of Object, but \"\n                        \"found type \",\n                        *field_type);\n                  }\n                  if (field_expression.custom_weak_marking) {\n                    ReportError(\"in-object properties cannot use @customWeakMarking\");\n                  }\n                }\n                std::optional<ClassFieldIndexInfo> array_length = field_expression.index;\n                const Field& field = class_type->RegisterField(\n                    {field_expression.name_and_type.name->pos,\n                     class_type,\n                     array_length,\n                     {field_expression.name_and_type.name->value, field_type},\n                     class_offset.SingleValue(),\n                     field_expression.custom_weak_marking,\n                     field_expression.const_qualified,\n                     field_expression.synchronization});\n                ResidueClass field_size = std::get<0>(field.GetFieldSizeInformation());\n                if (field.index) {\n                  // Validate that a value at any index in a packed array is aligned\n                  // correctly, since it is possible to define a struct whose size is not a\n                  // multiple of its alignment.\n                  field.ValidateAlignment(class_offset +\n                                          field_size * ResidueClass::Unknown());\n\n                  if (auto literal =\n                          IntegerLiteralExpression::DynamicCast(field.index->expr)) {\n                    if (auto value = literal->value.TryTo<size_t>()) {\n                      field_size *= *value;\n                    } else {\n                      Error(\"Not a valid field index\").Position(field.pos);\n                    }\n                  } else {\n                    field_size *= ResidueClass::Unknown();\n                  }\n                }\n                field.ValidateAlignment(class_offset);\n                class_offset += field_size;\n                // In-object properties are not considered part of the header.\n                if (class_offset.SingleValue() && !class_type->IsShape()) {\n                  header_size = *class_offset.SingleValue();\n                }\n                if (!field.index && !class_offset.SingleValue()) {\n                  Error(\"Indexed fields have to be at the end of the object\")\n                      .Position(field.pos);\n                }\n              }\n              DCHECK_GT(header_size, 0);\n              class_type->header_size_ = header_size;\n              class_type->size_ = class_offset;\n              class_type->GenerateAccessors();\n              DeclareMethods(class_type, class_declaration->methods);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStructMethods\",\n            \"parent\": \"TypeVisitor\",\n            \"about\": \"Visits struct methods to declare methods of a struct type.\",\n            "
}