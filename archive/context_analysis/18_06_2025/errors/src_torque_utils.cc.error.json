{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/utils.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/utils.cc\",\n        \"file_name\": \"utils.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides utility functions for the Torque language, including string manipulation, URI decoding, message building, and naming convention validation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for string manipulation, file I/O, standard algorithms, optional values, and logging.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/utils.h\"\n\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <optional>\n#include <string>\n\n#include \"src/base/bits.h\"\n#include \"src/base/logging.h\"\n#include \"src/torque/ast.h\"\n#include \"src/torque/constants.h\"\n#include \"src/torque/declarable.h\"\n\nEXPORT_CONTEXTUAL_VARIABLE(v8::internal::torque::TorqueMessages)\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StringLiteralUnquote\",\n            \"about\": \"Unquotes a string literal by removing surrounding quotes and handling escape sequences.\",\n            \"logic\": \"Iterates through the string, removing the first and last quotes. If a backslash is encountered, it checks the following character to determine the escape sequence and replaces it accordingly. Supports \\\\n, \\\\r, \\\\t, \\\\', \\\\\\\", and \\\\\\\\.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string literal to unquote.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The unquoted string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string StringLiteralUnquote(const std::string& s) {\n  DCHECK(('\"' == s.front() && '\"' == s.back()) ||\n         ('\\'' == s.front() && '\\'' == s.back()));\n  std::stringstream result;\n  for (size_t i = 1; i < s.length() - 1; ++i) {\n    if (s[i] == '\\\\') {\n      switch (s[++i]) {\n        case 'n':\n          result << '\\n';\n          break;\n        case 'r':\n          result << '\\r';\n          break;\n        case 't':\n          result << '\\t';\n          break;\n        case '\\'':\n        case '\"':\n        case '\\\\':\n          result << s[i];\n          break;\n        default:\n          UNREACHABLE();\n      }\n    } else {\n      result << s[i];\n    }\n  }\n  return result.str();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StringLiteralQuote\",\n            \"about\": \"Quotes a string literal by adding surrounding quotes and escaping special characters.\",\n            \"logic\": \"Iterates through the string, adding a backslash before special characters such as \\\\n, \\\\r, \\\\t, \\\\\\\", and \\\\\\\\. Surrounds the entire string with double quotes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string literal to quote.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The quoted string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string StringLiteralQuote(const std::string& s) {\n  std::stringstream result;\n  result << '\"';\n  for (size_t i = 0; i < s.length(); ++i) {\n    switch (s[i]) {\n      case '\\n':\n        result << \"\\\\n\";\n        break;\n      case '\\r':\n        result << \"\\\\r\";\n        break;\n      case '\\t':\n        result << \"\\\\t\";\n        break;\n      case '\"':\n      case '\\\\':\n        result << \"\\\\\" << s[i];\n        break;\n      default:\n        result << s[i];\n    }\n  }\n  result << '\"';\n  return result.str();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FileUriDecode\",\n            \"about\": \"Decodes a file URI, converting percent-encoded characters to their literal values.\",\n            \"logic\": \"Checks if the URI starts with 'file://'. If so, it iterates through the URI, replacing percent-encoded characters with their corresponding values. Returns std::nullopt if the URI doesn't start with 'file://' or if an invalid percent-encoded sequence is found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"uri\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The file URI to decode.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<std::string>\",\n                \"description\": \"The decoded file path, or std::nullopt if decoding fails.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_OS_WIN\nstatic const char kFileUriPrefix[] = \"file:///\";\n#else\nstatic const char kFileUriPrefix[] = \"file://\";\n#endif\nstatic const int kFileUriPrefixLength = sizeof(kFileUriPrefix) - 1;\n\nstatic int HexCharToInt(unsigned char c) {\n  if (isdigit(c)) return c - '0';\n  if (isupper(c)) return c - 'A' + 10;\n  DCHECK(islower(c));\n  return c - 'a' + 10;\n}\n\nstd::optional<std::string> FileUriDecode(const std::string& uri) {\n  // Abort decoding of URIs that don't start with \"file://\".\n  if (uri.rfind(kFileUriPrefix) != 0) return std::nullopt;\n\n  const std::string path = uri.substr(kFileUriPrefixLength);\n  std::ostringstream decoded;\n\n  for (auto iter = path.begin(), end = path.end(); iter != end; ++iter) {\n    std::string::value_type c = (*iter);\n\n    // Normal characters are appended.\n    if (c != '%') {\n      decoded << c;\n      continue;\n    }\n\n    // If '%' is not followed by at least two hex digits, we abort.\n    if (std::distance(iter, end) <= 2) return std::nullopt;\n\n    unsigned char first = (*++iter);\n    unsigned char second = (*++iter);\n    if (!isxdigit(first) || !isxdigit(second)) return std::nullopt;\n\n    // An escaped hex value needs converting.\n    unsigned char value = HexCharToInt(first) * 16 + HexCharToInt(second);\n    decoded << value;\n  }\n\n  return decoded.str();\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MessageBuilder\",\n            \"about\": \"Helper class for building and reporting/throwing Torque messages with source position and specialization context.\",\n            \"attributes\": [\n                {\n                    \"name\": \"message_\",\n                    \"type\": \"TorqueMessage\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Torque message to be reported.\"\n                },\n                {\n                    \"name\": \"extra_messages_\",\n                    \"type\": \"std::vector<TorqueMessage>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Extra messages related to specialization requests.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TorqueMessage\",\n                \"SourcePosition\",\n                \"CurrentSourcePosition\",\n                \"CurrentScope\",\n                \"Scope\",\n                \"SpecializationRequester\",\n                \"TorqueAbortCompilation\",\n                \"TorqueMessages\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMessageBuilder::MessageBuilder(const std::string& message,\n                               TorqueMessage::Kind kind) {\n  std::optional<SourcePosition> position;\n  if (CurrentSourcePosition::HasScope()) {\n    position = CurrentSourcePosition::Get();\n  }\n  message_ = TorqueMessage{message, position, kind};\n  if (CurrentScope::HasScope()) {\n    // Traverse the parent scopes to find one that was created to represent a\n    // specialization of something generic. If we find one, then log it and\n    // continue walking the scope tree of the code that requested that\n    // specialization. This allows us to collect the stack of locations that\n    // caused a specialization.\n    Scope* scope = CurrentScope::Get();\n    while (scope) {\n      SpecializationRequester requester = scope->GetSpecializationRequester();\n      if (!requester.IsNone()) {\n        extra_messages_.push_back(\n            {\"Note: in specialization \" + requester.name + \" requested here\",\n             requester.position, kind});\n        scope = requester.scope;\n      } else {\n        scope = scope->ParentScope();\n      }\n    }\n  }\n}\n\nvoid MessageBuilder::Report() const {\n  TorqueMessages::Get().push_back(message_);\n  for (const auto& message : extra_messages_) {\n    TorqueMessages::Get().push_back(message);\n  }\n}\n\n[[noreturn]] void MessageBuilder::Throw() const {\n  throw TorqueAbortCompilation{};\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsLowerCamelCase\",\n            \"about\": \"Checks if a string is in lower camel case.\",\n            \"logic\": \"Checks if the string is not empty and starts with a lowercase letter (or underscore followed by a lowercase letter).  Also verifies that it doesn't contain underscores after the optional leading underscore.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is in lower camel case, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ContainsUnderscore\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nbool ContainsUnderscore(const std::string& s) {\n  if (s.empty()) return false;\n  return s.find(\"_\") != std::string::npos;\n}\n\nbool ContainsUpperCase(const std::string& s) {\n  if (s.empty()) return false;\n  return std::any_of(s.begin(), s.end(), [](char c) { return isupper(c); });\n}\n\n// Torque has some namespace constants that are used like language level\n// keywords, e.g.: 'True', 'Undefined', etc.\n// These do not need to follow the default naming convention for constants.\nbool IsKeywordLikeName(const std::string& s) {\n  static const char* const keyword_like_constants[]{\n      \"True\", \"False\", \"TheHole\", \"PromiseHole\", \"Null\", \"Undefined\"};\n\n  return std::find(std::begin(keyword_like_constants),\n                   std::end(keyword_like_constants),\n                   s) != std::end(keyword_like_constants);\n}\n\n// Untagged/MachineTypes like 'int32', 'intptr' etc. follow a 'all-lowercase'\n// naming convention and are those exempt from the normal type convention.\nbool IsMachineType(const std::string& s) {\n  static const char* const machine_types[]{\n      VOID_TYPE_STRING,\n      NEVER_TYPE_STRING,\n      INT8_TYPE_STRING,\n      UINT8_TYPE_STRING,\n      INT16_TYPE_STRING,\n      UINT16_TYPE_STRING,\n      INT31_TYPE_STRING,\n      UINT31_TYPE_STRING,\n      INT32_TYPE_STRING,\n      UINT32_TYPE_STRING,\n      INT64_TYPE_STRING,\n      UINT64_TYPE_STRING,\n      INTPTR_TYPE_STRING,\n      UINTPTR_TYPE_STRING,\n      FLOAT16_RAW_BITS_TYPE_STRING,\n      FLOAT32_TYPE_STRING,\n      FLOAT64_TYPE_STRING,\n      FLOAT64_OR_UNDEFINED_OR_HOLE_TYPE_STRING,\n      BOOL_TYPE_STRING,\n      \"string\",\n      BINT_TYPE_STRING,\n      CHAR8_TYPE_STRING,\n      CHAR16_TYPE_STRING};\n  return std::find(std::begin(machine_types), std::end(machine_types), s) !=\n         std::end(machine_types);\n}\n\n}  // namespace\n\nbool IsLowerCamelCase(const std::string& s) {\n  if (s.empty()) return false;\n  size_t start = 0;\n  if (s[0] == '_') start = 1;\n  return islower(s[start]) && !ContainsUnderscore(s.substr(start));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsUpperCamelCase\",\n            \"about\": \"Checks if a string is in upper camel case.\",\n            \"logic\": \"Checks if the string is not empty and starts with an uppercase letter (or underscore followed by an uppercase letter).\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is in upper camel case, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsUpperCamelCase(const std::string& s) {\n  if (s.empty()) return false;\n  size_t start = 0;\n  if (s[0] == '_') start = 1;\n  return isupper(s[start]);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsSnakeCase\",\n            \"about\": \"Checks if a string is in snake case.\",\n            \"logic\": \"Checks if the string is not empty and does not contain any uppercase letters.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is in snake case, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ContainsUpperCase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsSnakeCase(const std::string& s) {\n  if (s.empty()) return false;\n  return !ContainsUpperCase(s);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsValidNamespaceConstName\",\n            \"about\": \"Checks if a string is a valid name for a namespace constant.\",\n            \"logic\": \"Checks if the string is empty, then checks if it's a keyword-like constant (e.g., True, False) or if it starts with 'k' followed by a string in upper camel case.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is a valid namespace constant name, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IsKeywordLikeName\",\n                \"IsUpperCamelCase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsValidNamespaceConstName(const std::string& s) {\n  if (s.empty()) return false;\n  if (IsKeywordLikeName(s)) return true;\n\n  return s[0] == 'k' && IsUpperCamelCase(s.substr(1));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsValidTypeName\",\n            \"about\": \"Checks if a string is a valid type name.\",\n            \"logic\": \"Checks if the string is empty, then checks if it's a machine type (e.g., int32, intptr) or if it's in upper camel case.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is a valid type name, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IsMachineType\",\n                \"IsUpperCamelCase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsValidTypeName(const std::string& s) {\n  if (s.empty()) return false;\n  if (IsMachineType(s)) return true;\n\n  return IsUpperCamelCase(s);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CapifyStringWithUnderscores\",\n            \"about\": \"Converts a camellified string to a capitalized string with underscores.\",\n            \"logic\": \"Iterates through the string, adding an underscore before each uppercase letter that follows a lowercase letter or digit (except for the 'JS' prefix). Converts all characters to uppercase.\",\n            \"parameters\": [\n                {\n                    \"name\": \"camellified_string\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The capitalized string with underscores.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string CapifyStringWithUnderscores(const std::string& camellified_string) {\n  // Special case: JSAbc yields JS_ABC, not JSABC, for any Abc.\n  size_t js_position = camellified_string.find(\"JS\");\n\n  std::string result;\n  bool previousWasLowerOrDigit = false;\n  for (size_t index = 0; index < camellified_string.size(); ++index) {\n    char current = camellified_string[index];\n    if ((previousWasLowerOrDigit && isupper(current)) ||\n        (js_position != std::string::npos &&\n         index == js_position + strlen(\"JS\"))) {\n      result += \"_\";\n    }\n    if (current == '.' || current == '-') {\n      result += \"_\";\n      previousWasLowerOrDigit = false;\n      continue;\n    }\n    result += toupper(current);\n    previousWasLowerOrDigit = islower(current) || isdigit(current);\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CamelifyString\",\n            \"about\": \"Converts a string with underscores or dashes to camel case.\",\n            \"logic\": \"Iterates through the string, setting the first letter of each word to uppercase.\",\n            \"parameters\": [\n                {\n                    \"name\": \"underscore_string\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The camel case string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string CamelifyString(const std::string& underscore_string) {\n  std::string result;\n  bool word_beginning = true;\n  for (auto current : underscore_string) {\n    if (current == '_' || current == '-') {\n      word_beginning = true;\n      continue;\n    }\n    if (word_beginning) {\n      current = toupper(current);\n    }\n    result += current;\n    word_beginning = false;\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SnakeifyString\",\n            \"about\": \"Converts a camel case string to snake case.\",\n            \"logic\": \"Iterates through the string, adding an underscore before each uppercase letter. Converts all letters to lowercase.\",\n            \"parameters\": [\n                {\n                    \"name\": \"camel_string\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The snake case string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string SnakeifyString(const std::string& camel_string) {\n  std::string result;\n  bool previousWasLower = false;\n  for (auto current : camel_string) {\n    if (previousWasLower && isupper(current)) {\n      result += \"_\";\n    }\n    result += tolower(current);\n    previousWasLower = (islower(current));\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DashifyString\",\n            \"about\": \"Replaces underscores in a string with dashes.\",\n            \"logic\": \"Uses std::replace to replace all occurrences of '_' with '-' in the input string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"underscore_string\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The string with underscores replaced by dashes.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string DashifyString(const std::string& underscore_string) {\n  std::string result = underscore_string;\n  std::replace(result.begin(), result.end(), '_', '-');\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"UnderlinifyPath\",\n            \"about\": \"Replaces characters in a file path with underscores and converts to uppercase.\",\n            \"logic\": \"Replaces hyphens, forward slashes, backslashes, and periods with underscores. Converts the resulting string to uppercase.\",\n            \"parameters\": [\n                {\n                    \"name\": \"path\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The path to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The converted path.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string UnderlinifyPath(std::string path) {\n  std::replace(path.begin(), path.end(), '-', '_');\n  std::replace(path.begin(), path.end(), '/', '_');\n  std::replace(path.begin(), path.end(), '\\\\', '_');\n  std::replace(path.begin(), path.end(), '.', '_');\n  transform(path.begin(), path.end(), path.begin(), ::toupper);\n  return path;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StartsWithSingleUnderscore\",\n            \"about\": \"Checks if a string starts with a single underscore.\",\n            \"logic\": \"Checks if the string has at least two characters and if the first character is an underscore and the second character is not an underscore.\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string starts with a single underscore, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool StartsWithSingleUnderscore(const std::string& str) {\n  return str.length() >= 2 && str[0] == '_' && str[1] != '_';\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ReplaceFileContentsIfDifferent\",\n            \"about\": \"Replaces the contents of a file with new contents if they are different.\",\n            \"logic\": \"Reads the existing contents of the file. If the file doesn't exist or the existing contents are different from the new contents, it overwrites the file with the new contents.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file_path\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The path to the file.\"\n                },\n                {\n                    \"name\": \"contents\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The new contents to write to the file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ReplaceFileContentsIfDifferent(const std::string& file_path,\n                                    const std::string& contents) {\n  std::ifstream old_contents_stream(file_path.c_str());\n  std::string old_contents;\n  bool file_exists = false;\n  if (old_contents_stream.good()) {\n    file_exists = true;\n    std::istreambuf_iterator<char> eos;\n    old_contents =\n        std::string(std::istreambuf_iterator<char>(old_contents_stream), eos);\n    old_contents_stream.close();\n  }\n  if (!file_exists || old_contents != contents) {\n    std::ofstream new_contents_stream;\n    new_contents_stream.open(file_path.c_str());\n    new_contents_stream << contents;\n    new_contents_stream.close();\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IfDefScope\",\n            \"about\": \"A RAII class that defines a preprocessor #ifdef scope.\",\n            \"attributes\": [\n                {\n                    \"name\": \"os_\",\n                    \"type\": \"std::ostream&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The output stream to write to.\"\n                },\n                {\n                    \"name\": \"d_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The preprocessor definition.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nIfDefScope::IfDefScope(std::ostream& os, std::string d)\n    : os_(os), d_(std::move(d)) {\n  os_ << \"#ifdef \" << d_ << \"\\n\";\n}\nIfDefScope::~IfDefScope() { os_ << \"#endif  // \" << d_ << \"\\n\"; }\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NamespaceScope\",\n            \"about\": \"A RAII class that defines a namespace scope.\",\n            \"attributes\": [\n                {\n                    \"name\": \"os_\",\n                    \"type\": \"std::ostream&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The output stream to write to.\"\n                },\n                {\n                    \"name\": \"d_\",\n                    \"type\": \"std::initializer_list<std::string>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The namespaces to open.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nNamespaceScope::NamespaceScope(std::ostream& os,\n                               std::initializer_list<std::string> namespaces)\n    : os_(os), d_(std::move(namespaces)) {\n  for (const std::string& s : d_) {\n    os_ << \"namespace \" << s << \" {\\n\";\n  }\n}\nNamespaceScope::~NamespaceScope() {\n  for (auto i = d_.rbegin(); i != d_.rend(); ++i) {\n    os_ << \"}  // namespace \" << *i << \"\\n\";\n  }\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IncludeGuardScope\",\n            \"about\": \"A RAII class that defines an include guard scope.\",\n            \"attributes\": [\n                {\n                    \"name\": \"os_\",\n                    \"type\": \"std::ostream&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The output stream to write to.\"\n                },\n                {\n                    \"name\": \"d_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The include guard definition.\"\n                }\n            ],\n            \"dependencies\": [\n                \"CapifyStringWithUnderscores\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nIncludeGuardScope::IncludeGuardScope(std::ostream& os, std::string file_name)\n    : os_(os),\n      d_(\"V8_GEN_TORQUE_GENERATED_\" + CapifyStringWithUnderscores(file_name) +\n         \"_\") {\n  os_ << \"#ifndef \" << d_ << \"\\n\";\n  os_ << \"#define \" << d_ << \"\\n\\n\";\n}\nIncludeGuardScope::~IncludeGuardScope() { os_ << \"#endif  // \" << d_ << \"\\n\"; }\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IncludeObjectMacrosScope\",\n            \"about\": \"A RAII class that includes object-macros.h and undefines them.\",\n            \"attributes\": [\n                {\n                    \"name\": \"os_\",\n                    \"type\": \"std::ostream&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The output stream to write to.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nIncludeObjectMacrosScope::IncludeObjectMacrosScope(std::ostream& os) : os_(os) {\n  os_ << \"\\n// Has to be the last include (doesn't have include guards):\\n\"\n         \"#include \\\"src/objects/object-macros.h\\\"\\n\";\n}\nIncludeObjectMacrosScope::~IncludeObjectMacrosScope() {\n  os_ << \"\\n#include \\\"src/objects/object-macros-undef.h\\\"\\n\";\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ResidueClass\",\n            \"about\": \"Represents a residue class modulo a power of 2.\",\n            \"attributes\": [\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The value of the residue class.\"\n                },\n                {\n                    \"name\": \"modulus_log_2_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The logarithm base 2 of the modulus.\"\n                }\n            ],\n            \"dependencies\": [\n                \"base::bits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nsize_t ResidueClass::AlignmentLog2() const {\n  if (value_ == 0) return modulus_log_2_;\n  return base::bits::CountTrailingZeros(value_);\n}\n\nconst size_t ResidueClass::kMaxModulusLog2;\n\nstd::ostream& operator<<(std::ostream& os, const ResidueClass& a) {\n  if (a.SingleValue().has_value()) return os << *a.SingleValue();\n  return os << \"[\" << a.value_ << \" mod 2^\" << a.modulus_log_2_ << \"]\";\n}\n        ]]></code>\n    </class>\n</"
}