{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/schedule.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 103, column 48",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/schedule.cc\",\n            \"file_name\": \"schedule.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the scheduling of nodes into basic blocks for the compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for schedule, node properties, node, and output streams.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/schedule.h\"\n\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/utils/ostreams.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BasicBlock\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents a basic block in the control flow graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"loop_number_\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Loop number associated with the block.\"\n                    },\n                    {\n                        \"name\": \"rpo_number_\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reverse postorder number of the block.\"\n                    },\n                    {\n                        \"name\": \"deferred_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if the block is deferred.\"\n                    },\n                    {\n                        \"name\": \"dominator_depth_\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Dominator depth of the block.\"\n                    },\n                    {\n                        \"name\": \"dominator_\",\n                        \"type\": \"BasicBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Dominator of the block.\"\n                    },\n                    {\n                        \"name\": \"rpo_next_\",\n                        \"type\": \"BasicBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Next block in reverse postorder.\"\n                    },\n                    {\n                        \"name\": \"loop_header_\",\n                        \"type\": \"BasicBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Loop header of the loop the block belongs to.\"\n                    },\n                    {\n                        \"name\": \"loop_end_\",\n                        \"type\": \"BasicBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Loop end of the loop the block belongs to.\"\n                    },\n                    {\n                        \"name\": \"loop_depth_\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Nesting depth of the loop the block belongs to.\"\n                    },\n                    {\n                        \"name\": \"control_\",\n                        \"type\": \"Control\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Control type of the block (e.g., kGoto, kBranch).\"\n                    },\n                    {\n                        \"name\": \"control_input_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Node that determines the control flow (e.g., branch condition).\"\n                    },\n                    {\n                        \"name\": \"nodes_\",\n                        \"type\": \"ZoneVector<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of nodes in the block.\"\n                    },\n                    {\n                        \"name\": \"successors_\",\n                        \"type\": \"ZoneVector<BasicBlock*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of successor blocks.\"\n                    },\n                    {\n                        \"name\": \"predecessors_\",\n                        \"type\": \"ZoneVector<BasicBlock*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of predecessor blocks.\"\n                    },\n                    {\n                        \"name\": \"debug_info_\",\n                        \"type\": \"AssemblerDebugInfo\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Debugging information for the block.\"\n                    },\n                    {\n                        \"name\": \"pgo_execution_count_\",\n                        \"type\": \"int64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"PGO execution count for the block.\"\n                    },\n                    {\n                        \"name\": \"id_\",\n                        \"type\": \"Id\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Unique identifier for the block.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Node\",\n                    \"Zone\",\n                    \"AssemblerDebugInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nBasicBlock::BasicBlock(Zone* zone, Id id)\n    : loop_number_(-1),\n      rpo_number_(-1),\n      deferred_(false),\n      dominator_depth_(-1),\n      dominator_(nullptr),\n      rpo_next_(nullptr),\n      loop_header_(nullptr),\n      loop_end_(nullptr),\n      loop_depth_(0),\n      control_(kNone),\n      control_input_(nullptr),\n      nodes_(zone),\n      successors_(zone),\n      predecessors_(zone),\n#if DEBUG\n      debug_info_(AssemblerDebugInfo(nullptr, nullptr, -1)),\n#endif\n#ifdef LOG_BUILTIN_BLOCK_COUNT\n      pgo_execution_count_(0),\n#endif\n      id_(id) {\n}\n\nbool BasicBlock::LoopContains(BasicBlock* block) const {\n  // RPO numbers must be initialized.\n  DCHECK_LE(0, rpo_number_);\n  DCHECK_LE(0, block->rpo_number_);\n  if (loop_end_ == nullptr) return false;  // This is not a loop.\n  return block->rpo_number_ >= rpo_number_ &&\n         block->rpo_number_ < loop_end_->rpo_number_;\n}\n\nvoid BasicBlock::AddSuccessor(BasicBlock* successor) {\n  successors_.push_back(successor);\n}\n\nvoid BasicBlock::AddPredecessor(BasicBlock* predecessor) {\n  predecessors_.push_back(predecessor);\n}\n\nvoid BasicBlock::RemovePredecessor(size_t index) {\n  predecessors_.erase(predecessors_.begin() + index);\n}\n\nvoid BasicBlock::AddNode(Node* node) { nodes_.push_back(node); }\n\nvoid BasicBlock::set_control(Control control) { control_ = control; }\n\nvoid BasicBlock::set_control_input(Node* control_input) {\n  if (!nodes_.empty() && control_input == nodes_.back()) {\n    nodes_.pop_back();\n  }\n  control_input_ = control_input;\n}\n\nvoid BasicBlock::set_loop_depth(int32_t loop_depth) {\n  loop_depth_ = loop_depth;\n}\n\nvoid BasicBlock::set_rpo_number(int32_t rpo_number) {\n  rpo_number_ = rpo_number;\n}\n\nvoid BasicBlock::set_loop_end(BasicBlock* loop_end) { loop_end_ = loop_end; }\n\nvoid BasicBlock::set_loop_header(BasicBlock* loop_header) {\n  loop_header_ = loop_header;\n}\n\nvoid BasicBlock::TrimNodes(iterator new_end) { nodes_.erase(new_end, end()); }\n\nvoid BasicBlock::ResetRPOInfo() {\n  loop_number_ = -1;\n  rpo_number_ = -1;\n  dominator_depth_ = -1;\n  dominator_ = nullptr;\n  rpo_next_ = nullptr;\n  loop_header_ = nullptr;\n  loop_end_ = nullptr;\n  loop_depth_ = 0;\n}\n\n// static\nBasicBlock* BasicBlock::GetCommonDominator(BasicBlock* b1, BasicBlock* b2) {\n  while (b1 != b2) {\n    if (b1->dominator_depth() < b2->dominator_depth()) {\n      b2 = b2->dominator();\n    } else {\n      b1 = b1->dominator();\n    }\n  }\n  return b1;\n}\n\nvoid BasicBlock::Print() { StdoutStream{} << *this << \"\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const BasicBlock& block) {\n  os << \"id:\" << block.id();\n#if DEBUG\n  AssemblerDebugInfo info = block.debug_info();\n  if (info.name) os << info;\n  // Print predecessor blocks for better debugging.\n  const int kMaxDisplayedBlocks = 4;\n  int i = 0;\n  const BasicBlock* current_block = &block;\n  while (current_block->PredecessorCount() > 0 && i++ < kMaxDisplayedBlocks) {\n    current_block = current_block->predecessors().front();\n    os << \" <= id:\" << current_block->id();\n    info = current_block->debug_info();\n    if (info.name) os << info;\n  }\n#endif\n  return os;\n}\n\nstd::ostream& operator<<(std::ostream& os, const BasicBlock::Control& c) {\n  switch (c) {\n    case BasicBlock::kNone:\n      return os << \"none\";\n    case BasicBlock::kGoto:\n      return os << \"goto\";\n    case BasicBlock::kCall:\n      return os << \"call\";\n    case BasicBlock::kBranch:\n      return os << \"branch\";\n    case BasicBlock::kSwitch:\n      return os << \"switch\";\n    case BasicBlock::kDeoptimize:\n      return os << \"deoptimize\";\n    case BasicBlock::kTailCall:\n      return os << \"tailcall\";\n    case BasicBlock::kReturn:\n      return os << \"return\";\n    case BasicBlock::kThrow:\n      return os << \"throw\";\n  }\n  UNREACHABLE();\n}\n\nstd::ostream& operator<<(std::ostream& os, const BasicBlock::Id& id) {\n  return os << id.ToSize();\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Schedule\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Schedules nodes into basic blocks.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating data.\"\n                    },\n                    {\n                        \"name\": \"all_blocks_\",\n                        \"type\": \"ZoneVector<BasicBlock*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of all basic blocks.\"\n                    },\n                    {\n                        \"name\": \"nodeid_to_block_\",\n                        \"type\": \"ZoneVector<BasicBlock*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mapping from node ID to basic block.\"\n                    },\n                    {\n                        \"name\": \"rpo_order_\",\n                        \"type\": \"ZoneVector<BasicBlock*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reverse postorder of basic blocks.\"\n                    },\n                    {\n                        \"name\": \"start_\",\n                        \"type\": \"BasicBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Start block of the schedule.\"\n                    },\n                    {\n                        \"name\": \"end_\",\n                        \"type\": \"BasicBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"End block of the schedule.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BasicBlock\",\n                    \"Node\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSchedule::Schedule(Zone* zone, size_t node_count_hint)\n    : zone_(zone),\n      all_blocks_(zone),\n      nodeid_to_block_(zone),\n      rpo_order_(zone),\n      start_(NewBasicBlock()),\n      end_(NewBasicBlock()) {\n  nodeid_to_block_.reserve(node_count_hint);\n}\n\nBasicBlock* Schedule::block(Node* node) const {\n  if (node->id() < static_cast<NodeId>(nodeid_to_block_.size())) {\n    return nodeid_to_block_[node->id()];\n  }\n  return nullptr;\n}\n\nbool Schedule::IsScheduled(Node* node) {\n  if (node->id() >= nodeid_to_block_.size()) return false;\n  return nodeid_to_block_[node->id()] != nullptr;\n}\n\nBasicBlock* Schedule::GetBlockById(BasicBlock::Id block_id) {\n  DCHECK(block_id.ToSize() < all_blocks_.size());\n  return all_blocks_[block_id.ToSize()];\n}\n\nvoid Schedule::ClearBlockById(BasicBlock::Id block_id) {\n  DCHECK(block_id.ToSize() < all_blocks_.size());\n  all_blocks_[block_id.ToSize()] = nullptr;\n}\n\nbool Schedule::SameBasicBlock(Node* a, Node* b) const {\n  BasicBlock* block = this->block(a);\n  return block != nullptr && block == this->block(b);\n}\n\nBasicBlock* Schedule::NewBasicBlock() {\n  BasicBlock* block = zone_->New<BasicBlock>(\n      zone_, BasicBlock::Id::FromSize(all_blocks_.size()));\n  all_blocks_.push_back(block);\n  return block;\n}\n\nvoid Schedule::PlanNode(BasicBlock* block, Node* node) {\n  if (v8_flags.trace_turbo_scheduler) {\n    StdoutStream{} << \"Planning #\" << node->id() << \":\"\n                   << node->op()->mnemonic()\n                   << \" for future add to id:\" << block->id() << \"\\n\";\n  }\n  DCHECK_NULL(this->block(node));\n  SetBlockForNode(block, node);\n}\n\nvoid Schedule::AddNode(BasicBlock* block, Node* node) {\n  if (v8_flags.trace_turbo_scheduler) {\n    StdoutStream{} << \"Adding #\" << node->id() << \":\" << node->op()->mnemonic()\n                   << \" to id:\" << block->id() << \"\\n\";\n  }\n  DCHECK(this->block(node) == nullptr || this->block(node) == block);\n  block->AddNode(node);\n  SetBlockForNode(block, node);\n}\n\nvoid Schedule::AddGoto(BasicBlock* block, BasicBlock* succ) {\n  CHECK_EQ(BasicBlock::kNone, block->control());\n  block->set_control(BasicBlock::kGoto);\n  AddSuccessor(block, succ);\n}\n\n#if DEBUG\nnamespace {\n\nbool IsPotentiallyThrowingCall(IrOpcode::Value opcode) {\n  switch (opcode) {\n#define BUILD_BLOCK_JS_CASE(Name, ...) case IrOpcode::k##Name:\n    JS_OP_LIST(BUILD_BLOCK_JS_CASE)\n#undef BUILD_BLOCK_JS_CASE\n    case IrOpcode::kCall:\n    case IrOpcode::kFastApiCall:\n      return true;\n    default:\n      return false;\n  }\n}\n\n}  // namespace\n#endif  // DEBUG\n\nvoid Schedule::AddCall(BasicBlock* block, Node* call, BasicBlock* success_block,\n                       BasicBlock* exception_block) {\n  CHECK_EQ(BasicBlock::kNone, block->control());\n  DCHECK(IsPotentiallyThrowingCall(call->opcode()));\n  block->set_control(BasicBlock::kCall);\n  AddSuccessor(block, success_block);\n  AddSuccessor(block, exception_block);\n  SetControlInput(block, call);\n}\n\nvoid Schedule::AddBranch(BasicBlock* block, Node* branch, BasicBlock* tblock,\n                         BasicBlock* fblock) {\n  CHECK_EQ(BasicBlock::kNone, block->control());\n  DCHECK_EQ(IrOpcode::kBranch, branch->opcode());\n  block->set_control(BasicBlock::kBranch);\n  AddSuccessor(block, tblock);\n  AddSuccessor(block, fblock);\n  SetControlInput(block, branch);\n}\n\nvoid Schedule::AddSwitch(BasicBlock* block, Node* sw, BasicBlock** succ_blocks,\n                         size_t succ_count) {\n  CHECK_EQ(BasicBlock::kNone, block->control());\n  DCHECK_EQ(IrOpcode::kSwitch, sw->opcode());\n  block->set_control(BasicBlock::kSwitch);\n  for (size_t index = 0; index < succ_count; ++index) {\n    AddSuccessor(block, succ_blocks[index]);\n  }\n  SetControlInput(block, sw);\n}\n\nvoid Schedule::AddTailCall(BasicBlock* block, Node* input) {\n  CHECK_EQ(BasicBlock::kNone, block->control());\n  block->set_control(BasicBlock::kTailCall);\n  SetControlInput(block, input);\n  if (block != end()) AddSuccessor(block, end());\n}\n\nvoid Schedule::AddReturn(BasicBlock* block, Node* input) {\n  CHECK_EQ(BasicBlock::kNone, block->control());\n  block->set_control(BasicBlock::kReturn);\n  SetControlInput(block, input);\n  if (block != end()) AddSuccessor(block, end());\n}\n\nvoid Schedule::AddDeoptimize(BasicBlock* block, Node* input) {\n  CHECK_EQ(BasicBlock::kNone, block->control());\n  block->set_control(BasicBlock::kDeoptimize);\n  SetControlInput(block, input);\n  if (block != end()) AddSuccessor(block, end());\n}\n\nvoid Schedule::AddThrow(BasicBlock* block, Node* input) {\n  CHECK_EQ(BasicBlock::kNone, block->control());\n  block->set_control(BasicBlock::kThrow);\n  SetControlInput(block, input);\n  if (block != end()) AddSuccessor(block, end());\n}\n\nvoid Schedule::InsertBranch(BasicBlock* block, BasicBlock* end, Node* branch,\n                            BasicBlock* tblock, BasicBlock* fblock) {\n  CHECK_NE(BasicBlock::kNone, block->control());\n  CHECK_EQ(BasicBlock::kNone, end->control());\n  end->set_control(block->control());\n  block->set_control(BasicBlock::kBranch);\n  MoveSuccessors(block, end);\n  AddSuccessor(block, tblock);\n  AddSuccessor(block, fblock);\n  if (block->control_input() != nullptr) {\n    SetControlInput(end, block->control_input());\n  }\n  SetControlInput(block, branch);\n}\n\nvoid Schedule::InsertSwitch(BasicBlock* block, BasicBlock* end, Node* sw,\n                            BasicBlock** succ_blocks, size_t succ_count) {\n  CHECK_NE(BasicBlock::kNone, block->control());\n  CHECK_EQ(BasicBlock::kNone, end->control());\n  end->set_control(block->control());\n  block->set_control(BasicBlock::kSwitch);\n  MoveSuccessors(block, end);\n  for (size_t index = 0; index < succ_count; ++index) {\n    AddSuccessor(block, succ_blocks[index]);\n  }\n  if (block->control_input() != nullptr) {\n    SetControlInput(end, block->control_input());\n  }\n  SetControlInput(block, sw);\n}\n\nvoid Schedule::EnsureCFGWellFormedness() {\n  // Ensure there are no critical edges.\n  for (BasicBlock* block : all_blocks_) {\n    if (block->PredecessorCount() > 1) {\n      if (block != end_) {\n        EnsureSplitEdgeForm(block);\n      }\n    }\n  }\n\n  EliminateRedundantPhiNodes();\n}\n\nvoid Schedule::EliminateRedundantPhiNodes() {\n  // Ensure that useless phi nodes that only have a single input, identical\n  // inputs, or are a self-referential loop phi,\n  // -- which can happen with the automatically generated code in the CSA and\n  // torque -- are pruned.\n  // Since we have strucured control flow, this is enough to minimize the number\n  // of phi nodes.\n  bool reached_fixed_point = false;\n  while (!reached_fixed_point) {\n    reached_fixed_point = true;\n    for (BasicBlock* block : all_blocks_) {\n      int predecessor_count = static_cast<int>(block->PredecessorCount());\n      for (size_t node_pos = 0; node_pos < block->NodeCount(); ++node_pos) {\n        Node* node = block->NodeAt(node_pos);\n        if (node->opcode() == IrOpcode::kPhi) {\n          Node* first_input = node->InputAt(0);\n          bool inputs_equal = true;\n          for (int i = 1; i < predecessor_count; ++i) {\n            Node* input = node->InputAt(i);\n            if (input != first_input && input != node) {\n              inputs_equal = false;\n              break;\n            }\n          }\n          if (!inputs_equal) continue;\n          node->ReplaceUses(first_input);\n          node->Kill();\n          block->RemoveNode(block->begin() + node_pos);\n          --node_pos;\n          reached_fixed_point = false;\n        }\n      }\n    }\n  }\n}\n\nvoid Schedule::EnsureSplitEdgeForm(BasicBlock* block) {\n#ifdef DEBUG\n  DCHECK(block->PredecessorCount() > 1 && block != end_);\n  for (auto current_pred = block->predecessors().begin();\n       current_pred != block->predecessors().end(); ++current_pred) {\n    BasicBlock* pred = *current_pred;\n    DCHECK_LE(pred->SuccessorCount(), 1);\n  }\n#endif\n}\n\nvoid Schedule::MovePhis(BasicBlock* from, BasicBlock* to) {\n  for (size_t i = 0; i < from->NodeCount();) {\n    Node* node = from->NodeAt(i);\n    if (node->opcode() == IrOpcode::kPhi) {\n      to->AddNode(node);\n      from->RemoveNode(from->begin() + i);\n      DCHECK_EQ(nodeid_to_block_[node->id()], from);\n      nodeid_to_block_[node->id()] = to;\n    } else {\n      ++i;\n    }\n  }\n}\n\nvoid Schedule::PropagateDeferredMark() {\n  // Push forward the deferred block marks through newly inserted blocks and\n  // other improperly marked blocks until a fixed point is reached.\n  // TODO(danno): optimize the propagation\n  bool done = false;\n  while (!done) {\n    done = true;\n    for (auto block : all_blocks_) {\n      if (!block->deferred()) {\n        bool deferred = block->PredecessorCount() > 0;\n        for (auto pred : block->predecessors()) {\n          if (!pred->deferred() && (pred->rpo_number() < block->rpo_number())) {\n            deferred = false;\n          }\n        }\n        if (deferred) {\n          block->set_deferred(true);\n          done = false;\n        }\n      }\n    }\n  }\n}\n\nvoid Schedule::AddSuccessor(BasicBlock* block, BasicBlock* succ) {\n  block->AddSuccessor(succ);\n  succ->AddPredecessor(block);\n}\n\nvoid Schedule::MoveSuccessors(BasicBlock* from, BasicBlock* to) {\n  for (BasicBlock* const successor : from->successors()) {\n    to->AddSuccessor(successor);\n    for (BasicBlock*& predecessor : successor->predecessors()) {\n      if (predecessor == from) predecessor = to;\n    }\n  }\n  from->ClearSuccessors();\n}\n\nvoid Schedule::SetControlInput(BasicBlock* block, Node* node) {\n  block->set_control_input(node);\n  SetBlockForNode(block, node);\n}\n\nvoid Schedule::SetBlockForNode(BasicBlock* block, Node* node) {\n  if (node->id() >= nodeid_to_block_.size()) {\n    nodeid_to_block_.resize(node->id() + 1);\n  }\n  nodeid_to_block_[node->id()] = block;\n}\n\nstd::ostream& operator<<(std::ostream& os, const Schedule& s) {\n  for (BasicBlock* block :\n       ((s.RpoBlockCount() == 0) ? *s.all_blocks() : *s.rpo_order())) {\n    if (block == nullptr) continue;\n    os << \"--- BLOCK B\" << block->rpo_number() << \" id\" << block->id();\n#ifdef LOG_BUILTIN_BLOCK_COUNT\n    os << \" PGO Execution Count:\" << block->pgo_execution_count();\n#endif\n    if (block->deferred()) os << \" (deferred)\";\n    if (block->PredecessorCount() != 0) os << \" <- \";\n    bool comma = false;\n    for (BasicBlock const* predecessor : block->predecessors()) {\n      if (comma) os << \", \";\n      comma = true;\n      os << \"B\" << predecessor->rpo_number();\n    }\n    os << \" ---\\n\";\n    for (Node* node : *block) {\n      os << \"  \" << *node;\n      if (NodeProperties::IsTyped(node)) {\n        os << \" : \" << NodeProperties::GetType(node);\n      }\n      os << \"\\n\";\n    }\n    BasicBlock::Control control = block->control();\n    if (control != BasicBlock::kNone) {\n      os << \"  \";\n      if (block->control_input() != nullptr) {\n        os << *block->control_input();\n      } else {\n        os << \"Goto\";\n      }\n      os << \" -> \";\n      comma = false;\n      for (BasicBlock const* successor : block->successors()) {\n        if (comma) os << \", \";\n        comma = true;\n        os << \"B\" << successor->rpo_number();\n      }\n      os << \"\\n\";\n    }\n  }\n  return os;\n}\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Node\",\n                    \"about\": \"Represents a node in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Node {\n                public:\n                    IrOpcode::Value opcode() const;\n                    NodeId id() const;\n                    Node* InputAt(int i) const;\n                    void ReplaceUses(Node* other);\n                    void Kill();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"Memory allocation zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Zone {\n                public:\n                    template <typename T>\n                    T* New();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"StdoutStream\",\n                    \"about\": \"Output stream to stdout.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class StdoutStream {};\n                StdoutStream& operator<<(StdoutStream& os, const char* str);\n                StdoutStream& operator<<(StdoutStream& os, int value);\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NodeProperties\",\n                    \"about\": \"Provides properties for nodes.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class NodeProperties {\n                public:\n                    static bool IsTyped(Node* node);\n                    static Type GetType(Node* node);\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}