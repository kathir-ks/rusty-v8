{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/bytecode-analysis.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 198, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/bytecode-analysis.h\",\n        \"file_name\": \"bytecode-analysis.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Header file for bytecode analysis functionality, including loop detection, loop assignments, and liveness analysis.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include standard library and V8 specific headers for data structures and functionality.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n\n            #include \"src/compiler/bytecode-liveness-map.h\"\n            #include \"src/handles/handles.h\"\n            #include \"src/interpreter/bytecode-register.h\"\n            #include \"src/utils/bit-vector.h\"\n            #include \"src/utils/utils.h\"\n            #include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BytecodeLoopAssignments\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents assignments to registers within a bytecode loop.\",\n            \"attributes\": [\n                {\n                    \"name\": \"parameter_count_\",\n                    \"type\": \"int const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of parameters in the bytecode array.\"\n                },\n                {\n                    \"name\": \"bit_vector_\",\n                    \"type\": \"BitVector* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Bit vector representing assigned registers.\"\n                }\n            ],\n            \"dependencies\": [\n                \"BitVector\",\n                \"interpreter::Register\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE BytecodeLoopAssignments {\n            public:\n            BytecodeLoopAssignments(int parameter_count, int register_count, Zone* zone);\n\n            void Add(interpreter::Register r);\n            void AddList(interpreter::Register r, uint32_t count);\n            void Union(const BytecodeLoopAssignments& other);\n\n            bool ContainsParameter(int index) const;\n            bool ContainsLocal(int index) const;\n\n            int parameter_count() const { return parameter_count_; }\n            int local_count() const { return bit_vector_->length() - parameter_count_; }\n\n            private:\n            int const parameter_count_;\n            BitVector* const bit_vector_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ResumeJumpTarget\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents jump targets for resuming a suspended generator.\",\n            \"attributes\": [\n                {\n                    \"name\": \"suspend_id_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The suspend id of the resume.\"\n                },\n                {\n                    \"name\": \"target_offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The target offset of this resume jump.\"\n                },\n                {\n                    \"name\": \"final_target_offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The final offset of this resume, which may be across multiple jumps.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE ResumeJumpTarget {\n            public:\n            // Create a resume jump target representing an actual resume.\n            static ResumeJumpTarget Leaf(int suspend_id, int target_offset);\n\n            // Create a resume jump target at a loop header, which will have another\n            // resume jump after the loop header is crossed.\n            static ResumeJumpTarget AtLoopHeader(int loop_header_offset,\n                                                const ResumeJumpTarget& next);\n\n            int suspend_id() const { return suspend_id_; }\n            int target_offset() const { return target_offset_; }\n            bool is_leaf() const { return target_offset_ == final_target_offset_; }\n\n            private:\n            // The suspend id of the resume.\n            int suspend_id_;\n            // The target offset of this resume jump.\n            int target_offset_;\n            // The final offset of this resume, which may be across multiple jumps.\n            int final_target_offset_;\n\n            ResumeJumpTarget(int suspend_id, int target_offset, int final_target_offset);\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"LoopInfo\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Stores information about a bytecode loop, including its start, end, parent, and assigned registers.\",\n            \"attributes\": [\n                {\n                    \"name\": \"parent_offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The offset to the parent loop, or -1 if there is no parent.\"\n                },\n                {\n                    \"name\": \"loop_start_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Start offset of the loop.\"\n                },\n                {\n                    \"name\": \"loop_end_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"End offset of the loop.\"\n                },\n                {\n                    \"name\": \"resumable_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the loop is resumable (generator function).\"\n                },\n                {\n                    \"name\": \"innermost_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the loop is the innermost loop.\"\n                },\n                {\n                    \"name\": \"assignments_\",\n                    \"type\": \"BytecodeLoopAssignments\",\n                    \"access\": \"private\",\n                    \"purpose\": \"BytecodeLoopAssignments object to track assigned registers in loop.\"\n                },\n                {\n                    \"name\": \"resume_jump_targets_\",\n                    \"type\": \"ZoneVector<ResumeJumpTarget>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of ResumeJumpTarget objects representing jump targets for resuming the loop.\"\n                }\n            ],\n            \"dependencies\": [\n                \"BytecodeLoopAssignments\",\n                \"ResumeJumpTarget\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct V8_EXPORT_PRIVATE LoopInfo {\n            public:\n            LoopInfo(int parent_offset, int loop_start, int loop_end, int parameter_count,\n                    int register_count, Zone* zone)\n                : parent_offset_(parent_offset),\n                loop_start_(loop_start),\n                loop_end_(loop_end),\n                assignments_(parameter_count, register_count, zone),\n                resume_jump_targets_(zone) {}\n\n            int parent_offset() const { return parent_offset_; }\n            int loop_start() const { return loop_start_; }\n            int loop_end() const { return loop_end_; }\n            bool resumable() const { return resumable_; }\n            void mark_resumable() { resumable_ = true; }\n            bool innermost() const { return innermost_; }\n            void mark_not_innermost() { innermost_ = false; }\n\n            bool Contains(int offset) const {\n                return offset >= loop_start_ && offset < loop_end_;\n            }\n\n            const ZoneVector<ResumeJumpTarget>& resume_jump_targets() const {\n                return resume_jump_targets_;\n            }\n            void AddResumeTarget(const ResumeJumpTarget& target) {\n                resume_jump_targets_.push_back(target);\n            }\n\n            BytecodeLoopAssignments& assignments() { return assignments_; }\n            const BytecodeLoopAssignments& assignments() const { return assignments_; }\n\n            private:\n            // The offset to the parent loop, or -1 if there is no parent.\n            int parent_offset_;\n            int loop_start_;\n            int loop_end_;\n            bool resumable_ = false;\n            bool innermost_ = true;\n            BytecodeLoopAssignments assignments_;\n            ZoneVector<ResumeJumpTarget> resume_jump_targets_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BytecodeAnalysis\",\n            \"extends\": \"ZoneObject\",\n            \"implements\": [],\n            \"about\": \"Analyzes bytecode to find loop ranges, loop nesting, loop assignments and liveness.\",\n            \"attributes\": [\n                {\n                    \"name\": \"osr_bailout_id_\",\n                    \"type\": \"BytecodeOffset const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Bytecode offset for on-stack replacement (OSR) bailout.\"\n                },\n                {\n                    \"name\": \"analyze_liveness_\",\n                    \"type\": \"bool const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether liveness analysis was performed.\"\n                },\n                {\n                    \"name\": \"resume_jump_targets_\",\n                    \"type\": \"ZoneVector<ResumeJumpTarget>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of resume jump targets.\"\n                },\n                {\n                    \"name\": \"end_to_header_\",\n                    \"type\": \"ZoneMap<int, int>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map from loop end offset to loop header offset.\"\n                },\n                {\n                    \"name\": \"header_to_info_\",\n                    \"type\": \"ZoneMap<int, LoopInfo>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map from loop header offset to LoopInfo.\"\n                },\n                {\n                    \"name\": \"osr_entry_point_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Bytecode offset of the OSR entry point.\"\n                },\n                {\n                    \"name\": \"liveness_map_\",\n                    \"type\": \"std::optional<BytecodeLivenessMap>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Optional liveness map containing liveness information for each bytecode.\"\n                },\n                {\n                    \"name\": \"bytecode_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of bytecodes in the bytecode array.\"\n                }\n            ],\n            \"dependencies\": [\n                \"BytecodeLivenessMap\",\n                \"LoopInfo\",\n                \"ResumeJumpTarget\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE BytecodeAnalysis : public ZoneObject {\n            public:\n            BytecodeAnalysis(Handle<BytecodeArray> bytecode_array, Zone* zone,\n                            BytecodeOffset osr_bailout_id, bool analyze_liveness);\n            BytecodeAnalysis(const BytecodeAnalysis&) = delete;\n            BytecodeAnalysis& operator=(const BytecodeAnalysis&) = delete;\n\n            // Return true if the given offset is a loop header\n            bool IsLoopHeader(int offset) const;\n            // Get the loop header offset of the containing loop for arbitrary\n            // {offset}, or -1 if the {offset} is not inside any loop.\n            int GetLoopOffsetFor(int offset) const;\n            // Get the loop end offset given the header offset of an innermost loop\n            int GetLoopEndOffsetForInnermost(int header_offset) const;\n            // Get the loop info of the loop header at {header_offset}.\n            const LoopInfo& GetLoopInfoFor(int header_offset) const;\n            // Try to get the loop info of the loop header at {header_offset}, returning\n            // null if there isn't any.\n            const LoopInfo* TryGetLoopInfoFor(int header_offset) const;\n\n            const ZoneMap<int, LoopInfo>& GetLoopInfos() const { return header_to_info_; }\n\n            // Get the top-level resume jump targets.\n            const ZoneVector<ResumeJumpTarget>& resume_jump_targets() const {\n                return resume_jump_targets_;\n            }\n\n            // Gets the in-/out-liveness for the bytecode at {offset}.\n            const BytecodeLivenessState* GetInLivenessFor(int offset) const;\n            const BytecodeLivenessState* GetOutLivenessFor(int offset) const;\n\n            // In the case of OSR, the analysis also computes the (bytecode offset of the)\n            // OSR entry point from the {osr_bailout_id} that was given to the\n            // constructor.\n            int osr_entry_point() const {\n                CHECK_LE(0, osr_entry_point_);\n                return osr_entry_point_;\n            }\n            // Return the osr_bailout_id (for verification purposes).\n            BytecodeOffset osr_bailout_id() const { return osr_bailout_id_; }\n\n            // Return whether liveness analysis was performed (for verification purposes).\n            bool liveness_analyzed() const { return analyze_liveness_; }\n\n            // Return the number of bytecodes (i.e. the number of bytecode operations, as\n            // opposed to the number of bytes in the bytecode).\n            int bytecode_count() const { return bytecode_count_; }\n\n            private:\n            BytecodeLivenessMap& liveness_map() {\n                DCHECK(analyze_liveness_);\n                return *liveness_map_;\n            }\n            const BytecodeLivenessMap& liveness_map() const {\n                DCHECK(analyze_liveness_);\n                return *liveness_map_;\n            }\n\n            BytecodeOffset const osr_bailout_id_;\n            bool const analyze_liveness_;\n            ZoneVector<ResumeJumpTarget> resume_jump_targets_;\n            ZoneMap<int, int> end_to_header_;\n            ZoneMap<int, LoopInfo> header_to_info_;\n            int osr_entry_point_;\n            std::optional<BytecodeLivenessMap> liveness_map_;\n            int bytecode_count_ = -1;\n\n            class BytecodeAnalysisImpl;\n            friend class BytecodeAnalysisImpl;\n            };\n        ]]></code>\n    </class>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BytecodeArray\",\n                \"about\": \"Represents an array of bytecodes.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BytecodeArray;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BytecodeLivenessMap\",\n                \"about\": \"Stores liveness information for bytecodes.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BytecodeLivenessMap;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BytecodeLivenessState\",\n                \"about\": \"Represents the liveness state of registers at a specific bytecode offset.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BytecodeLivenessState;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneObject\",\n                \"about\": \"Base class for zone-allocated objects in V8.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ZoneObject;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Zone\",\n                \"about\": \"Memory allocation zone in V8.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Zone;\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}