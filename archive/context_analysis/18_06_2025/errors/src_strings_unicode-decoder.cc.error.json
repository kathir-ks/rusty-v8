{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/strings/unicode-decoder.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 107, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/strings/unicode-decoder.cc\",\n            \"file_name\": \"unicode-decoder.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides classes for decoding UTF-8 encoded strings into UTF-16 strings, handling different UTF-8 variants and error conditions.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for Unicode decoding, string manipulation, and memory operations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/strings/unicode-decoder.h\"\n\n#include \"src/strings/unicode-inl.h\"\n#include \"src/utils/memcopy.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"third_party/utf8-decoder/generalized-utf8-decoder.h\"\n#endif\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::internal\",\n                \"purpose\": \"Encapsulates the Unicode decoder implementation within the V8 internal namespace.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"anonymous\",\n                \"purpose\": \"Contains helper structs and functions specific to the Unicode decoder implementation, hidden from external access.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\ntemplate <class Decoder>\nstruct DecoderTraits;\n\ntemplate <>\nstruct DecoderTraits<Utf8Decoder> {\n  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {\n    // The DfaDecoder will only ever decode Unicode scalar values, and all\n    // sequences of USVs are valid.\n    DCHECK(!unibrow::Utf16::IsLeadSurrogate(trail));\n    DCHECK(!unibrow::Utf16::IsTrailSurrogate(trail));\n    return false;\n  }\n  static const bool kAllowIncompleteSequences = true;\n  using DfaDecoder = Utf8DfaDecoder;\n};\n\n#if V8_ENABLE_WEBASSEMBLY\ntemplate <>\nstruct DecoderTraits<Wtf8Decoder> {\n  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {\n    return unibrow::Utf16::IsSurrogatePair(lead, trail);\n  }\n  static const bool kAllowIncompleteSequences = false;\n  using DfaDecoder = GeneralizedUtf8DfaDecoder;\n};\n\ntemplate <>\nstruct DecoderTraits<StrictUtf8Decoder> {\n  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {\n    // The DfaDecoder will only ever decode Unicode scalar values, and all\n    // sequences of USVs are valid.\n    DCHECK(!unibrow::Utf16::IsLeadSurrogate(trail));\n    DCHECK(!unibrow::Utf16::IsTrailSurrogate(trail));\n    return false;\n  }\n  static const bool kAllowIncompleteSequences = false;\n  using DfaDecoder = Utf8DfaDecoder;\n};\n#endif  // V8_ENABLE_WEBASSEMBLY\n}  // namespace\n        ]]></code>\n    </namespace>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"DecoderTraits<Utf8Decoder>\",\n                \"about\": \"Specialization of DecoderTraits for Utf8Decoder, defining specific behavior for UTF-8 decoding.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Utf8Decoder\",\n                    \"unibrow::Utf16\",\n                    \"Utf8DfaDecoder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nstruct DecoderTraits<Utf8Decoder> {\n  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {\n    // The DfaDecoder will only ever decode Unicode scalar values, and all\n    // sequences of USVs are valid.\n    DCHECK(!unibrow::Utf16::IsLeadSurrogate(trail));\n    DCHECK(!unibrow::Utf16::IsTrailSurrogate(trail));\n    return false;\n  }\n  static const bool kAllowIncompleteSequences = true;\n  using DfaDecoder = Utf8DfaDecoder;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"DecoderTraits<Wtf8Decoder>\",\n                \"about\": \"Specialization of DecoderTraits for Wtf8Decoder, defining specific behavior for WTF-8 decoding.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Wtf8Decoder\",\n                    \"unibrow::Utf16\",\n                    \"GeneralizedUtf8DfaDecoder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\ntemplate <>\nstruct DecoderTraits<Wtf8Decoder> {\n  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {\n    return unibrow::Utf16::IsSurrogatePair(lead, trail);\n  }\n  static const bool kAllowIncompleteSequences = false;\n  using DfaDecoder = GeneralizedUtf8DfaDecoder;\n};\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"DecoderTraits<StrictUtf8Decoder>\",\n                \"about\": \"Specialization of DecoderTraits for StrictUtf8Decoder, defining specific behavior for strict UTF-8 decoding.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"StrictUtf8Decoder\",\n                    \"unibrow::Utf16\",\n                    \"Utf8DfaDecoder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\ntemplate <>\nstruct DecoderTraits<StrictUtf8Decoder> {\n  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {\n    // The DfaDecoder will only ever decode Unicode scalar values, and all\n    // sequences of USVs are valid.\n    DCHECK(!unibrow::Utf16::IsLeadSurrogate(trail));\n    DCHECK(!unibrow::Utf16::IsTrailSurrogate(trail));\n    return false;\n  }\n  static const bool kAllowIncompleteSequences = false;\n  using DfaDecoder = Utf8DfaDecoder;\n};\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Utf8DecoderBase\",\n                \"about\": \"Base class for UTF-8 decoders, providing common functionality for decoding UTF-8 encoded strings.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"encoding_\",\n                        \"type\": \"Encoding\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the detected encoding of the UTF-8 string.\"\n                    },\n                    {\n                        \"name\": \"non_ascii_start_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the index of the first non-ASCII character in the string.\"\n                    },\n                    {\n                        \"name\": \"utf16_length_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the length of the decoded UTF-16 string.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"base::Vector\",\n                    \"Encoding\",\n                    \"DecoderTraits\",\n                    \"Utf8Decoder\",\n                    \"Wtf8Decoder\",\n                    \"StrictUtf8Decoder\",\n                    \"NonAsciiStart\",\n                    \"unibrow::Utf8\",\n                    \"unibrow::Latin1\",\n                    \"unibrow::Utf16\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Decoder>\nUtf8DecoderBase<Decoder>::Utf8DecoderBase(base::Vector<const uint8_t> data)\n    : encoding_(Encoding::kAscii),\n      non_ascii_start_(NonAsciiStart(data.begin(), data.length())),\n      utf16_length_(non_ascii_start_) {\n  using Traits = DecoderTraits<Decoder>;\n  if (non_ascii_start_ == data.length()) return;\n\n  bool is_one_byte = true;\n  auto state = Traits::DfaDecoder::kAccept;\n  uint32_t current = 0;\n  uint32_t previous = 0;\n  const uint8_t* cursor = data.begin() + non_ascii_start_;\n  const uint8_t* end = data.begin() + data.length();\n\n  while (cursor < end) {\n    if (V8_LIKELY(*cursor <= unibrow::Utf8::kMaxOneByteChar &&\n                  state == Traits::DfaDecoder::kAccept)) {\n      DCHECK_EQ(0u, current);\n      DCHECK(!Traits::IsInvalidSurrogatePair(previous, *cursor));\n      previous = *cursor;\n      utf16_length_++;\n      cursor++;\n      continue;\n    }\n\n    auto previous_state = state;\n    Traits::DfaDecoder::Decode(*cursor, &state, &current);\n    if (state < Traits::DfaDecoder::kAccept) {\n      DCHECK_EQ(state, Traits::DfaDecoder::kReject);\n      if (Traits::kAllowIncompleteSequences) {\n        state = Traits::DfaDecoder::kAccept;\n        static_assert(unibrow::Utf8::kBadChar > unibrow::Latin1::kMaxChar);\n        is_one_byte = false;\n        utf16_length_++;\n        previous = unibrow::Utf8::kBadChar;\n        current = 0;\n        // If we were trying to continue a multibyte sequence, try this byte\n        // again.\n        if (previous_state != Traits::DfaDecoder::kAccept) continue;\n      } else {\n        encoding_ = Encoding::kInvalid;\n        return;\n      }\n    } else if (state == Traits::DfaDecoder::kAccept) {\n      if (Traits::IsInvalidSurrogatePair(previous, current)) {\n        encoding_ = Encoding::kInvalid;\n        return;\n      }\n      is_one_byte = is_one_byte && current <= unibrow::Latin1::kMaxChar;\n      utf16_length_++;\n      if (current > unibrow::Utf16::kMaxNonSurrogateCharCode) utf16_length_++;\n      previous = current;\n      current = 0;\n    }\n    cursor++;\n  }\n\n  if (state == Traits::DfaDecoder::kAccept) {\n    encoding_ = is_one_byte ? Encoding::kLatin1 : Encoding::kUtf16;\n  } else if (Traits::kAllowIncompleteSequences) {\n    static_assert(unibrow::Utf8::kBadChar > unibrow::Latin1::kMaxChar);\n    encoding_ = Encoding::kUtf16;\n    utf16_length_++;\n  } else {\n    encoding_ = Encoding::kInvalid;\n  }\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Utf8DecoderBase::Decode\",\n                \"parent\": \"Utf8DecoderBase\",\n                \"about\": \"Decodes a UTF-8 encoded string to a character array of type Char.\",\n                \"logic\": \"Iterates through the UTF-8 input, using a DFA decoder (defined by the Decoder template parameter) to process multi-byte sequences and convert them to UTF-16 characters. Handles invalid or incomplete sequences based on decoder traits.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"out\",\n                        \"type\": \"Char*\",\n                        \"purpose\": \"Pointer to the output character array.\"\n                    },\n                    {\n                        \"name\": \"data\",\n                        \"type\": \"base::Vector<const uint8_t>\",\n                        \"purpose\": \"Input UTF-8 encoded data.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"DecoderTraits\",\n                    \"unibrow::Utf8\",\n                    \"unibrow::Utf16\",\n                    \"CopyChars\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Decoder>\ntemplate <typename Char>\nvoid Utf8DecoderBase<Decoder>::Decode(Char* out,\n                                      base::Vector<const uint8_t> data) {\n  using Traits = DecoderTraits<Decoder>;\n  DCHECK(!is_invalid());\n  CopyChars(out, data.begin(), non_ascii_start_);\n\n  out += non_ascii_start_;\n\n  auto state = Traits::DfaDecoder::kAccept;\n  uint32_t current = 0;\n  const uint8_t* cursor = data.begin() + non_ascii_start_;\n  const uint8_t* end = data.begin() + data.length();\n\n  while (cursor < end) {\n    if (V8_LIKELY(*cursor <= unibrow::Utf8::kMaxOneByteChar &&\n                  state == Traits::DfaDecoder::kAccept)) {\n      DCHECK_EQ(0u, current);\n      *(out++) = static_cast<Char>(*cursor);\n      cursor++;\n      continue;\n    }\n\n    auto previous_state = state;\n    Traits::DfaDecoder::Decode(*cursor, &state, &current);\n    if (Traits::kAllowIncompleteSequences &&\n        state < Traits::DfaDecoder::kAccept) {\n      state = Traits::DfaDecoder::kAccept;\n      *(out++) = static_cast<Char>(unibrow::Utf8::kBadChar);\n      current = 0;\n      // If we were trying to continue a multibyte sequence, try this byte\n      // again.\n      if (previous_state != Traits::DfaDecoder::kAccept) continue;\n    } else if (state == Traits::DfaDecoder::kAccept) {\n      if (sizeof(Char) == 1 ||\n          current <= unibrow::Utf16::kMaxNonSurrogateCharCode) {\n        *(out++) = static_cast<Char>(current);\n      } else {\n        *(out++) = unibrow::Utf16::LeadSurrogate(current);\n        *(out++) = unibrow::Utf16::TrailSurrogate(current);\n      }\n      current = 0;\n    }\n    cursor++;\n  }\n\n  if (Traits::kAllowIncompleteSequences &&\n      state != Traits::DfaDecoder::kAccept) {\n    *out = static_cast<Char>(unibrow::Utf8::kBadChar);\n  } else {\n    DCHECK_EQ(state, Traits::DfaDecoder::kAccept);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"DEFINE_UNICODE_DECODER\",\n                \"about\": \"A macro used to instantiate the Utf8DecoderBase class and its Decode method for a specific decoder type.\",\n                \"logic\": \"The macro takes a decoder type as input and generates explicit template instantiations for the constructor and the Decode method with uint8_t* and uint16_t* as output types.  This is required because the template class is defined in a header file, and the compiler needs to know which instantiations are used in the library.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value. Generates template instantiations.\"\n                },\n                \"dependencies\": [\n                    \"Utf8DecoderBase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define DEFINE_UNICODE_DECODER(Decoder)                                 \\\n  template V8_EXPORT_PRIVATE Utf8DecoderBase<Decoder>::Utf8DecoderBase( \\\n      base::Vector<const uint8_t> data);                                \\\n  template V8_EXPORT_PRIVATE void Utf8DecoderBase<Decoder>::Decode(     \\\n      uint8_t* out, base::Vector<const uint8_t> data);                  \\\n  template V8_EXPORT_PRIVATE void Utf8DecoderBase<Decoder>::Decode(     \\\n      uint16_t* out, base::Vector<const uint8_t> data)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"instantiation\",\n                \"name\": \"Utf8DecoderBase<Utf8Decoder>\",\n                \"about\": \"Explicitly instantiates the Utf8DecoderBase class with Utf8Decoder.\",\n                \"logic\": \"This instantiation makes the Utf8DecoderBase class and its member functions available for use with the Utf8Decoder.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value. Generates class specializations.\"\n                },\n                \"dependencies\": [\n                    \"Utf8DecoderBase\",\n                    \"Utf8Decoder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDEFINE_UNICODE_DECODER(Utf8Decoder);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"instantiation\",\n                \"name\": \"Utf8DecoderBase<Wtf8Decoder>\",\n                \"about\": \"Explicitly instantiates the Utf8DecoderBase class with Wtf8Decoder.\",\n                \"logic\": \"This instantiation makes the Utf8DecoderBase class and its member functions available for use with the Wtf8Decoder.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value. Generates class specializations.\"\n                },\n                \"dependencies\": [\n                    \"Utf8DecoderBase\",\n                    \"Wtf8Decoder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\nDEFINE_UNICODE_DECODER(Wtf8Decoder);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"instantiation\",\n                \"name\": \"Utf8DecoderBase<StrictUtf8Decoder>\",\n                \"about\": \"Explicitly instantiates the Utf8DecoderBase class with StrictUtf8Decoder.\",\n                \"logic\": \"This instantiation makes the Utf8DecoderBase class and its member functions available for use with the StrictUtf8Decoder.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value. Generates class specializations.\"\n                },\n                \"dependencies\": [\n                    \"Utf8DecoderBase\",\n                    \"StrictUtf8Decoder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDEFINE_UNICODE_DECODER(StrictUtf8Decoder);\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </func>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::internal\",\n                \"purpose\": \"Closes the v8::internal namespace.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#undef DEFINE_UNICODE_DECODER\n\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </namespace>\n</file>\n```"
}