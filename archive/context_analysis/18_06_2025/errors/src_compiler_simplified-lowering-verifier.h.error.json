{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-lowering-verifier.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 195, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-lowering-verifier.h\",\n            \"file_name\": \"simplified-lowering-verifier.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the SimplifiedLoweringVerifier class for verifying the correctness of the simplified lowering phase in the V8 compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for optional types, container utilities, opcodes, and representation changes.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/container-utils.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/representation-change.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Verifies the correctness of the simplified lowering phase in the V8 compiler.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OperationTyper\",\n                    \"Zone\",\n                    \"TFGraph\",\n                    \"Node\",\n                    \"Type\",\n                    \"Truncation\",\n                    \"IrOpcode\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass SimplifiedLoweringVerifier final {\n public:\n  struct PerNodeData {\n    std::optional<Type> type = std::nullopt;\n    Truncation truncation = Truncation::Any(IdentifyZeros::kDistinguishZeros);\n  };\n\n  SimplifiedLoweringVerifier(Zone* zone, TFGraph* graph)\n      : hints_(zone),\n        machine_uses_of_constants_(zone),\n        data_(zone),\n        graph_(graph),\n        zone_(zone) {}\n\n  void VisitNode(Node* node, OperationTyper& op_typer);\n\n  void RecordHint(Node* node) {\n    DCHECK_EQ(node->opcode(), IrOpcode::kSLVerifierHint);\n    hints_.push_back(node);\n  }\n  const ZoneVector<Node*>& inserted_hints() const { return hints_; }\n  void RecordMachineUsesOfConstant(Node* constant, Node::Uses uses) {\n    DCHECK(IrOpcode::IsMachineConstantOpcode(constant->opcode()));\n    auto it = machine_uses_of_constants_.find(constant);\n    if (it == machine_uses_of_constants_.end()) {\n      it =\n          machine_uses_of_constants_.emplace(constant, ZoneVector<Node*>(zone_))\n              .first;\n    }\n    base::vector_append(it->second, uses);\n  }\n  const ZoneUnorderedMap<Node*, ZoneVector<Node*>>& machine_uses_of_constants()\n      const {\n    return machine_uses_of_constants_;\n  }\n\n  std::optional<Type> GetType(Node* node) const {\n    if (NodeProperties::IsTyped(node)) {\n      Type type = NodeProperties::GetType(node);\n      // We do not use the static type for constants, even if we have one,\n      // because those are cached in the graph and shared between machine\n      // and non-machine subgraphs. The former might have assigned\n      // Type::Machine() to them.\n      if (IrOpcode::IsMachineConstantOpcode(node->opcode())) {\n        DCHECK(type.Is(Type::Machine()));\n      } else {\n        return type;\n      }\n    }\n    // For nodes that have not been typed before SL, we use the type that has\n    // been inferred by the verifier.\n    if (node->id() < data_.size()) {\n      return data_[node->id()].type;\n    }\n    return std::nullopt;\n  }\n\n private:\n  void ResizeDataIfNecessary(Node* node) {\n    if (data_.size() <= node->id()) {\n      data_.resize(node->id() + 1);\n    }\n    DCHECK_EQ(data_[node->id()].truncation,\n              Truncation::Any(IdentifyZeros::kDistinguishZeros));\n  }\n\n  void SetType(Node* node, const Type& type) {\n    ResizeDataIfNecessary(node);\n    data_[node->id()].type = type;\n  }\n\n  Type InputType(Node* node, int input_index) const {\n    // TODO(nicohartmann): Check that inputs are typed, once all operators are\n    // supported.\n    auto type_opt = GetType(node->InputAt(input_index));\n    return type_opt.has_value() ? *type_opt : Type::None();\n  }\n\n  void SetTruncation(Node* node, const Truncation& truncation) {\n    ResizeDataIfNecessary(node);\n    data_[node->id()].truncation = truncation;\n  }\n\n  Truncation InputTruncation(Node* node, int input_index) const {\n    static const Truncation any_truncation =\n        Truncation::Any(IdentifyZeros::kDistinguishZeros);\n\n    Node* input = node->InputAt(input_index);\n    if (input->id() < data_.size()) {\n      return data_[input->id()].truncation;\n    }\n    return any_truncation;\n  }\n\n  void CheckType(Node* node, const Type& type);\n  void CheckAndSet(Node* node, const Type& type, const Truncation& trunc);\n  void ReportInvalidTypeCombination(Node* node, const std::vector<Type>& types);\n\n  // Generalize to a less strict truncation in the context of a given type. For\n  // example, a Truncation::kWord32[kIdentifyZeros] does not have any effect on\n  // a type Range(0, 100), because all equivalence classes are singleton, for\n  // the values of the given type. We can use Truncation::Any[kDistinguishZeros]\n  // instead to avoid a combinatorial explosion of occurring type-truncation-\n  // pairs.\n  Truncation GeneralizeTruncation(const Truncation& truncation,\n                                  const Type& type) const;\n  Truncation JoinTruncation(const Truncation& t1, const Truncation& t2);\n  Truncation JoinTruncation(const Truncation& t1, const Truncation& t2,\n                            const Truncation& t3) {\n    return JoinTruncation(JoinTruncation(t1, t2), t3);\n  }\n\n  Zone* graph_zone() const { return graph_->zone(); }\n\n  ZoneVector<Node*> hints_;\n  ZoneUnorderedMap<Node*, ZoneVector<Node*>> machine_uses_of_constants_;\n  ZoneVector<PerNodeData> data_;\n  TFGraph* graph_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"PerNodeData\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Stores type and truncation information for each node.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"std::optional<Type>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the type of the node, if available.\"\n                    },\n                    {\n                        \"name\": \"truncation\",\n                        \"type\": \"Truncation\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the truncation information for the node.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"Truncation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  struct PerNodeData {\n    std::optional<Type> type = std::nullopt;\n    Truncation truncation = Truncation::Any(IdentifyZeros::kDistinguishZeros);\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SimplifiedLoweringVerifier\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Constructor for the SimplifiedLoweringVerifier class.\",\n                \"logic\": \"Initializes the member variables.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone to allocate memory from.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The graph to verify.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  SimplifiedLoweringVerifier(Zone* zone, TFGraph* graph)\n      : hints_(zone),\n        machine_uses_of_constants_(zone),\n        data_(zone),\n        graph_(graph),\n        zone_(zone) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitNode\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Visits a node and performs verification checks.\",\n                \"logic\": \"Performs type and truncation checks for the given node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to visit.\"\n                    },\n                    {\n                        \"name\": \"op_typer\",\n                        \"type\": \"OperationTyper&\",\n                        \"purpose\": \"The operation typer to use for type inference.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"OperationTyper\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void VisitNode(Node* node, OperationTyper& op_typer);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RecordHint\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Records a verifier hint node.\",\n                \"logic\": \"Adds the hint node to the list of inserted hints.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The hint node to record.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void RecordHint(Node* node) {\n    DCHECK_EQ(node->opcode(), IrOpcode::kSLVerifierHint);\n    hints_.push_back(node);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"inserted_hints\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Returns the list of inserted hints.\",\n                \"logic\": \"Returns the vector of hint nodes.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"const ZoneVector<Node*>&\",\n                    \"description\": \"The list of inserted hints.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ZoneVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  const ZoneVector<Node*>& inserted_hints() const { return hints_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RecordMachineUsesOfConstant\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Records the machine uses of a constant node.\",\n                \"logic\": \"Adds the uses of the constant node to the map of machine uses.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"constant\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The constant node.\"\n                    },\n                    {\n                        \"name\": \"uses\",\n                        \"type\": \"Node::Uses\",\n                        \"purpose\": \"The uses of the constant node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"ZoneVector\",\n                    \"ZoneUnorderedMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void RecordMachineUsesOfConstant(Node* constant, Node::Uses uses) {\n    DCHECK(IrOpcode::IsMachineConstantOpcode(constant->opcode()));\n    auto it = machine_uses_of_constants_.find(constant);\n    if (it == machine_uses_of_constants_.end()) {\n      it =\n          machine_uses_of_constants_.emplace(constant, ZoneVector<Node*>(zone_))\n              .first;\n    }\n    base::vector_append(it->second, uses);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"machine_uses_of_constants\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Returns the map of machine uses of constant nodes.\",\n                \"logic\": \"Returns the map.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"const ZoneUnorderedMap<Node*, ZoneVector<Node*> >&\",\n                    \"description\": \"The map of machine uses.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ZoneVector\",\n                    \"ZoneUnorderedMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  const ZoneUnorderedMap<Node*, ZoneVector<Node*>>& machine_uses_of_constants()\n      const {\n    return machine_uses_of_constants_;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetType\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Gets the type of a node.\",\n                \"logic\": \"Retrieves the type of the node from either the NodeProperties or the internal data structure.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to get the type of.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<Type>\",\n                    \"description\": \"The type of the node, or std::nullopt if not available.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Type\",\n                    \"NodeProperties\",\n                    \"IrOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  std::optional<Type> GetType(Node* node) const {\n    if (NodeProperties::IsTyped(node)) {\n      Type type = NodeProperties::GetType(node);\n      // We do not use the static type for constants, even if we have one,\n      // because those are cached in the graph and shared between machine\n      // and non-machine subgraphs. The former might have assigned\n      // Type::Machine() to them.\n      if (IrOpcode::IsMachineConstantOpcode(node->opcode())) {\n        DCHECK(type.Is(Type::Machine()));\n      } else {\n        return type;\n      }\n    }\n    // For nodes that have not been typed before SL, we use the type that has\n    // been inferred by the verifier.\n    if (node->id() < data_.size()) {\n      return data_[node->id()].type;\n    }\n    return std::nullopt;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ResizeDataIfNecessary\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Resizes the internal data structure if necessary.\",\n                \"logic\": \"Resizes the data_ vector to accommodate the node's ID.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Truncation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void ResizeDataIfNecessary(Node* node) {\n    if (data_.size() <= node->id()) {\n      data_.resize(node->id() + 1);\n    }\n    DCHECK_EQ(data_[node->id()].truncation,\n              Truncation::Any(IdentifyZeros::kDistinguishZeros));\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetType\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Sets the type of a node in the internal data structure.\",\n                \"logic\": \"Sets the type of the node after resizing the data structure if needed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to set the type of.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type&\",\n                        \"purpose\": \"The type to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void SetType(Node* node, const Type& type) {\n    ResizeDataIfNecessary(node);\n    data_[node->id()].type = type;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InputType\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Gets the type of an input node.\",\n                \"logic\": \"Retrieves the type of the input node using GetType.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to get the input type of.\"\n                    },\n                    {\n                        \"name\": \"input_index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the input.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type\",\n                    \"description\": \"The type of the input node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Type InputType(Node* node, int input_index) const {\n    // TODO(nicohartmann): Check that inputs are typed, once all operators are\n    // supported.\n    auto type_opt = GetType(node->InputAt(input_index));\n    return type_opt.has_value() ? *type_opt : Type::None();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetTruncation\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Sets the truncation of a node in the internal data structure.\",\n                \"logic\": \"Sets the truncation of the node after resizing the data structure if needed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to set the truncation of.\"\n                    },\n                    {\n                        \"name\": \"truncation\",\n                        \"type\": \"const Truncation&\",\n                        \"purpose\": \"The truncation to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Truncation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void SetTruncation(Node* node, const Truncation& truncation) {\n    ResizeDataIfNecessary(node);\n    data_[node->id()].truncation = truncation;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InputTruncation\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Gets the truncation of an input node.\",\n                \"logic\": \"Retrieves the truncation of the input node from the internal data structure.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to get the input truncation of.\"\n                    },\n                    {\n                        \"name\": \"input_index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the input.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Truncation\",\n                    \"description\": \"The truncation of the input node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Truncation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Truncation InputTruncation(Node* node, int input_index) const {\n    static const Truncation any_truncation =\n        Truncation::Any(IdentifyZeros::kDistinguishZeros);\n\n    Node* input = node->InputAt(input_index);\n    if (input->id() < data_.size()) {\n      return data_[input->id()].truncation;\n    }\n    return any_truncation;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CheckType\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Checks the type of a node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type&\",\n                        \"purpose\": \"The expected type.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void CheckType(Node* node, const Type& type);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CheckAndSet\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Checks and sets the type and truncation of a node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check and set.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type&\",\n                        \"purpose\": \"The expected type.\"\n                    },\n                    {\n                        \"name\": \"trunc\",\n                        \"type\": \"const Truncation&\",\n                        \"purpose\": \"The expected truncation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Type\",\n                    \"Truncation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void CheckAndSet(Node* node, const Type& type, const Truncation& trunc);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReportInvalidTypeCombination\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Reports an invalid type combination for a node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node with the invalid type combination.\"\n                    },\n                    {\n                        \"name\": \"types\",\n                        \"type\": \"const std::vector<Type>&\",\n                        \"purpose\": \"The list of types involved.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void ReportInvalidTypeCombination(Node* node, const std::vector<Type>& types);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GeneralizeTruncation\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Generalizes a truncation based on the given type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"truncation\",\n                        \"type\": \"const Truncation&\",\n                        \"purpose\": \"The truncation to generalize.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type&\",\n                        \"purpose\": \"The type to base the generalization on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Truncation\",\n                    \"description\": \"The generalized truncation.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"Truncation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Truncation GeneralizeTruncation(const Truncation& truncation,\n                                  const Type& type) const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JoinTruncation\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Joins two truncations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"t1\",\n                        \"type\": \"const Truncation&\",\n                        \"purpose\": \"The first truncation.\"\n                    },\n                    {\n                        \"name\": \"t2\",\n                        \"type\": \"const Truncation&\",\n                        \"purpose\": \"The second truncation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Truncation\",\n                    \"description\": \"The joined truncation.\"\n                },\n                \"dependencies\": [\n                    \"Truncation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Truncation JoinTruncation(const Truncation& t1, const Truncation& t2);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JoinTruncation\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Joins three truncations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"t1\",\n                        \"type\": \"const Truncation&\",\n                        \"purpose\": \"The first truncation.\"\n                    },\n                    {\n                        \"name\": \"t2\",\n                        \"type\": \"const Truncation&\",\n                        \"purpose\": \"The second truncation.\"\n                    },\n                    {\n                        \"name\": \"t3\",\n                        \"type\": \"const Truncation&\",\n                        \"purpose\": \"The third truncation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Truncation\",\n                    \"description\": \"The joined truncation.\"\n                },\n                \"dependencies\": [\n                    \"Truncation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Truncation JoinTruncation(const Truncation& t1, const Truncation& t2,\n                            const Truncation& t3) {\n    return JoinTruncation(JoinTruncation(t1, t2), t3);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"graph_zone\",\n                \"parent\": \"SimplifiedLoweringVerifier\",\n                \"about\": \"Returns the zone of the graph.\",\n                \"logic\": \"Returns the zone.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Zone*\",\n                    \"description\": \"The zone of the graph.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Zone* graph_zone() const { return graph_->zone(); }\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"OperationTyper\",\n                    \"about\": \"Abstract base class for operation typers.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass OperationTyper;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"Memory allocation zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Zone;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TFGraph\",\n                    \"about\": \"Represents the TensorFlow graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass TFGraph;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Node\",\n                    \"about\": \"Represents a node in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Node;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Type\",\n                    \"about\": \"Represents the type of a node.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Type;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Truncation\",\n                    \"about\": \"Represents the truncation of a node.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Truncation;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"IrOpcode\",\n                    \"about\": \"Enum of IrOpcodes.\"\n                }\n            </metadata>\n            <code><![CDATA[\nenum class IrOpcode;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NodeProperties\",\n                    \"about\": \"Provides access to node properties.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass NodeProperties;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneVector\",\n                    \"about\": \"A vector that allocates memory from a Zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\ntemplate <typename T>\nclass ZoneVector;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneUnorderedMap\",\n                    \"about\": \"An unordered map that allocates memory from a Zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\ntemplate <typename K, typename V>\nclass ZoneUnorderedMap;\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}