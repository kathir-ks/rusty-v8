{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/store-store-elimination-reducer-inl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 36, column 81",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/store-store-elimination-reducer-inl.h\",\n            \"file_name\": \"store-store-elimination-reducer-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the StoreStoreEliminationReducer, which eliminates redundant stores and merges consecutive 32-bit stores into a 64-bit store in the Turboshaft compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for optional types, assembler, graph, operations, sidetable, snapshot table, uniform reducer adapter, heap layout, and heap objects.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/sidetable.h\"\n#include \"src/compiler/turboshaft/snapshot-table.h\"\n#include \"src/compiler/turboshaft/uniform-reducer-adapter.h\"\n#include \"src/heap/heap-layout-inl.h\"\n#include \"src/objects/heap-object-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MaybeRedundantStoresTable\",\n                \"extends\": \"ChangeTrackingSnapshotTable<MaybeRedundantStoresTable, StoreObservability, MaybeRedundantStoresKeyData>\",\n                \"about\": \"Tracks potentially redundant stores in a snapshot table.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"const Graph&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to the graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"block_to_snapshot_mapping_\",\n                        \"type\": \"GrowingBlockSidetable<std::optional<Snapshot>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps blocks to their snapshots.\"\n                    },\n                    {\n                        \"name\": \"key_mapping_\",\n                        \"type\": \"ZoneAbslFlatHashMap<std::pair<OpIndex, int32_t>, Key>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps (OpIndex, offset) pairs to keys in the snapshot table.\"\n                    },\n                    {\n                        \"name\": \"active_keys_\",\n                        \"type\": \"ZoneIntrusiveSet<Key, GetActiveKeysIndex>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks keys of stores that are gc-observable or unobservable.\"\n                    },\n                    {\n                        \"name\": \"current_block_\",\n                        \"type\": \"const Block*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The currently processed block.\"\n                    },\n                    {\n                        \"name\": \"successor_snapshots_\",\n                        \"type\": \"ZoneVector<Snapshot>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Temporary storage for successor snapshots during block processing.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ChangeTrackingSnapshotTable\",\n                    \"StoreObservability\",\n                    \"MaybeRedundantStoresKeyData\",\n                    \"Graph\",\n                    \"Block\",\n                    \"OpIndex\",\n                    \"Snapshot\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass MaybeRedundantStoresTable\n    : public ChangeTrackingSnapshotTable<MaybeRedundantStoresTable,\n                                         StoreObservability,\n                                         MaybeRedundantStoresKeyData> {\n  using super =\n      ChangeTrackingSnapshotTable<MaybeRedundantStoresTable, StoreObservability,\n                                  MaybeRedundantStoresKeyData>;\n\n public:\n  explicit MaybeRedundantStoresTable(const Graph& graph, Zone* zone)\n      : ChangeTrackingSnapshotTable(zone),\n        graph_(graph),\n        block_to_snapshot_mapping_(zone),\n        key_mapping_(zone),\n        active_keys_(zone),\n        successor_snapshots_(zone) {}\n\n  void OnNewKey(Key key, StoreObservability value) {\n    DCHECK_EQ(value, StoreObservability::kObservable);\n    DCHECK(!active_keys_.Contains(key));\n  }\n\n  void OnValueChange(Key key, StoreObservability old_value,\n                     StoreObservability new_value) {\n    DCHECK_NE(old_value, new_value);\n    if (new_value == StoreObservability::kObservable) {\n      active_keys_.Remove(key);\n    } else if (old_value == StoreObservability::kObservable) {\n      active_keys_.Add(key);\n    }\n  }\n\n  void BeginBlock(const Block* block) {\n    // Seal the current block first.\n    if (IsSealed()) {\n      DCHECK_NULL(current_block_);\n    } else {\n      // If we bind a new block while the previous one is still unsealed, we\n      // finalize it.\n      Seal();\n    }\n\n    // Collect the snapshots of all successors.\n    {\n      auto successors = SuccessorBlocks(block->LastOperation(graph_));\n      successor_snapshots_.clear();\n      for (const Block* s : successors) {\n        std::optional<Snapshot> s_snapshot =\n            block_to_snapshot_mapping_[s->index()];\n        // When we visit the loop for the first time, the loop header hasn't\n        // been visited yet, so we ignore it.\n        DCHECK_IMPLIES(!s_snapshot.has_value(), s->IsLoop());\n        if (!s_snapshot.has_value()) continue;\n        successor_snapshots_.push_back(*s_snapshot);\n      }\n    }\n\n    // Start a new snapshot for this block by merging information from\n    // successors.\n    StartNewSnapshot(\n        base::VectorOf(successor_snapshots_),\n        [](Key, base::Vector<const StoreObservability> successors) {\n          return static_cast<StoreObservability>(\n              *std::max_element(successors.begin(), successors.end()));\n        });\n\n    current_block_ = block;\n  }\n\n  StoreObservability GetObservability(OpIndex base, int32_t offset,\n                                      uint8_t size) {\n    Key key = map_to_key(base, offset, size);\n    if (key.data().size < size) return StoreObservability::kObservable;\n    return Get(key);\n  }\n\n  void MarkStoreAsUnobservable(OpIndex base, int32_t offset, uint8_t size) {\n    // We can only shadow stores to the exact same `base`+`offset` and keep\n    // everything else because they might or might not alias.\n    Key key = map_to_key(base, offset, size);\n    // If the `size` we want to mark unobservable here is less than the size we\n    // have seen for this key before, we do not overwrite the entire field, so\n    // preceeding stores are not (fully) unobservable.\n    if (size < key.data().size) return;\n    Set(key, StoreObservability::kUnobservable);\n  }\n\n  void MarkPotentiallyAliasingStoresAsObservable(OpIndex base, int32_t offset) {\n    // For now, we consider all stores to the same offset as potentially\n    // aliasing. We might improve this to eliminate more precisely, if we have\n    // some sort of aliasing information.\n    for (Key key : active_keys_) {\n      if (key.data().offset == offset)\n        Set(key, StoreObservability::kObservable);\n    }\n  }\n\n  void MarkAllStoresAsObservable() {\n    for (Key key : active_keys_) {\n      Set(key, StoreObservability::kObservable);\n    }\n  }\n\n  void MarkAllStoresAsGCObservable() {\n    for (Key key : active_keys_) {\n      auto current = Get(key);\n      DCHECK_NE(current, StoreObservability::kObservable);\n      if (current == StoreObservability::kUnobservable) {\n        Set(key, StoreObservability::kGCObservable);\n      }\n    }\n  }\n\n  void Seal(bool* snapshot_has_changed = nullptr) {\n    DCHECK(!IsSealed());\n    DCHECK_NOT_NULL(current_block_);\n    DCHECK(current_block_->index().valid());\n    auto& snapshot = block_to_snapshot_mapping_[current_block_->index()];\n    if (!snapshot_has_changed) {\n      snapshot = super::Seal();\n    } else if (!snapshot.has_value()) {\n      *snapshot_has_changed = true;\n      snapshot = super::Seal();\n    } else {\n      auto new_snapshot = super::Seal();\n      *snapshot_has_changed = false;\n      StartNewSnapshot(\n          base::VectorOf({snapshot.value(), new_snapshot}),\n          [&](Key key, base::Vector<const StoreObservability> successors) {\n            DCHECK_LE(successors[0], successors[1]);\n            if (successors[0] != successors[1]) *snapshot_has_changed = true;\n            return static_cast<StoreObservability>(\n                *std::max_element(successors.begin(), successors.end()));\n          });\n      snapshot = super::Seal();\n    }\n    current_block_ = nullptr;\n  }\n\n  void Print(std::ostream& os, const char* sep = \"\\n\") const {\n    bool first = true;\n    for (Key key : active_keys_) {\n      os << (first ? \"\" : sep) << key.data().base.id() << \"@\"\n         << key.data().offset << \": \" << Get(key);\n      first = false;\n    }\n  }\n\n private:\n  Key map_to_key(OpIndex base, int32_t offset, uint8_t size) {\n    std::pair p{base, offset};\n    auto it = key_mapping_.find(p);\n    if (it != key_mapping_.end()) return it->second;\n    Key new_key = NewKey(MaybeRedundantStoresKeyData{base, offset, size},\n                         StoreObservability::kObservable);\n    key_mapping_.emplace(p, new_key);\n    return new_key;\n  }\n  struct GetActiveKeysIndex {\n    IntrusiveSetIndex& operator()(Key key) const {\n      return key.data().active_keys_index;\n    }\n  };\n\n  const Graph& graph_;\n  GrowingBlockSidetable<std::optional<Snapshot>> block_to_snapshot_mapping_;\n  ZoneAbslFlatHashMap<std::pair<OpIndex, int32_t>, Key> key_mapping_;\n  // In `active_keys_`, we track the keys of all stores that arge gc-observable\n  // or unobservable. Keys that are mapped to the default value (observable) are\n  // removed from the `active_keys_`.\n  ZoneIntrusiveSet<Key, GetActiveKeysIndex> active_keys_;\n  const Block* current_block_ = nullptr;\n  // {successor_snapshots_} and {temp_key_vector_} are used as temporary vectors\n  // inside functions. We store them as members to avoid reallocation.\n  ZoneVector<Snapshot> successor_snapshots_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RedundantStoreAnalysis\",\n                \"about\": \"Performs the redundant store analysis on the graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"const Graph&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A reference to the Turboshaft graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"table_\",\n                        \"type\": \"MaybeRedundantStoresTable\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The table used to track potentially redundant stores.\"\n                    },\n                    {\n                        \"name\": \"eliminable_stores_\",\n                        \"type\": \"ZoneSet<OpIndex>*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the set of stores that can be eliminated.\"\n                    },\n                    {\n                        \"name\": \"mergeable_store_pairs_\",\n                        \"type\": \"ZoneMap<OpIndex, uint64_t>*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the map of store pairs that can be merged into a 64-bit store.\"\n                    },\n                    {\n                        \"name\": \"last_field_initialization_store_\",\n                        \"type\": \"OpIndex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the last field initialization store, used to merge stores.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Graph\",\n                    \"MaybeRedundantStoresTable\",\n                    \"OpIndex\",\n                    \"StoreOp\",\n                    \"LoadOp\",\n                    \"ConstantOp\",\n                    \"OpEffects\",\n                    \"Block\",\n                    \"HeapLayout\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass RedundantStoreAnalysis {\n public:\n  RedundantStoreAnalysis(const Graph& graph, Zone* phase_zone)\n      : graph_(graph), table_(graph, phase_zone) {}\n\n  void Run(ZoneSet<OpIndex>& eliminable_stores,\n           ZoneMap<OpIndex, uint64_t>& mergeable_store_pairs) {\n    eliminable_stores_ = &eliminable_stores;\n    mergeable_store_pairs_ = &mergeable_store_pairs;\n    for (uint32_t processed = graph_.block_count(); processed > 0;\n         --processed) {\n      BlockIndex block_index = static_cast<BlockIndex>(processed - 1);\n\n      const Block& block = graph_.Get(block_index);\n      ProcessBlock(block);\n\n      // If this block is a loop header, check if this loop needs to be\n      // revisited.\n      if (block.IsLoop()) {\n        DCHECK(!table_.IsSealed());\n        bool needs_revisit = false;\n        table_.Seal(&needs_revisit);\n        if (needs_revisit) {\n          Block* back_edge = block.LastPredecessor();\n          DCHECK_GE(back_edge->index(), block_index);\n          processed = back_edge->index().id() + 1;\n        }\n      }\n    }\n    eliminable_stores_ = nullptr;\n    mergeable_store_pairs_ = nullptr;\n  }\n\n  void ProcessBlock(const Block& block) {\n    table_.BeginBlock(&block);\n\n    auto op_range = graph_.OperationIndices(block);\n    for (auto it = op_range.end(); it != op_range.begin();) {\n      --it;\n      OpIndex index = *it;\n      const Operation& op = graph_.Get(index);\n\n      switch (op.opcode) {\n        case Opcode::kStore: {\n          const StoreOp& store = op.Cast<StoreOp>();\n          // TODO(nicohartmann@): Use the new effect flags to distinguish heap\n          // access once available.\n          const bool is_on_heap_store = store.kind.tagged_base;\n          const bool is_field_store = !store.index().valid();\n          const uint8_t size = store.stored_rep.SizeInBytes();\n          // For now we consider only stores of fields of objects on the heap.\n          if (is_on_heap_store && is_field_store) {\n            bool is_eliminable_store = false;\n            switch (table_.GetObservability(store.base(), store.offset, size)) {\n              case StoreObservability::kUnobservable:\n                eliminable_stores_->insert(index);\n                last_field_initialization_store_ = OpIndex::Invalid();\n                is_eliminable_store = true;\n                break;\n              case StoreObservability::kGCObservable:\n                if (store.maybe_initializing_or_transitioning) {\n                  // We cannot eliminate this store, but we mark all following\n                  // stores to the same `base+offset` as unobservable.\n                  table_.MarkStoreAsUnobservable(store.base(), store.offset,\n                                                 size);\n                } else {\n                  eliminable_stores_->insert(index);\n                  last_field_initialization_store_ = OpIndex::Invalid();\n                  is_eliminable_store = true;\n                }\n                break;\n              case StoreObservability::kObservable:\n                // We cannot eliminate this store, but we mark all following\n                // stores to the same `base+offset` as unobservable.\n                table_.MarkStoreAsUnobservable(store.base(), store.offset,\n                                               size);\n                break;\n            }\n\n            // Try to merge 2 consecutive 32-bit stores into a single 64-bit\n            // one.\n            if (COMPRESS_POINTERS_BOOL && !is_eliminable_store &&\n                store.maybe_initializing_or_transitioning &&\n                store.kind == StoreOp::Kind::TaggedBase() &&\n                store.write_barrier == WriteBarrierKind::kNoWriteBarrier &&\n                store.stored_rep.IsCompressibleTagged()) {\n              if (last_field_initialization_store_.valid() &&\n                  graph_.NextIndex(index) == last_field_initialization_store_) {\n                const StoreOp& store0 = store;\n                const StoreOp& store1 =\n                    graph_.Get(last_field_initialization_store_)\n                        .Cast<StoreOp>();\n\n                DCHECK(!store0.index().valid());\n                DCHECK(!store1.index().valid());\n\n                const ConstantOp* c0 =\n                    graph_.Get(store0.value()).TryCast<ConstantOp>();\n                const ConstantOp* c1 =\n                    graph_.Get(store1.value()).TryCast<ConstantOp>();\n\n                // TODO(dmercadier): for now, we only apply this optimization\n                // when storing read-only values, because otherwise the GC will\n                // lose track of Handles when we convert them to a raw Word64.\n                // However, if we were to keep the reloc info up-to-date, then\n                // this might work for any object. To do this, we might need to\n                // delay this optimization to later (instruction selector for\n                // instance).\n                if (c0 && c1 && c0->kind == ConstantOp::Kind::kHeapObject &&\n                    c1->kind == ConstantOp::Kind::kHeapObject &&\n                    store1.offset - store0.offset == 4 &&\n                    HeapLayout::InReadOnlySpace(*c0->handle()) &&\n                    HeapLayout::InReadOnlySpace(*c1->handle())) {\n                  uint32_t high = static_cast<uint32_t>(c1->handle()->ptr());\n                  uint32_t low = static_cast<uint32_t>(c0->handle()->ptr());\n#if V8_TARGET_BIG_ENDIAN\n                  uint64_t merged = make_uint64(low, high);\n#else\n                  uint64_t merged = make_uint64(high, low);\n#endif\n                  mergeable_store_pairs_->insert({index, merged});\n\n                  eliminable_stores_->insert(last_field_initialization_store_);\n                  last_field_initialization_store_ = OpIndex::Invalid();\n                }\n\n              } else {\n                last_field_initialization_store_ = index;\n              }\n            }\n          }\n          break;\n        }\n        case Opcode::kLoad: {\n          const LoadOp& load = op.Cast<LoadOp>();\n          // TODO(nicohartmann@): Use the new effect flags to distinguish heap\n          // access once available.\n          const bool is_on_heap_load = load.kind.tagged_base;\n          const bool is_field_load = !load.index().valid();\n          // For now we consider only loads of fields of objects on the heap.\n          if (is_on_heap_load && is_field_load) {\n            table_.MarkPotentiallyAliasingStoresAsObservable(load.base(),\n                                                             load.offset);\n          }\n          break;\n        }\n        default: {\n          OpEffects effects = op.Effects();\n          if (effects.can_read_mutable_memory()) {\n            table_.MarkAllStoresAsObservable();\n          } else if (effects.requires_consistent_heap()) {\n            table_.MarkAllStoresAsGCObservable();\n          }\n        } break;\n      }\n    }\n  }\n\n private:\n  const Graph& graph_;\n  MaybeRedundantStoresTable table_;\n  ZoneSet<OpIndex>* eliminable_stores_ = nullptr;\n\n  ZoneMap<OpIndex, uint64_t>* mergeable_store_pairs_ = nullptr;\n  OpIndex last_field_initialization_store_ = OpIndex::Invalid();\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StoreStoreEliminationReducer\",\n                \"extends\": \"Next\",\n                \"about\": \"Reducer that eliminates redundant stores and merges stores.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"analysis_\",\n                        \"type\": \"RedundantStoreAnalysis\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The analysis object used to identify redundant stores.\"\n                    },\n                    {\n                        \"name\": \"eliminable_stores_\",\n                        \"type\": \"ZoneSet<OpIndex>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of stores that can be eliminated.\"\n                    },\n                    {\n                        \"name\": \"mergeable_store_pairs_\",\n                        \"type\": \"ZoneMap<OpIndex, uint64_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map of store pairs that can be merged into a single 64-bit store.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"RedundantStoreAnalysis\",\n                    \"OpIndex\",\n                    \"StoreOp\",\n                    \"MemoryRepresentation\",\n                    \"WriteBarrierKind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass StoreStoreEliminationReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(StoreStoreElimination)\n\n  void Analyze() {\n    analysis_.Run(eliminable_stores_, mergeable_store_pairs_);\n    Next::Analyze();\n  }\n\n  OpIndex REDUCE_INPUT_GRAPH(Store)(OpIndex ig_index, const StoreOp& store) {\n    if (eliminable_stores_.count(ig_index) > 0) {\n      return OpIndex::Invalid();\n    } else if (mergeable_store_pairs_.count(ig_index) > 0) {\n      DCHECK(COMPRESS_POINTERS_BOOL);\n      OpIndex value = __ Word64Constant(mergeable_store_pairs_[ig_index]);\n      __ Store(__ MapToNewGraph(store.base()), value,\n               StoreOp::Kind::TaggedBase(), MemoryRepresentation::Uint64(),\n               WriteBarrierKind::kNoWriteBarrier, store.offset);\n      return OpIndex::Invalid();\n    }\n    return Next::ReduceInputGraphStore(ig_index, store);\n  }\n\n private:\n  RedundantStoreAnalysis analysis_{Asm().input_graph(), Asm().phase_zone()};\n  ZoneSet<OpIndex> eliminable_stores_{Asm().phase_zone()};\n  ZoneMap<OpIndex, uint64_t> mergeable_store_pairs_{Asm().phase_zone()};\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for StoreObservability enum to provide a string representation for printing.\",\n                \"logic\": \"Returns a string based on the StoreObservability enum value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"observability\",\n                        \"type\": \"StoreObservability\",\n                        \"purpose\": \"The StoreObservability value to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The modified output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ninline std::ostream& operator<<(std::ostream& os,\n                                StoreObservability observability) {\n  switch (observability) {\n    case StoreObservability::kUnobservable:\n      return os << \"Unobservable\";\n    case StoreObservability::kGCObservable:\n      return os << \"GCObservable\";\n    case StoreObservability::kObservable:\n      return os << \"Observable\";\n  }\n}\n        ]]></code>\n    </func>\n    <interface>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"MaybeRedundantStoresKeyData\",\n                \"about\": \"Key data for the MaybeRedundantStoresTable, containing base, offset, size, and an intrusive set index.\",\n                \"methods\": [],\n                \"dependencies\": [\n                    \"OpIndex\",\n                    \"IntrusiveSetIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct MaybeRedundantStoresKeyData {\n  OpIndex base;\n  int32_t offset;\n  uint8_t size;\n  IntrusiveSetIndex active_keys_index = {};\n};\n        ]]></code>\n    </interface>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"StoreObservability\",\n                \"about\": \"Represents the observability state of a store.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class StoreObservability {\n  kUnobservable = 0,\n  kGCObservable = 1,\n  kObservable = 2,\n};\n        ]]></code>\n    </enum>\n    <dependencies>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"make_uint64\",\n                    \"about\": \"Combines two 32-bit integers into a 64-bit integer.\"\n                }\n            </metadata>\n            <code><![CDATA[\nuint64_t make_uint64(uint32_t high, uint32_t low);\n            ]]></code>\n        </func>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ChangeTrackingSnapshotTable\",\n                    \"about\": \"Base class for snapshot tables with change tracking.\"\n                }\n            </metadata>\n            <code><![CDATA[\ntemplate <typename Table, typename Value, typename KeyData>\nclass ChangeTrackingSnapshotTable {\n public:\n  Snapshot Seal();\n  Value Get(Key key) const;\n  void Set(Key key, Value value);\n  Key NewKey(KeyData data, Value initial_value);\n protected:\n  virtual void OnNewKey(Key key, Value initial_value) {}\n  virtual void OnValueChange(Key key, Value old_value, Value new_value) {}\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Graph\",\n                    \"about\": \"Represents the Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Graph {\n public:\n  Block& Get(BlockIndex index) const;\n  uint32_t block_count() const;\n  Operation& Get(OpIndex index) const;\n  BlockIndex GetDominatorTreeRoot() const;\n  bool IsPhi(OpIndex index) const;\n  base::Range<Operation const*> operations() const;\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Block\",\n                    \"about\": \"Represents a basic block in the Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Block {\n public:\n  bool IsLoop() const;\n  BlockIndex index() const;\n  OperationIndex LastOperation() const;\n  Block* LastPredecessor();\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Operation\",\n                    \"about\": \"Base class for operations in the Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Operation {\n public:\n  Opcode opcode;\n  OpEffects Effects() const;\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"StoreOp\",\n                    \"about\": \"Represents a store operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass StoreOp : public Operation {\n public:\n  OpIndex base() const;\n  int32_t offset;\n  MemoryRepresentation stored_rep;\n  WriteBarrierKind write_barrier;\n  Kind kind;\n  bool maybe_initializing_or_transitioning;\n  OpIndex index() const;\n  enum class Kind {\n      TaggedBase,\n      UnTaggedBase,\n      kMapBase,\n      kHeaderBase\n  };\n};\n            ]]></code>\n        </class>\n         <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"OpEffects\",\n                    \"about\": \"Represents the side effects of an operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n class OpEffects {\n public:\n  bool can_read_mutable_memory() const;\n  bool requires_consistent_heap() const;\n };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"LoadOp\",\n                    \"about\": \"Represents a load operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass LoadOp : public Operation {\n public:\n  OpIndex base() const;\n  int32_t offset;\n  Kind kind;\n  enum class Kind {\n      TaggedBase,\n      UnTaggedBase,\n      kMapBase,\n      kHeaderBase\n  };\n  OpIndex index() const;\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ConstantOp\",\n                    \"about\": \"Represents a constant operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass ConstantOp : public Operation {\n public:\n  enum class Kind {\n      kInteger,\n      kFloat,\n      kHeapObject,\n      kExternalReference,\n      kTagged\n  };\n  Kind kind;\n  Handle<HeapObject> handle() const;\n};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}