{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/member.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/member.h\",\n            \"file_name\": \"member.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines smart pointer types (Member, WeakMember, UntracedMember) for garbage-collected objects in cppgc.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers for atomic operations, size definitions, type traits, and the v8config header.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <atomic>\n            #include <cstddef>\n            #include <type_traits>\n\n            #include \"cppgc/internal/api-constants.h\"\n            #include \"cppgc/internal/member-storage.h\"\n            #include \"cppgc/internal/pointer-policies.h\"\n            #include \"cppgc/sentinel-pointer.h\"\n            #include \"cppgc/type-traits.h\"\n            #include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemberBase\",\n                \"about\": \"Base class for Member smart pointers. Handles raw pointer storage and atomic operations.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"raw_\",\n                        \"type\": \"StorageType\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the raw pointer value. Uses StorageType to handle compression and atomic access.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"StorageType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename StorageType>\n            class V8_TRIVIAL_ABI MemberBase {\n            public:\n              using RawStorage = StorageType;\n\n             protected:\n              struct AtomicInitializerTag {};\n\n              V8_INLINE MemberBase() = default;\n              V8_INLINE explicit MemberBase(const void* value) : raw_(value) {}\n              V8_INLINE MemberBase(const void* value, AtomicInitializerTag)\n                  : raw_(value, typename RawStorage::AtomicInitializerTag{}) {}\n\n              V8_INLINE explicit MemberBase(RawStorage raw) : raw_(raw) {}\n              V8_INLINE explicit MemberBase(std::nullptr_t) : raw_(nullptr) {}\n              V8_INLINE explicit MemberBase(SentinelPointer s) : raw_(s) {}\n\n              V8_INLINE const void** GetRawSlot() const {\n                return reinterpret_cast<const void**>(const_cast<MemberBase*>(this));\n              }\n              V8_INLINE const void* GetRaw() const { return raw_.Load(); }\n              V8_INLINE void SetRaw(void* value) { raw_.Store(value); }\n\n              V8_INLINE const void* GetRawAtomic() const { return raw_.LoadAtomic(); }\n              V8_INLINE void SetRawAtomic(const void* value) { raw_.StoreAtomic(value); }\n\n              V8_INLINE RawStorage GetRawStorage() const { return raw_; }\n              V8_INLINE void SetRawStorageAtomic(RawStorage other) {\n                reinterpret_cast<std::atomic<RawStorage>&>(raw_).store(\n                    other, std::memory_order_relaxed);\n              }\n\n              V8_INLINE bool IsCleared() const { return raw_.IsCleared(); }\n\n              V8_INLINE void ClearFromGC() const { raw_.Clear(); }\n\n             private:\n              friend class MemberDebugHelper;\n\n              mutable RawStorage raw_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BasicMember\",\n                \"about\": \"The core implementation of Member, WeakMember, and UntracedMember. Manages the underlying pointer, write barriers, and checking policies.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"MemberBase\",\n                    \"WriteBarrierPolicy\",\n                    \"CheckingPolicy\",\n                    \"StorageType\",\n                    \"IsDecayedSameV\",\n                    \"IsStrictlyBaseOfV\",\n                    \"BasicPersistent\",\n                    \"subtle::HeapConsistency\",\n                    \"Visitor\",\n                    \"TraceTrait\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType>\n            class V8_TRIVIAL_ABI BasicMember final : private MemberBase<StorageType>,\n                                                     private CheckingPolicy {\n              using Base = MemberBase<StorageType>;\n\n             public:\n              using PointeeType = T;\n              using RawStorage = typename Base::RawStorage;\n\n              V8_INLINE constexpr BasicMember() = default;\n              V8_INLINE constexpr BasicMember(std::nullptr_t) {}     // NOLINT\n              V8_INLINE BasicMember(SentinelPointer s) : Base(s) {}  // NOLINT\n              V8_INLINE BasicMember(T* raw) : Base(raw) {            // NOLINT\n                InitializingWriteBarrier(raw);\n                CheckPointer(raw);\n              }\n              V8_INLINE BasicMember(T& raw)  // NOLINT\n                  : BasicMember(&raw) {}\n\n              // Atomic ctor. Using the AtomicInitializerTag forces BasicMember to\n              // initialize using atomic assignments. This is required for preventing\n              // data races with concurrent marking.\n              using AtomicInitializerTag = typename Base::AtomicInitializerTag;\n              V8_INLINE BasicMember(std::nullptr_t, AtomicInitializerTag atomic)\n                  : Base(nullptr, atomic) {}\n              V8_INLINE BasicMember(SentinelPointer s, AtomicInitializerTag atomic)\n                  : Base(s, atomic) {}\n              V8_INLINE BasicMember(T* raw, AtomicInitializerTag atomic)\n                  : Base(raw, atomic) {\n                InitializingWriteBarrier(raw);\n                CheckPointer(raw);\n              }\n              V8_INLINE BasicMember(T& raw, AtomicInitializerTag atomic)\n                  : BasicMember(&raw, atomic) {}\n\n              // Copy ctor.\n              V8_INLINE BasicMember(const BasicMember& other)\n                  : BasicMember(other.GetRawStorage()) {}\n\n              // Heterogeneous copy constructors. When the source pointer have a different\n              // type, perform a compress-decompress round, because the source pointer may\n              // need to be adjusted.\n              template <typename U, typename OtherBarrierPolicy, typename OtherWeaknessTag,\n                        typename OtherCheckingPolicy,\n                        std::enable_if_t<IsDecayedSameV<T, U>>* = nullptr>\n              V8_INLINE BasicMember(  // NOLINT\n                  const BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy,\n                                    OtherCheckingPolicy, StorageType>& other)\n                  : BasicMember(other.GetRawStorage()) {}\n\n              template <typename U, typename OtherBarrierPolicy, typename OtherWeaknessTag,\n                        typename OtherCheckingPolicy,\n                        std::enable_if_t<IsStrictlyBaseOfV<T, U>>* = nullptr>\n              V8_INLINE BasicMember(  // NOLINT\n                  const BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy,\n                                    OtherCheckingPolicy, StorageType>& other)\n                  : BasicMember(other.Get()) {}\n\n              // Move ctor.\n              V8_INLINE BasicMember(BasicMember&& other) noexcept\n                  : BasicMember(other.GetRawStorage()) {\n                other.Clear();\n              }\n\n              // Heterogeneous move constructors. When the source pointer have a different\n              // type, perform a compress-decompress round, because the source pointer may\n              // need to be adjusted.\n              template <typename U, typename OtherBarrierPolicy, typename OtherWeaknessTag,\n                        typename OtherCheckingPolicy,\n                        std::enable_if_t<IsDecayedSameV<T, U>>* = nullptr>\n              V8_INLINE BasicMember(\n                  BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy, OtherCheckingPolicy,\n                              StorageType>&& other) noexcept\n                  : BasicMember(other.GetRawStorage()) {\n                other.Clear();\n              }\n\n              template <typename U, typename OtherBarrierPolicy, typename OtherWeaknessTag,\n                        typename OtherCheckingPolicy,\n                        std::enable_if_t<IsStrictlyBaseOfV<T, U>>* = nullptr>\n              V8_INLINE BasicMember(\n                  BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy, OtherCheckingPolicy,\n                              StorageType>&& other) noexcept\n                  : BasicMember(other.Get()) {\n                other.Clear();\n              }\n\n              // Construction from Persistent.\n              template <typename U, typename PersistentWeaknessPolicy,\n                        typename PersistentLocationPolicy,\n                        typename PersistentCheckingPolicy,\n                        typename = std::enable_if_t<std::is_base_of<T, U>::value>>\n              V8_INLINE BasicMember(const BasicPersistent<U, PersistentWeaknessPolicy,\n                                                          PersistentLocationPolicy,\n                                                          PersistentCheckingPolicy>& p)\n                  : BasicMember(p.Get()) {}\n\n              // Copy assignment.\n              V8_INLINE BasicMember& operator=(const BasicMember& other) {\n                return operator=(other.GetRawStorage());\n              }\n\n              // Heterogeneous copy assignment. When the source pointer have a different\n              // type, perform a compress-decompress round, because the source pointer may\n              // need to be adjusted.\n              template <typename U, typename OtherWeaknessTag, typename OtherBarrierPolicy,\n                        typename OtherCheckingPolicy>\n              V8_INLINE BasicMember& operator=(\n                  const BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy,\n                                    OtherCheckingPolicy, StorageType>& other) {\n                if constexpr (IsDecayedSameV<T, U>) {\n                  return operator=(other.GetRawStorage());\n                } else {\n                  static_assert(IsStrictlyBaseOfV<T, U>);\n                  return operator=(other.Get());\n                }\n              }\n\n              // Move assignment.\n              V8_INLINE BasicMember& operator=(BasicMember&& other) noexcept {\n                operator=(other.GetRawStorage());\n                other.Clear();\n                return *this;\n              }\n\n              // Heterogeneous move assignment. When the source pointer have a different\n              // type, perform a compress-decompress round, because the source pointer may\n              // need to be adjusted.\n              template <typename U, typename OtherWeaknessTag, typename OtherBarrierPolicy,\n                        typename OtherCheckingPolicy>\n              V8_INLINE BasicMember& operator=(\n                  BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy, OtherCheckingPolicy,\n                              StorageType>&& other) noexcept {\n                if constexpr (IsDecayedSameV<T, U>) {\n                  operator=(other.GetRawStorage());\n                } else {\n                  static_assert(IsStrictlyBaseOfV<T, U>);\n                  operator=(other.Get());\n                }\n                other.Clear();\n                return *this;\n              }\n\n              // Assignment from Persistent.\n              template <typename U, typename PersistentWeaknessPolicy,\n                        typename PersistentLocationPolicy,\n                        typename PersistentCheckingPolicy,\n                        typename = std::enable_if_t<std::is_base_of<T, U>::value>>\n              V8_INLINE BasicMember& operator=(\n                  const BasicPersistent<U, PersistentWeaknessPolicy,\n                                        PersistentLocationPolicy, PersistentCheckingPolicy>&\n                      other) {\n                return operator=(other.Get());\n              }\n\n              V8_INLINE BasicMember& operator=(T* other) {\n                Base::SetRawAtomic(other);\n                AssigningWriteBarrier(other);\n                CheckPointer(other);\n                return *this;\n              }\n\n              V8_INLINE BasicMember& operator=(std::nullptr_t) {\n                Clear();\n                return *this;\n              }\n              V8_INLINE BasicMember& operator=(SentinelPointer s) {\n                Base::SetRawAtomic(s);\n                return *this;\n              }\n\n              template <typename OtherWeaknessTag, typename OtherBarrierPolicy,\n                        typename OtherCheckingPolicy>\n              V8_INLINE void Swap(BasicMember<T, OtherWeaknessTag, OtherBarrierPolicy,\n                                          OtherCheckingPolicy, StorageType>& other) {\n                auto tmp = GetRawStorage();\n                *this = other;\n                other = tmp;\n              }\n\n              V8_INLINE explicit operator bool() const { return !Base::IsCleared(); }\n              V8_INLINE operator T*() const { return Get(); }\n              V8_INLINE T* operator->() const { return Get(); }\n              V8_INLINE T& operator*() const { return *Get(); }\n\n              // CFI cast exemption to allow passing SentinelPointer through T* and support\n              // heterogeneous assignments between different Member and Persistent handles\n              // based on their actual types.\n              V8_INLINE V8_CLANG_NO_SANITIZE(\"cfi-unrelated-cast\") T* Get() const {\n                // Executed by the mutator, hence non atomic load.\n                //\n                // The const_cast below removes the constness from MemberBase storage. The\n                // following static_cast re-adds any constness if specified through the\n                // user-visible template parameter T.\n                return static_cast<T*>(const_cast<void*>(Base::GetRaw()));\n              }\n\n              V8_INLINE void Clear() { Base::SetRawStorageAtomic(RawStorage{}); }\n\n              V8_INLINE T* Release() {\n                T* result = Get();\n                Clear();\n                return result;\n              }\n\n              V8_INLINE const T** GetSlotForTesting() const {\n                return reinterpret_cast<const T**>(Base::GetRawSlot());\n              }\n\n              V8_INLINE RawStorage GetRawStorage() const { return Base::GetRawStorage(); }\n\n             private:\n              V8_INLINE explicit BasicMember(RawStorage raw) : Base(raw) {\n                InitializingWriteBarrier();\n                CheckPointer();\n              }\n\n              V8_INLINE BasicMember& operator=(RawStorage other) {\n                Base::SetRawStorageAtomic(other);\n                AssigningWriteBarrier();\n                CheckPointer();\n                return *this;\n              }\n\n              V8_INLINE const T* GetRawAtomic() const {\n                return static_cast<const T*>(Base::GetRawAtomic());\n              }\n\n              V8_INLINE void InitializingWriteBarrier(T* value) const {\n                WriteBarrierPolicy::InitializingBarrier(Base::GetRawSlot(), value);\n              }\n              V8_INLINE void InitializingWriteBarrier() const {\n                WriteBarrierPolicy::InitializingBarrier(Base::GetRawSlot(),\n                                                        Base::GetRawStorage());\n              }\n              V8_INLINE void AssigningWriteBarrier(T* value) const {\n                WriteBarrierPolicy::template AssigningBarrier<\n                    StorageType::kWriteBarrierSlotType>(Base::GetRawSlot(), value);\n              }\n              V8_INLINE void AssigningWriteBarrier() const {\n                WriteBarrierPolicy::template AssigningBarrier<\n                    StorageType::kWriteBarrierSlotType>(Base::GetRawSlot(),\n                                                        Base::GetRawStorage());\n              }\n              V8_INLINE void CheckPointer(T* value) {\n                CheckingPolicy::template CheckPointer<T>(value);\n              }\n              V8_INLINE void CheckPointer() {\n                CheckingPolicy::template CheckPointer<T>(Base::GetRawStorage());\n              }\n\n              V8_INLINE void ClearFromGC() const { Base::ClearFromGC(); }\n\n              V8_INLINE T* GetFromGC() const { return Get(); }\n\n              friend class cppgc::subtle::HeapConsistency;\n              friend class cppgc::Visitor;\n              template <typename U>\n              friend struct cppgc::TraceTrait;\n              template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,\n                        typename CheckingPolicy1, typename StorageType1>\n              friend class BasicMember;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Equality operator for BasicMember instances.  Compares raw storage if types are the same, otherwise decompresses and compares pointers.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"member1\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The left-hand side BasicMember.\"\n                    },\n                    {\n                        \"name\": \"member2\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The right-hand side BasicMember.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the members are equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\",\n                    \"IsDecayedSameV\",\n                    \"IsStrictlyBaseOfV\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,\n                      typename CheckingPolicy1, typename T2, typename WeaknessTag2,\n                      typename WriteBarrierPolicy2, typename CheckingPolicy2,\n                      typename StorageType>\n            V8_INLINE bool operator==(\n                const BasicMember<T1, WeaknessTag1, WriteBarrierPolicy1, CheckingPolicy1,\n                                  StorageType>& member1,\n                const BasicMember<T2, WeaknessTag2, WriteBarrierPolicy2, CheckingPolicy2,\n                                  StorageType>& member2) {\n              if constexpr (IsDecayedSameV<T1, T2>) {\n                // Check compressed pointers if types are the same.\n                return member1.GetRawStorage() == member2.GetRawStorage();\n              } else {\n                static_assert(IsStrictlyBaseOfV<T1, T2> || IsStrictlyBaseOfV<T2, T1>);\n                // Otherwise, check decompressed pointers.\n                return member1.Get() == member2.Get();\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator!=\",\n                \"about\": \"Inequality operator for BasicMember instances.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"member1\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The left-hand side BasicMember.\"\n                    },\n                    {\n                        \"name\": \"member2\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The right-hand side BasicMember.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the members are not equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,\n                      typename CheckingPolicy1, typename T2, typename WeaknessTag2,\n                      typename WriteBarrierPolicy2, typename CheckingPolicy2,\n                      typename StorageType>\n            V8_INLINE bool operator!=(\n                const BasicMember<T1, WeaknessTag1, WriteBarrierPolicy1, CheckingPolicy1,\n                                  StorageType>& member1,\n                const BasicMember<T2, WeaknessTag2, WriteBarrierPolicy2, CheckingPolicy2,\n                                  StorageType>& member2) {\n              return !(member1 == member2);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Equality operator between a BasicMember and a raw pointer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    },\n                    {\n                        \"name\": \"raw\",\n                        \"type\": \"U*\",\n                        \"purpose\": \"The raw pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the member and raw pointer are equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\",\n                    \"IsDecayedSameV\",\n                    \"IsStrictlyBaseOfV\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType, typename U>\n            V8_INLINE bool operator==(\n                const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,\n                                  StorageType>& member,\n                U* raw) {\n              // Never allow comparison with erased pointers.\n              static_assert(!IsDecayedSameV<void, U>);\n\n              if constexpr (IsDecayedSameV<T, U>) {\n                // Check compressed pointers if types are the same.\n                return member.GetRawStorage() == StorageType(raw);\n              } else if constexpr (IsStrictlyBaseOfV<T, U>) {\n                // Cast the raw pointer to T, which may adjust the pointer.\n                return member.GetRawStorage() == StorageType(static_cast<T*>(raw));\n              } else {\n                // Otherwise, decompressed the member.\n                return member.Get() == raw;\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator!=\",\n                \"about\": \"Inequality operator between a BasicMember and a raw pointer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    },\n                    {\n                        \"name\": \"raw\",\n                        \"type\": \"U*\",\n                        \"purpose\": \"The raw pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the member and raw pointer are not equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType, typename U>\n            V8_INLINE bool operator!=(\n                const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,\n                                  StorageType>& member,\n                U* raw) {\n              return !(member == raw);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Equality operator between a raw pointer and a BasicMember.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"raw\",\n                        \"type\": \"T*\",\n                        \"purpose\": \"The raw pointer.\"\n                    },\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the raw pointer and member are equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename U, typename WeaknessTag,\n                      typename WriteBarrierPolicy, typename CheckingPolicy,\n                      typename StorageType>\n            V8_INLINE bool operator==(\n                T* raw, const BasicMember<U, WeaknessTag, WriteBarrierPolicy,\n                                          CheckingPolicy, StorageType>& member) {\n              return member == raw;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator!=\",\n                \"about\": \"Inequality operator between a raw pointer and a BasicMember.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"raw\",\n                        \"type\": \"T*\",\n                        \"purpose\": \"The raw pointer.\"\n                    },\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the raw pointer and member are not equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename U, typename WeaknessTag,\n                      typename WriteBarrierPolicy, typename CheckingPolicy,\n                      typename StorageType>\n            V8_INLINE bool operator!=(\n                T* raw, const BasicMember<U, WeaknessTag, WriteBarrierPolicy,\n                                          CheckingPolicy, StorageType>& member) {\n              return !(raw == member);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Equality operator between a BasicMember and a SentinelPointer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    },\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"SentinelPointer\",\n                        \"purpose\": \"The SentinelPointer instance.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the member and sentinel pointer are equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\",\n                    \"SentinelPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType>\n            V8_INLINE bool operator==(\n                const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,\n                                  StorageType>& member,\n                SentinelPointer) {\n              return member.GetRawStorage().IsSentinel();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator!=\",\n                \"about\": \"Inequality operator between a BasicMember and a SentinelPointer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    },\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"SentinelPointer\",\n                        \"purpose\": \"The SentinelPointer instance.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the member and sentinel pointer are not equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\",\n                    \"SentinelPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType>\n            V8_INLINE bool operator!=(\n                const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,\n                                  StorageType>& member,\n                SentinelPointer s) {\n              return !(member == s);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Equality operator between a SentinelPointer and a BasicMember.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"SentinelPointer\",\n                        \"purpose\": \"The SentinelPointer instance.\"\n                    },\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the sentinel pointer and member are equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\",\n                    \"SentinelPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType>\n            V8_INLINE bool operator==(\n                SentinelPointer s, const BasicMember<T, WeaknessTag, WriteBarrierPolicy,\n                                             CheckingPolicy, StorageType>& member) {\n              return member == s;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator!=\",\n                \"about\": \"Inequality operator between a SentinelPointer and a BasicMember.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"SentinelPointer\",\n                        \"purpose\": \"The SentinelPointer instance.\"\n                    },\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the sentinel pointer and member are not equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\",\n                    \"SentinelPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType>\n            V8_INLINE bool operator!=(\n                SentinelPointer s, const BasicMember<T, WeaknessTag, WriteBarrierPolicy,\n                                             CheckingPolicy, StorageType>& member) {\n              return !(s == member);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Equality operator between a BasicMember and nullptr.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    },\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"std::nullptr_t\",\n                        \"purpose\": \"The nullptr.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the member is null, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType>\n            V8_INLINE bool operator==(\n                const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,\n                                  StorageType>& member,\n                std::nullptr_t) {\n              return !static_cast<bool>(member);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator!=\",\n                \"about\": \"Inequality operator between a BasicMember and nullptr.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    },\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"std::nullptr_t\",\n                        \"purpose\": \"The nullptr.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the member is not null, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType>\n            V8_INLINE bool operator!=(\n                const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,\n                                  StorageType>& member,\n                std::nullptr_t n) {\n              return !(member == n);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Equality operator between nullptr and a BasicMember.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"std::nullptr_t\",\n                        \"purpose\": \"The nullptr.\"\n                    },\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The BasicMember instance.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the member is null, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy, typename StorageType>\n            V8_INLINE bool operator==(\n                std::nullptr_t n, const BasicMember<T, WeaknessTag, WriteBarrierPolicy,\n                                         CheckingPolicy, StorageType>& member) {\n              return member == n;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator!=\",\n                \"about\": \"Inequality operator between nullptr and a BasicMember.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"std::nullptr_t\",\n                        \"purpose\": \"The nullptr.\"\n                    },\n                    {\n                        \"name\": \"member\",\n                        \"type\": \"const BasicMember&\",\n                        \"purpose\": \"The"
}