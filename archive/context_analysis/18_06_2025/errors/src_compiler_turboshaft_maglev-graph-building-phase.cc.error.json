{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/maglev-graph-building-phase.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/maglev-graph-building-phase.cc\",\n        \"file_name\": \"maglev-graph-building-phase.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Translates a Maglev graph into a Turboshaft graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for compiler, code generation, and runtime functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/maglev-graph-building-phase.h\"\n\n#include <limits>\n#include <memory>\n#include <optional>\n#include <type_traits>\n\n#include \"src/base/logging.h\"\n#include \"src/base/small-vector.h\"\n#include \"src/base/vector.h\"\n#include \"src/codegen/bailout-reason.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/bytecode-analysis.h\"\n#include \"src/compiler/bytecode-liveness-map.h\"\n#include \"src/compiler/frame-states.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/turboshaft/access-builder.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/machine-optimization-reducer.h\"\n#include \"src/compiler/turboshaft/maglev-early-lowering-reducer-inl.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/compiler/turboshaft/required-optimization-reducer.h\"\n#include \"src/compiler/turboshaft/sidetable.h\"\n#include \"src/compiler/turboshaft/utils.h\"\n#include \"src/compiler/turboshaft/value-numbering-reducer.h\"\n#include \"src/compiler/turboshaft/variable-reducer.h\"\n#include \"src/compiler/write-barrier-kind.h\"\n#include \"src/deoptimizer/deoptimize-reason.h\"\n#include \"src/handles/global-handles-inl.h\"\n#include \"src/handles/handles.h\"\n#include \"src/interpreter/bytecode-register.h\"\n#include \"src/maglev/maglev-basic-block.h\"\n#include \"src/maglev/maglev-compilation-info.h\"\n#include \"src/maglev/maglev-compilation-unit.h\"\n#include \"src/maglev/maglev-graph-builder.h\"\n#include \"src/maglev/maglev-graph-labeller.h\"\n#include \"src/maglev/maglev-graph-processor.h\"\n#include \"src/maglev/maglev-graph-verifier.h\"\n#include \"src/maglev/maglev-inlining.h\"\n#include \"src/maglev/maglev-ir-inl.h\"\n#include \"src/maglev/maglev-ir.h\"\n#include \"src/maglev/maglev-phi-representation-selector.h\"\n#include \"src/maglev/maglev-post-hoc-optimizations-processors.h\"\n#include \"src/objects/elements-kind.h\"\n#include \"src/objects/heap-object.h\"\n#include \"src/objects/js-array-buffer.h\"\n#include \"src/objects/map.h\"\n#include \"src/objects/objects.h\"\n#include \"src/objects/property-cell.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MachineTypeFor\",\n            \"about\": \"Determines the Turboshaft MachineType corresponding to a Maglev ValueRepresentation.\",\n            \"logic\": \"A switch statement maps Maglev ValueRepresentation enum values to corresponding Turboshaft MachineType enum values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"repr\",\n                    \"type\": \"maglev::ValueRepresentation\",\n                    \"purpose\": \"The Maglev value representation to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MachineType\",\n                \"description\": \"The corresponding Turboshaft MachineType.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nMachineType MachineTypeFor(maglev::ValueRepresentation repr) {\n  switch (repr) {\n    case maglev::ValueRepresentation::kTagged:\n      return MachineType::AnyTagged();\n    case maglev::ValueRepresentation::kInt32:\n      return MachineType::Int32();\n    case maglev::ValueRepresentation::kUint32:\n      return MachineType::Uint32();\n    case maglev::ValueRepresentation::kIntPtr:\n      return MachineType::IntPtr();\n    case maglev::ValueRepresentation::kFloat64:\n      return MachineType::Float64();\n    case maglev::ValueRepresentation::kHoleyFloat64:\n      return MachineType::HoleyFloat64();\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BlockOriginTrackingReducer\",\n            \"about\": \"A Turboshaft reducer that tracks the Maglev origin of Turboshaft blocks.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Next\",\n                \"maglev::BasicBlock\",\n                \"GrowingBlockSidetable\",\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass BlockOriginTrackingReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(BlockOriginTracking)\n  void SetMaglevInputBlock(const maglev::BasicBlock* block) {\n    maglev_input_block_ = block;\n  }\n  const maglev::BasicBlock* maglev_input_block() const {\n    return maglev_input_block_;\n  }\n  void Bind(Block* block) {\n    Next::Bind(block);\n    // The 1st block we bind doesn't exist in Maglev and is meant to hold\n    // Constants (which in Maglev are not in any block), and thus\n    // {maglev_input_block_} should still be nullptr. In all other cases,\n    // {maglev_input_block_} should not be nullptr.\n    DCHECK_EQ(maglev_input_block_ == nullptr,\n              block == &__ output_graph().StartBlock());\n    turboshaft_block_origins_[block->index()] = maglev_input_block_;\n  }\n\n  const maglev::BasicBlock* GetMaglevOrigin(const Block* block) {\n    DCHECK_NOT_NULL(turboshaft_block_origins_[block->index()]);\n    return turboshaft_block_origins_[block->index()];\n  }\n\n private:\n  const maglev::BasicBlock* maglev_input_block_ = nullptr;\n  GrowingBlockSidetable<const maglev::BasicBlock*> turboshaft_block_origins_{\n      __ phase_zone()};\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GeneratorAnalyzer\",\n            \"about\": \"Analyzes Maglev graphs for generator resumes that bypass loop headers, and facilitates re-routing of edges in Turboshaft.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Zone\",\n                \"maglev::MaglevGraphLabeller\",\n                \"ZoneAbslFlatHashMap\",\n                \"ZoneVector\",\n                \"maglev::Graph\",\n                \"maglev::BasicBlock\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass GeneratorAnalyzer {\n  // A document explaning how generators are handled by the translation can be\n  // found here:\n  //\n  //     https://docs.google.com/document/d/1-iFoVuvpIEjA9dtSsOjmKL5vAzzvf0cKI6f4zaObiV8/edit?usp=sharing\n  //\n  //\n  // Because of generator resumes, Maglev graphs can have edges that bypass loop\n  // headers. This actually happens everytime a loop contains a `yield`.\n  // In Turboshaft, however, the loop header must always dominate every block in\n  // the loop, and thus does not allow such edges that bypass the loop header.\n  // For instance,\n  //\n  //     function* foo() {\n  //       for (let i = 0; i < 10; i++) {\n  //         if (i % 2 == 0) {\n  //           yield i;\n  //         }\n  //       }\n  //     }\n  //\n  // The corresponding Maglev graph will look something like (this is a little\n  // bit simplified since details don't matter much for this high level\n  // explanation; the drawing in FindLoopHeaderBypasses below gives a more\n  // precise view of what the Maglev graph looks like):\n  //\n  //                       + 1 ------+\n  //                       | Switch  |\n  //                       +---------+\n  //                        /      \\\n  //                      /          \\      |----------------------|\n  //                    /              \\    |                      |\n  //                  /                 v   v                      |\n  //                /              + 2 --------+                   |\n  //              /                | Loop      |                   |\n  //             |                 +-----------+                   |\n  //             |                      |                          |\n  //             |                      |                          |\n  //             v                      v                          |\n  //        + 4 ------+             + 3 --------------+            |\n  //        | Resume  |             | Branch(i%2==0)  |            |\n  //        +---------+             +-----------------+            |\n  //            |                     /        \\                   |\n  //            |                    /          \\                  |\n  //            |                   /            \\                 |\n  //            |             + 5 -------+        |                |\n  //            |             | yield i  |        |                |\n  //            |             +----------+        |                |\n  //            |                                 |                |\n  //            |----------------------------|    |                |\n  //                                         |    |                |\n  //                                         v    v                |\n  //                                    + 6 ----------+            |\n  //                                    | i++         |            |\n  //                                    | backedge    |            |\n  //                                    +-------------+            |\n  //                                           |                   |\n  //                                           |-------------------|\n  //\n  // In this graph, the edge from block 4 to block 6 bypasses the loop header.\n  //\n  //\n  // Note that it's even possible that the graph contains no forward path from\n  // the loop header to the backedge. This happens for instance when the loop\n  // body always unconditionally yields. In such cases, the backedge is always\n  // reached through the main resume switch. For instance:\n  //\n  //     function* foo() {\n  //       for (let i = 0; i < 10; i++) {\n  //         yield i;\n  //       }\n  //     }\n  //\n  // Will produce the following graph:\n  //\n  //                       + 1 ------+\n  //                       | Switch  |\n  //                       +---------+\n  //                        /      \\\n  //                      /          \\      |-------------|\n  //                    /              \\    |             |\n  //                  /                 v   v             |\n  //                /              + 2 --------+          |\n  //              /                | Loop      |          |\n  //             |                 +-----------+          |\n  //             |                      |                 |\n  //             |                      |                 |\n  //             v                      v                 |\n  //        + 4 ------+             + 3 -------+          |\n  //        | Resume  |             | yield i  |          |\n  //        +---------+             +----------+          |\n  //             |                                        |\n  //             |                                        |\n  //             |----------------------------------------|\n  //\n  //\n  // GeneratorAnalyzer finds the loop in the Maglev graph, and finds the\n  // generator resume edges that bypass loops headers. The GraphBuilder then\n  // uses this information to re-route such edges to loop headers and insert\n  // secondary switches. For instance, the graph right above will be transformed\n  // to something like this:\n  //\n  //                       + 1 ------+\n  //                       | Switch  |\n  //                       +---------+\n  //                          |  |\n  //                          |  |\n  //                          v  v\n  //                     + 2 --------+\n  //                     | p1 = phi  |\n  //                     +-----------+\n  //                          |\n  //                          |    |-----------------------|\n  //                          |    |                       |\n  //                          v    v                       |\n  //                     + 3 -----------------+            |\n  //                     | Loop               |            |\n  //                     | p2 = phi(p1,...)   |            |\n  //                     +--------------------+            |\n  //                           |                           |\n  //                           |                           |\n  //                           v                           |\n  //                     + 4 -----------+                  |\n  //                     | Switch(p2)   |                  |\n  //                     +--------------+                  |\n  //                       /       \\                       |\n  //                     /           \\                     |\n  //                   /               \\                   |\n  //                 v                   v                 |\n  //           + 5 --------+        + 6 --------+          |\n  //           | Resume    |        | yield i   |          |\n  //           +-----------+        +-----------+          |\n  //                 |                                     |\n  //                 |                                     |\n  //                 |-------------------------------------|\n\n public:\n  explicit GeneratorAnalyzer(Zone* phase_zone,\n                             maglev::MaglevGraphLabeller* labeller)\n      : labeller_(labeller),\n        block_to_header_(phase_zone),\n        visit_queue_(phase_zone) {\n    USE(labeller_);\n  }\n\n  void Analyze(maglev::Graph* graph) {\n    for (auto it = graph->rbegin(); it != graph->rend(); ++it) {\n      if ((*it)->is_loop()) {\n        FindLoopBody(it);\n      }\n    }\n\n    FindLoopHeaderBypasses(graph);\n  }\n\n  bool JumpBypassesHeader(const maglev::BasicBlock* target) {\n    return block_to_innermost_bypassed_header_.contains(target);\n  }\n\n  const maglev::BasicBlock* GetInnermostBypassedHeader(\n      const maglev::BasicBlock* target) {\n    DCHECK(JumpBypassesHeader(target));\n    return block_to_innermost_bypassed_header_[target];\n  }\n\n  bool HeaderIsBypassed(const maglev::BasicBlock* header) {\n    DCHECK(header->is_loop());\n    return bypassed_headers_.contains(header);\n  }\n\n  const maglev::BasicBlock* GetLoopHeader(const maglev::BasicBlock* node) {\n    if (block_to_header_.contains(node)) {\n      return block_to_header_[node];\n    }\n    return nullptr;\n  }\n\n  bool has_header_bypasses() const { return !bypassed_headers_.empty(); }\n\n private:\n  // We consider that every block in between the loop header and the backedge\n  // belongs to the loop. This is a little bit more conservative than necessary\n  // and might include blocks that in fact cannot reach the backedge, but it\n  // makes dealing with exception blocks easier (because they have no explicit\n  // predecessors in Maglev).\n  void FindLoopBody(maglev::BlockConstReverseIterator it) {\n    const maglev::BasicBlock* header = *it;\n    DCHECK(header->is_loop());\n\n    --it;  // Skipping the header, since we consider its loop header to be the\n           // header of their outer loop (if any).\n\n    const maglev::BasicBlock* backedge_block = header->backedge_predecessor();\n    if (backedge_block == header) {\n      // This is a 1-block loop. Since headers are part of the outer loop, we\n      // have nothing to mark.\n      return;\n    }\n\n    block_to_header_[backedge_block] = header;\n\n    for (; *it != backedge_block; --it) {\n      const maglev::BasicBlock* curr = *it;\n      if (block_to_header_.contains(curr)) {\n        // {curr} is part of an inner loop.\n        continue;\n      }\n      block_to_header_[curr] = header;\n    }\n  }\n\n  void FindLoopHeaderBypasses(maglev::Graph* graph) {\n    // As mentioned earlier, Maglev graphs for resumable generator functions\n    // always start with a main dispatch switch in the 3rd block:\n    //\n    //\n    //                       + 1 -----------------+\n    //                       | InitialValues...   |\n    //                       | Jump               |\n    //                       +--------------------+\n    //                                  |\n    //                                  |\n    //                                  v\n    //                       + 2 --------------------+\n    //                       | BranchIfRootConstant  |\n    //                       +-----------------------+\n    //                          /                  \\\n    //                         /                     \\\n    //                        /                        \\\n    //                       /                           \\\n    //                      v                              v\n    //              + 3 ----------+                  + 4 --------------+\n    //              | Load state  |                  | Initial setup   |\n    //              | Switch      |                  | return          |\n    //              +-------------+                  +-----------------+\n    //                /    |    \\\n    //               /     |     \\\n    //              v      v      v\n    //          Resuming in various places\n    //\n    //\n    //\n    // In order to find loop header bypasses, we are looking for cases where\n    // the destination of the dispatch switch (= the successors of block 3) are\n    // inside a loop.\n\n    constexpr int kGeneratorSwitchBLockIndex = 2;\n    maglev::BasicBlock* generator_switch_block =\n        graph->blocks()[kGeneratorSwitchBLockIndex];\n    DCHECK(generator_switch_block->control_node()->Is<maglev::Switch>());\n\n    for (maglev::BasicBlock* target : generator_switch_block->successors()) {\n      const maglev::BasicBlock* innermost_header = GetLoopHeader(target);\n\n      if (innermost_header) {\n        // This case bypasses a loop header.\n        RecordHeadersForBypass(target, innermost_header);\n      }\n    }\n  }\n\n  void RecordHeadersForBypass(maglev::BasicBlock* initial_target,\n                              const maglev::BasicBlock* innermost_header) {\n    block_to_innermost_bypassed_header_[initial_target] = innermost_header;\n    bypassed_headers_.insert(innermost_header);\n\n    for (const maglev::BasicBlock* outer_header =\n             GetLoopHeader(innermost_header);\n         outer_header; outer_header = GetLoopHeader(outer_header)) {\n      bypassed_headers_.insert(outer_header);\n    }\n  }\n\n  maglev::MaglevGraphLabeller* labeller_;\n\n  // Map from blocks inside loops to the header of said loops.\n  ZoneAbslFlatHashMap<const maglev::BasicBlock*, const maglev::BasicBlock*>\n      block_to_header_;\n\n  // Map from jump target to the innermost header they bypass.\n  std::unordered_map<const maglev::BasicBlock*, const maglev::BasicBlock*>\n      block_to_innermost_bypassed_header_;\n  // Set of headers that are bypassed because of generator resumes.\n  std::unordered_set<const maglev::BasicBlock*> bypassed_headers_;\n\n  // {visit_queue_} is used in FindLoopBody to store nodes that still need to be\n  // visited. It is an instance variable in order to reuse its memory more\n  // efficiently.\n  ZoneVector<const maglev::BasicBlock*> visit_queue_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GraphBuildingNodeProcessor\",\n            \"about\": \"The core class responsible for processing Maglev graph nodes and building the Turboshaft graph.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"TSAssembler\",\n                \"BlockOriginTrackingReducer\",\n                \"MaglevEarlyLoweringReducer\",\n                \"MachineOptimizationReducer\",\n                \"VariableReducer\",\n                \"RequiredOptimizationReducer\",\n                \"ValueNumberingReducer\",\n                \"PipelineData\",\n                \"Graph\",\n                \"Zone\",\n                \"maglev::MaglevCompilationUnit\",\n                \"BailoutReason\",\n                \"TSAssembler\",\n                \"GraphBuildingNodeProcessor\",\n                \"AssemblerT\",\n                \"maglev::Constant\",\n                \"maglev::RootConstant\",\n                \"maglev::Int32Constant\",\n                \"maglev::Uint32Constant\",\n                \"maglev::Float64Constant\",\n                \"maglev::SmiConstant\",\n                \"maglev::TaggedIndexConstant\",\n                \"maglev::TrustedConstant\",\n                \"maglev::InitialValue\",\n                \"maglev::RegisterInput\",\n                \"maglev::FunctionEntryStackCheck\",\n                \"maglev::Phi\",\n                \"maglev::Call\",\n                \"maglev::CallKnownJSFunction\",\n                \"maglev::CallKnownApiFunction\",\n                \"maglev::CallBuiltin\",\n                \"maglev::CallRuntime\",\n                \"maglev::ThrowReferenceErrorIfHole\",\n                \"maglev::ThrowIfNotSuperConstructor\",\n                \"maglev::ThrowSuperAlreadyCalledIfNotHole\",\n                \"maglev::ThrowSuperNotCalledIfHole\",\n                \"maglev::ThrowIfNotCallable\",\n                \"maglev::CreateFunctionContext\",\n                \"maglev::FastCreateClosure\",\n                \"maglev::CreateClosure\",\n                \"maglev::CallWithArrayLike\",\n                \"maglev::CallWithSpread\",\n                \"maglev::CallForwardVarargs\",\n                \"maglev::Construct\",\n                \"maglev::ConstructWithSpread\",\n                \"maglev::CheckConstructResult\",\n                \"maglev::CheckDerivedConstructResult\",\n                \"maglev::SetKeyedGeneric\",\n                \"maglev::GetKeyedGeneric\",\n                \"maglev::SetNamedGeneric\",\n                \"maglev::LoadNamedGeneric\",\n                \"maglev::LoadNamedFromSuperGeneric\",\n                \"maglev::LoadGlobal\",\n                \"maglev::StoreGlobal\",\n                \"maglev::DefineKeyedOwnGeneric\",\n                \"maglev::DefineNamedOwnGeneric\",\n                \"maglev::GetIterator\",\n                \"maglev::CreateShallowObjectLiteral\",\n                \"maglev::CreateShallowArrayLiteral\",\n                \"maglev::StoreInArrayLiteralGeneric\",\n                \"maglev::MapPrototypeGet\",\n                \"maglev::MapPrototypeGetInt32Key\",\n                \"maglev::TestInstanceOf\",\n                \"maglev::DeleteProperty\",\n                \"maglev::ToName\",\n                \"maglev::CreateRegExpLiteral\",\n                \"maglev::GetTemplateObject\",\n                \"maglev::CreateObjectLiteral\",\n                \"maglev::CreateArrayLiteral\",\n                \"maglev::ForInPrepare\",\n                \"maglev::ForInNext\",\n                \"maglev::CheckSmi\",\n                \"maglev::CheckNumber\",\n                \"maglev::CheckBigInt\",\n                \"maglev::CheckString\",\n                \"maglev::CheckSymbol\",\n                \"maglev::CheckNotSymbol\",\n                \"maglev::CheckReceiver\",\n                \"maglev::ToObject\",\n                \"maglev::Allocate\",\n                \"maglev::AllocateAndInitializeElements\",\n                \"maglev::TransitionElementsKind\",\n                \"maglev::CreateArgumentsObject\",\n                \"maglev::CreateUnmappedArgumentsObject\",\n                \"maglev::MaterializeBox\",\n                \"maglev::LoadBoxedValue\",\n                \"maglev::StoreBoxedValue\",\n                \"maglev::LoadContext\",\n                \"maglev::StoreContext\",\n                \"maglev::LoadPropertyCell\",\n                \"maglev::StorePropertyCell\",\n                \"maglev::LoadElement\",\n                \"maglev::StoreElement\",\n                \"maglev::AddElement\",\n                \"maglev::HasElement\",\n                \"maglev::LoadField\",\n                \"maglev::StoreField\",\n                \"maglev::LoadExternal\",\n                \"maglev::StoreExternal\",\n                \"maglev::CreateObject\",\n                \"maglev::UnsafeCast\",\n                \"maglev::TransitionAndReinitialize\",\n                \"maglev::AllocateAndInitFunctionContext\",\n                \"maglev::LoadModuleVariable\",\n                \"maglev::StoreModuleVariable\",\n                \"maglev::IncBlockCounter\",\n                \"maglev::DecBlockCounter\",\n                \"maglev::IncLoopCounter\",\n                \"maglev::DecLoopCounter\",\n                \"maglev::CheckEquals\",\n                \"maglev::BranchIfTrue\",\n                \"maglev::BranchIfFalse\",\n                \"maglev::Branch\",\n                \"maglev::Switch\",\n                \"maglev::DeoptimizeIf\",\n                \"maglev::DeoptimizeUnless\",\n                \"maglev::Return\",\n                \"maglev::GeneratorResume\",\n                \"maglev::GeneratorClose\",\n                \"maglev::ResumeIfException\",\n                \"maglev::ResumeIfValue\",\n                \"maglev::Yield\",\n                \"maglev::Abort\",\n                \"maglev::CheckMap\",\n                \"maglev::CheckMaps\",\n                \"maglev::CheckElementsKind\",\n                \"maglev::CheckIf\",\n                \"maglev::TaggedToI32\",\n                \"maglev::TaggedToFloat64\",\n                \"maglev::TruncateInt32ToInt8\",\n                \"maglev::TruncateInt32ToInt16\",\n                \"maglev::ChangeUint32ToTagged\",\n                \"maglev::ChangeFloat64ToTagged\",\n                \"maglev::ChangeTaggedToUint32\",\n                \"maglev::ChangeTaggedToInt32\",\n                \"maglev::ChangeTaggedToFloat64\",\n                \"maglev::ChangeFloat64ToInt32\",\n                \"maglev::BitcastFloat64ToInt64\",\n                \"maglev::BitcastInt64ToFloat64\",\n                \"maglev::NumberToBoolean\",\n                \"maglev::PlainPrimitiveToNumber\",\n                \"maglev::ObjectToNumber\",\n                \"maglev::ObjectToInt32\",\n                \"maglev::NumberToInt32\",\n                \"maglev::NumberToUint32\",\n                \"maglev::NumberToFloat64\",\n                \"maglev::ObjectToBigInt\",\n                \"maglev::StringToNumber\",\n                \"maglev::StringToInt32\",\n                \"maglev::SameValue\",\n                \"maglev::GenericBinop\",\n                \"maglev::GenericUnop\",\n                \"maglev::StringLength\",\n                \"maglev::StringCharCodeAt\",\n                \"maglev::StringFromCharCode\",\n                \"maglev::RegExpExec\",\n                \"maglev::RegExpTest\",\n                \"maglev::OsrValue\",\n                \"maglev::StackSlot\",\n                \"maglev::TypeGuard\",\n                \"maglev::YieldAwait\",\n                \"maglev::CompareMapsGeneric\",\n                \"maglev::TryFinally\",\n                \"maglev::EndTry\",\n                \"maglev::ReThrow\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass GraphBuildingNodeProcessor {\n public:\n  using AssemblerT =\n      TSAssembler<BlockOriginTrackingReducer, MaglevEarlyLoweringReducer,\n                  MachineOptimizationReducer, VariableReducer,\n                  RequiredOptimizationReducer, ValueNumberingReducer>;\n\n  GraphBuildingNodeProcessor(\n      PipelineData* data, Graph& graph, Zone* temp_zone,\n      maglev::MaglevCompilationUnit* maglev_compilation_unit,\n      std::optional<BailoutReason>* bailout)\n      : data_(data),\n        temp_zone_(temp_zone),\n        assembler_(data, graph, graph, temp_zone),\n        maglev_compilation_unit_(maglev_compilation_unit),\n        node_mapping_(temp_zone),\n        block_mapping_(temp_zone),\n        regs_to_vars_(temp_zone),\n        loop_single_edge_predecessors_(temp_zone),\n        maglev_representations_(temp_zone),\n        generator_analyzer_(temp_zone,\n                            maglev_compilation_unit_->graph_labeller()),\n        bailout_(bailout) {}\n\n  void PreProcessGraph(maglev::Graph* graph) {\n    for (maglev::BasicBlock* block : *graph) {\n      block_mapping_[block] =\n          block->is_loop() ? __ NewLoopHeader() : __ NewBlock();\n    }\n    // Constants are not in a block in Maglev but are in Turboshaft. We bind a\n    // block now, so that Constants can then be emitted.\n    __ Bind(__ NewBlock());\n\n    // Initializing undefined constant so that we don't need to recreate it too\n    // often.\n    undefined_value_ = __ HeapConstant(local_factory_->undefined_value());\n\n    if (maglev_compilation_unit_->bytecode()\n            .incoming_new_target_or_generator_register()\n            .is_valid()) {\n      // The Maglev graph might contain a RegisterInput for\n      // kJavaScriptCallNewTargetRegister later in the graph, which in\n      // Turboshaft is represented as a Parameter. We create this Parameter\n      // here, because the Instruction Selector tends to be unhappy when\n      // Parameters are defined late in the graph.\n      int new_target_index = Linkage::GetJSCallNewTargetParamIndex(\n          maglev_compilation_unit_->parameter_count());\n      new_target_param_ = __ Parameter(\n          new_target_index, RegisterRepresentation::Tagged(), \"%new.target\");\n    }\n\n    if (graph->has_resumable_generator()) {\n      generator_analyzer_.Analyze(graph);\n\n      dummy_object_input_ = __ SmiZeroConstant();\n      dummy_word32_input_ = __ Word32Constant(0);\n      dummy_float64_input_ = __ Float64Constant(0);\n\n      header_switch_input_ = __ NewVariable(RegisterRepresentation::Word32());\n      loop_default_generator_value_ = __ Word32Constant(kDefaultSwitchVarValue);\n      generator_context_ =\n          __ NewLoopInvariantVariable(RegisterRepresentation::Tagged());\n      __ SetVariable(generator_context_, __ NoContextConstant());\n    }\n\n    // Maglev nodes often don't have the NativeContext as input, but instead\n    // rely on the MaglevAssembler to provide it during code generation, unlike\n    // Turboshaft nodes, which need the NativeContext as an explicit input if\n    // they use it. We thus emit a single NativeContext constant here, which we\n    // reuse later to construct Turboshaft nodes.\n    native_context_ =\n        __ HeapConstant(broker_->target_native_context().object());\n  }\n\n  void PostProcessGraph(maglev::Graph* graph) {\n    // It can happen that some Maglev loops don't actually loop (the backedge\n    // isn't actually reachable). We can't know this when emitting the header in\n    // Turboshaft, which means that we still emit the header, but then we never\n    // come around to calling FixLoopPhis on it. So, once we've generated the\n    // whole Turboshaft graph, we go over all loop headers, and if some turn out\n    // to not be headers, we turn them into regular merge blocks (and patch\n    // their PendingLoopPhis).\n    for (Block& block : __ output_graph().blocks()) {\n      if (block.IsLoop() && block.PredecessorCount() == 1) {\n        __ output_graph().TurnLoopIntoMerge(&block);\n      }\n    }\n  }\n\n  // The Maglev graph for resumable generator functions always has the main\n  // dispatch Switch in its 3rd block.\n  bool IsMaglevMainGeneratorSwitchBlock(\n      const maglev::BasicBlock* maglev_block) {\n    if (!generator_analyzer_.has_header_bypasses()) return false;\n    constexpr int kMainSwitchBlockId = 3;\n    bool is_main_switch_block =\n        maglev_compilation_unit_->graph_labeller()->BlockId(maglev_block) ==\n        kMainSwitchBlockId;\n    DCHECK_IMPLIES(is_main_switch_block,\n                   maglev_block->control_node()->Is<maglev::Switch>());\n    return is_main_switch_block;\n  }\n\n  void PostProcessBasicBlock(maglev::BasicBlock* maglev_block) {}\n  maglev::BlockProcessResult PreProcessBasicBlock(\n      maglev::BasicBlock* maglev_block) {\n    // Note that it's important to call SetMaglevInputBlock before calling Bind,\n    // so that BlockOriginTrackingReducer::Bind records the correct predecessor\n    // for the current block.\n    __ SetMaglevInputBlock(maglev_block);\n\n    is_visiting_generator_main_switch_ =\n        IsMaglevMainGeneratorSwitchBlock(maglev_block);\n\n    Block* turboshaft_block = Map(maglev_block);\n\n    if (__ current_block() != nullptr) {\n      // The first block for Constants doesn't end with a Jump, so we add one\n      // now.\n      __ Goto(turboshaft_block);\n    }\n\n#ifdef DEBUG\n    loop_phis_first_input_."
}