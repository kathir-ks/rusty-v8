{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/context-serializer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/context-serializer.cc\",\n            \"file_name\": \"context-serializer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Serializes a context for snapshotting, allowing for faster startup times by saving the state of the context.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for context serialization, API interaction, execution management, heap operations, number handling, object manipulation, slot management, and serializer/deserializer functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/context-serializer.h\"\n\n#include \"src/api/api-inl.h\"\n#include \"src/execution/microtask-queue.h\"\n#include \"src/heap/combined-heap.h\"\n#include \"src/numbers/math-random.h\"\n#include \"src/objects/embedder-data-array-inl.h\"\n#include \"src/objects/js-objects.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/slots.h\"\n#include \"src/snapshot/serializer-deserializer.h\"\n#include \"src/snapshot/startup-serializer.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SanitizeNativeContextScope\",\n                \"about\": \"Temporarily modifies the native context for serialization and restores it afterwards. It clears the microtask queue external pointer during serialization and restores it after serialization.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"native_context_\",\n                        \"type\": \"Tagged<NativeContext>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the native context to sanitize.\"\n                    },\n                    {\n                        \"name\": \"microtask_queue_external_pointer_\",\n                        \"type\": \"ExternalPointerSlot::RawContent\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the original value of the microtask queue external pointer.\"\n                    },\n                    {\n                        \"name\": \"no_gc_\",\n                        \"type\": \"const DisallowGarbageCollection&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to DisallowGarbageCollection object.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"NativeContext\",\n                    \"MicrotaskQueue\",\n                    \"ExternalPointerSlot\",\n                    \"DisallowGarbageCollection\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_NODISCARD SanitizeNativeContextScope final {\n public:\n  SanitizeNativeContextScope(Isolate* isolate,\n                             Tagged<NativeContext> native_context,\n                             bool allow_active_isolate_for_testing,\n                             const DisallowGarbageCollection& no_gc)\n      : native_context_(native_context), no_gc_(no_gc) {\n#ifdef DEBUG\n    if (!allow_active_isolate_for_testing) {\n      // Microtasks.\n      MicrotaskQueue* microtask_queue = native_context_->microtask_queue();\n      DCHECK_EQ(0, microtask_queue->size());\n      DCHECK(!microtask_queue->HasMicrotasksSuppressions());\n      DCHECK_EQ(0, microtask_queue->GetMicrotasksScopeDepth());\n      DCHECK(microtask_queue->DebugMicrotasksScopeDepthIsZero());\n    }\n#endif\n    microtask_queue_external_pointer_ =\n        native_context_\n            ->RawExternalPointerField(NativeContext::kMicrotaskQueueOffset,\n                                      kNativeContextMicrotaskQueueTag)\n            .GetAndClearContentForSerialization(no_gc);\n  }\n\n  ~SanitizeNativeContextScope() {\n    // Restore saved fields.\n    native_context_\n        ->RawExternalPointerField(NativeContext::kMicrotaskQueueOffset,\n                                  kNativeContextMicrotaskQueueTag)\n        .RestoreContentAfterSerialization(microtask_queue_external_pointer_,\n                                          no_gc_);\n  }\n\n private:\n  Tagged<NativeContext> native_context_;\n  ExternalPointerSlot::RawContent microtask_queue_external_pointer_;\n  const DisallowGarbageCollection& no_gc_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ContextSerializer\",\n                \"about\": \"Serializes a context to a snapshot for faster startup.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"startup_serializer_\",\n                        \"type\": \"StartupSerializer*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the startup serializer.\"\n                    },\n                    {\n                        \"name\": \"serialize_embedder_fields_\",\n                        \"type\": \"SerializeEmbedderFieldsCallback\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Callback function to serialize embedder fields.\"\n                    },\n                    {\n                        \"name\": \"can_be_rehashed_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the serialized context can be rehashed.\"\n                    },\n                    {\n                        \"name\": \"context_\",\n                        \"type\": \"Tagged<Context>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The context being serialized.\"\n                    },\n                    {\n                        \"name\": \"embedder_fields_sink_\",\n                        \"type\": \"Serializer::Sink\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Sink for embedder fields data.\"\n                    },\n                    {\n                        \"name\": \"api_wrapper_sink_\",\n                        \"type\": \"Serializer::Sink\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Sink for api wrapper fields data.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Serializer\",\n                    \"StartupSerializer\",\n                    \"Context\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass ContextSerializer : public Serializer {\n public:\n  ContextSerializer(Isolate* isolate,\n                                     Snapshot::SerializerFlags flags,\n                                     StartupSerializer* startup_serializer,\n                                     SerializeEmbedderFieldsCallback callback)\n    : Serializer(isolate, flags),\n      startup_serializer_(startup_serializer),\n      serialize_embedder_fields_(callback),\n      can_be_rehashed_(true) {\n  InitializeCodeAddressMap();\n}\n\n  ~ContextSerializer() {\n  OutputStatistics(\"ContextSerializer\");\n}\n\n  void Serialize(Tagged<Context>* o,\n                                  const DisallowGarbageCollection& no_gc);\n\n private:\n  void SerializeObjectImpl(Handle<HeapObject> obj,\n                                            SlotType slot_type);\n\n  bool ShouldBeInTheStartupObjectCache(Tagged<HeapObject> o);\n\n  bool ShouldBeInTheSharedObjectCache(Tagged<HeapObject> o);\n\n  void SerializeApiWrapperFields(\n    DirectHandle<JSObject> js_object);\n\n  template <typename V8Type, typename UserSerializerWrapper,\n          typename UserCallback, typename ApiObjectType>\nvoid SerializeObjectWithEmbedderFields(\n    Handle<V8Type> data_holder, int embedder_fields_count,\n    UserSerializerWrapper wrapper, UserCallback user_callback,\n    ApiObjectType api_obj);\n  \n  void CheckRehashability(Tagged<HeapObject> obj);\n\n  StartupSerializer* startup_serializer_;\n  SerializeEmbedderFieldsCallback serialize_embedder_fields_;\n  bool can_be_rehashed_;\n\n  Tagged<Context> context_;\n  Serializer::Sink embedder_fields_sink_;\n  Serializer::Sink api_wrapper_sink_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"InternalFieldSerializeWrapper\",\n                \"about\": \"Wrapper function for serializing internal fields of JS objects.\",\n                \"logic\": \"Handles the case where no user-provided serializer is available, defaulting to serializing the field as nullptr if it's already null.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the internal field.\"\n                    },\n                    {\n                        \"name\": \"field_is_nullptr\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether the field is a nullptr.\"\n                    },\n                    {\n                        \"name\": \"user_callback\",\n                        \"type\": \"v8::SerializeInternalFieldsCallback\",\n                        \"purpose\": \"The callback provided by the user for serializing the field.\"\n                    },\n                    {\n                        \"name\": \"api_obj\",\n                        \"type\": \"v8::Local<v8::Object>\",\n                        \"purpose\": \"The API object being serialized.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"v8::StartupData\",\n                    \"description\": \"The startup data containing the serialized field data.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nv8::StartupData InternalFieldSerializeWrapper(\n    int index, bool field_is_nullptr,\n    v8::SerializeInternalFieldsCallback user_callback,\n    v8::Local<v8::Object> api_obj) {\n  // If no serializer is provided and the field was empty, we\n  // serialize it by default to nullptr.\n  if (user_callback.callback == nullptr && field_is_nullptr) {\n    return StartupData{nullptr, 0};\n  }\n\n  DCHECK(user_callback.callback);\n  return user_callback.callback(api_obj, index, user_callback.data);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ContextDataSerializeWrapper\",\n                \"about\": \"Wrapper function for serializing context data.\",\n                \"logic\": \"If no user callback is provided, it defaults to the old behavior of serializing the context data verbatim.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the context data.\"\n                    },\n                    {\n                        \"name\": \"field_is_nullptr\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether the field is a nullptr.\"\n                    },\n                    {\n                        \"name\": \"user_callback\",\n                        \"type\": \"v8::SerializeContextDataCallback\",\n                        \"purpose\": \"The callback provided by the user for serializing the context data.\"\n                    },\n                    {\n                        \"name\": \"api_obj\",\n                        \"type\": \"v8::Local<v8::Context>\",\n                        \"purpose\": \"The API context being serialized.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"v8::StartupData\",\n                    \"description\": \"The startup data containing the serialized context data.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nv8::StartupData ContextDataSerializeWrapper(\n    int index, bool field_is_nullptr,\n    v8::SerializeContextDataCallback user_callback,\n    v8::Local<v8::Context> api_obj) {\n  // For compatibility, we do not require all non-null context pointer\n  // fields to be serialized by a proper user callback. Instead, if no\n  // user callback is provided, we serialize it verbatim, which was\n  // the old behavior before we introduce context data callbacks.\n  if (user_callback.callback == nullptr) {\n    return StartupData{nullptr, 0};\n  }\n\n  return user_callback.callback(api_obj, index, user_callback.data);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Serialize\",\n                \"parent\": \"ContextSerializer\",\n                \"about\": \"Serializes a V8 context.\",\n                \"logic\": \"This function performs the main serialization logic. It sets up the context, sanitizes it using SanitizeNativeContextScope, visits root pointers, serializes deferred objects, and handles embedder fields.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"o\",\n                        \"type\": \"Tagged<Context>*\",\n                        \"purpose\": \"The context to serialize.\"\n                    },\n                    {\n                        \"name\": \"no_gc\",\n                        \"type\": \"const DisallowGarbageCollection&\",\n                        \"purpose\": \"A DisallowGarbageCollection object to prevent garbage collection during serialization.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IsNativeContext\",\n                    \"SanitizeNativeContextScope\",\n                    \"VisitRootPointer\",\n                    \"SerializeDeferredObjects\",\n                    \"reference_map\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ContextSerializer::Serialize(Tagged<Context>* o,\n                                  const DisallowGarbageCollection& no_gc) {\n  context_ = *o;\n  DCHECK(IsNativeContext(context_));\n\n  // Upon deserialization, references to the global proxy and its map will be\n  // replaced.\n  reference_map()->AddAttachedReference(context_->global_proxy());\n  reference_map()->AddAttachedReference(context_->global_proxy()->map());\n\n  // The bootstrap snapshot has a code-stub context. When serializing the\n  // context snapshot, it is chained into the weak context list on the isolate\n  // and it's next context pointer may point to the code-stub context.  Clear\n  // it before serializing, it will get re-added to the context list\n  // explicitly when it's loaded.\n  // TODO(v8:10416): These mutations should not observably affect the running\n  // context.\n  context_->set(Context::NEXT_CONTEXT_LINK,\n                ReadOnlyRoots(isolate()).undefined_value());\n  DCHECK(!IsUndefined(context_->global_object()));\n  // Reset math random cache to get fresh random numbers.\n  MathRandom::ResetContext(context_);\n\n  SanitizeNativeContextScope sanitize_native_context(\n      isolate(), context_->native_context(), allow_active_isolate_for_testing(),\n      no_gc);\n\n  VisitRootPointer(Root::kStartupObjectCache, nullptr, FullObjectSlot(o));\n  SerializeDeferredObjects();\n\n  // Add section for embedder-serialized embedder fields.\n  if (!embedder_fields_sink_.data()->empty()) {\n    sink_.Put(kEmbedderFieldsData, \"embedder fields data\");\n    sink_.Append(embedder_fields_sink_);\n    sink_.Put(kSynchronize, \"Finished with embedder fields data\");\n  }\n\n  // Add section for embedder-serializer API wrappers.\n  if (!api_wrapper_sink_.data()->empty()) {\n    sink_.Put(kApiWrapperFieldsData, \"api wrapper fields data\");\n    sink_.Append(api_wrapper_sink_);\n    sink_.Put(kSynchronize, \"Finished with api wrapper fields data\");\n  }\n\n  Pad();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeObjectImpl\",\n                \"parent\": \"ContextSerializer\",\n                \"about\": \"Serializes a HeapObject based on its type and properties.\",\n                \"logic\": \"This function handles the serialization of various HeapObject types, including special handling for FeedbackVectors, JSObjects with embedder fields, and JSFunctions.  It also interacts with the startup serializer for caching frequently used objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"purpose\": \"The HeapObject to serialize.\"\n                    },\n                    {\n                        \"name\": \"slot_type\",\n                        \"type\": \"SlotType\",\n                        \"purpose\": \"The type of slot the object is referenced from.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"SerializeHotObject\",\n                    \"SerializeRoot\",\n                    \"SerializeBackReference\",\n                    \"SerializeReadOnlyObjectReference\",\n                    \"startup_serializer_\",\n                    \"ShouldBeInTheStartupObjectCache\",\n                    \"IsInternalizedString\",\n                    \"IsTemplateInfo\",\n                    \"FeedbackVector\",\n                    \"JSObject\",\n                    \"EmbedderDataArray\",\n                    \"ObjectSerializer\",\n                    \"IsJSApiWrapperObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ContextSerializer::SerializeObjectImpl(Handle<HeapObject> obj,\n                                            SlotType slot_type) {\n  DCHECK(!ObjectIsBytecodeHandler(*obj));  // Only referenced in dispatch table.\n\n  if (!allow_active_isolate_for_testing()) {\n    // When serializing a snapshot intended for real use, we should not end up\n    // at another native context.\n    // But in test scenarios there is no way to avoid this. Since we only\n    // serialize a single context in these cases, and this context does not\n    // have to be executable, we can simply ignore this.\n    DCHECK_IMPLIES(IsNativeContext(*obj), *obj == context_);\n  }\n\n  {\n    DisallowGarbageCollection no_gc;\n    Tagged<HeapObject> raw = *obj;\n    if (SerializeHotObject(raw)) return;\n    if (SerializeRoot(raw)) return;\n    if (SerializeBackReference(raw)) return;\n    if (SerializeReadOnlyObjectReference(raw, &sink_)) return;\n  }\n\n  if (startup_serializer_->SerializeUsingSharedHeapObjectCache(&sink_, obj)) {\n    return;\n  }\n\n  if (ShouldBeInTheStartupObjectCache(*obj)) {\n    startup_serializer_->SerializeUsingStartupObjectCache(&sink_, obj);\n    return;\n  }\n\n  // Pointers from the context snapshot to the objects in the startup snapshot\n  // should go through the root array or through the startup object cache.\n  // If this is not the case you may have to add something to the root array.\n  DCHECK(!startup_serializer_->ReferenceMapContains(obj));\n  // All the internalized strings that the context snapshot needs should be\n  // either in the root table or in the shared heap object cache.\n  DCHECK(!IsInternalizedString(*obj));\n  // Function and object templates are not context specific.\n  DCHECK(!IsTemplateInfo(*obj));\n\n  InstanceType instance_type = obj->map()->instance_type();\n  if (InstanceTypeChecker::IsFeedbackVector(instance_type)) {\n    // Clear literal boilerplates and feedback.\n    Cast<FeedbackVector>(obj)->ClearSlots(isolate());\n  } else if (InstanceTypeChecker::IsJSObject(instance_type)) {\n    Handle<JSObject> js_obj = Cast<JSObject>(obj);\n    int embedder_fields_count = js_obj->GetEmbedderFieldCount();\n    if (embedder_fields_count > 0) {\n      DCHECK(!js_obj->NeedsRehashing(cage_base()));\n      v8::Local<v8::Object> api_obj = v8::Utils::ToLocal(js_obj);\n      v8::SerializeInternalFieldsCallback user_callback =\n          serialize_embedder_fields_.js_object_callback;\n      SerializeObjectWithEmbedderFields(js_obj, embedder_fields_count,\n                                        InternalFieldSerializeWrapper,\n                                        user_callback, api_obj);\n      if (IsJSApiWrapperObject(*js_obj)) {\n        SerializeApiWrapperFields(js_obj);\n      }\n      return;\n    }\n    if (InstanceTypeChecker::IsJSFunction(instance_type)) {\n      DisallowGarbageCollection no_gc;\n      // Unconditionally reset the JSFunction to its SFI's code, since we can't\n      // serialize optimized code anyway.\n      Tagged<JSFunction> closure = Cast<JSFunction>(*obj);\n      if (closure->shared()->HasBytecodeArray()) {\n        closure->SetInterruptBudget(isolate(), BudgetModification::kReset);\n      }\n      closure->ResetIfCodeFlushed(isolate());\n      if (closure->is_compiled(isolate())) {\n        if (closure->shared()->HasBaselineCode()) {\n          closure->shared()->FlushBaselineCode();\n        }\n        Tagged<Code> sfi_code = closure->shared()->GetCode(isolate());\n        if (!sfi_code.SafeEquals(closure->code(isolate()))) {\n          closure->UpdateCode(sfi_code);\n        }\n      }\n    }\n  } else if (InstanceTypeChecker::IsEmbedderDataArray(instance_type) &&\n             !allow_active_isolate_for_testing()) {\n    DCHECK_EQ(*obj, context_->embedder_data());\n    Handle<EmbedderDataArray> embedder_data = Cast<EmbedderDataArray>(obj);\n    int embedder_fields_count = embedder_data->length();\n    if (embedder_data->length() > 0) {\n      DirectHandle<Context> context_handle(context_, isolate());\n      v8::Local<v8::Context> api_obj =\n          v8::Utils::ToLocal(Cast<NativeContext>(context_handle));\n      v8::SerializeContextDataCallback user_callback =\n          serialize_embedder_fields_.context_callback;\n      SerializeObjectWithEmbedderFields(embedder_data, embedder_fields_count,\n                                        ContextDataSerializeWrapper,\n                                        user_callback, api_obj);\n      return;\n    }\n  }\n\n  CheckRehashability(*obj);\n\n  // Object has not yet been serialized.  Serialize it here.\n  ObjectSerializer serializer(this, obj, &sink_);\n  serializer.Serialize(slot_type);\n  if (IsJSApiWrapperObject(obj->map())) {\n    SerializeApiWrapperFields(Cast<JSObject>(obj));\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ShouldBeInTheStartupObjectCache\",\n                \"parent\": \"ContextSerializer\",\n                \"about\": \"Determines whether a given HeapObject should be placed in the startup object cache.\",\n                \"logic\": \"This function checks the type of the HeapObject and returns true if it's a type that should be cached in the startup object cache (e.g., Names, Scripts, SharedFunctionInfos, HeapNumbers, Code objects, InstructionStreams, ScopeInfos, AccessorInfos, TemplateInfos or ClassPositions).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"o\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The HeapObject to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object should be in the startup object cache, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"IsName\",\n                    \"IsScript\",\n                    \"IsSharedFunctionInfo\",\n                    \"IsHeapNumber\",\n                    \"IsCode\",\n                    \"IsInstructionStream\",\n                    \"IsScopeInfo\",\n                    \"IsAccessorInfo\",\n                    \"IsTemplateInfo\",\n                    \"IsClassPositions\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool ContextSerializer::ShouldBeInTheStartupObjectCache(Tagged<HeapObject> o) {\n  // We can't allow scripts to be part of the context snapshot because they\n  // contain a unique ID, and deserializing several context snapshots containing\n  // script would cause dupes.\n  return IsName(o) || IsScript(o) || IsSharedFunctionInfo(o) ||\n         IsHeapNumber(o) || IsCode(o) || IsInstructionStream(o) ||\n         IsScopeInfo(o) || IsAccessorInfo(o) || IsTemplateInfo(o) ||\n         IsClassPositions(o) ||\n         o->map() == ReadOnlyRoots(isolate()).fixed_cow_array_map();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ShouldBeInTheSharedObjectCache\",\n                \"parent\": \"ContextSerializer\",\n                \"about\": \"Determines whether a given HeapObject should be placed in the shared object cache.\",\n                \"logic\": \"This function returns true if the object is an internalized string, as internalized strings are often shared between isolates.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"o\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The HeapObject to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object should be in the shared object cache, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"IsInternalizedString\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool ContextSerializer::ShouldBeInTheSharedObjectCache(Tagged<HeapObject> o) {\n  // v8_flags.shared_string_table may be true during deserialization, so put\n  // internalized strings into the shared object snapshot.\n  return IsInternalizedString(o);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeApiWrapperFields\",\n                \"parent\": \"ContextSerializer\",\n                \"about\": \"Serializes fields of JS API wrapper objects.\",\n                \"logic\": \"If there is a callback for the API wrapper and the object is not null, calls the callback to serialize the data. Stores the back reference index and the raw size and data in the api_wrapper_sink_.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"js_object\",\n                        \"type\": \"DirectHandle<JSObject>\",\n                        \"purpose\": \"The JS API wrapper object to serialize.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IsJSApiWrapperObject\",\n                    \"JSApiWrapper\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ContextSerializer::SerializeApiWrapperFields(\n    DirectHandle<JSObject> js_object) {\n  DCHECK(IsJSApiWrapperObject(*js_object));\n  auto* cpp_heap_pointer =\n      JSApiWrapper(*js_object)\n          .GetCppHeapWrappable(isolate(), kAnyCppHeapPointer);\n  const auto& callback_data = serialize_embedder_fields_.api_wrapper_callback;\n  if (callback_data.callback == nullptr && cpp_heap_pointer == nullptr) {\n    // No need to serialize anything as empty handles or handles pointing to\n    // null objects will be preserved.\n    return;\n  }\n  DCHECK_NOT_NULL(callback_data.callback);\n  const auto data = callback_data.callback(\n      v8::Utils::ToLocal(js_object), cpp_heap_pointer, callback_data.data);\n  if (DataIsEmpty(data)) {\n    return;\n  }\n  const SerializerReference* reference =\n      reference_map()->LookupReference(*js_object);\n  DCHECK_NOT_NULL(reference);\n  DCHECK(reference->is_back_reference());\n  api_wrapper_sink_.Put(kNewObject, \"api wrapper field holder\");\n  api_wrapper_sink_.PutUint30(reference->back_ref_index(), \"BackRefIndex\");\n  api_wrapper_sink_.PutUint30(data.raw_size, \"api wrapper raw field data size\");\n  api_wrapper_sink_.PutRaw(reinterpret_cast<const uint8_t*>(data.data),\n                           data.raw_size, \"api wrapper raw field data\");\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeObjectWithEmbedderFields\",\n                \"parent\": \"ContextSerializer\",\n                \"about\": \"Serializes an object along with its embedder fields.\",\n                \"logic\": \"This function iterates through the embedder fields of the object, stores their original values, and clears the fields. It then serializes the object itself and stores the data returned by the embedder callbacks in a separate sink, which is later appended to the main sink.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"data_holder\",\n                        \"type\": \"Handle<V8Type>\",\n                        \"purpose\": \"The object holding the embedder fields.\"\n                    },\n                    {\n                        \"name\": \"embedder_fields_count\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of embedder fields to serialize.\"\n                    },\n                    {\n                        \"name\": \"wrapper\",\n                        \"type\": \"UserSerializerWrapper\",\n                        \"purpose\": \"Wrapper for the user-provided serialization callback.\"\n                    },\n                    {\n                        \"name\": \"user_callback\",\n                        \"type\": \"UserCallback\",\n                        \"purpose\": \"The user-provided serialization callback.\"\n                    },\n                    {\n                        \"name\": \"api_obj\",\n                        \"type\": \"ApiObjectType\",\n                        \"purpose\": \"The API object to pass to the user callback.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"EmbedderDataSlot\",\n                    \"ObjectSerializer\",\n                    \"reference_map\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename V8Type, typename UserSerializerWrapper,\n          typename UserCallback, typename ApiObjectType>\nvoid ContextSerializer::SerializeObjectWithEmbedderFields(\n    Handle<V8Type> data_holder, int embedder_fields_count,\n    UserSerializerWrapper wrapper, UserCallback user_callback,\n    ApiObjectType api_obj) {\n  DisallowGarbageCollection no_gc;\n  CHECK_GT(embedder_fields_count, 0);\n  DisallowJavascriptExecution no_js(isolate());\n  DisallowCompilation no_compile(isolate());\n\n  auto raw_obj = *data_holder;\n\n  std::vector<EmbedderDataSlot::RawData> original_embedder_values;\n  std::vector<StartupData> serialized_data;\n  std::vector<bool> should_clear_slot;\n\n  // 1) Iterate embedder fields. Hold onto the original value of the fields.\n  //    Ignore references to heap objects since these are to be handled by the\n  //    serializer. For aligned pointers, call the serialize callback. Hold\n  //    onto the result.\n  for (int i = 0; i < embedder_fields_count; i++) {\n    EmbedderDataSlot slot(raw_obj, i);\n    original_embedder_values.emplace_back(slot.load_raw(isolate(), no_gc));\n    Tagged<Object> object = slot.load_tagged();\n    if (IsHeapObject(object)) {\n      DCHECK(IsValidHeapObject(isolate()->heap(), Cast<HeapObject>(object)));\n      serialized_data.push_back({nullptr, 0});\n      should_clear_slot.push_back(false);\n    } else {\n      StartupData data =\n          wrapper(i, object == Smi::zero(), user_callback, api_obj);\n      serialized_data.push_back(data);\n      bool clear_slot =\n          !DataIsEmpty(data) || slot.MustClearDuringSerialization(no_gc);\n      should_clear_slot.push_back(clear_slot);\n    }\n  }\n\n  // 2) Prevent embedder fields that are not V8 objects from ending up in the\n  //    blob.  This is done separately to step 1 so as to not interleave with\n  //    embedder callbacks.\n  for (int i = 0; i < embedder_fields_count; i++) {\n    if (should_clear_slot[i]) {\n      EmbedderDataSlot(raw_obj, i).store_raw(isolate(), kNullAddress, no_gc);\n    }\n  }\n\n  // 3) Serialize the object. References from embedder fields to heap objects or\n  //    smis are serialized regularly.\n  {\n    AllowGarbageCollection allow_gc;\n    ObjectSerializer(this, data_holder, &sink_).Serialize(SlotType::kAnySlot);\n    // Reload raw pointer.\n    raw_obj = *data_holder;\n  }\n\n  // 4) Obtain back reference for the serialized object.\n  const SerializerReference* reference =\n      reference_map()->LookupReference(raw_obj);\n  DCHECK_NOT_NULL(reference);\n  DCHECK(reference->is_back_reference());\n\n  // 5) Write data returned by the embedder callbacks into a separate sink,\n  //    headed by the back reference. Restore the original embedder fields.\n  for (int i = 0; i < embedder_fields_count; i++) {\n    StartupData data = serialized_data[i];\n    if (!should_clear_slot[i]) continue;\n    // Restore original values from cleared fields.\n    EmbedderDataSlot(raw_obj, i)\n        .store_raw(isolate(), original_embedder_values[i], no_gc);\n    if (DataIsEmpty(data)) continue;\n    embedder_fields_sink_.Put(kNewObject, \"embedder field holder\");\n    embedder_fields_sink_.PutUint30(reference->back_ref_index(),\n                                    \"BackRefIndex\");\n    embedder_fields_sink_.PutUint30(i, \"embedder field index\");\n    embedder_fields_sink_.PutUint30(data.raw_size, \"embedder fields data size\");\n    embedder_fields_sink_.PutRaw(reinterpret_cast<const uint8_t*>(data.data),\n                                 data.raw_size, \"embedder fields data\");\n    delete[] data.data;\n  }\n\n  // 6) The content of the separate sink is appended eventually to the default\n  //    sink. The ensures that during deserialization, we call the deserializer\n  //    callback at the end, and can guarantee that the deserialized objects are\n  //    in a consistent state. See ContextSerializer::Serialize.\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\":"
}