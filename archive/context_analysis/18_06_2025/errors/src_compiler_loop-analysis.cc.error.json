{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/loop-analysis.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/loop-analysis.cc\",\n            \"file_name\": \"loop-analysis.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements loop analysis algorithms for the Turbofan compiler in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for loop analysis, code generation, graph manipulation, and memory management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/loop-analysis.h\"\n\n#include \"src/codegen/tick-counter.h\"\n#include \"src/compiler/all-nodes.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/node-marker.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoopFinderImpl\",\n                \"about\": \"Encapsulates the loop finding algorithm for Turbofan graphs.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"LoopTree\",\n                    \"TickCounter\",\n                    \"Zone\",\n                    \"NodeDeque\",\n                    \"NodeMarker\",\n                    \"ZoneVector\",\n                    \"NodeInfo\",\n                    \"TempLoopInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass LoopFinderImpl {\n public:\n  LoopFinderImpl(TFGraph* graph, LoopTree* loop_tree, TickCounter* tick_counter,\n                 Zone* zone)\n      : zone_(zone),\n        end_(graph->end()),\n        queue_(zone),\n        queued_(graph, 2),\n        info_(graph->NodeCount(), {nullptr, nullptr, false}, zone),\n        loops_(zone),\n        loop_num_(graph->NodeCount(), -1, zone),\n        loop_tree_(loop_tree),\n        loops_found_(0),\n        width_(0),\n        backward_(nullptr),\n        forward_(nullptr),\n        tick_counter_(tick_counter) {}\n\n  void Run() {\n    PropagateBackward();\n    PropagateForward();\n    FinishLoopTree();\n  }\n\n  void Print() {\n    // Print out the results.\n    for (NodeInfo& ni : info_) {\n      if (ni.node == nullptr) continue;\n      for (int i = 1; i <= loops_found_; i++) {\n        int index = ni.node->id() * width_ + INDEX(i);\n        bool marked_forward = forward_[index] & BIT(i);\n        bool marked_backward = backward_[index] & BIT(i);\n        if (marked_forward && marked_backward) {\n          PrintF(\"X\");\n        } else if (marked_forward) {\n          PrintF(\">\");\n        } else if (marked_backward) {\n          PrintF(\"<\");\n        } else {\n          PrintF(\" \");\n        }\n      }\n      PrintF(\" #%d:%s\\n\", ni.node->id(), ni.node->op()->mnemonic());\n    }\n\n    int i = 0;\n    for (TempLoopInfo& li : loops_) {\n      PrintF(\"Loop %d headed at #%d\\n\", i, li.header->id());\n      i++;\n    }\n\n    for (LoopTree::Loop* loop : loop_tree_->outer_loops_) {\n      PrintLoop(loop);\n    }\n  }\n\n private:\n  Zone* zone_;\n  Node* end_;\n  NodeDeque queue_;\n  NodeMarker<bool> queued_;\n  ZoneVector<NodeInfo> info_;\n  ZoneVector<TempLoopInfo> loops_;\n  ZoneVector<int> loop_num_;\n  LoopTree* loop_tree_;\n  int loops_found_;\n  int width_;\n  uint32_t* backward_;\n  uint32_t* forward_;\n  TickCounter* const tick_counter_;\n\n  int num_nodes() {\n    return static_cast<int>(loop_tree_->node_to_loop_num_.size());\n  }\n\n  // Tb = Tb | (Fb - loop_filter)\n  bool PropagateBackwardMarks(Node* from, Node* to, int loop_filter) {\n    if (from == to) return false;\n    uint32_t* fp = &backward_[from->id() * width_];\n    uint32_t* tp = &backward_[to->id() * width_];\n    bool change = false;\n    for (int i = 0; i < width_; i++) {\n      uint32_t mask = i == INDEX(loop_filter) ? ~BIT(loop_filter) : 0xFFFFFFFF;\n      uint32_t prev = tp[i];\n      uint32_t next = prev | (fp[i] & mask);\n      tp[i] = next;\n      if (!change && (prev != next)) change = true;\n    }\n    return change;\n  }\n\n  // Tb = Tb | B\n  bool SetBackwardMark(Node* to, int loop_num) {\n    uint32_t* tp = &backward_[to->id() * width_ + INDEX(loop_num)];\n    uint32_t prev = tp[0];\n    uint32_t next = prev | BIT(loop_num);\n    tp[0] = next;\n    return next != prev;\n  }\n\n  // Tf = Tf | B\n  bool SetForwardMark(Node* to, int loop_num) {\n    uint32_t* tp = &forward_[to->id() * width_ + INDEX(loop_num)];\n    uint32_t prev = tp[0];\n    uint32_t next = prev | BIT(loop_num);\n    tp[0] = next;\n    return next != prev;\n  }\n\n  // Tf = Tf | (Ff & Tb)\n  bool PropagateForwardMarks(Node* from, Node* to) {\n    if (from == to) return false;\n    bool change = false;\n    int findex = from->id() * width_;\n    int tindex = to->id() * width_;\n    for (int i = 0; i < width_; i++) {\n      uint32_t marks = backward_[tindex + i] & forward_[findex + i];\n      uint32_t prev = forward_[tindex + i];\n      uint32_t next = prev | marks;\n      forward_[tindex + i] = next;\n      if (!change && (prev != next)) change = true;\n    }\n    return change;\n  }\n\n  bool IsInLoop(Node* node, int loop_num) {\n    int offset = node->id() * width_ + INDEX(loop_num);\n    return backward_[offset] & forward_[offset] & BIT(loop_num);\n  }\n\n  // Propagate marks backward from loop headers.\n  void PropagateBackward() {\n    ResizeBackwardMarks();\n    SetBackwardMark(end_, 0);\n    Queue(end_);\n\n    while (!queue_.empty()) {\n      tick_counter_->TickAndMaybeEnterSafepoint();\n      Node* node = queue_.front();\n      info(node).backwards_visited = true;\n      queue_.pop_front();\n      queued_.Set(node, false);\n\n      int loop_num = -1;\n      // Setup loop headers first.\n      if (node->opcode() == IrOpcode::kLoop) {\n        // found the loop node first.\n        loop_num = CreateLoopInfo(node);\n      } else if (NodeProperties::IsPhi(node)) {\n        // found a phi first.\n        Node* merge = node->InputAt(node->InputCount() - 1);\n        if (merge->opcode() == IrOpcode::kLoop) {\n          loop_num = CreateLoopInfo(merge);\n        }\n      } else if (node->opcode() == IrOpcode::kLoopExit) {\n        // Intentionally ignore return value. Loop exit node marks\n        // are propagated normally.\n        CreateLoopInfo(node->InputAt(1));\n      } else if (node->opcode() == IrOpcode::kLoopExitValue ||\n                 node->opcode() == IrOpcode::kLoopExitEffect) {\n        Node* loop_exit = NodeProperties::GetControlInput(node);\n        // Intentionally ignore return value. Loop exit node marks\n        // are propagated normally.\n        CreateLoopInfo(loop_exit->InputAt(1));\n      }\n\n      // Propagate marks backwards from this node.\n      for (int i = 0; i < node->InputCount(); i++) {\n        Node* input = node->InputAt(i);\n        if (IsBackedge(node, i)) {\n          // Only propagate the loop mark on backedges.\n          if (SetBackwardMark(input, loop_num) ||\n              !info(input).backwards_visited) {\n            Queue(input);\n          }\n        } else {\n          // Entry or normal edge. Propagate all marks except loop_num.\n          // TODO(manoskouk): Add test that needs backwards_visited to function\n          // correctly, probably using wasm loop unrolling when it is available.\n          if (PropagateBackwardMarks(node, input, loop_num) ||\n              !info(input).backwards_visited) {\n            Queue(input);\n          }\n        }\n      }\n    }\n  }\n\n  // Make a new loop if necessary for the given node.\n  int CreateLoopInfo(Node* node) {\n    DCHECK_EQ(IrOpcode::kLoop, node->opcode());\n    int loop_num = LoopNum(node);\n    if (loop_num > 0) return loop_num;\n\n    loop_num = ++loops_found_;\n    if (INDEX(loop_num) >= width_) ResizeBackwardMarks();\n\n    // Create a new loop.\n    loops_.push_back({node, nullptr, nullptr, nullptr, nullptr});\n    loop_tree_->NewLoop();\n    SetLoopMarkForLoopHeader(node, loop_num);\n    return loop_num;\n  }\n\n  void SetLoopMark(Node* node, int loop_num) {\n    info(node);  // create the NodeInfo\n    SetBackwardMark(node, loop_num);\n    loop_tree_->node_to_loop_num_[node->id()] = loop_num;\n  }\n\n  void SetLoopMarkForLoopHeader(Node* node, int loop_num) {\n    DCHECK_EQ(IrOpcode::kLoop, node->opcode());\n    SetLoopMark(node, loop_num);\n    for (Node* use : node->uses()) {\n      if (NodeProperties::IsPhi(use)) {\n        SetLoopMark(use, loop_num);\n      }\n\n      // Do not keep the loop alive if it does not have any backedges.\n      if (node->InputCount() <= 1) continue;\n\n      if (use->opcode() == IrOpcode::kLoopExit) {\n        SetLoopMark(use, loop_num);\n        for (Node* exit_use : use->uses()) {\n          if (exit_use->opcode() == IrOpcode::kLoopExitValue ||\n              exit_use->opcode() == IrOpcode::kLoopExitEffect) {\n            SetLoopMark(exit_use, loop_num);\n          }\n        }\n      }\n    }\n  }\n\n  void ResizeBackwardMarks() {\n    int new_width = width_ + 1;\n    int max = num_nodes();\n    uint32_t* new_backward = zone_->AllocateArray<uint32_t>(new_width * max);\n    memset(new_backward, 0, new_width * max * sizeof(uint32_t));\n    if (width_ > 0) {  // copy old matrix data.\n      for (int i = 0; i < max; i++) {\n        uint32_t* np = &new_backward[i * new_width];\n        uint32_t* op = &backward_[i * width_];\n        for (int j = 0; j < width_; j++) np[j] = op[j];\n      }\n    }\n    width_ = new_width;\n    backward_ = new_backward;\n  }\n\n  void ResizeForwardMarks() {\n    int max = num_nodes();\n    forward_ = zone_->AllocateArray<uint32_t>(width_ * max);\n    memset(forward_, 0, width_ * max * sizeof(uint32_t));\n  }\n\n  // Propagate marks forward from loops.\n  void PropagateForward() {\n    ResizeForwardMarks();\n    for (TempLoopInfo& li : loops_) {\n      SetForwardMark(li.header, LoopNum(li.header));\n      Queue(li.header);\n    }\n    // Propagate forward on paths that were backward reachable from backedges.\n    while (!queue_.empty()) {\n      tick_counter_->TickAndMaybeEnterSafepoint();\n      Node* node = queue_.front();\n      queue_.pop_front();\n      queued_.Set(node, false);\n      for (Edge edge : node->use_edges()) {\n        Node* use = edge.from();\n        if (!IsBackedge(use, edge.index())) {\n          if (PropagateForwardMarks(node, use)) Queue(use);\n        }\n      }\n    }\n  }\n\n  bool IsLoopHeaderNode(Node* node) {\n    return node->opcode() == IrOpcode::kLoop || NodeProperties::IsPhi(node);\n  }\n\n  bool IsLoopExitNode(Node* node) {\n    return node->opcode() == IrOpcode::kLoopExit ||\n           node->opcode() == IrOpcode::kLoopExitValue ||\n           node->opcode() == IrOpcode::kLoopExitEffect;\n  }\n\n  bool IsBackedge(Node* use, int index) {\n    if (LoopNum(use) <= 0) return false;\n    if (NodeProperties::IsPhi(use)) {\n      return index != NodeProperties::FirstControlIndex(use) &&\n             index != kAssumedLoopEntryIndex;\n    } else if (use->opcode() == IrOpcode::kLoop) {\n      return index != kAssumedLoopEntryIndex;\n    }\n    DCHECK(IsLoopExitNode(use));\n    return false;\n  }\n\n  int LoopNum(Node* node) { return loop_tree_->node_to_loop_num_[node->id()]; }\n\n  NodeInfo& info(Node* node) {\n    NodeInfo& i = info_[node->id()];\n    if (i.node == nullptr) i.node = node;\n    return i;\n  }\n\n  void Queue(Node* node) {\n    if (!queued_.Get(node)) {\n      queue_.push_back(node);\n      queued_.Set(node, true);\n    }\n  }\n\n  void AddNodeToLoop(NodeInfo* node_info, TempLoopInfo* loop, int loop_num) {\n    if (LoopNum(node_info->node) == loop_num) {\n      if (IsLoopHeaderNode(node_info->node)) {\n        node_info->next = loop->header_list;\n        loop->header_list = node_info;\n      } else {\n        DCHECK(IsLoopExitNode(node_info->node));\n        node_info->next = loop->exit_list;\n        loop->exit_list = node_info;\n      }\n    } else {\n      node_info->next = loop->body_list;\n      loop->body_list = node_info;\n    }\n  }\n\n  void FinishLoopTree() {\n    DCHECK(loops_found_ == static_cast<int>(loops_.size()));\n    DCHECK(loops_found_ == static_cast<int>(loop_tree_->all_loops_.size()));\n\n    // Degenerate cases.\n    if (loops_found_ == 0) return;\n    if (loops_found_ == 1) return FinishSingleLoop();\n\n    for (int i = 1; i <= loops_found_; i++) ConnectLoopTree(i);\n\n    size_t count = 0;\n    // Place the node into the innermost nested loop of which it is a member.\n    for (NodeInfo& ni : info_) {\n      if (ni.node == nullptr) continue;\n\n      TempLoopInfo* innermost = nullptr;\n      int innermost_index = 0;\n      int pos = ni.node->id() * width_;\n      // Search the marks word by word.\n      for (int i = 0; i < width_; i++) {\n        uint32_t marks = backward_[pos + i] & forward_[pos + i];\n\n        for (int j = 0; j < 32; j++) {\n          if (marks & (1u << j)) {\n            int loop_num = i * 32 + j;\n            if (loop_num == 0) continue;\n            TempLoopInfo* loop = &loops_[loop_num - 1];\n            if (innermost == nullptr ||\n                loop->loop->depth_ > innermost->loop->depth_) {\n              innermost = loop;\n              innermost_index = loop_num;\n            }\n          }\n        }\n      }\n      if (innermost == nullptr) continue;\n\n      // Return statements should never be found by forward or backward walk.\n      CHECK(ni.node->opcode() != IrOpcode::kReturn);\n\n      AddNodeToLoop(&ni, innermost, innermost_index);\n      count++;\n    }\n\n    // Serialize the node lists for loops into the loop tree.\n    loop_tree_->loop_nodes_.reserve(count);\n    for (LoopTree::Loop* loop : loop_tree_->outer_loops_) {\n      SerializeLoop(loop);\n    }\n  }\n\n  // Handle the simpler case of a single loop (no checks for nesting necessary).\n  void FinishSingleLoop() {\n    // Place nodes into the loop header and body.\n    TempLoopInfo* li = &loops_[0];\n    li->loop = &loop_tree_->all_loops_[0];\n    loop_tree_->SetParent(nullptr, li->loop);\n    size_t count = 0;\n    for (NodeInfo& ni : info_) {\n      if (ni.node == nullptr || !IsInLoop(ni.node, 1)) continue;\n\n      // Return statements should never be found by forward or backward walk.\n      CHECK(ni.node->opcode() != IrOpcode::kReturn);\n\n      AddNodeToLoop(&ni, li, 1);\n      count++;\n    }\n\n    // Serialize the node lists for the loop into the loop tree.\n    loop_tree_->loop_nodes_.reserve(count);\n    SerializeLoop(li->loop);\n  }\n\n  // Recursively serialize the list of header nodes and body nodes\n  // so that nested loops occupy nested intervals.\n  void SerializeLoop(LoopTree::Loop* loop) {\n    int loop_num = loop_tree_->LoopNum(loop);\n    TempLoopInfo& li = loops_[loop_num - 1];\n\n    // Serialize the header.\n    loop->header_start_ = static_cast<int>(loop_tree_->loop_nodes_.size());\n    for (NodeInfo* ni = li.header_list; ni != nullptr; ni = ni->next) {\n      loop_tree_->loop_nodes_.push_back(ni->node);\n      loop_tree_->node_to_loop_num_[ni->node->id()] = loop_num;\n    }\n\n    // Serialize the body.\n    loop->body_start_ = static_cast<int>(loop_tree_->loop_nodes_.size());\n    for (NodeInfo* ni = li.body_list; ni != nullptr; ni = ni->next) {\n      loop_tree_->loop_nodes_.push_back(ni->node);\n      loop_tree_->node_to_loop_num_[ni.node->id()] = loop_num;\n    }\n\n    // Serialize nested loops.\n    for (LoopTree::Loop* child : loop->children_) SerializeLoop(child);\n\n    // Serialize the exits.\n    loop->exits_start_ = static_cast<int>(loop_tree_->loop_nodes_.size());\n    for (NodeInfo* ni = li.exit_list; ni != nullptr; ni = ni->next) {\n      loop_tree_->loop_nodes_.push_back(ni->node);\n      loop_tree_->node_to_loop_num_[ni.node->id()] = loop_num;\n    }\n\n    loop->exits_end_ = static_cast<int>(loop_tree_->loop_nodes_.size());\n  }\n\n  // Connect the LoopTree loops to their parents recursively.\n  LoopTree::Loop* ConnectLoopTree(int loop_num) {\n    TempLoopInfo& li = loops_[loop_num - 1];\n    if (li.loop != nullptr) return li.loop;\n\n    NodeInfo& ni = info(li.header);\n    LoopTree::Loop* parent = nullptr;\n    for (int i = 1; i <= loops_found_; i++) {\n      if (i == loop_num) continue;\n      if (IsInLoop(ni.node, i)) {\n        // recursively create potential parent loops first.\n        LoopTree::Loop* upper = ConnectLoopTree(i);\n        if (parent == nullptr || upper->depth_ > parent->depth_) {\n          parent = upper;\n        }\n      }\n    }\n    li.loop = &loop_tree_->all_loops_[loop_num - 1];\n    loop_tree_->SetParent(parent, li.loop);\n    return li.loop;\n  }\n\n  void PrintLoop(LoopTree::Loop* loop) {\n    for (int i = 0; i < loop->depth_; i++) PrintF(\"  \");\n    PrintF(\"Loop depth = %d \", loop->depth_);\n    int i = loop->header_start_;\n    while (i < loop->body_start_) {\n      PrintF(\" H#%d\", loop_tree_->loop_nodes_[i++]->id());\n    }\n    while (i < loop->exits_start_) {\n      PrintF(\" B#%d\", loop_tree_->loop_nodes_[i++]->id());\n    }\n    while (i < loop->exits_end_) {\n      PrintF(\" E#%d\", loop_tree_->loop_nodes_[i++]->id());\n    }\n    PrintF(\"\\n\");\n    for (LoopTree::Loop* child : loop->children_) PrintLoop(child);\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BuildLoopTree\",\n                \"about\": \"Builds a LoopTree from a Turbofan graph.\",\n                \"logic\": \"Creates a LoopTree object, uses the LoopFinderImpl class to perform the loop analysis, and returns the populated LoopTree.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The Turbofan graph to analyze.\"\n                    },\n                    {\n                        \"name\": \"tick_counter\",\n                        \"type\": \"TickCounter*\",\n                        \"purpose\": \"A tick counter for safepoint checks.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"Memory zone for allocations.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"LoopTree*\",\n                    \"description\": \"The constructed LoopTree.\"\n                },\n                \"dependencies\": [\n                    \"LoopTree\",\n                    \"LoopFinderImpl\",\n                    \"TFGraph\",\n                    \"TickCounter\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nLoopTree* LoopFinder::BuildLoopTree(TFGraph* graph, TickCounter* tick_counter,\n                                    Zone* zone) {\n  LoopTree* loop_tree =\n      graph->zone()->New<LoopTree>(graph->NodeCount(), graph->zone());\n  LoopFinderImpl finder(graph, loop_tree, tick_counter, zone);\n  finder.Run();\n  if (v8_flags.trace_turbo_loop) {\n    finder.Print();\n  }\n  return loop_tree;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"FindSmallInnermostLoopFromHeader\",\n                \"about\": \"Finds a small innermost loop from a given loop header node, used in WebAssembly compilation.\",\n                \"logic\": \"Performs a breadth-first search from the loop header to find all nodes within the loop. Limits the search based on max_size to avoid excessive traversal. Includes checks for nested loops and floating control to ensure validity.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"loop_header\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The header node of the loop to analyze.\"\n                    },\n                    {\n                        \"name\": \"all_nodes\",\n                        \"type\": \"AllNodes&\",\n                        \"purpose\": \"Provides information about all nodes in the graph.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"Memory zone for allocations.\"\n                    },\n                    {\n                        \"name\": \"max_size\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"Maximum size of the loop (number of nodes).\"\n                    },\n                    {\n                        \"name\": \"purpose\",\n                        \"type\": \"Purpose\",\n                        \"purpose\": \"Purpose of the search (e.g., loop unrolling).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ZoneUnorderedSet<Node*>*\",\n                    \"description\": \"A set of nodes in the loop, or nullptr if the loop is too large or invalid.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode\",\n                    \"Node\",\n                    \"AllNodes\",\n                    \"Zone\",\n                    \"ZoneUnorderedSet\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\n// static\nZoneUnorderedSet<Node*>* LoopFinder::FindSmallInnermostLoopFromHeader(\n    Node* loop_header, AllNodes& all_nodes, Zone* zone, size_t max_size,\n    Purpose purpose) {\n  auto* visited = zone->New<ZoneUnorderedSet<Node*>>(zone);\n  std::vector<Node*> queue;\n\n  DCHECK_EQ(loop_header->opcode(), IrOpcode::kLoop);\n\n  queue.push_back(loop_header);\n  visited->insert(loop_header);\n\n#define ENQUEUE_USES(use_name, condition)             \\\n  for (Node * use_name : node->uses()) {              \\\n    if (condition && visited->count(use_name) == 0) { \\\n      visited->insert(use_name);                      \\\n      queue.push_back(use_name);                      \\\n    }                                                 \\\n  }\n  bool has_instruction_worth_peeling = false;\n  while (!queue.empty()) {\n    Node* node = queue.back();\n    queue.pop_back();\n    if (node->opcode() == IrOpcode::kEnd) {\n      // We reached the end of the graph. The end node is not part of the loop.\n      visited->erase(node);\n      continue;\n    }\n    if (visited->size() > max_size) return nullptr;\n    switch (node->opcode()) {\n      case IrOpcode::kLoop:\n        // Found nested loop.\n        if (node != loop_header) return nullptr;\n        ENQUEUE_USES(use, true);\n        break;\n      case IrOpcode::kLoopExit:\n        // Found nested loop.\n        if (node->InputAt(1) != loop_header) return nullptr;\n        // LoopExitValue/Effect uses are inside the loop. The rest are not.\n        ENQUEUE_USES(use, (use->opcode() == IrOpcode::kLoopExitEffect ||\n                           use->opcode() == IrOpcode::kLoopExitValue))\n        break;\n      case IrOpcode::kLoopExitEffect:\n      case IrOpcode::kLoopExitValue:\n        if (NodeProperties::GetControlInput(node)->InputAt(1) != loop_header) {\n          // Found nested loop.\n          return nullptr;\n        }\n        // All uses are outside the loop, do nothing.\n        break;\n      // If unrolling, call nodes are considered to have unbounded size,\n      // i.e. >max_size, with the exception of certain wasm builtins.\n      case IrOpcode::kTailCall:\n      case IrOpcode::kJSWasmCall:\n      case IrOpcode::kJSCall:\n        if (purpose == Purpose::kLoopUnrolling) return nullptr;\n        ENQUEUE_USES(use, true)\n        break;\n      case IrOpcode::kCall: {\n        if (purpose == Purpose::kLoopPeeling) {\n          ENQUEUE_USES(use, true);\n          break;\n        }\n        Node* callee = node->InputAt(0);\n        if (callee->opcode() != IrOpcode::kRelocatableInt32Constant &&\n            callee->opcode() != IrOpcode::kRelocatableInt64Constant) {\n          return nullptr;\n        }\n        Builtin builtin = static_cast<Builtin>(\n            OpParameter<RelocatablePtrConstantInfo>(callee->op()).value());\n        constexpr Builtin unrollable_builtins[] = {\n            // Exists in every stack check.\n            Builtin::kWasmStackGuard,\n            // Fast table operations.\n            Builtin::kWasmTableGet, Builtin::kWasmTableSet,\n            Builtin::kWasmTableGetFuncRef, Builtin::kWasmTableSetFuncRef,\n            Builtin::kWasmTableGrow,\n            // Atomics.\n            Builtin::kWasmI32AtomicWait, Builtin::kWasmI64AtomicWait,\n            // Exceptions.\n            Builtin::kWasmAllocateFixedArray, Builtin::kWasmThrow,\n            Builtin::kWasmRethrow, Builtin::kWasmRethrowExplicitContext,\n            // Fast wasm-gc operations.\n            Builtin::kWasmRefFunc,\n            // While a built-in call, this is the slow path, so it should not\n            // prevent loop unrolling for stringview_wtf16.get_codeunit.\n            Builtin::kWasmStringViewWtf16GetCodeUnit};\n        if (std::count(std::begin(unrollable_builtins),\n                       std::end(unrollable_builtins), builtin) == 0) {\n          return nullptr;\n        }\n        ENQUEUE_USES(use, true)\n        break;\n      }\n      case IrOpcode::kWasmStructGet: {\n        // When a chained load occurs in the loop, assume that peeling might\n        // help.\n        Node* object = node->InputAt(0);\n        if (object->opcode() == IrOpcode::kWasmStructGet &&\n            visited->find(object) != visited->end()) {\n          has_instruction_worth_peeling = true;\n        }\n        ENQUEUE_USES(use, true);\n        break;\n      }\n      case IrOpcode::kWasmArrayGet:\n        // Rationale for array.get: loops that contain an array.get also\n        // contain a bounds check, which needs to load the array's length,\n        // which benefits from load elimination after peeling.\n      case IrOpcode::kStringPrepareForGetCodeunit:\n        // Rationale for PrepareForGetCodeunit: this internal operation is\n        // specifically designed for being hoisted out of loops.\n        has_instruction_worth_peeling = true;\n        [[fallthrough]];\n      default:\n        ENQUEUE_USES(use, true)\n        break;\n    }\n  }\n\n  // Check that there is no floating control other than direct nodes to start().\n  // We do this by checking that all non-start control inputs of loop nodes are\n  // also in the loop.\n  // TODO(manoskouk): This is a safety check. Consider making it DEBUG-only when\n  // we are confident there is no incompatible floating control generated in\n  // wasm.\n  for (Node* node : *visited) {\n    // The loop header is allowed to point outside the loop.\n    if (node == loop_header) continue;\n\n    if (!all_nodes.IsLive(node)) continue;\n\n    for (Edge edge : node->input_edges()) {\n      Node* input = edge.to();\n      if (NodeProperties::IsControlEdge(edge) && visited->count(input) == 0 &&\n          input->opcode() != IrOpcode::kStart) {\n        FATAL(\n            \"Floating control detected in wasm turbofan graph: Node #%d:%s is \"\n            \"inside loop headed by #%d, but its control dependency #%d:%s is \"\n            \"outside\",\n            node->id(), node->op()->mnemonic(), loop_header->id(), input->id(),\n            input->op()->mnemonic());\n      }\n    }\n  }\n\n  // Only peel functions containing instructions for which loop peeling is known\n  // to be useful. TODO(14034): Add more instructions to get more benefits out\n  // of loop peeling.\n  if (purpose == Purpose::kLoopPeeling && !has_instruction_worth_peeling) {\n    return nullptr;\n  }\n  return visited;\n}\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasMarkedExits\",\n                \"about\": \"Checks if all exits of a given loop are properly marked, which is important for loop peeling transformations.\",\n                \"logic\": \"Iterates through the nodes in the loop and their uses. Returns false if any use outside the loop isn't a Terminate node, or if LoopExit nodes aren't correctly connected to the loop control node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"loop_tree\",\n                        \"type\": \"LoopTree*\",\n                        \"purpose"
}