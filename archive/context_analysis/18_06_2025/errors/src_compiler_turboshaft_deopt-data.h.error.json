{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/deopt-data.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 37, column 54",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/deopt-data.h\",\n            \"file_name\": \"deopt-data.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines data structures and logic for representing and manipulating frame state data used during deoptimization in the Turboshaft compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for using small vectors, global definitions, frame states, index types, and representation types.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/small-vector.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/frame-states.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"FrameStateData\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents the data associated with a frame state, including instructions, machine types, and integer operands. Encodes a pre-traversal of a tree representing the frame state.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"frame_state_info\",\n                        \"type\": \"const FrameStateInfo&\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores information about the frame state.\"\n                    },\n                    {\n                        \"name\": \"instructions\",\n                        \"type\": \"base::Vector<Instr>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores a sequence of instructions that define how to reconstruct the frame state.\"\n                    },\n                    {\n                        \"name\": \"machine_types\",\n                        \"type\": \"base::Vector<MachineType>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores machine types associated with inputs in the frame state.\"\n                    },\n                    {\n                        \"name\": \"int_operands\",\n                        \"type\": \"base::Vector<uint32_t>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores integer operands used by various instructions.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"FrameStateInfo\",\n                    \"base::Vector\",\n                    \"Instr\",\n                    \"MachineType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct FrameStateData {\n  // The data is encoded as a pre-traversal of a tree.\n  enum class Instr : uint8_t {\n    kInput,  // 1 Operand: input machine type\n    kUnusedRegister,\n    kDematerializedObject,           // 2 Operands: id, field_count\n    kDematerializedObjectReference,  // 1 Operand: id\n    kArgumentsElements,              // 1 Operand: type\n    kArgumentsLength,\n    kRestLength,\n    kDematerializedStringConcat,  // 1 Operand: id\n    // TODO(dmercadier): do escape analysis for objects and string-concat in a\n    // single pass, and always use kDematerializedObjectReference rather than\n    // kDematerializedStringConcatReference (and thus remove\n    // kDematerializedStringConcatReference).\n    kDematerializedStringConcatReference  // 1 Operand: id\n  };\n\n  class Builder;\n  struct Iterator;\n\n  Iterator iterator(base::Vector<const OpIndex> state_values) const;\n\n  const FrameStateInfo& frame_state_info;\n  base::Vector<Instr> instructions;\n  base::Vector<MachineType> machine_types;\n  base::Vector<uint32_t> int_operands;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FrameStateData::Builder\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"A helper class for building FrameStateData instances. Provides methods for adding different types of instructions and operands.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"instructions_\",\n                        \"type\": \"base::SmallVector<Instr, 32>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the instructions being built.\"\n                    },\n                    {\n                        \"name\": \"machine_types_\",\n                        \"type\": \"base::SmallVector<MachineType, 32>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the machine types being built.\"\n                    },\n                    {\n                        \"name\": \"int_operands_\",\n                        \"type\": \"base::SmallVector<uint32_t, 16>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the integer operands being built.\"\n                    },\n                    {\n                        \"name\": \"inputs_\",\n                        \"type\": \"base::SmallVector<OpIndex, 32>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the input OpIndices\"\n                    },\n                    {\n                        \"name\": \"inlined_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the frame state is inlined.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"FrameStateData\",\n                    \"Instr\",\n                    \"MachineType\",\n                    \"OpIndex\",\n                    \"FrameStateInfo\",\n                    \"Zone\",\n                    \"base::SmallVector\",\n                    \"base::Vector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class Builder {\n   public:\n    void AddParentFrameState(V<FrameState> parent) {\n      DCHECK(inputs_.empty());\n      inlined_ = true;\n      inputs_.push_back(parent);\n    }\n    void AddInput(MachineType type, OpIndex input) {\n      instructions_.push_back(Instr::kInput);\n      machine_types_.push_back(type);\n      inputs_.push_back(input);\n    }\n\n    void AddUnusedRegister() {\n      instructions_.push_back(Instr::kUnusedRegister);\n    }\n\n    void AddDematerializedObjectReference(uint32_t id) {\n      instructions_.push_back(Instr::kDematerializedObjectReference);\n      int_operands_.push_back(id);\n    }\n\n    void AddDematerializedObject(uint32_t id, uint32_t field_count) {\n      instructions_.push_back(Instr::kDematerializedObject);\n      int_operands_.push_back(id);\n      int_operands_.push_back(field_count);\n    }\n\n    void AddDematerializedStringConcat(uint32_t id) {\n      instructions_.push_back(Instr::kDematerializedStringConcat);\n      int_operands_.push_back(id);\n    }\n\n    void AddDematerializedStringConcatReference(uint32_t id) {\n      instructions_.push_back(Instr::kDematerializedStringConcatReference);\n      int_operands_.push_back(id);\n    }\n\n    void AddArgumentsElements(CreateArgumentsType type) {\n      instructions_.push_back(Instr::kArgumentsElements);\n      int_operands_.push_back(static_cast<int>(type));\n    }\n\n    void AddArgumentsLength() {\n      instructions_.push_back(Instr::kArgumentsLength);\n    }\n\n    void AddRestLength() { instructions_.push_back(Instr::kRestLength); }\n\n    const FrameStateData* AllocateFrameStateData(const FrameStateInfo& info,\n                                                 Zone* zone) {\n      return zone->New<FrameStateData>(\n          FrameStateData{info, zone->CloneVector(base::VectorOf(instructions_)),\n                         zone->CloneVector(base::VectorOf(machine_types_)),\n                         zone->CloneVector(base::VectorOf(int_operands_))});\n    }\n\n    base::Vector<const OpIndex> Inputs() { return base::VectorOf(inputs_); }\n    bool inlined() const { return inlined_; }\n\n   private:\n    base::SmallVector<Instr, 32> instructions_;\n    base::SmallVector<MachineType, 32> machine_types_;\n    base::SmallVector<uint32_t, 16> int_operands_;\n    base::SmallVector<OpIndex, 32> inputs_;\n\n    bool inlined_ = false;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"FrameStateData::Iterator\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"An iterator for traversing the FrameStateData structure. Allows consuming instructions and associated data.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"instructions\",\n                        \"type\": \"base::Vector<const Instr>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Holds the instruction vector to iterate over.\"\n                    },\n                    {\n                        \"name\": \"machine_types\",\n                        \"type\": \"base::Vector<const MachineType>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Holds the machine type vector to iterate over.\"\n                    },\n                    {\n                        \"name\": \"int_operands\",\n                        \"type\": \"base::Vector<const uint32_t>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Holds the integer operand vector to iterate over.\"\n                    },\n                    {\n                        \"name\": \"inputs\",\n                        \"type\": \"base::Vector<const OpIndex>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Holds the input OpIndex vector to iterate over.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"FrameStateData\",\n                    \"Instr\",\n                    \"MachineType\",\n                    \"OpIndex\",\n                    \"CreateArgumentsType\",\n                    \"base::Vector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  struct Iterator {\n    base::Vector<const Instr> instructions;\n    base::Vector<const MachineType> machine_types;\n    base::Vector<const uint32_t> int_operands;\n    base::Vector<const OpIndex> inputs;\n\n    bool has_more() const {\n      DCHECK_IMPLIES(instructions.empty(), machine_types.empty());\n      DCHECK_IMPLIES(instructions.empty(), int_operands.empty());\n      DCHECK_IMPLIES(instructions.empty(), inputs.empty());\n      return !instructions.empty();\n    }\n\n    Instr current_instr() { return instructions[0]; }\n\n    void ConsumeInput(MachineType* machine_type, OpIndex* input) {\n      DCHECK_EQ(instructions[0], Instr::kInput);\n      instructions += 1;\n      *machine_type = machine_types[0];\n      machine_types += 1;\n      *input = inputs[0];\n      inputs += 1;\n    }\n    void ConsumeUnusedRegister() {\n      DCHECK_EQ(instructions[0], Instr::kUnusedRegister);\n      instructions += 1;\n    }\n    void ConsumeDematerializedObject(uint32_t* id, uint32_t* field_count) {\n      DCHECK_EQ(instructions[0], Instr::kDematerializedObject);\n      instructions += 1;\n      *id = int_operands[0];\n      *field_count = int_operands[1];\n      int_operands += 2;\n    }\n    void ConsumeDematerializedObjectReference(uint32_t* id) {\n      DCHECK_EQ(instructions[0], Instr::kDematerializedObjectReference);\n      instructions += 1;\n      *id = int_operands[0];\n      int_operands += 1;\n    }\n    void ConsumeDematerializedStringConcat(uint32_t* id) {\n      DCHECK_EQ(instructions[0], Instr::kDematerializedStringConcat);\n      instructions += 1;\n      *id = int_operands[0];\n      int_operands += 1;\n    }\n    void ConsumeDematerializedStringConcatReference(uint32_t* id) {\n      DCHECK_EQ(instructions[0], Instr::kDematerializedStringConcatReference);\n      instructions += 1;\n      *id = int_operands[0];\n      int_operands += 1;\n    }\n    void ConsumeArgumentsElements(CreateArgumentsType* type) {\n      DCHECK_EQ(instructions[0], Instr::kArgumentsElements);\n      instructions += 1;\n      *type = static_cast<CreateArgumentsType>(int_operands[0]);\n      int_operands += 1;\n    }\n    void ConsumeArgumentsLength() {\n      DCHECK_EQ(instructions[0], Instr::kArgumentsLength);\n      instructions += 1;\n    }\n    void ConsumeRestLength() {\n      DCHECK_EQ(instructions[0], Instr::kRestLength);\n      instructions += 1;\n    }\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"parent\": null,\n                \"about\": \"Equality operator for FrameStateData.\",\n                \"logic\": \"Compares the frame_state_info, instructions, machine_types and int_operands fields of two FrameStateData objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"const FrameStateData&\",\n                        \"purpose\": \"Left-hand side FrameStateData object.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const FrameStateData&\",\n                        \"purpose\": \"Right-hand side FrameStateData object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the two FrameStateData objects are equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"FrameStateData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ninline bool operator==(const FrameStateData& lhs, const FrameStateData& rhs) {\n  return lhs.frame_state_info == rhs.frame_state_info &&\n         lhs.instructions == rhs.instructions &&\n         lhs.machine_types == rhs.machine_types &&\n         lhs.int_operands == rhs.int_operands;\n}\n        ]]></code>\n    </func>\n</file>\n```"
}