{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/read-only-serializer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/read-only-serializer.cc\",\n        \"file_name\": \"read-only-serializer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Serializes the read-only heap for creating snapshots.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary header files for serialization, heap management, and object manipulation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/read-only-serializer.h\"\n\n#include \"src/common/globals.h\"\n#include \"src/heap/heap-inl.h\"\n#include \"src/heap/read-only-heap.h\"\n#include \"src/heap/visit-object.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/slots.h\"\n#include \"src/snapshot/read-only-serializer-deserializer.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ObjectPreProcessor\",\n            \"about\": \"Preprocesses objects in the read-only heap before serialization, primarily to encode external references.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the current isolate.\"\n                },\n                {\n                    \"name\": \"extref_encoder_\",\n                    \"type\": \"ExternalReferenceEncoder\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Encodes external references.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"HeapObject\",\n                \"AccessorInfo\",\n                \"FunctionTemplateInfo\",\n                \"Code\",\n                \"ExternalReferenceEncoder\",\n                \"ExternalPointerSlot\",\n                \"ro::EncodedExternalReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ObjectPreProcessor final {\n public:\n  explicit ObjectPreProcessor(Isolate* isolate)\n      : isolate_(isolate), extref_encoder_(isolate) {}\n\n#define PRE_PROCESS_TYPE_LIST(V) \\\n  V(AccessorInfo)                \\\n  V(FunctionTemplateInfo)        \\\n  V(Code)\n\n  void PreProcessIfNeeded(Tagged<HeapObject> o) {\n    const InstanceType itype = o->map(isolate_)->instance_type();\n#define V(TYPE)                               \\\n  if (InstanceTypeChecker::Is##TYPE(itype)) { \\\n    return PreProcess##TYPE(Cast<TYPE>(o));   \\\n  }\n    PRE_PROCESS_TYPE_LIST(V)\n#undef V\n    // If we reach here, no preprocessing is needed for this object.\n  }\n#undef PRE_PROCESS_TYPE_LIST\n\n private:\n  void EncodeExternalPointerSlot(ExternalPointerSlot slot) {\n    Address value = slot.load(isolate_);\n    EncodeExternalPointerSlot(slot, value);\n  }\n\n  void EncodeExternalPointerSlot(ExternalPointerSlot slot, Address value) {\n    // Note it's possible that `value != slot.load(...)`, e.g. for\n    // AccessorInfo::remove_getter_indirection.\n    ExternalReferenceEncoder::Value encoder_value =\n        extref_encoder_.Encode(value);\n    DCHECK_LT(encoder_value.index(),\n              1UL << ro::EncodedExternalReference::kIndexBits);\n    ro::EncodedExternalReference encoded{encoder_value.is_from_api(),\n                                         encoder_value.index()};\n    // Constructing no_gc here is not the intended use pattern (instead we\n    // should pass it along the entire callchain); but there's little point of\n    // doing that here - all of the code in this file relies on GC being\n    // disabled, and that's guarded at entry points.\n    DisallowGarbageCollection no_gc;\n    slot.ReplaceContentWithIndexForSerialization(no_gc, encoded.ToUint32());\n  }\n  void PreProcessAccessorInfo(Tagged<AccessorInfo> o) {\n    EncodeExternalPointerSlot(\n        o->RawExternalPointerField(AccessorInfo::kMaybeRedirectedGetterOffset,\n                                   kAccessorInfoGetterTag),\n        o->getter(isolate_));  // Pass the non-redirected value.\n    EncodeExternalPointerSlot(o->RawExternalPointerField(\n        AccessorInfo::kSetterOffset, kAccessorInfoSetterTag));\n  }\n  void PreProcessFunctionTemplateInfo(Tagged<FunctionTemplateInfo> o) {\n    EncodeExternalPointerSlot(\n        o->RawExternalPointerField(\n            FunctionTemplateInfo::kMaybeRedirectedCallbackOffset,\n            kFunctionTemplateInfoCallbackTag),\n        o->callback(isolate_));  // Pass the non-redirected value.\n  }\n  void PreProcessCode(Tagged<Code> o) {\n    o->ClearInstructionStartForSerialization(isolate_);\n    CHECK(!o->has_source_position_table_or_bytecode_offset_table());\n    CHECK(!o->has_deoptimization_data_or_interpreter_data());\n#ifdef V8_ENABLE_LEAPTIERING\n    CHECK_EQ(o->js_dispatch_handle(), kNullJSDispatchHandle);\n#endif\n  }\n\n  Isolate* const isolate_;\n  ExternalReferenceEncoder extref_encoder_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ReadOnlySegmentForSerialization\",\n            \"about\": \"Represents a segment of the read-only heap that is being serialized.\",\n            \"attributes\": [\n                {\n                    \"name\": \"page\",\n                    \"type\": \"const ReadOnlyPageMetadata*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Metadata for the read-only page this segment belongs to.\"\n                },\n                {\n                    \"name\": \"segment_start\",\n                    \"type\": \"const Address\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Starting address of the segment within the read-only heap.\"\n                },\n                {\n                    \"name\": \"segment_size\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Size of the segment in bytes.\"\n                },\n                {\n                    \"name\": \"segment_offset\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Offset of the segment from the start of the page's area.\"\n                },\n                {\n                    \"name\": \"contents\",\n                    \"type\": \"std::unique_ptr<uint8_t[]>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"A copy of the segment's contents, which can be mutated during preprocessing and encoding.\"\n                },\n                {\n                    \"name\": \"tagged_slots\",\n                    \"type\": \"ro::BitSet\",\n                    \"access\": \"public\",\n                    \"purpose\": \"A bitset indicating which slots within the segment contain tagged pointers (i.e., pointers to HeapObjects).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"ReadOnlyPageMetadata\",\n                \"ObjectPreProcessor\",\n                \"HeapObject\",\n                \"ReadOnlyPageObjectIterator\",\n                \"ro::BitSet\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct ReadOnlySegmentForSerialization {\n  ReadOnlySegmentForSerialization(Isolate* isolate,\n                                  const ReadOnlyPageMetadata* page,\n                                  Address segment_start, size_t segment_size,\n                                  ObjectPreProcessor* pre_processor)\n      : page(page),\n        segment_start(segment_start),\n        segment_size(segment_size),\n        segment_offset(segment_start - page->area_start()),\n        contents(new uint8_t[segment_size]),\n        tagged_slots(segment_size / kTaggedSize) {\n    // .. because tagged_slots records a bit for each slot:\n    DCHECK(IsAligned(segment_size, kTaggedSize));\n    // Ensure incoming pointers to this page are representable.\n    CHECK_LT(isolate->read_only_heap()->read_only_space()->IndexOf(page),\n             1UL << ro::EncodedTagged::kPageIndexBits);\n\n    MemCopy(contents.get(), reinterpret_cast<void*>(segment_start),\n            segment_size);\n    PreProcessSegment(pre_processor);\n    if (!V8_STATIC_ROOTS_BOOL) EncodeTaggedSlots(isolate);\n  }\n\n  void PreProcessSegment(ObjectPreProcessor* pre_processor) {\n    // Iterate the RO page and the contents copy in lockstep, preprocessing\n    // objects as we go along.\n    //\n    // See also ObjectSerializer::OutputRawData.\n    DCHECK_GE(segment_start, page->area_start());\n    const Address segment_end = segment_start + segment_size;\n    ReadOnlyPageObjectIterator it(page, segment_start);\n    for (Tagged<HeapObject> o = it.Next(); !o.is_null(); o = it.Next()) {\n      if (o.address() >= segment_end) break;\n      size_t o_offset = o.ptr() - segment_start;\n      Address o_dst = reinterpret_cast<Address>(contents.get()) + o_offset;\n      pre_processor->PreProcessIfNeeded(\n          Cast<HeapObject>(Tagged<Object>(o_dst)));\n    }\n  }\n\n  void EncodeTaggedSlots(Isolate* isolate);\n\n  const ReadOnlyPageMetadata* const page;\n  const Address segment_start;\n  const size_t segment_size;\n  const size_t segment_offset;\n  // The (mutated) off-heap copy of the on-heap segment.\n  std::unique_ptr<uint8_t[]> contents;\n  // The relocation table.\n  ro::BitSet tagged_slots;\n\n  friend class EncodeRelocationsVisitor;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Encode\",\n            \"about\": \"Encodes a HeapObject as a pair of page index and offset within the read-only heap.\",\n            \"logic\": \"Calculates the index of the memory chunk containing the object and the object's offset within that chunk, then packs them into an EncodedTagged value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current isolate.\"\n                },\n                {\n                    \"name\": \"o\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The HeapObject to encode.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ro::EncodedTagged\",\n                \"description\": \"The encoded representation of the HeapObject.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"HeapObject\",\n                \"MemoryChunkMetadata\",\n                \"ReadOnlySpace\",\n                \"ro::EncodedTagged\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nro::EncodedTagged Encode(Isolate* isolate, Tagged<HeapObject> o) {\n  Address o_address = o.address();\n  MemoryChunkMetadata* chunk = MemoryChunkMetadata::FromAddress(o_address);\n\n  ReadOnlySpace* ro_space = isolate->read_only_heap()->read_only_space();\n  int index = static_cast<int>(ro_space->IndexOf(chunk));\n  uint32_t offset = static_cast<int>(chunk->Offset(o_address));\n  DCHECK(IsAligned(offset, kTaggedSize));\n\n  return ro::EncodedTagged(index, offset / kTaggedSize);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EncodeRelocationsVisitor\",\n            \"about\": \"Visitor class used to encode tagged slots within a ReadOnlySegmentForSerialization. It traverses the segment, identifies HeapObject pointers, encodes them and records their locations.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the current isolate.\"\n                },\n                {\n                    \"name\": \"segment_\",\n                    \"type\": \"ReadOnlySegmentForSerialization*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the segment being processed.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"ObjectVisitor\",\n                \"ReadOnlySegmentForSerialization\",\n                \"HeapObject\",\n                \"MaybeObjectSlot\",\n                \"InstructionStreamSlot\",\n                \"RelocInfo\",\n                \"ExternalPointerSlot\",\n                \"ro::EncodedTagged\",\n                \"ExternalReferenceTable\",\n                \"ro::EncodedExternalReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass EncodeRelocationsVisitor final : public ObjectVisitor {\n public:\n  EncodeRelocationsVisitor(Isolate* isolate,\n                           ReadOnlySegmentForSerialization* segment)\n      : isolate_(isolate), segment_(segment) {\n    DCHECK(!V8_STATIC_ROOTS_BOOL);\n  }\n\n  void VisitPointers(Tagged<HeapObject> host, ObjectSlot start,\n                     ObjectSlot end) override {\n    VisitPointers(host, MaybeObjectSlot(start), MaybeObjectSlot(end));\n  }\n\n  void VisitPointers(Tagged<HeapObject> host, MaybeObjectSlot start,\n                     MaybeObjectSlot end) override {\n    for (MaybeObjectSlot slot = start; slot < end; slot++) {\n      ProcessSlot(slot);\n    }\n  }\n\n  void VisitMapPointer(Tagged<HeapObject> host) override {\n    ProcessSlot(host->RawMaybeWeakField(HeapObject::kMapOffset));\n  }\n\n  // Sanity-checks:\n  void VisitInstructionStreamPointer(Tagged<Code> host,\n                                     InstructionStreamSlot slot) override {\n    // RO space contains only builtin Code objects.\n    DCHECK(!host->has_instruction_stream());\n  }\n  void VisitCodeTarget(Tagged<InstructionStream>, RelocInfo*) override {\n    UNREACHABLE();\n  }\n  void VisitEmbeddedPointer(Tagged<InstructionStream>, RelocInfo*) override {\n    UNREACHABLE();\n  }\n  void VisitExternalReference(Tagged<InstructionStream>, RelocInfo*) override {\n    UNREACHABLE();\n  }\n  void VisitInternalReference(Tagged<InstructionStream>, RelocInfo*) override {\n    UNREACHABLE();\n  }\n  void VisitOffHeapTarget(Tagged<InstructionStream>, RelocInfo*) override {\n    UNREACHABLE();\n  }\n  void VisitExternalPointer(Tagged<HeapObject>,\n                            ExternalPointerSlot slot) override {\n    // This slot was encoded in a previous pass, see EncodeExternalPointerSlot.\n#ifdef DEBUG\n    ExternalPointerSlot slot_in_segment{\n        reinterpret_cast<Address>(segment_->contents.get() +\n                                  SegmentOffsetOf(slot)),\n        slot.exact_tag()};\n    // Constructing no_gc here is not the intended use pattern (instead we\n    // should pass it along the entire callchain); but there's little point of\n    // doing that here - all of the code in this file relies on GC being\n    // disabled, and that's guarded at entry points.\n    DisallowGarbageCollection no_gc;\n    auto encoded = ro::EncodedExternalReference::FromUint32(\n        slot_in_segment.GetContentAsIndexAfterDeserialization(no_gc));\n    if (encoded.is_api_reference) {\n      // Can't validate these since we don't know how many entries\n      // api_external_references contains.\n    } else {\n      CHECK_LT(encoded.index, ExternalReferenceTable::kSize);\n    }\n#endif  // DEBUG\n  }\n\n private:\n  void ProcessSlot(MaybeObjectSlot slot) {\n    Tagged<MaybeObject> o = *slot;\n    if (!o.IsStrongOrWeak()) return;  // Smis don't need relocation.\n    DCHECK(o.IsStrong());\n\n    int slot_offset = SegmentOffsetOf(slot);\n    DCHECK(IsAligned(slot_offset, kTaggedSize));\n\n    // Encode:\n    ro::EncodedTagged encoded = Encode(isolate_, o.GetHeapObject());\n    memcpy(segment_->contents.get() + slot_offset, &encoded,\n           ro::EncodedTagged::kSize);\n\n    // Record:\n    segment_->tagged_slots.set(AsSlot(slot_offset));\n  }\n\n  template <class SlotT>\n  int SegmentOffsetOf(SlotT slot) const {\n    Address addr = slot.address();\n    DCHECK_GE(addr, segment_->segment_start);\n    DCHECK_LT(addr, segment_->segment_start + segment_->segment_size);\n    return static_cast<int>(addr - segment_->segment_start);\n  }\n\n  static constexpr int AsSlot(int byte_offset) {\n    return byte_offset / kTaggedSize;\n  }\n\n  Isolate* const isolate_;\n  ReadOnlySegmentForSerialization* const segment_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EncodeTaggedSlots\",\n            \"parent\": \"ReadOnlySegmentForSerialization\",\n            \"about\": \"Encodes tagged slots within a read-only segment for serialization by visiting all objects in the segment and processing their slots.\",\n            \"logic\": \"Creates an EncodeRelocationsVisitor and then iterates through all HeapObjects in the segment, calling VisitObject to visit all the pointers and encode them. Uses PtrComprCageBase to handle pointer compression.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"EncodeRelocationsVisitor\",\n                \"HeapObject\",\n                \"ReadOnlyPageObjectIterator\",\n                \"VisitObject\",\n                \"PtrComprCageBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ReadOnlySegmentForSerialization::EncodeTaggedSlots(Isolate* isolate) {\n  DCHECK(!V8_STATIC_ROOTS_BOOL);\n  EncodeRelocationsVisitor v(isolate, this);\n  PtrComprCageBase cage_base(isolate);\n\n  DCHECK_GE(segment_start, page->area_start());\n  const Address segment_end = segment_start + segment_size;\n  ReadOnlyPageObjectIterator it(page, segment_start,\n                                SkipFreeSpaceOrFiller::kNo);\n  for (Tagged<HeapObject> o = it.Next(); !o.is_null(); o = it.Next()) {\n    if (o.address() >= segment_end) break;\n    VisitObject(isolate, o, &v);\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ReadOnlyHeapImageSerializer\",\n            \"about\": \"Serializes the read-only heap image, including page allocation, segment serialization, and the read-only roots table.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the isolate.\"\n                },\n                {\n                    \"name\": \"sink_\",\n                    \"type\": \"SnapshotByteSink*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The sink to which serialized data is written.\"\n                },\n                {\n                    \"name\": \"pre_processor_\",\n                    \"type\": \"ObjectPreProcessor\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The object preprocessor.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"SnapshotByteSink\",\n                \"ReadOnlySpace\",\n                \"ReadOnlyPageMetadata\",\n                \"ObjectPreProcessor\",\n                \"ReadOnlySegmentForSerialization\",\n                \"ro::Bytecode\",\n                \"ReadOnlyRoots\",\n                \"ro::EncodedTagged\",\n                \"V8HeapCompressionScheme\",\n                \"WasmNull\",\n                \"FreeSpace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ReadOnlyHeapImageSerializer {\n public:\n  struct MemoryRegion {\n    Address start;\n    size_t size;\n  };\n\n  static void Serialize(Isolate* isolate, SnapshotByteSink* sink,\n                        const std::vector<MemoryRegion>& unmapped_regions) {\n    ReadOnlyHeapImageSerializer{isolate, sink}.SerializeImpl(unmapped_regions);\n  }\n\n private:\n  using Bytecode = ro::Bytecode;\n\n  ReadOnlyHeapImageSerializer(Isolate* isolate, SnapshotByteSink* sink)\n      : isolate_(isolate), sink_(sink), pre_processor_(isolate) {}\n\n  void SerializeImpl(const std::vector<MemoryRegion>& unmapped_regions) {\n    DCHECK_EQ(sink_->Position(), 0);\n\n    ReadOnlySpace* ro_space = isolate_->read_only_heap()->read_only_space();\n\n    // Allocate all pages first s.t. the deserializer can easily handle forward\n    // references (e.g.: an object on page i points at an object on page i+1).\n    for (const ReadOnlyPageMetadata* page : ro_space->pages()) {\n      EmitAllocatePage(page, unmapped_regions);\n    }\n\n    // Now write the page contents.\n    for (const ReadOnlyPageMetadata* page : ro_space->pages()) {\n      SerializePage(page, unmapped_regions);\n    }\n\n    EmitReadOnlyRootsTable();\n    sink_->Put(Bytecode::kFinalizeReadOnlySpace, \"space end\");\n  }\n\n  uint32_t IndexOf(const ReadOnlyPageMetadata* page) {\n    ReadOnlySpace* ro_space = isolate_->read_only_heap()->read_only_space();\n    return static_cast<uint32_t>(ro_space->IndexOf(page));\n  }\n\n  void EmitAllocatePage(const ReadOnlyPageMetadata* page,\n                        const std::vector<MemoryRegion>& unmapped_regions) {\n    if (V8_STATIC_ROOTS_BOOL) {\n      sink_->Put(Bytecode::kAllocatePageAt, \"fixed page begin\");\n    } else {\n      sink_->Put(Bytecode::kAllocatePage, \"page begin\");\n    }\n    sink_->PutUint30(IndexOf(page), \"page index\");\n    sink_->PutUint30(\n        static_cast<uint32_t>(page->HighWaterMark() - page->area_start()),\n        \"area size in bytes\");\n    if (V8_STATIC_ROOTS_BOOL) {\n      auto page_addr = page->ChunkAddress();\n      sink_->PutUint32(V8HeapCompressionScheme::CompressAny(page_addr),\n                       \"page start offset\");\n    }\n  }\n\n  void SerializePage(const ReadOnlyPageMetadata* page,\n                     const std::vector<MemoryRegion>& unmapped_regions) {\n    Address pos = page->area_start();\n\n    // If this page contains unmapped regions split it into multiple segments.\n    for (auto r = unmapped_regions.begin(); r != unmapped_regions.end(); ++r) {\n      // Regions must be sorted and non-overlapping.\n      if (r + 1 != unmapped_regions.end()) {\n        CHECK(r->start < (r + 1)->start);\n        CHECK(r->start + r->size < (r + 1)->start);\n      }\n      if (base::IsInRange(r->start, pos, page->HighWaterMark())) {\n        size_t segment_size = r->start - pos;\n        ReadOnlySegmentForSerialization segment(isolate_, page, pos,\n                                                segment_size, &pre_processor_);\n        EmitSegment(&segment);\n        pos += segment_size + r->size;\n      }\n    }\n\n    // Pages are shrunk, but memory at the end of the area is still\n    // uninitialized and we do not want to include it in the snapshot.\n    size_t segment_size = page->HighWaterMark() - pos;\n    ReadOnlySegmentForSerialization segment(isolate_, page, pos, segment_size,\n                                            &pre_processor_);\n    EmitSegment(&segment);\n  }\n\n  void EmitSegment(const ReadOnlySegmentForSerialization* segment) {\n    sink_->Put(Bytecode::kSegment, \"segment begin\");\n    sink_->PutUint30(IndexOf(segment->page), \"page index\");\n    sink_->PutUint30(static_cast<uint32_t>(segment->segment_offset),\n                     \"segment start offset\");\n    sink_->PutUint30(static_cast<uint32_t>(segment->segment_size),\n                     \"segment byte size\");\n    sink_->PutRaw(segment->contents.get(),\n                  static_cast<int>(segment->segment_size), \"page\");\n    if (!V8_STATIC_ROOTS_BOOL) {\n      sink_->Put(Bytecode::kRelocateSegment, \"relocate segment\");\n      sink_->PutRaw(segment->tagged_slots.data(),\n                    static_cast<int>(segment->tagged_slots.size_in_bytes()),\n                    \"tagged_slots\");\n    }\n  }\n\n  void EmitReadOnlyRootsTable() {\n    sink_->Put(Bytecode::kReadOnlyRootsTable, \"read only roots table\");\n    if (!V8_STATIC_ROOTS_BOOL) {\n      ReadOnlyRoots roots(isolate_);\n      for (size_t i = 0; i < ReadOnlyRoots::kEntriesCount; i++) {\n        RootIndex rudi = static_cast<RootIndex>(i);\n        Tagged<HeapObject> rudolf = Cast<HeapObject>(roots.object_at(rudi));\n        ro::EncodedTagged encoded = Encode(isolate_, rudolf);\n        sink_->PutUint32(encoded.ToUint32(), \"read only roots entry\");\n      }\n    }\n  }\n\n  Isolate* const isolate_;\n  SnapshotByteSink* const sink_;\n  ObjectPreProcessor pre_processor_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetUnmappedRegions\",\n            \"about\": \"Retrieves the unmapped memory regions within the read-only heap, specifically used for handling WasmNull's payload in static roots mode.\",\n            \"logic\": \"In V8_STATIC_ROOTS mode, identifies the unmapped memory regions associated with WasmNull (padding and payload) and returns them as a vector of MemoryRegion structs.  Otherwise returns an empty vector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::vector<ReadOnlyHeapImageSerializer::MemoryRegion>\",\n                \"description\": \"A vector of MemoryRegion structs representing the unmapped regions.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"ReadOnlyHeapImageSerializer::MemoryRegion\",\n                \"ReadOnlyRoots\",\n                \"WasmNull\",\n                \"FreeSpace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::vector<ReadOnlyHeapImageSerializer::MemoryRegion> GetUnmappedRegions(\n    Isolate* isolate) {\n#ifdef V8_STATIC_ROOTS\n  // WasmNull's payload is aligned to the OS page and consists of\n  // WasmNull::kPayloadSize bytes of unmapped memory. To avoid inflating the\n  // snapshot size and accessing uninitialized and/or unmapped memory, the\n  // serializer skips the padding bytes and the payload.\n  ReadOnlyRoots ro_roots(isolate);\n  Tagged<WasmNull> wasm_null = ro_roots.wasm_null();\n  Tagged<HeapObject> wasm_null_padding = ro_roots.wasm_null_padding();\n  CHECK(IsFreeSpace(wasm_null_padding));\n  Address wasm_null_padding_start =\n      wasm_null_padding.address() + FreeSpace::kHeaderSize;\n  std::vector<ReadOnlyHeapImageSerializer::MemoryRegion> unmapped;\n  if (wasm_null.address() > wasm_null_padding_start) {\n    unmapped.push_back({wasm_null_padding_start,\n                        wasm_null.address() - wasm_null_padding_start});\n  }\n  unmapped.push_back({wasm_null->payload(), WasmNull::kPayloadSize});\n  return unmapped;\n#else\n  return {};\n#endif  // V8_STATIC_ROOTS\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ReadOnlySerializer\",\n            \"about\": \"Serializes the read-only heap, including preprocessing, encoding, and writing to the snapshot.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Snapshot::SerializerFlags\",\n                \"RootsSerializer\",\n                \"ReadOnlyHeapImageSerializer\",\n                \"HeapObject\",\n                \"SnapshotSpace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReadOnlySerializer::ReadOnlySerializer(Isolate* isolate,\n                                       Snapshot::SerializerFlags flags)\n    : RootsSerializer(isolate, flags, RootIndex::kFirstReadOnlyRoot) {}\n\nReadOnlySerializer::~ReadOnlySerializer() {\n  OutputStatistics(\"ReadOnlySerializer\");\n}\n\nvoid ReadOnlySerializer::Serialize() {\n  DisallowGarbageCollection no_gc;\n  ReadOnlyHeapImageSerializer::Serialize(isolate(), &sink_,\n                                         GetUnmappedRegions(isolate()));\n\n  ReadOnlyHeapObjectIterator it(isolate()->read_only_heap());\n  for (Tagged<HeapObject> o = it.Next(); !o.is_null(); o = it.Next()) {\n    CheckRehashability(o);\n    if (v8_flags.serialization_statistics) {\n      CountAllocation(o->map(), o->Size(), SnapshotSpace::kReadOnlyHeap);\n    }\n  }\n}\n        ]]></code>\n    </class>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HeapObject\",\n                \"about\": \"Base class for objects allocated in the V8 heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class HeapObject;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AccessorInfo\",\n                \"about\": \"Stores information about accessors (getters/setters) on JavaScript objects.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class AccessorInfo;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FunctionTemplateInfo\",\n                \"about\": \"Stores information about function templates used to create JavaScript functions.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class FunctionTemplateInfo;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Code\",\n                \"about\": \"Represents compiled JavaScript code.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Code;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ExternalReferenceEncoder\",\n                \"about\": \"Encodes external references for serialization.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class ExternalReferenceEncoder;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ExternalPointerSlot\",\n                \"about\": \"Represents a slot containing an external pointer.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class ExternalPointerSlot;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReadOnlyPageMetadata\",\n                \"about\": \"Stores metadata for a read-only page in the heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class ReadOnlyPageMetadata;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReadOnlyPageObjectIterator\",\n                \"about\": \"Iterates over objects in a read-only page.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class ReadOnlyPageObjectIterator;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemoryChunkMetadata\",\n                \"about\": \"Stores metadata for a memory chunk in the heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class MemoryChunkMetadata;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReadOnlySpace\",\n                \"about\": \"Represents the read-only space in the heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class ReadOnlySpace;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\":"
}