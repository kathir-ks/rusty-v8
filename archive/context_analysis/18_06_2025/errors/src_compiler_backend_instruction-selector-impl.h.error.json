{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-selector-impl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 71, column 34",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-selector-impl.h\",\n            \"file_name\": \"instruction-selector-impl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides implementation details and helper classes for the instruction selection phase in the V8 compiler backend.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for code generation, instruction selection, instruction representation, linkage information, and tagged index manipulation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/compiler/backend/instruction-selector.h\"\n#include \"src/compiler/backend/instruction.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/objects/tagged-index.h\"\n        ]]></code>\n    </imports>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"CaseInfoT\",\n                \"about\": \"Represents information about a case in a switch statement.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The case value.\"\n                    },\n                    {\n                        \"name\": \"order\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The order for lowering to comparisons (less means earlier).\"\n                    },\n                    {\n                        \"name\": \"branch\",\n                        \"type\": \"turboshaft::Block*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The basic block corresponding to the case value.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"turboshaft::Block\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct CaseInfoT {\n  int32_t value;  // The case value.\n  int32_t order;  // The order for lowering to comparisons (less means earlier).\n  turboshaft::Block*\n      branch;  // The basic blocks corresponding to the case value.\n};\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<\",\n                \"about\": \"Overloads the less-than operator for CaseInfoT structs.\",\n                \"logic\": \"Compares the order members of two CaseInfoT structs.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"l\",\n                        \"type\": \"const CaseInfoT&\",\n                        \"purpose\": \"The left-hand side CaseInfoT.\"\n                    },\n                    {\n                        \"name\": \"r\",\n                        \"type\": \"const CaseInfoT&\",\n                        \"purpose\": \"The right-hand side CaseInfoT.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if l.order is less than r.order, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ninline bool operator<(const CaseInfoT& l, const CaseInfoT& r) {\n  return l.order < r.order;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SwitchInfoT\",\n                \"about\": \"Helper struct containing data about a table or lookup switch.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"cases_\",\n                        \"type\": \"const ZoneVector<CaseInfo>&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The list of cases in the switch statement.\"\n                    },\n                    {\n                        \"name\": \"min_value_\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The minimum value of the cases.\"\n                    },\n                    {\n                        \"name\": \"max_value_\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The maximum value of the cases.\"\n                    },\n                    {\n                        \"name\": \"value_range_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The range of values in the cases (max_value - min_value + 1).\"\n                    },\n                    {\n                        \"name\": \"default_branch_\",\n                        \"type\": \"turboshaft::Block*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The basic block to jump to if no case matches.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"CaseInfoT\",\n                    \"ZoneVector\",\n                    \"turboshaft::Block\",\n                    \"base::bit_cast\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass SwitchInfoT {\n public:\n  using CaseInfo = CaseInfoT;\n  SwitchInfoT(ZoneVector<CaseInfo> const& cases, int32_t min_value,\n              int32_t max_value, turboshaft::Block* default_branch)\n      : cases_(cases),\n        min_value_(min_value),\n        max_value_(max_value),\n        default_branch_(default_branch) {\n    if (cases.size() != 0) {\n      DCHECK_LE(min_value, max_value);\n      // Note that {value_range} can be 0 if {min_value} is -2^31 and\n      // {max_value} is 2^31-1, so don't assume that it's non-zero below.\n      value_range_ = 1u + base::bit_cast<uint32_t>(max_value) -\n                     base::bit_cast<uint32_t>(min_value);\n    } else {\n      value_range_ = 0;\n    }\n  }\n\n  std::vector<CaseInfo> CasesSortedByValue() const {\n    std::vector<CaseInfo> result(cases_.begin(), cases_.end());\n    std::stable_sort(result.begin(), result.end(),\n                     [](CaseInfo a, CaseInfo b) { return a.value < b.value; });\n    return result;\n  }\n  const ZoneVector<CaseInfo>& CasesUnsorted() const { return cases_; }\n  int32_t min_value() const { return min_value_; }\n  int32_t max_value() const { return max_value_; }\n  size_t value_range() const { return value_range_; }\n  size_t case_count() const { return cases_.size(); }\n  turboshaft::Block* default_branch() const { return default_branch_; }\n\n private:\n  const ZoneVector<CaseInfo>& cases_;\n  int32_t min_value_;   // minimum value of {cases_}\n  int32_t max_value_;   // maximum value of {cases_}\n  size_t value_range_;  // |max_value - min_value| + 1\n  turboshaft::Block* default_branch_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OperandGeneratorT\",\n                \"extends\": \"TurboshaftAdapter\",\n                \"about\": \"A helper class for the instruction selector that simplifies construction of Operands. This class implements a base for architecture-specific helpers.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"selector_\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the instruction selector.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TurboshaftAdapter\",\n                    \"InstructionSelectorT\",\n                    \"InstructionOperand\",\n                    \"LinkageLocation\",\n                    \"Register\",\n                    \"FPRegType\",\n                    \"turboshaft::OpIndex\",\n                    \"turboshaft::ConstantOp\",\n                    \"MachineRepresentation\",\n                    \"RelocInfo\",\n                    \"RelocatablePtrConstantInfo\",\n                    \"TaggedIndex\",\n                    \"Constant\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass OperandGeneratorT : public TurboshaftAdapter {\n public:\n  explicit OperandGeneratorT(InstructionSelectorT* selector)\n      : TurboshaftAdapter(selector->schedule()), selector_(selector) {}\n\n  InstructionOperand NoOutput() {\n    return InstructionOperand();  // Generates an invalid operand.\n  }\n\n  InstructionOperand DefineAsRegister(turboshaft::OpIndex node) {\n    return Define(node,\n                  UnallocatedOperand(UnallocatedOperand::MUST_HAVE_REGISTER,\n                                     GetVReg(node)));\n  }\n\n  InstructionOperand DefineSameAsInput(turboshaft::OpIndex node,\n                                       int input_index) {\n    return Define(node, UnallocatedOperand(GetVReg(node), input_index));\n  }\n\n  InstructionOperand DefineSameAsFirst(turboshaft::OpIndex node) {\n    return DefineSameAsInput(node, 0);\n  }\n\n  InstructionOperand DefineAsFixed(turboshaft::OpIndex node, Register reg) {\n    return Define(node, UnallocatedOperand(UnallocatedOperand::FIXED_REGISTER,\n                                           reg.code(), GetVReg(node)));\n  }\n\n  template <typename FPRegType>\n  InstructionOperand DefineAsFixed(turboshaft::OpIndex node, FPRegType reg) {\n    return Define(node,\n                  UnallocatedOperand(UnallocatedOperand::FIXED_FP_REGISTER,\n                                     reg.code(), GetVReg(node)));\n  }\n\n  InstructionOperand DefineAsConstant(turboshaft::OpIndex node) {\n    selector()->MarkAsDefined(node);\n    int virtual_register = GetVReg(node);\n    sequence()->AddConstant(virtual_register, ToConstant(node));\n    return ConstantOperand(virtual_register);\n  }\n\n  InstructionOperand DefineAsLocation(turboshaft::OpIndex node,\n                                      LinkageLocation location) {\n    return Define(node, ToUnallocatedOperand(location, GetVReg(node)));\n  }\n\n  InstructionOperand DefineAsDualLocation(turboshaft::OpIndex node,\n                                          LinkageLocation primary_location,\n                                          LinkageLocation secondary_location) {\n    return Define(node,\n                  ToDualLocationUnallocatedOperand(\n                      primary_location, secondary_location, GetVReg(node)));\n  }\n\n  InstructionOperand Use(turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::NONE,\n                                        UnallocatedOperand::USED_AT_START,\n                                        GetVReg(node)));\n  }\n\n  InstructionOperand UseAnyAtEnd(turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::REGISTER_OR_SLOT,\n                                        UnallocatedOperand::USED_AT_END,\n                                        GetVReg(node)));\n  }\n\n  InstructionOperand UseAny(turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::REGISTER_OR_SLOT,\n                                        UnallocatedOperand::USED_AT_START,\n                                        GetVReg(node)));\n  }\n\n  InstructionOperand UseRegisterOrSlotOrConstant(turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(\n                         UnallocatedOperand::REGISTER_OR_SLOT_OR_CONSTANT,\n                         UnallocatedOperand::USED_AT_START, GetVReg(node)));\n  }\n\n  InstructionOperand UseUniqueRegisterOrSlotOrConstant(\n      turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(\n                         UnallocatedOperand::REGISTER_OR_SLOT_OR_CONSTANT,\n                         GetVReg(node)));\n  }\n\n  InstructionOperand UseRegister(turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::MUST_HAVE_REGISTER,\n                                        UnallocatedOperand::USED_AT_START,\n                                        GetVReg(node)));\n  }\n\n  InstructionOperand UseRegisterAtEnd(turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::MUST_HAVE_REGISTER,\n                                        UnallocatedOperand::USED_AT_END,\n                                        GetVReg(node)));\n  }\n\n  InstructionOperand UseUniqueSlot(turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::MUST_HAVE_SLOT,\n                                        GetVReg(node)));\n  }\n\n  // Use register or operand for the node. If a register is chosen, it won't\n  // alias any temporary or output registers.\n  InstructionOperand UseUnique(turboshaft::OpIndex node) {\n    return Use(node,\n               UnallocatedOperand(UnallocatedOperand::NONE, GetVReg(node)));\n  }\n\n  // Use a unique register for the node that does not alias any temporary or\n  // output registers.\n  InstructionOperand UseUniqueRegister(turboshaft::OpIndex node) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::MUST_HAVE_REGISTER,\n                                        GetVReg(node)));\n  }\n\n  enum class RegisterUseKind { kUseRegister, kUseUniqueRegister };\n  InstructionOperand UseRegister(turboshaft::OpIndex node,\n                                 RegisterUseKind unique_reg) {\n    if (V8_LIKELY(unique_reg == RegisterUseKind::kUseRegister)) {\n      return UseRegister(node);\n    } else {\n      DCHECK_EQ(unique_reg, RegisterUseKind::kUseUniqueRegister);\n      return UseUniqueRegister(node);\n    }\n  }\n\n  InstructionOperand UseFixed(turboshaft::OpIndex node, Register reg) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::FIXED_REGISTER,\n                                        reg.code(), GetVReg(node)));\n  }\n\n  template <typename FPRegType>\n  InstructionOperand UseFixed(turboshaft::OpIndex node, FPRegType reg) {\n    return Use(node, UnallocatedOperand(UnallocatedOperand::FIXED_FP_REGISTER,\n                                        reg.code(), GetVReg(node)));\n  }\n\n  InstructionOperand UseImmediate(int immediate) {\n    return sequence()->AddImmediate(Constant(immediate));\n  }\n\n  InstructionOperand UseImmediate64(int64_t immediate) {\n    return sequence()->AddImmediate(Constant(immediate));\n  }\n\n  InstructionOperand UseImmediate(turboshaft::OpIndex node) {\n    return sequence()->AddImmediate(ToConstant(node));\n  }\n\n  InstructionOperand UseNegatedImmediate(turboshaft::OpIndex node) {\n    return sequence()->AddImmediate(ToNegatedConstant(node));\n  }\n\n  InstructionOperand UseLocation(turboshaft::OpIndex node,\n                                 LinkageLocation location) {\n    return Use(node, ToUnallocatedOperand(location, GetVReg(node)));\n  }\n\n  // Used to force gap moves from the from_location to the to_location\n  // immediately before an instruction.\n  InstructionOperand UsePointerLocation(LinkageLocation to_location,\n                                        LinkageLocation from_location) {\n    UnallocatedOperand casted_from_operand =\n        UnallocatedOperand::cast(TempLocation(from_location));\n    selector_->Emit(kArchNop, casted_from_operand);\n    return ToUnallocatedOperand(to_location,\n                                casted_from_operand.virtual_register());\n  }\n\n  InstructionOperand TempRegister() {\n    return UnallocatedOperand(UnallocatedOperand::MUST_HAVE_REGISTER,\n                              UnallocatedOperand::USED_AT_START,\n                              sequence()->NextVirtualRegister());\n  }\n\n  int AllocateVirtualRegister() { return sequence()->NextVirtualRegister(); }\n\n  InstructionOperand DefineSameAsFirstForVreg(int vreg) {\n    return UnallocatedOperand(UnallocatedOperand::SAME_AS_INPUT, vreg);\n  }\n\n  InstructionOperand DefineAsRegistertForVreg(int vreg) {\n    return UnallocatedOperand(UnallocatedOperand::MUST_HAVE_REGISTER, vreg);\n  }\n\n  InstructionOperand UseRegisterForVreg(int vreg) {\n    return UnallocatedOperand(UnallocatedOperand::MUST_HAVE_REGISTER,\n                              UnallocatedOperand::USED_AT_START, vreg);\n  }\n\n  // The kind of register generated for memory operands. kRegister is alive\n  // until the start of the operation, kUniqueRegister until the end.\n  enum RegisterMode {\n    kRegister,\n    kUniqueRegister,\n  };\n\n  InstructionOperand UseRegisterWithMode(turboshaft::OpIndex node,\n                                         RegisterMode register_mode) {\n    return register_mode == kRegister ? UseRegister(node)\n                                      : UseUniqueRegister(node);\n  }\n\n  InstructionOperand TempDoubleRegister() {\n    UnallocatedOperand op = UnallocatedOperand(\n        UnallocatedOperand::MUST_HAVE_REGISTER,\n        UnallocatedOperand::USED_AT_START, sequence()->NextVirtualRegister());\n    sequence()->MarkAsRepresentation(MachineRepresentation::kFloat64,\n                                     op.virtual_register());\n    return op;\n  }\n\n  InstructionOperand TempSimd128Register() {\n    UnallocatedOperand op = UnallocatedOperand(\n        UnallocatedOperand::MUST_HAVE_REGISTER,\n        UnallocatedOperand::USED_AT_START, sequence()->NextVirtualRegister());\n    sequence()->MarkAsRepresentation(MachineRepresentation::kSimd128,\n                                     op.virtual_register());\n    return op;\n  }\n\n  InstructionOperand TempSimd256Register() {\n    UnallocatedOperand op = UnallocatedOperand(\n        UnallocatedOperand::MUST_HAVE_REGISTER,\n        UnallocatedOperand::USED_AT_START, sequence()->NextVirtualRegister());\n    sequence()->MarkAsRepresentation(MachineRepresentation::kSimd256,\n                                     op.virtual_register());\n    return op;\n  }\n\n  InstructionOperand TempRegister(Register reg) {\n    return UnallocatedOperand(UnallocatedOperand::FIXED_REGISTER, reg.code(),\n                              InstructionOperand::kInvalidVirtualRegister);\n  }\n\n  InstructionOperand TempRegister(int code) {\n    return UnallocatedOperand(UnallocatedOperand::FIXED_REGISTER, code,\n                              sequence()->NextVirtualRegister());\n  }\n\n  template <typename FPRegType>\n  InstructionOperand TempFpRegister(FPRegType reg) {\n    UnallocatedOperand op =\n        UnallocatedOperand(UnallocatedOperand::FIXED_FP_REGISTER, reg.code(),\n                           sequence()->NextVirtualRegister());\n    sequence()->MarkAsRepresentation(MachineRepresentation::kSimd128,\n                                     op.virtual_register());\n    return op;\n  }\n\n  InstructionOperand TempImmediate(int32_t imm) {\n    return sequence()->AddImmediate(Constant(imm));\n  }\n\n  InstructionOperand TempLocation(LinkageLocation location) {\n    return ToUnallocatedOperand(location, sequence()->NextVirtualRegister());\n  }\n\n  InstructionOperand Label(turboshaft::Block* block) {\n    return sequence()->AddImmediate(Constant(this->rpo_number(block)));\n  }\n\n protected:\n  InstructionSelectorT* selector() const { return selector_; }\n  InstructionSequence* sequence() const { return selector()->sequence(); }\n  Zone* zone() const { return selector()->instruction_zone(); }\n\n private:\n  int GetVReg(turboshaft::OpIndex node) const {\n    return selector_->GetVirtualRegister(node);\n  }\n\n  Constant ToConstant(turboshaft::OpIndex node) {\n    using Kind = turboshaft::ConstantOp::Kind;\n    if (const turboshaft::ConstantOp* constant =\n            this->turboshaft_graph()\n                ->Get(node)\n                .template TryCast<turboshaft::ConstantOp>()) {\n      switch (constant->kind) {\n        case Kind::kWord32:\n          return Constant(static_cast<int32_t>(constant->word32()));\n        case Kind::kWord64:\n          return Constant(static_cast<int64_t>(constant->word64()));\n        case Kind::kSmi:\n          if constexpr (Is64()) {\n            return Constant(static_cast<int64_t>(constant->smi().ptr()));\n          } else {\n            return Constant(static_cast<int32_t>(constant.smi().ptr()));\n          }\n        case Kind::kHeapObject:\n        case Kind::kCompressedHeapObject:\n        case Kind::kTrustedHeapObject:\n          return Constant(constant->handle(),\n                          constant->kind == Kind::kCompressedHeapObject);\n        case Kind::kExternal:\n          return Constant(constant->external_reference());\n        case Kind::kNumber:\n          return Constant(constant->number());\n        case Kind::kFloat32:\n          return Constant(constant->float32());\n        case Kind::kFloat64:\n          return Constant(constant->float64());\n        case Kind::kTaggedIndex: {\n          // Unencoded index value.\n          intptr_t value = static_cast<intptr_t>(constant->tagged_index());\n          DCHECK(TaggedIndex::IsValid(value));\n          // Generate it as 32/64-bit constant in a tagged form.\n          Address tagged_index = TaggedIndex::FromIntptr(value).ptr();\n          if (kSystemPointerSize == kInt32Size) {\n            return Constant(static_cast<int32_t>(tagged_index));\n          } else {\n            return Constant(static_cast<int64_t>(tagged_index));\n          }\n        }\n        case Kind::kRelocatableWasmCall:\n        case Kind::kRelocatableWasmStubCall: {\n          uint64_t value = constant->integral();\n          auto mode = constant->kind == Kind::kRelocatableWasmCall\n                          ? RelocInfo::WASM_CALL\n                          : RelocInfo::WASM_STUB_CALL;\n          using constant_type = std::conditional_t<Is64(), int64_t, int32_t>;\n          return Constant(RelocatablePtrConstantInfo(\n              base::checked_cast<constant_type>(value), mode));\n        }\n        case Kind::kRelocatableWasmCanonicalSignatureId:\n          return Constant(RelocatablePtrConstantInfo(\n              base::checked_cast<int32_t>(constant->integral()),\n              RelocInfo::WASM_CANONICAL_SIG_ID));\n        case Kind::kRelocatableWasmIndirectCallTarget:\n          uint64_t value = constant->integral();\n          return Constant(RelocatablePtrConstantInfo(\n              base::checked_cast<int32_t>(value),\n              RelocInfo::WASM_CODE_POINTER_TABLE_ENTRY));\n      }\n    }\n    UNREACHABLE();\n  }\n\n  Constant ToNegatedConstant(turboshaft::OpIndex node) {\n    const turboshaft::ConstantOp& constant =\n        Get(node).Cast<turboshaft::ConstantOp>();\n    switch (constant.kind) {\n      case turboshaft::ConstantOp::Kind::kWord32:\n        return Constant(-static_cast<int32_t>(constant.word32()));\n      case turboshaft::ConstantOp::Kind::kWord64:\n        return Constant(-static_cast<int64_t>(constant.word64()));\n      case turboshaft::ConstantOp::Kind::kSmi:\n        if (Is64()) {\n          return Constant(-static_cast<int64_t>(constant.smi().ptr()));\n        } else {\n          return Constant(-static_cast<int32_t>(constant.smi().ptr()));\n        }\n      default:\n        UNREACHABLE();\n    }\n  }\n\n  UnallocatedOperand Define(turboshaft::OpIndex node,\n                            UnallocatedOperand operand) {\n    DCHECK(node.valid());\n    DCHECK_EQ(operand.virtual_register(), GetVReg(node));\n    selector()->MarkAsDefined(node);\n    return operand;\n  }\n\n  UnallocatedOperand Use(turboshaft::OpIndex node, UnallocatedOperand operand) {\n    DCHECK(node.valid());\n    DCHECK_EQ(operand.virtual_register(), GetVReg(node));\n    selector()->MarkAsUsed(node);\n    return operand;\n  }\n\n  UnallocatedOperand ToDualLocationUnallocatedOperand(\n      LinkageLocation primary_location, LinkageLocation secondary_location,\n      int virtual_register) {\n    // We only support the primary location being a register and the secondary\n    // one a slot.\n    DCHECK(primary_location.IsRegister() &&\n           secondary_location.IsCalleeFrameSlot());\n    int reg_id = primary_location.AsRegister();\n    int slot_id = secondary_location.AsCalleeFrameSlot();\n    return UnallocatedOperand(reg_id, slot_id, virtual_register);\n  }\n\n  UnallocatedOperand ToUnallocatedOperand(LinkageLocation location,\n                                          int virtual_register) {\n    if (location.IsAnyRegister() || location.IsNullRegister()) {\n      // any machine register.\n      return UnallocatedOperand(UnallocatedOperand::MUST_HAVE_REGISTER,\n                                virtual_register);\n    }\n    if (location.IsCallerFrameSlot()) {\n      // a location on the caller frame.\n      return UnallocatedOperand(UnallocatedOperand::FIXED_SLOT,\n                                location.AsCallerFrameSlot(), virtual_register);\n    }\n    if (location.IsCalleeFrameSlot()) {\n      // a spill location on this (callee) frame.\n      return UnallocatedOperand(UnallocatedOperand::FIXED_SLOT,\n                                location.AsCalleeFrameSlot(), virtual_register);\n    }\n    // a fixed register.\n    if (IsFloatingPoint(location.GetType().representation())) {\n      return UnallocatedOperand(UnallocatedOperand::FIXED_FP_REGISTER,\n                                location.AsRegister(), virtual_register);\n    }\n    return UnallocatedOperand(UnallocatedOperand::FIXED_REGISTER,\n                              location.AsRegister(), virtual_register);\n  }\n\n  InstructionSelectorT* selector_;\n};\n        ]]></code>\n    </class>\n</file>\n```"
}