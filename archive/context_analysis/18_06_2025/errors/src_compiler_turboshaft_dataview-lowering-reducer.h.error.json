{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/dataview-lowering-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 202, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/dataview-lowering-reducer.h\",\n        \"file_name\": \"dataview-lowering-reducer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines a reducer that lowers DataView operations in the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for assembler functionality.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DataViewLoweringReducer\",\n            \"extends\": \"Next\",\n            \"about\": \"A reducer that lowers DataView operations to simpler Turboshaft operations.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Next\",\n                \"ExternalArrayType\",\n                \"OpIndex\",\n                \"MachineType\",\n                \"MemoryRepresentation\",\n                \"Variable\",\n                \"AccessBuilder\",\n                \"LoadOp\",\n                \"StoreOp\",\n                \"WriteBarrierKind\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Next>\nclass DataViewLoweringReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(DataViewLowering)\n\n  OpIndex BuildReverseBytes(ExternalArrayType type, OpIndex value);\n\n  OpIndex REDUCE(LoadDataViewElement)(V<Object> object, V<WordPtr> storage,\n                                      V<WordPtr> index,\n                                      V<Word32> is_little_endian,\n                                      ExternalArrayType element_type);\n\n  OpIndex REDUCE(StoreDataViewElement)(V<Object> object, V<WordPtr> storage,\n                                       V<WordPtr> index, OpIndex value,\n                                       V<Word32> is_little_endian,\n                                       ExternalArrayType element_type);\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BuildReverseBytes\",\n            \"parent\": \"DataViewLoweringReducer\",\n            \"about\": \"Reverses the byte order of a value based on the given ExternalArrayType.\",\n            \"logic\": \"Uses a switch statement to handle different ExternalArrayTypes, reversing bytes using Word32ReverseBytes or Word64ReverseBytes as appropriate.  For float types, it bitcasts to the corresponding integer type, reverses the bytes, and then bitcasts back.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"ExternalArrayType\",\n                    \"purpose\": \"The type of the external array element.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The value to reverse the bytes of.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"OpIndex\",\n                \"description\": \"The value with reversed byte order.\"\n            },\n            \"dependencies\": [\n                \"ExternalArrayType\",\n                \"OpIndex\",\n                \"Word32ShiftRightArithmetic\",\n                \"Word32ReverseBytes\",\n                \"Word32ShiftRightLogical\",\n                \"BitcastFloat32ToWord32\",\n                \"BitcastWord32ToFloat32\",\n                \"BitcastFloat64ToWord64\",\n                \"Word64ReverseBytes\",\n                \"BitcastWord64ToFloat64\",\n                \"Float64ExtractLowWord32\",\n                \"Float64ExtractHighWord32\",\n                \"BitcastWord32PairToFloat64\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  OpIndex DataViewLoweringReducer::BuildReverseBytes(ExternalArrayType type, OpIndex value) {\n    switch (type) {\n      case kExternalInt8Array:\n      case kExternalUint8Array:\n      case kExternalUint8ClampedArray:\n        return value;\n      case kExternalInt16Array:\n        return __ Word32ShiftRightArithmetic(__ Word32ReverseBytes(value), 16);\n      case kExternalFloat16Array:\n      case kExternalUint16Array:\n        return __ Word32ShiftRightLogical(__ Word32ReverseBytes(value), 16);\n      case kExternalInt32Array:\n      case kExternalUint32Array:\n        return __ Word32ReverseBytes(value);\n      case kExternalFloat32Array: {\n        V<Word32> bytes = __ BitcastFloat32ToWord32(value);\n        V<Word32> reversed = __ Word32ReverseBytes(bytes);\n        return __ BitcastWord32ToFloat32(reversed);\n      }\n      case kExternalFloat64Array: {\n        if constexpr (Is64()) {\n          V<Word64> bytes = __ BitcastFloat64ToWord64(value);\n          V<Word64> reversed = __ Word64ReverseBytes(bytes);\n          return __ BitcastWord64ToFloat64(reversed);\n        } else {\n          V<Word32> reversed_lo =\n              __ Word32ReverseBytes(__ Float64ExtractLowWord32(value));\n          V<Word32> reversed_hi =\n              __ Word32ReverseBytes(__ Float64ExtractHighWord32(value));\n          return __ BitcastWord32PairToFloat64(reversed_lo, reversed_hi);\n        }\n      }\n      case kExternalBigInt64Array:\n      case kExternalBigUint64Array:\n        return __ Word64ReverseBytes(value);\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(LoadDataViewElement)\",\n            \"parent\": \"DataViewLoweringReducer\",\n            \"about\": \"Reduces a LoadDataViewElement operation to simpler Turboshaft operations.\",\n            \"logic\": \"Loads the data from memory, then conditionally reverses the byte order depending on the endianness and target architecture.  It also retains the object to keep the underlying buffer alive during the operation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The DataView or ArrayBuffer object.\"\n                },\n                {\n                    \"name\": \"storage\",\n                    \"type\": \"V<WordPtr>\",\n                    \"purpose\": \"The base address of the storage.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"V<WordPtr>\",\n                    \"purpose\": \"The index into the storage.\"\n                },\n                {\n                    \"name\": \"is_little_endian\",\n                    \"type\": \"V<Word32>\",\n                    \"purpose\": \"Indicates whether the DataView is little-endian.\"\n                },\n                {\n                    \"name\": \"element_type\",\n                    \"type\": \"ExternalArrayType\",\n                    \"purpose\": \"The type of the element being loaded.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"OpIndex\",\n                \"description\": \"The loaded value.\"\n            },\n            \"dependencies\": [\n                \"V<Object>\",\n                \"V<WordPtr>\",\n                \"V<Word32>\",\n                \"ExternalArrayType\",\n                \"MachineType\",\n                \"MemoryRepresentation\",\n                \"OpIndex\",\n                \"AccessBuilder\",\n                \"LoadOp\",\n                \"Variable\",\n                \"RegisterRepresentationForArrayType\",\n                \"BuildReverseBytes\",\n                \"Retain\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  OpIndex DataViewLoweringReducer::REDUCE(LoadDataViewElement)(V<Object> object, V<WordPtr> storage,\n                                      V<WordPtr> index,\n                                      V<Word32> is_little_endian,\n                                      ExternalArrayType element_type) {\n    const MachineType machine_type =\n        AccessBuilder::ForTypedArrayElement(element_type, true).machine_type;\n    const MemoryRepresentation memory_rep =\n        MemoryRepresentation::FromMachineType(machine_type);\n\n    OpIndex value =\n        __ Load(storage, index,\n                LoadOp::Kind::MaybeUnaligned(memory_rep).NotLoadEliminable(),\n                memory_rep);\n\n    Variable result = Asm().NewLoopInvariantVariable(\n        RegisterRepresentationForArrayType(element_type));\n    IF (is_little_endian) {\n#if V8_TARGET_LITTLE_ENDIAN\n      Asm().SetVariable(result, value);\n#else\n      Asm().SetVariable(result, BuildReverseBytes(element_type, value));\n#endif  // V8_TARGET_LITTLE_ENDIAN\n    } ELSE {\n#if V8_TARGET_LITTLE_ENDIAN\n      Asm().SetVariable(result, BuildReverseBytes(element_type, value));\n#else\n      Asm().SetVariable(result, value);\n#endif  // V8_TARGET_LITTLE_ENDIAN\n    }\n\n    // We need to keep the {object} (either the JSArrayBuffer or the JSDataView)\n    // alive so that the GC will not release the JSArrayBuffer (if there's any)\n    // as long as we are still operating on it.\n    __ Retain(object);\n    return Asm().GetVariable(result);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(StoreDataViewElement)\",\n            \"parent\": \"DataViewLoweringReducer\",\n            \"about\": \"Reduces a StoreDataViewElement operation to simpler Turboshaft operations.\",\n            \"logic\": \"Conditionally reverses the byte order depending on the endianness and target architecture, then stores the data to memory. It also retains the object to keep the underlying buffer alive during the operation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The DataView or ArrayBuffer object.\"\n                },\n                {\n                    \"name\": \"storage\",\n                    \"type\": \"V<WordPtr>\",\n                    \"purpose\": \"The base address of the storage.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"V<WordPtr>\",\n                    \"purpose\": \"The index into the storage.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The value to store.\"\n                },\n                {\n                    \"name\": \"is_little_endian\",\n                    \"type\": \"V<Word32>\",\n                    \"purpose\": \"Indicates whether the DataView is little-endian.\"\n                },\n                {\n                    \"name\": \"element_type\",\n                    \"type\": \"ExternalArrayType\",\n                    \"purpose\": \"The type of the element being stored.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"OpIndex\",\n                \"description\": \"No return value (void).\"\n            },\n            \"dependencies\": [\n                \"V<Object>\",\n                \"V<WordPtr>\",\n                \"V<Word32>\",\n                \"ExternalArrayType\",\n                \"MachineType\",\n                \"MemoryRepresentation\",\n                \"OpIndex\",\n                \"AccessBuilder\",\n                \"StoreOp\",\n                \"Variable\",\n                \"RegisterRepresentationForArrayType\",\n                \"BuildReverseBytes\",\n                \"Retain\",\n                \"WriteBarrierKind\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  OpIndex DataViewLoweringReducer::REDUCE(StoreDataViewElement)(V<Object> object, V<WordPtr> storage,\n                                       V<WordPtr> index, OpIndex value,\n                                       V<Word32> is_little_endian,\n                                       ExternalArrayType element_type) {\n    const MachineType machine_type =\n        AccessBuilder::ForTypedArrayElement(element_type, true).machine_type;\n\n    Variable value_to_store = Asm().NewLoopInvariantVariable(\n        RegisterRepresentationForArrayType(element_type));\n    IF (is_little_endian) {\n#if V8_TARGET_LITTLE_ENDIAN\n      Asm().SetVariable(value_to_store, value);\n#else\n      Asm().SetVariable(value_to_store, BuildReverseBytes(element_type, value));\n#endif  // V8_TARGET_LITTLE_ENDIAN\n    } ELSE {\n#if V8_TARGET_LITTLE_ENDIAN\n      Asm().SetVariable(value_to_store, BuildReverseBytes(element_type, value));\n#else\n      Asm().SetVariable(value_to_store, value);\n#endif  // V8_TARGET_LITTLE_ENDIAN\n    }\n\n    const MemoryRepresentation memory_rep =\n        MemoryRepresentation::FromMachineType(machine_type);\n    __ Store(storage, index, Asm().GetVariable(value_to_store),\n             StoreOp::Kind::MaybeUnaligned(memory_rep).NotLoadEliminable(),\n             memory_rep, WriteBarrierKind::kNoWriteBarrier);\n\n    // We need to keep the {object} (either the JSArrayBuffer or the JSDataView)\n    // alive so that the GC will not release the JSArrayBuffer (if there's any)\n    // as long as we are still operating on it.\n    __ Retain(object);\n    return {};\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}