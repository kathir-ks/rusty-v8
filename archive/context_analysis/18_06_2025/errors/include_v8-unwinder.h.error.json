{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-unwinder.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 84, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-unwinder.h\",\n        \"file_name\": \"v8-unwinder.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Unwinder class and related structures for skipping over V8 frames in a stack, used for profiling and debugging.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library features and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <memory>\n\n#include \"v8-embedder-state-scope.h\"  // NOLINT(build/include_directory)\n#include \"v8config.h\"                 // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"CalleeSavedRegisters\",\n            \"about\": \"Holds callee saved registers needed for the stack unwinder. It is the empty struct if no registers are required.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstruct CalleeSavedRegisters;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"RegisterState\",\n            \"about\": \"Represents the current state of registers used by the sampling profiler API.\",\n            \"attributes\": [\n                {\n                    \"name\": \"pc\",\n                    \"type\": \"void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Instruction pointer.\"\n                },\n                {\n                    \"name\": \"sp\",\n                    \"type\": \"void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Stack pointer.\"\n                },\n                {\n                    \"name\": \"fp\",\n                    \"type\": \"void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Frame pointer.\"\n                },\n                {\n                    \"name\": \"lr\",\n                    \"type\": \"void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Link register (or nullptr on platforms without a link register).\"\n                },\n                {\n                    \"name\": \"callee_saved\",\n                    \"type\": \"std::unique_ptr<CalleeSavedRegisters>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Callee saved registers (or null if no callee saved registers were stored).\"\n                }\n            ],\n            \"dependencies\": [\n                \"CalleeSavedRegisters\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct V8_EXPORT RegisterState {\n  RegisterState();\n  ~RegisterState();\n  RegisterState(const RegisterState& other);\n  RegisterState& operator=(const RegisterState& other);\n\n  void* pc;  // Instruction pointer.\n  void* sp;  // Stack pointer.\n  void* fp;  // Frame pointer.\n  void* lr;  // Link register (or nullptr on platforms without a link register).\n  // Callee saved registers (or null if no callee saved registers were stored)\n  std::unique_ptr<CalleeSavedRegisters> callee_saved;\n};\n        ]]></code>\n    </class>\n\n    <interface>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"StateTag\",\n            \"about\": \"Represents a possible state of the VM.\",\n            \"methods\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nenum StateTag : uint16_t {\n  JS,\n  GC,\n  PARSER,\n  BYTECODE_COMPILER,\n  COMPILER,\n  OTHER,\n  EXTERNAL,\n  ATOMICS_WAIT,\n  IDLE,\n  LOGGING,\n};\n        ]]></code>\n    </interface>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SampleInfo\",\n            \"about\": \"The output structure filled up by GetStackSample API function.\",\n            \"attributes\": [\n                {\n                    \"name\": \"frames_count\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Number of frames collected.\"\n                },\n                {\n                    \"name\": \"external_callback_entry\",\n                    \"type\": \"void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"External callback address if VM is executing an external callback.\"\n                },\n                {\n                    \"name\": \"context\",\n                    \"type\": \"void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Incumbent native context address.\"\n                },\n                {\n                    \"name\": \"embedder_context\",\n                    \"type\": \"void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Native context address for embedder state\"\n                },\n                {\n                    \"name\": \"vm_state\",\n                    \"type\": \"StateTag\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Current VM state.\"\n                },\n                {\n                    \"name\": \"embedder_state\",\n                    \"type\": \"EmbedderStateTag\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Current Embedder state\"\n                }\n            ],\n            \"dependencies\": [\n                \"StateTag\",\n                \"EmbedderStateTag\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct SampleInfo {\n  size_t frames_count;              // Number of frames collected.\n  void* external_callback_entry;    // External callback address if VM is\n                                    // executing an external callback.\n  void* context;                    // Incumbent native context address.\n  void* embedder_context;           // Native context address for embedder state\n  StateTag vm_state;                // Current VM state.\n  EmbedderStateTag embedder_state;  // Current Embedder state\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"MemoryRange\",\n            \"about\": \"Represents a range of memory.\",\n            \"attributes\": [\n                {\n                    \"name\": \"start\",\n                    \"type\": \"const void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Start address of the memory range.\"\n                },\n                {\n                    \"name\": \"length_in_bytes\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Length of the memory range in bytes.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstruct MemoryRange {\n  const void* start = nullptr;\n  size_t length_in_bytes = 0;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"JSEntryStub\",\n            \"about\": \"Represents a JS entry stub with its code range.\",\n            \"attributes\": [\n                {\n                    \"name\": \"code\",\n                    \"type\": \"MemoryRange\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Memory range of the JS entry stub code.\"\n                }\n            ],\n            \"dependencies\": [\n                \"MemoryRange\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct JSEntryStub {\n  MemoryRange code;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"JSEntryStubs\",\n            \"about\": \"Collection of JS entry stubs.\",\n            \"attributes\": [\n                {\n                    \"name\": \"js_entry_stub\",\n                    \"type\": \"JSEntryStub\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Normal JS entry stub.\"\n                },\n                {\n                    \"name\": \"js_construct_entry_stub\",\n                    \"type\": \"JSEntryStub\",\n                    \"access\": \"public\",\n                    \"purpose\": \"JS construct entry stub.\"\n                },\n                {\n                    \"name\": \"js_run_microtasks_entry_stub\",\n                    \"type\": \"JSEntryStub\",\n                    \"access\": \"public\",\n                    \"purpose\": \"JS run microtasks entry stub.\"\n                }\n            ],\n            \"dependencies\": [\n                \"JSEntryStub\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct JSEntryStubs {\n  JSEntryStub js_entry_stub;\n  JSEntryStub js_construct_entry_stub;\n  JSEntryStub js_run_microtasks_entry_stub;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Unwinder\",\n            \"about\": \"Helpers for skipping over V8 frames in a given stack.  The unwinder API is only supported on the x64, ARM64 and ARM32 architectures.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT Unwinder {\n public:\n  /**\n   * Attempt to unwind the stack to the most recent C++ frame. This function is\n   * signal-safe and does not access any V8 state and thus doesn't require an\n   * Isolate.\n   *\n   * The unwinder needs to know the location of the JS Entry Stub (a piece of\n   * code that is run when C++ code calls into generated JS code). This is used\n   * for edge cases where the current frame is being constructed or torn down\n   * when the stack sample occurs.\n   *\n   * The unwinder also needs the virtual memory range of all possible V8 code\n   * objects. There are two ranges required - the heap code range and the range\n   * for code embedded in the binary.\n   *\n   * Available on x64, ARM64 and ARM32.\n   *\n   * \\param code_pages A list of all of the ranges in which V8 has allocated\n   * executable code. The caller should obtain this list by calling\n   * Isolate::CopyCodePages() during the same interrupt/thread suspension that\n   * captures the stack.\n   * \\param register_state The current registers. This is an in-out param that\n   * will be overwritten with the register values after unwinding, on success.\n   * \\param stack_base The resulting stack pointer and frame pointer values are\n   * bounds-checked against the stack_base and the original stack pointer value\n   * to ensure that they are valid locations in the given stack. If these values\n   * or any intermediate frame pointer values used during unwinding are ever out\n   * of these bounds, unwinding will fail.\n   *\n   * \\return True on success.\n   */\n  static bool TryUnwindV8Frames(const JSEntryStubs& entry_stubs,\n                                size_t code_pages_length,\n                                const MemoryRange* code_pages,\n                                RegisterState* register_state,\n                                const void* stack_base);\n\n  /**\n   * Whether the PC is within the V8 code range represented by code_pages.\n   *\n   * If this returns false, then calling UnwindV8Frames() with the same PC\n   * and unwind_state will always fail. If it returns true, then unwinding may\n   * (but not necessarily) be successful.\n   *\n   * Available on x64, ARM64 and ARM32\n   */\n  static bool PCIsInV8(size_t code_pages_length, const MemoryRange* code_pages,\n                       void* pc);\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TryUnwindV8Frames\",\n            \"parent\": \"Unwinder\",\n            \"about\": \"Attempts to unwind the stack to the most recent C++ frame.\",\n            \"logic\": \"This function is signal-safe and does not access any V8 state. It requires the location of the JS Entry Stub and the virtual memory range of all possible V8 code objects. Bounds-checks the stack pointer and frame pointer values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"entry_stubs\",\n                    \"type\": \"const JSEntryStubs&\",\n                    \"purpose\": \"The JS entry stubs.\"\n                },\n                {\n                    \"name\": \"code_pages_length\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The length of the code pages array.\"\n                },\n                {\n                    \"name\": \"code_pages\",\n                    \"type\": \"const MemoryRange*\",\n                    \"purpose\": \"A list of all of the ranges in which V8 has allocated executable code.\"\n                },\n                {\n                    \"name\": \"register_state\",\n                    \"type\": \"RegisterState*\",\n                    \"purpose\": \"The current registers. This is an in-out param that will be overwritten with the register values after unwinding, on success.\"\n                },\n                {\n                    \"name\": \"stack_base\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The base of the stack.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True on success.\"\n            },\n            \"dependencies\": [\n                \"JSEntryStubs\",\n                \"MemoryRange\",\n                \"RegisterState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static bool TryUnwindV8Frames(const JSEntryStubs& entry_stubs,\n                                size_t code_pages_length,\n                                const MemoryRange* code_pages,\n                                RegisterState* register_state,\n                                const void* stack_base);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PCIsInV8\",\n            \"parent\": \"Unwinder\",\n            \"about\": \"Checks if the PC is within the V8 code range represented by code_pages.\",\n            \"logic\": \"Determines if a given program counter (PC) value falls within any of the provided memory ranges associated with V8 code.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code_pages_length\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The length of the code pages array.\"\n                },\n                {\n                    \"name\": \"code_pages\",\n                    \"type\": \"const MemoryRange*\",\n                    \"purpose\": \"A list of all of the ranges in which V8 has allocated executable code.\"\n                },\n                {\n                    \"name\": \"pc\",\n                    \"type\": \"void*\",\n                    \"purpose\": \"The program counter to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the PC is within the V8 code range.\"\n            },\n            \"dependencies\": [\n                \"MemoryRange\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static bool PCIsInV8(size_t code_pages_length, const MemoryRange* code_pages,\n                       void* pc);\n        ]]></code>\n    </func>\n</file>\n```"
}