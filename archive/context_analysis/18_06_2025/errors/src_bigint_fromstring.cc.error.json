{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/fromstring.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/fromstring.cc\",\n            \"file_name\": \"fromstring.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements conversion from string to BigInt\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for BigInt implementation and vector arithmetic\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/bigint/bigint-internal.h\"\n            #include \"src/bigint/vector-arithmetic.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ProcessorImpl\",\n                \"about\": \"Implementation details for BigInt processing.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace bigint {\n\n            // The classic algorithm: for every part, multiply the accumulator with\n            // the appropriate multiplier, and add the part. O(n\u00b2) overall.\n            void ProcessorImpl::FromStringClassic(RWDigits Z,\n                                                  FromStringAccumulator* accumulator) {\n              // We always have at least one part to process.\n              DCHECK(accumulator->stack_parts_used_ > 0);\n              Z[0] = accumulator->stack_parts_[0];\n              RWDigits already_set(Z, 0, 1);\n              for (int i = 1; i < Z.len(); i++) Z[i] = 0;\n\n              // The {FromStringAccumulator} uses stack-allocated storage for the first\n              // few parts; if heap storage is used at all then all parts are copied there.\n              int num_stack_parts = accumulator->stack_parts_used_;\n              if (num_stack_parts == 1) return;\n              const std::vector<digit_t>& heap_parts = accumulator->heap_parts_;\n              int num_heap_parts = static_cast<int>(heap_parts.size());\n              // All multipliers are the same, except possibly for the last.\n              const digit_t max_multiplier = accumulator->max_multiplier_;\n\n              if (num_heap_parts == 0) {\n                for (int i = 1; i < num_stack_parts - 1; i++) {\n                  MultiplySingle(Z, already_set, max_multiplier);\n                  Add(Z, accumulator->stack_parts_[i]);\n                  already_set.set_len(already_set.len() + 1);\n                }\n                MultiplySingle(Z, already_set, accumulator->last_multiplier_);\n                Add(Z, accumulator->stack_parts_[num_stack_parts - 1]);\n                return;\n              }\n              // Parts are stored on the heap.\n              for (int i = 1; i < num_heap_parts - 1; i++) {\n                MultiplySingle(Z, already_set, max_multiplier);\n                Add(Z, accumulator->heap_parts_[i]);\n                already_set.set_len(already_set.len() + 1);\n              }\n              MultiplySingle(Z, already_set, accumulator->last_multiplier_);\n              Add(Z, accumulator->heap_parts_.back());\n            }\n\n            // The fast algorithm: combine parts in a balanced-binary-tree like order:\n            // Multiply-and-add neighboring pairs of parts, then loop, until only one\n            // part is left. The benefit is that the multiplications will have inputs of\n            // similar sizes, which makes them amenable to fast multiplication algorithms.\n            // We have to do more multiplications than the classic algorithm though,\n            // because we also have to multiply the multipliers.\n            // Optimizations:\n            // - We can skip the multiplier for the first part, because we never need it.\n            // - Most multipliers are the same; we can avoid repeated multiplications and\n            //   just copy the previous result. (In theory we could even de-dupe them, but\n            //   as the parts/multipliers grow, we'll need most of the memory anyway.)\n            //   Copied results are marked with a * below.\n            // - We can reuse memory using a system of three buffers whose usage rotates:\n            //   - one is considered empty, and is overwritten with the new parts,\n            //   - one holds the multipliers (and will be \"empty\" in the next round), and\n            //   - one initially holds the parts and is overwritten with the new multipliers\n            //   Parts and multipliers both grow in each iteration, and get fewer, so we\n            //   use the space of two adjacent old chunks for one new chunk.\n            //   Since the {heap_parts_} vectors has the right size, and so does the\n            //   result {Z}, we can use that memory, and only need to allocate one scratch\n            //   vector. If the final result ends up in the wrong bucket, we have to copy it\n            //   to the correct one.\n            // - We don't have to keep track of the positions and sizes of the chunks,\n            //   because we can deduce their precise placement from the iteration index.\n            //\n            // Example, assuming digit_t is 4 bits, fitting one decimal digit:\n            // Initial state:\n            // parts_:        1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n            // multipliers_: 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10\n            // After the first iteration of the outer loop:\n            // parts:         12    34    56    78    90    12    34    5\n            // multipliers:        100  *100  *100  *100  *100  *100   10\n            // After the second iteration:\n            // parts:         1234        5678        9012        345\n            // multipliers:              10000      *10000       1000\n            // After the third iteration:\n            // parts:         12345678                9012345\n            // multipliers:                          10000000\n            // And then there's an obvious last iteration.\n            void ProcessorImpl::FromStringLarge(RWDigits Z,\n                                                FromStringAccumulator* accumulator) {\n              int num_parts = static_cast<int>(accumulator->heap_parts_.size());\n              DCHECK(num_parts >= 2);\n              DCHECK(Z.len() >= num_parts);\n              RWDigits parts(accumulator->heap_parts_.data(), num_parts);\n              Storage multipliers_storage(num_parts);\n              RWDigits multipliers(multipliers_storage.get(), num_parts);\n              RWDigits temp(Z, 0, num_parts);\n              // Unrolled and specialized first iteration: part_len == 1, so instead of\n              // Digits sub-vectors we have individual digit_t values, and the multipliers\n              // are known up front.\n              {\n                digit_t max_multiplier = accumulator->max_multiplier_;\n                digit_t last_multiplier = accumulator->last_multiplier_;\n                RWDigits new_parts = temp;\n                RWDigits new_multipliers = parts;\n                int i = 0;\n                for (; i + 1 < num_parts; i += 2) {\n                  digit_t p_in = parts[i];\n                  digit_t p_in2 = parts[i + 1];\n                  digit_t m_in = max_multiplier;\n                  digit_t m_in2 = i == num_parts - 2 ? last_multiplier : max_multiplier;\n                  // p[j] = p[i] * m[i+1] + p[i+1]\n                  digit_t p_high;\n                  digit_t p_low = digit_mul(p_in, m_in2, &p_high);\n                  digit_t carry;\n                  new_parts[i] = digit_add2(p_low, p_in2, &carry);\n                  new_parts[i + 1] = p_high + carry;\n                  // m[j] = m[i] * m[i+1]\n                  if (i > 0) {\n                    if (i > 2 && m_in2 != last_multiplier) {\n                      new_multipliers[i] = new_multipliers[i - 2];\n                      new_multipliers[i + 1] = new_multipliers[i - 1];\n                    } else {\n                      digit_t m_high;\n                      new_multipliers[i] = digit_mul(m_in, m_in2, &m_high);\n                      new_multipliers[i + 1] = m_high;\n                    }\n                  }\n                }\n                // Trailing last part (if {num_parts} was odd).\n                if (i < num_parts) {\n                  new_parts[i] = parts[i];\n                  new_multipliers[i] = last_multiplier;\n                  i += 2;\n                }\n                num_parts = i >> 1;\n                RWDigits new_temp = multipliers;\n                parts = new_parts;\n                multipliers = new_multipliers;\n                temp = new_temp;\n                AddWorkEstimate(num_parts);\n              }\n              int part_len = 2;\n\n              // Remaining iterations.\n              while (num_parts > 1) {\n                RWDigits new_parts = temp;\n                RWDigits new_multipliers = parts;\n                int new_part_len = part_len * 2;\n                int i = 0;\n                for (; i + 1 < num_parts; i += 2) {\n                  int start = i * part_len;\n                  Digits p_in(parts, start, part_len);\n                  Digits p_in2(parts, start + part_len, part_len);\n                  Digits m_in(multipliers, start, part_len);\n                  Digits m_in2(multipliers, start + part_len, part_len);\n                  RWDigits p_out(new_parts, start, new_part_len);\n                  RWDigits m_out(new_multipliers, start, new_part_len);\n                  // p[j] = p[i] * m[i+1] + p[i+1]\n                  Multiply(p_out, p_in, m_in2);\n                  if (should_terminate()) return;\n                  digit_t overflow = AddAndReturnOverflow(p_out, p_in2);\n                  DCHECK(overflow == 0);\n                  USE(overflow);\n                  // m[j] = m[i] * m[i+1]\n                  if (i > 0) {\n                    bool copied = false;\n                    if (i > 2) {\n                      int prev_start = (i - 2) * part_len;\n                      Digits m_in_prev(multipliers, prev_start, part_len);\n                      Digits m_in2_prev(multipliers, prev_start + part_len, part_len);\n                      if (Compare(m_in, m_in_prev) == 0 &&\n                          Compare(m_in2, m_in2_prev) == 0) {\n                        copied = true;\n                        Digits m_out_prev(new_multipliers, prev_start, new_part_len);\n                        for (int k = 0; k < new_part_len; k++) m_out[k] = m_out_prev[k];\n                      }\n                    }\n                    if (!copied) {\n                      Multiply(m_out, m_in, m_in2);\n                      if (should_terminate()) return;\n                    }\n                  }\n                }\n                // Trailing last part (if {num_parts} was odd).\n                if (i < num_parts) {\n                  Digits p_in(parts, i * part_len, part_len);\n                  Digits m_in(multipliers, i * part_len, part_len);\n                  RWDigits p_out(new_parts, i * part_len, new_part_len);\n                  RWDigits m_out(new_multipliers, i * part_len, new_part_len);\n                  int k = 0;\n                  for (; k < p_in.len(); k++) p_out[k] = p_in[k];\n                  for (; k < p_out.len(); k++) p_out[k] = 0;\n                  k = 0;\n                  for (; k < m_in.len(); k++) m_out[k] = m_in[k];\n                  for (; k < m_out.len(); k++) m_out[k] = 0;\n                  i += 2;\n                }\n                num_parts = i >> 1;\n                part_len = new_part_len;\n                RWDigits new_temp = multipliers;\n                parts = new_parts;\n                multipliers = new_multipliers;\n                temp = new_temp;\n              }\n              // Copy the result to Z, if it doesn't happen to be there already.\n              if (parts.digits() != Z.digits()) {\n                int i = 0;\n                for (; i < parts.len(); i++) Z[i] = parts[i];\n                // Z might be bigger than we requested; be robust towards that.\n                for (; i < Z.len(); i++) Z[i] = 0;\n              }\n            }\n\n            // Specialized algorithms for power-of-two radixes. Designed to work with\n            // {ParsePowerTwo}: {max_multiplier_} isn't saved, but {radix_} is, and\n            // {last_multiplier_} has special meaning, namely the number of unpopulated bits\n            // in the last part.\n            // For these radixes, {parts} already is a list of correct bit sequences, we\n            // just have to put them together in the right way:\n            // - The parts are currently in reversed order. The highest-index parts[i]\n            //   will go into Z[0].\n            // - All parts, possibly except for the last, are maximally populated.\n            // - A maximally populated part stores a non-fractional number of characters,\n            //   i.e. the largest fitting multiple of {char_bits} of it is populated.\n            // - The populated bits in a part are at the low end.\n            // - The number of unused bits in the last part is stored in\n            //   {accumulator->last_multiplier_}.\n            //\n            // Example: Given the following parts vector, where letters are used to\n            // label bits, bit order is big endian (i.e. [00000101] encodes \"5\"),\n            // 'x' means \"unpopulated\", kDigitBits == 8, radix == 8, and char_bits == 3:\n            //\n            //     parts[0] -> [xxABCDEF][xxGHIJKL][xxMNOPQR][xxxxxSTU] <- parts[3]\n            //\n            // We have to assemble the following result:\n            //\n            //         Z[0] -> [NOPQRSTU][FGHIJKLM][xxxABCDE] <- Z[2]\n            //\n            void ProcessorImpl::FromStringBasePowerOfTwo(\n                RWDigits Z, FromStringAccumulator* accumulator) {\n              const int num_parts = accumulator->ResultLength();\n              DCHECK(num_parts >= 1);\n              DCHECK(Z.len() >= num_parts);\n              Digits parts(accumulator->heap_parts_.empty()\n                               ? accumulator->stack_parts_\n                               : accumulator->heap_parts_.data(),\n                           num_parts);\n              uint8_t radix = accumulator->radix_;\n              DCHECK(radix == 2 || radix == 4 || radix == 8 || radix == 16 || radix == 32);\n              const int char_bits = BitLength(radix - 1);\n              const int unused_last_part_bits =\n                  static_cast<int>(accumulator->last_multiplier_);\n              const int unused_part_bits = kDigitBits % char_bits;\n              const int max_part_bits = kDigitBits - unused_part_bits;\n              int z_index = 0;\n              int part_index = num_parts - 1;\n\n              // If the last part is fully populated, then all parts must be, and we can\n              // simply copy them (in reversed order).\n              if (unused_last_part_bits == 0) {\n                DCHECK(kDigitBits % char_bits == 0);\n                while (part_index >= 0) {\n                  Z[z_index++] = parts[part_index--];\n                }\n                for (; z_index < Z.len(); z_index++) Z[z_index] = 0;\n                return;\n              }\n\n              // Otherwise we have to shift parts contents around as needed.\n              // Holds the next Z digit that we want to store...\n              digit_t digit = parts[part_index--];\n              // ...and the number of bits (at the right end) we already know.\n              int digit_bits = kDigitBits - unused_last_part_bits;\n              while (part_index >= 0) {\n                // Holds the last part that we read from {parts}...\n                digit_t part;\n                // ...and the number of bits (at the right end) that we haven't used yet.\n                int part_bits;\n                while (digit_bits < kDigitBits) {\n                  part = parts[part_index--];\n                  part_bits = max_part_bits;\n                  digit |= part << digit_bits;\n                  int part_shift = kDigitBits - digit_bits;\n                  if (part_shift > part_bits) {\n                    digit_bits += part_bits;\n                    part = 0;\n                    part_bits = 0;\n                    if (part_index < 0) break;\n                  } else {\n                    digit_bits = kDigitBits;\n                    part >>= part_shift;\n                    part_bits -= part_shift;\n                  }\n                }\n                Z[z_index++] = digit;\n                digit = part;\n                digit_bits = part_bits;\n              }\n              if (digit_bits > 0) {\n                Z[z_index++] = digit;\n              }\n              for (; z_index < Z.len(); z_index++) Z[z_index] = 0;\n            }\n\n            void ProcessorImpl::FromString(RWDigits Z, FromStringAccumulator* accumulator) {\n              if (accumulator->inline_everything_) {\n                int i = 0;\n                for (; i < accumulator->stack_parts_used_; i++) {\n                  Z[i] = accumulator->stack_parts_[i];\n                }\n                for (; i < Z.len(); i++) Z[i] = 0;\n              } else if (accumulator->stack_parts_used_ == 0) {\n                for (int i = 0; i < Z.len(); i++) Z[i] = 0;\n              } else if (IsPowerOfTwo(accumulator->radix_)) {\n                FromStringBasePowerOfTwo(Z, accumulator);\n              } else if (accumulator->ResultLength() < kFromStringLargeThreshold) {\n                FromStringClassic(Z, accumulator);\n              } else {\n                FromStringLarge(Z, accumulator);\n              }\n            }\n\n            }  // namespace bigint\n            }  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FromStringClassic\",\n                \"parent\": \"ProcessorImpl\",\n                \"about\": \"Implements the classic algorithm for string to BigInt conversion.\",\n                \"logic\": \"Iterates through parts, multiplying the accumulator and adding the current part.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination BigInt digits\"\n                    },\n                    {\n                        \"name\": \"accumulator\",\n                        \"type\": \"FromStringAccumulator*\",\n                        \"purpose\": \"The accumulator containing the parts and multipliers\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"MultiplySingle\",\n                    \"Add\",\n                    \"RWDigits\",\n                    \"FromStringAccumulator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::FromStringClassic(RWDigits Z,\n                                                  FromStringAccumulator* accumulator) {\n              // We always have at least one part to process.\n              DCHECK(accumulator->stack_parts_used_ > 0);\n              Z[0] = accumulator->stack_parts_[0];\n              RWDigits already_set(Z, 0, 1);\n              for (int i = 1; i < Z.len(); i++) Z[i] = 0;\n\n              // The {FromStringAccumulator} uses stack-allocated storage for the first\n              // few parts; if heap storage is used at all then all parts are copied there.\n              int num_stack_parts = accumulator->stack_parts_used_;\n              if (num_stack_parts == 1) return;\n              const std::vector<digit_t>& heap_parts = accumulator->heap_parts_;\n              int num_heap_parts = static_cast<int>(heap_parts.size());\n              // All multipliers are the same, except possibly for the last.\n              const digit_t max_multiplier = accumulator->max_multiplier_;\n\n              if (num_heap_parts == 0) {\n                for (int i = 1; i < num_stack_parts - 1; i++) {\n                  MultiplySingle(Z, already_set, max_multiplier);\n                  Add(Z, accumulator->stack_parts_[i]);\n                  already_set.set_len(already_set.len() + 1);\n                }\n                MultiplySingle(Z, already_set, accumulator->last_multiplier_);\n                Add(Z, accumulator->stack_parts_[num_stack_parts - 1]);\n                return;\n              }\n              // Parts are stored on the heap.\n              for (int i = 1; i < num_heap_parts - 1; i++) {\n                MultiplySingle(Z, already_set, max_multiplier);\n                Add(Z, accumulator->heap_parts_[i]);\n                already_set.set_len(already_set.len() + 1);\n              }\n              MultiplySingle(Z, already_set, accumulator->last_multiplier_);\n              Add(Z, accumulator->heap_parts_.back());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FromStringLarge\",\n                \"parent\": \"ProcessorImpl\",\n                \"about\": \"Implements the fast algorithm for string to BigInt conversion.\",\n                \"logic\": \"Combines parts in a balanced binary tree order, multiplying and adding neighboring pairs.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination BigInt digits\"\n                    },\n                    {\n                        \"name\": \"accumulator\",\n                        \"type\": \"FromStringAccumulator*\",\n                        \"purpose\": \"The accumulator containing the parts and multipliers\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Storage\",\n                    \"Multiply\",\n                    \"AddAndReturnOverflow\",\n                    \"should_terminate\",\n                    \"Compare\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::FromStringLarge(RWDigits Z,\n                                                FromStringAccumulator* accumulator) {\n              int num_parts = static_cast<int>(accumulator->heap_parts_.size());\n              DCHECK(num_parts >= 2);\n              DCHECK(Z.len() >= num_parts);\n              RWDigits parts(accumulator->heap_parts_.data(), num_parts);\n              Storage multipliers_storage(num_parts);\n              RWDigits multipliers(multipliers_storage.get(), num_parts);\n              RWDigits temp(Z, 0, num_parts);\n              // Unrolled and specialized first iteration: part_len == 1, so instead of\n              // Digits sub-vectors we have individual digit_t values, and the multipliers\n              // are known up front.\n              {\n                digit_t max_multiplier = accumulator->max_multiplier_;\n                digit_t last_multiplier = accumulator->last_multiplier_;\n                RWDigits new_parts = temp;\n                RWDigits new_multipliers = parts;\n                int i = 0;\n                for (; i + 1 < num_parts; i += 2) {\n                  digit_t p_in = parts[i];\n                  digit_t p_in2 = parts[i + 1];\n                  digit_t m_in = max_multiplier;\n                  digit_t m_in2 = i == num_parts - 2 ? last_multiplier : max_multiplier;\n                  // p[j] = p[i] * m[i+1] + p[i+1]\n                  digit_t p_high;\n                  digit_t p_low = digit_mul(p_in, m_in2, &p_high);\n                  digit_t carry;\n                  new_parts[i] = digit_add2(p_low, p_in2, &carry);\n                  new_parts[i + 1] = p_high + carry;\n                  // m[j] = m[i] * m[i+1]\n                  if (i > 0) {\n                    if (i > 2 && m_in2 != last_multiplier) {\n                      new_multipliers[i] = new_multipliers[i - 2];\n                      new_multipliers[i + 1] = new_multipliers[i - 1];\n                    } else {\n                      digit_t m_high;\n                      new_multipliers[i] = digit_mul(m_in, m_in2, &m_high);\n                      new_multipliers[i + 1] = m_high;\n                    }\n                  }\n                }\n                // Trailing last part (if {num_parts} was odd).\n                if (i < num_parts) {\n                  new_parts[i] = parts[i];\n                  new_multipliers[i] = last_multiplier;\n                  i += 2;\n                }\n                num_parts = i >> 1;\n                RWDigits new_temp = multipliers;\n                parts = new_parts;\n                multipliers = new_multipliers;\n                temp = new_temp;\n                AddWorkEstimate(num_parts);\n              }\n              int part_len = 2;\n\n              // Remaining iterations.\n              while (num_parts > 1) {\n                RWDigits new_parts = temp;\n                RWDigits new_multipliers = parts;\n                int new_part_len = part_len * 2;\n                int i = 0;\n                for (; i + 1 < num_parts; i += 2) {\n                  int start = i * part_len;\n                  Digits p_in(parts, start, part_len);\n                  Digits p_in2(parts, start + part_len, part_len);\n                  Digits m_in(multipliers, start, part_len);\n                  Digits m_in2(multipliers, start + part_len, part_len);\n                  RWDigits p_out(new_parts, start, new_part_len);\n                  RWDigits m_out(new_multipliers, start, new_part_len);\n                  // p[j] = p[i] * m[i+1] + p[i+1]\n                  Multiply(p_out, p_in, m_in2);\n                  if (should_terminate()) return;\n                  digit_t overflow = AddAndReturnOverflow(p_out, p_in2);\n                  DCHECK(overflow == 0);\n                  USE(overflow);\n                  // m[j] = m[i] * m[i+1]\n                  if (i > 0) {\n                    bool copied = false;\n                    if (i > 2) {\n                      int prev_start = (i - 2) * part_len;\n                      Digits m_in_prev(multipliers, prev_start, part_len);\n                      Digits m_in2_prev(multipliers, prev_start + part_len, part_len);\n                      if (Compare(m_in, m_in_prev) == 0 &&\n                          Compare(m_in2, m_in2_prev) == 0) {\n                        copied = true;\n                        Digits m_out_prev(new_multipliers, prev_start, new_part_len);\n                        for (int k = 0; k < new_part_len; k++) m_out[k] = m_out_prev[k];\n                      }\n                    }\n                    if (!copied) {\n                      Multiply(m_out, m_in, m_in2);\n                      if (should_terminate()) return;\n                    }\n                  }\n                }\n                // Trailing last part (if {num_parts} was odd).\n                if (i < num_parts) {\n                  Digits p_in(parts, i * part_len, part_len);\n                  Digits m_in(multipliers, i * part_len, part_len);\n                  RWDigits p_out(new_parts, i * part_len, new_part_len);\n                  RWDigits m_out(new_multipliers, i * part_len, new_part_len);\n                  int k = 0;\n                  for (; k < p_in.len(); k++) p_out[k] = p_in[k];\n                  for (; k < p_out.len(); k++) p_out[k] = 0;\n                  k = 0;\n                  for (; k < m_in.len(); k++) m_out[k] = m_in[k];\n                  for (; k < m_out.len(); k++) m_out[k] = 0;\n                  i += 2;\n                }\n                num_parts = i >> 1;\n                part_len = new_part_len;\n                RWDigits new_temp = multipliers;\n                parts = new_parts;\n                multipliers = new_multipliers;\n                temp = new_temp;\n              }\n              // Copy the result to Z, if it doesn't happen to be there already.\n              if (parts.digits() != Z.digits()) {\n                int i = 0;\n                for (; i < parts.len(); i++) Z[i] = parts[i];\n                // Z might be bigger than we requested; be robust towards that.\n                for (; i < Z.len(); i++) Z[i] = 0;\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FromStringBasePowerOfTwo\",\n                \"parent\": \"ProcessorImpl\",\n                \"about\": \"Specialized algorithm for power-of-two radixes.\",\n                \"logic\": \"Combines parts based on radix, handling bit shifts.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination BigInt digits\"\n                    },\n                    {\n                        \"name\": \"accumulator\",\n                        \"type\": \"FromStringAccumulator*\",\n                        \"purpose\": \"The accumulator containing the parts and multipliers\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\",\n                    \"BitLength\",\n                    \"IsPowerOfTwo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::FromStringBasePowerOfTwo(\n                RWDigits Z, FromStringAccumulator* accumulator) {\n              const int num_parts = accumulator->ResultLength();\n              DCHECK(num_parts >= 1);\n              DCHECK(Z.len() >= num_parts);\n              Digits parts(accumulator->heap_parts_.empty()\n                               ? accumulator->stack_parts_\n                               : accumulator->heap_parts_.data(),\n                           num_parts);\n              uint8_t radix = accumulator->radix_;\n              DCHECK(radix == 2 || radix == 4 || radix == 8 || radix == 16 || radix == 32);\n              const int char_bits = BitLength(radix - 1);\n              const int unused_last_part_bits =\n                  static_cast<int>(accumulator->last_multiplier_);\n              const int unused_part_bits = kDigitBits % char_bits;\n              const int max_part_bits = kDigitBits - unused_part_bits;\n              int z_index = 0;\n              int part_index = num_parts - 1;\n\n              // If the last part is fully populated, then all parts must be, and we can\n              // simply copy them (in reversed order).\n              if (unused_last_part_bits == 0) {\n                DCHECK(kDigitBits % char_bits == 0);\n                while (part_index >= 0) {\n                  Z[z_index++] = parts[part_index--];\n                }\n                for (; z_index < Z.len(); z_index++) Z[z_index] = 0;\n                return;\n              }\n\n              // Otherwise we have to shift parts contents around as needed.\n              // Holds the next Z digit that we want to store...\n              digit_t digit = parts[part_index--];\n              // ...and the number of bits (at the right end) we already know.\n              int digit_bits = kDigitBits - unused_last_part_bits;\n              while (part_index >= 0) {\n                // Holds the last part that we read from {parts}...\n                digit_t part;\n                // ...and the number of bits (at the right end) that we haven't used yet.\n                int part_bits;\n                while (digit_bits < kDigitBits) {\n                  part = parts[part_index--];\n                  part_bits = max_part_"
}