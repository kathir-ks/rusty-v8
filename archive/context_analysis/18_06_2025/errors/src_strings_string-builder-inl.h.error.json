{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/strings/string-builder-inl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 235, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/strings/string-builder-inl.h\",\n            \"file_name\": \"string-builder-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Inline implementations for the StringBuilder classes, providing efficient string concatenation capabilities.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for isolate management, handle management, string objects, and the string builder class definition.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/isolate.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/objects/string-inl.h\"\n#include \"src/strings/string-builder.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReplacementStringBuilder\",\n                \"about\": \"Helper class for building strings by replacing substrings of a source string.  It uses a FixedArrayBuilder to store the encoded slices.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"FixedArrayBuilder\",\n                    \"Smi\",\n                    \"StringBuilderSubstringLength\",\n                    \"StringBuilderSubstringPosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\ninline void ReplacementStringBuilder::AddSubjectSlice(\n    FixedArrayBuilder* builder, int from, int to) {\n  DCHECK_GE(from, 0);\n  int length = to - from;\n  DCHECK_GT(length, 0);\n  if (StringBuilderSubstringLength::is_valid(length) &&\n      StringBuilderSubstringPosition::is_valid(from)) {\n    int encoded_slice = StringBuilderSubstringLength::encode(length) |\n                        StringBuilderSubstringPosition::encode(from);\n    builder->Add(Smi::FromInt(encoded_slice));\n  } else {\n    // Otherwise encode as two smis.\n    builder->Add(Smi::FromInt(-length));\n    builder->Add(Smi::FromInt(from));\n  }\n}\n\ninline void ReplacementStringBuilder::AddSubjectSlice(int from, int to) {\n  EnsureCapacity(2);  // Subject slices are encoded with up to two smis.\n  AddSubjectSlice(&array_builder_, from, to);\n  IncrementCharacterCount(to - from);\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IncrementalStringBuilder\",\n                \"about\": \"Helper class for incrementally building strings. Appends characters and strings to a sequence of SeqStrings.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"SeqOneByteString\",\n                    \"SeqTwoByteString\",\n                    \"SeqString\",\n                    \"Factory\",\n                    \"std::string_view\",\n                    \"IntToStringView\",\n                    \"indirect_handle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename SrcChar, typename DestChar>\nvoid IncrementalStringBuilder::Append(SrcChar c) {\n  DCHECK_EQ(encoding_ == String::ONE_BYTE_ENCODING, sizeof(DestChar) == 1);\n  if (sizeof(DestChar) == 1) {\n    DCHECK_EQ(String::ONE_BYTE_ENCODING, encoding_);\n    Cast<SeqOneByteString>(*current_part_)\n        ->SeqOneByteStringSet(current_index_++, c);\n  } else {\n    DCHECK_EQ(String::TWO_BYTE_ENCODING, encoding_);\n    Cast<SeqTwoByteString>(*current_part_)\n        ->SeqTwoByteStringSet(current_index_++, c);\n  }\n  if (current_index_ == part_length_) Extend();\n  DCHECK(HasValidCurrentIndex());\n}\n\nV8_INLINE void IncrementalStringBuilder::AppendCharacter(uint8_t c) {\n  if (encoding_ == String::ONE_BYTE_ENCODING) {\n    Append<uint8_t, uint8_t>(c);\n  } else {\n    Append<uint8_t, base::uc16>(c);\n  }\n}\n\ntemplate <int N>\nV8_INLINE void IncrementalStringBuilder::AppendCStringLiteral(\n    const char (&literal)[N]) {\n  // Note that the literal contains the zero char.\n  const int length = N - 1;\n  static_assert(length > 0);\n  if (length == 1) return AppendCharacter(literal[0]);\n  if (encoding_ == String::ONE_BYTE_ENCODING && CurrentPartCanFit(N)) {\n    const uint8_t* chars = reinterpret_cast<const uint8_t*>(literal);\n    Cast<SeqOneByteString>(*current_part_)\n        ->SeqOneByteStringSetChars(current_index_, chars, length);\n    current_index_ += length;\n    if (current_index_ == part_length_) Extend();\n    DCHECK(HasValidCurrentIndex());\n    return;\n  }\n  return AppendCString(literal);\n}\n\ntemplate <typename SrcChar>\nV8_INLINE void IncrementalStringBuilder::AppendCString(const SrcChar* s) {\n  if (encoding_ == String::ONE_BYTE_ENCODING) {\n    while (*s != '\\0') Append<SrcChar, uint8_t>(*s++);\n  } else {\n    while (*s != '\\0') Append<SrcChar, base::uc16>(*s++);\n  }\n}\n\nV8_INLINE void IncrementalStringBuilder::AppendString(std::string_view str) {\n  uint32_t length = static_cast<uint32_t>(str.length());\n  if (encoding_ == String::ONE_BYTE_ENCODING && CurrentPartCanFit(length)) {\n    Cast<SeqOneByteString>(*current_part_)\n        ->SeqOneByteStringSetChars(current_index_,\n                                   reinterpret_cast<const uint8_t*>(str.data()),\n                                   length);\n    current_index_ += str.length();\n    if (current_index_ == part_length_) Extend();\n    DCHECK(HasValidCurrentIndex());\n  } else {\n    for (size_t i = 0; i < str.length(); i++) {\n      AppendCharacter(str[i]);\n    }\n  }\n}\n\nV8_INLINE void IncrementalStringBuilder::AppendInt(int i) {\n  char buffer[kIntToStringViewBufferSize];\n  std::string_view str = IntToStringView(i, base::ArrayVector(buffer));\n  AppendString(str);\n}\n\nV8_INLINE int IncrementalStringBuilder::EscapedLengthIfCurrentPartFits(\n    int length) {\n  if (length > kMaxPartLength) return 0;\n  // The worst case length of an escaped character is 6. Shifting the remaining\n  // string length right by 3 is a more pessimistic estimate, but faster to\n  // calculate.\n  static_assert((kMaxPartLength << 3) <= String::kMaxLength);\n  // This shift will not overflow because length is already less than the\n  // maximum part length.\n  int worst_case_length = length << 3;\n  return CurrentPartCanFit(worst_case_length) ? worst_case_length : 0;\n}\n\n// Change encoding to two-byte.\nvoid IncrementalStringBuilder::ChangeEncoding() {\n  DCHECK_EQ(String::ONE_BYTE_ENCODING, encoding_);\n  ShrinkCurrentPart();\n  encoding_ = String::TWO_BYTE_ENCODING;\n  Extend();\n}\n\nV8_INLINE Factory* IncrementalStringBuilder::factory() {\n  return isolate_->factory();\n}\n\nV8_INLINE void IncrementalStringBuilder::ShrinkCurrentPart() {\n  DCHECK(current_index_ < part_length_);\n  set_current_part(SeqString::Truncate(\n      isolate_, indirect_handle(Cast<SeqString>(current_part()), isolate_),\n      current_index_));\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StringBuilderConcatHelper\",\n                \"about\": \"Helper function for string concatenation, used with StringBuilders.  Generic over character type.\",\n                \"logic\": \"Concatenates substrings represented by a FixedArray into a destination buffer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"special\",\n                        \"type\": \"Tagged<String>\",\n                        \"purpose\": \"A special string, likely a prefix or suffix.\"\n                    },\n                    {\n                        \"name\": \"sink\",\n                        \"type\": \"sinkchar*\",\n                        \"purpose\": \"Pointer to the destination buffer.\"\n                    },\n                    {\n                        \"name\": \"fixed_array\",\n                        \"type\": \"Tagged<FixedArray>\",\n                        \"purpose\": \"Array containing substring information.\"\n                    },\n                    {\n                        \"name\": \"array_length\",\n                        \"type\": \"int\",\n                        \"purpose\": \"Length of the FixedArray to process.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"String\",\n                    \"FixedArray\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename sinkchar>\nvoid StringBuilderConcatHelper(Tagged<String> special, sinkchar* sink,\n                               Tagged<FixedArray> fixed_array,\n                               int array_length);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StringBuilderConcatLength\",\n                \"about\": \"Calculates the resulting length of a StringBuilder concatenation operation.\",\n                \"logic\": \"Determines the length of the concatenated string based on the special string length, the fixed array, and the array length. Detects if the result can be represented as a one-byte string.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"special_length\",\n                        \"type\": \"int\",\n                        \"purpose\": \"Length of a special string.\"\n                    },\n                    {\n                        \"name\": \"fixed_array\",\n                        \"type\": \"Tagged<FixedArray>\",\n                        \"purpose\": \"FixedArray containing substring information.\"\n                    },\n                    {\n                        \"name\": \"array_length\",\n                        \"type\": \"int\",\n                        \"purpose\": \"Length of the FixedArray.\"\n                    },\n                    {\n                        \"name\": \"one_byte\",\n                        \"type\": \"bool*\",\n                        \"purpose\": \"Pointer to a boolean indicating whether the resulting string is one-byte.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The length of the resulting concatenated string, or -1 on illegal arguments.\"\n                },\n                \"dependencies\": [\n                    \"FixedArray\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nint StringBuilderConcatLength(int special_length,\n                              Tagged<FixedArray> fixed_array, int array_length,\n                              bool* one_byte);\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"FixedArrayBuilder\",\n                    \"about\": \"Dynamically builds a fixed array of Smis.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class FixedArrayBuilder {\n                public:\n                    void Add(Tagged<Smi> element);\n                    void EnsureCapacity(int size);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SeqOneByteString\",\n                    \"about\": \"A string object that stores characters as one byte.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class SeqOneByteString {\n                public:\n                    void SeqOneByteStringSet(int index, uint8_t c);\n                    void SeqOneByteStringSetChars(int index, const uint8_t* chars, int length);\n                    static Tagged<SeqString> Truncate(Isolate* isolate, const indirect_handle<SeqString>& str, int length);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SeqTwoByteString\",\n                    \"about\": \"A string object that stores characters as two bytes.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class SeqTwoByteString {\n                public:\n                    void SeqTwoByteStringSet(int index, base::uc16 c);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SeqString\",\n                    \"about\": \"Base class for sequential strings.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class SeqString : public String {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"String\",\n                    \"about\": \"Base string class.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class String {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Smi\",\n                    \"about\": \"Small integer class.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Smi {};\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <interface>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"interface\",\n                \"name\": \"StringBuilderSubstringLength\",\n                \"about\": \"Provides encoding and validation for substring lengths within the string builder.\",\n                \"methods\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing StringBuilderSubstringLength =\n    base::BitField<int, 0, kStringBuilderConcatHelperLengthBits>;\n        ]]></code>\n    </interface>\n\n    <interface>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"interface\",\n                \"name\": \"StringBuilderSubstringPosition\",\n                \"about\": \"Provides encoding and validation for substring positions within the string builder.\",\n                \"methods\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing StringBuilderSubstringPosition =\n    base::BitField<int, kStringBuilderConcatHelperLengthBits,\n                   kStringBuilderConcatHelperPositionBits>;\n        ]]></code>\n    </interface>\n\n    <constants>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constant\",\n                \"name\": \"kStringBuilderConcatHelperLengthBits\",\n                \"about\": \"Number of bits used to encode the substring length in the StringBuilder's helper data structure\",\n                \"value\": \"11\"\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kStringBuilderConcatHelperLengthBits = 11;\n        ]]></code>\n    </constants>\n\n    <constants>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constant\",\n                \"name\": \"kStringBuilderConcatHelperPositionBits\",\n                \"about\": \"Number of bits used to encode the substring position in the StringBuilder's helper data structure\",\n                \"value\": \"19\"\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kStringBuilderConcatHelperPositionBits = 19;\n        ]]></code>\n    </constants>\n</file>\n```"
}