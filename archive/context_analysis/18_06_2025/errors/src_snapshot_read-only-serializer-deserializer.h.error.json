{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/read-only-serializer-deserializer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 56, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/read-only-serializer-deserializer.h\",\n        \"file_name\": \"read-only-serializer-deserializer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines common functionality for read-only space serialization and deserialization in V8 snapshot mechanism.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes global definitions for V8, such as common types and macros.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BitSet\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents a bitset with a known underlying encoding, similar to std::vector<bool>.\",\n            \"attributes\": [\n                {\n                    \"name\": \"size_in_bits_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the number of bits in the bitset.\"\n                },\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"uint8_t*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the underlying data buffer storing the bits.\"\n                },\n                {\n                    \"name\": \"owns_data_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the BitSet object owns the data buffer.  Used for memory management in the destructor.\"\n                }\n            ],\n            \"dependencies\": [\n                \"kBitsPerByte\",\n                \"kUInt8Size\",\n                \"RoundUp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass BitSet final {\n public:\n  explicit BitSet(size_t size_in_bits)\n      : size_in_bits_(size_in_bits),\n        data_(new uint8_t[size_in_bytes()]()),\n        owns_data_(true) {}\n\n  explicit BitSet(uint8_t* data, size_t size_in_bits)\n      : size_in_bits_(size_in_bits), data_(data), owns_data_(false) {}\n\n  ~BitSet() {\n    if (owns_data_) delete[] data_;\n  }\n\n  bool contains(int i) const {\n    DCHECK(0 <= i && i < static_cast<int>(size_in_bits_));\n    return (data_[chunk_index(i)] & bit_mask(i)) != 0;\n  }\n\n  void set(int i) {\n    DCHECK(0 <= i && i < static_cast<int>(size_in_bits_));\n    data_[chunk_index(i)] |= bit_mask(i);\n  }\n\n  size_t size_in_bits() const { return size_in_bits_; }\n  size_t size_in_bytes() const {\n    return RoundUp<kBitsPerByte>(size_in_bits_) / kBitsPerByte;\n  }\n\n  const uint8_t* data() const { return data_; }\n\n private:\n  static constexpr int kBitsPerChunk = kUInt8Size * kBitsPerByte;\n  static constexpr int chunk_index(int i) { return i / kBitsPerChunk; }\n  static constexpr int bit_index(int i) { return i % kBitsPerChunk; }\n  static constexpr uint32_t bit_mask(int i) { return 1 << bit_index(i); }\n\n  const size_t size_in_bits_;\n  uint8_t* const data_;\n  const bool owns_data_;\n};\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"EncodedTagged\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents an encoded tagged slot containing page index and offset for relocation purposes.\",\n            \"attributes\": [\n                {\n                    \"name\": \"page_index\",\n                    \"type\": \"unsigned int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Index of the page where the tagged slot resides.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"unsigned int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Offset within the page where the tagged slot is located.\"\n                }\n            ],\n            \"dependencies\": [\n                \"kPageSizeBits\",\n                \"kUInt32Size\",\n                \"kTaggedSizeLog2\",\n                \"Address\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct EncodedTagged {\n  static constexpr int kOffsetBits = kPageSizeBits;\n  static constexpr int kSize = kUInt32Size;\n  static constexpr int kPageIndexBits =\n      kSize * 8 - kOffsetBits;  // Determines max number of RO pages.\n\n  explicit EncodedTagged(unsigned int page_index, unsigned int offset)\n      : page_index(page_index), offset(offset) {\n    DCHECK_LT(page_index, 1UL << kPageIndexBits);\n    DCHECK_LT(offset, 1UL << kOffsetBits);\n  }\n\n  uint32_t ToUint32() const {\n    static_assert(kSize == kUInt32Size);\n    return *reinterpret_cast<const uint32_t*>(this);\n  }\n  static EncodedTagged FromUint32(uint32_t v) {\n    return FromAddress(reinterpret_cast<Address>(&v));\n  }\n  static EncodedTagged FromAddress(Address address) {\n    return *reinterpret_cast<EncodedTagged*>(address);\n  }\n\n  const unsigned int page_index : kPageIndexBits;\n  const unsigned int offset : kOffsetBits;  // Shifted by kTaggedSizeLog2.\n};\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"EncodedExternalReference\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents an encoded external reference, used to identify API or internal references during deserialization.\",\n            \"attributes\": [\n                {\n                    \"name\": \"is_api_reference\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Flag indicating whether the reference is an API reference.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Index of the external reference.\"\n                }\n            ],\n            \"dependencies\": [\n                \"kUInt32Size\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct EncodedExternalReference {\n  static constexpr int kIsApiReferenceBits = 1;\n  static constexpr int kIndexBits = 31;\n  static constexpr int kSize = kUInt32Size;\n\n  uint32_t ToUint32() const {\n    static_assert(kSize == kUInt32Size);\n    return *reinterpret_cast<const uint32_t*>(this);\n  }\n  static EncodedExternalReference FromUint32(uint32_t v) {\n    return *reinterpret_cast<EncodedExternalReference*>(&v);\n  }\n\n  // This ctor is needed to convert parameter types. We can't use bool/uint32_t\n  // as underlying member types since that messes with field packing on\n  // windows.\n  EncodedExternalReference(bool is_api_reference, uint32_t index)\n      : is_api_reference(is_api_reference), index(index) {}\n\n  int is_api_reference : kIsApiReferenceBits;\n  int index : kIndexBits;\n};\n        ]]></code>\n    </struct>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"Bytecode\",\n            \"about\": \"Defines the bytecode instructions used during read-only space serialization and deserialization.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nenum Bytecode {\n  // kAllocatePage parameters:\n  //   Uint30 page_index\n  //   Uint30 area_size_in_bytes\n  kAllocatePage,\n  // kAllocatePageAt parameters:\n  //   Uint30 page_index\n  //   Uint30 area_size_in_bytes\n  //   Uint32 compressed_page_address\n  kAllocatePageAt,\n  //\n  // kSegment parameters:\n  //   Uint30 page_index\n  //   Uint30 offset\n  //   Uint30 size_in_bytes\n  //   ... segment byte stream\n  kSegment,\n  //\n  // kRelocateSegment parameters:\n  //   ... relocation byte stream\n  kRelocateSegment,\n  //\n  // kReadOnlyRootsTable parameters:\n  //   IF_STATIC_ROOTS(... ro roots table slots)\n  kReadOnlyRootsTable,\n  //\n  kFinalizeReadOnlySpace,\n};\n        ]]></code>\n    </enum>\n    <variable>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constexpr int\",\n            \"name\": \"kNumberOfBytecodes\",\n            \"about\": \"Defines the total number of bytecodes in the Bytecode enum.\",\n            \"dependencies\": [\n                \"kFinalizeReadOnlySpace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic constexpr int kNumberOfBytecodes =\n    static_cast<int>(kFinalizeReadOnlySpace) + 1;\n        ]]></code>\n    </variable>\n</file>\n```"
}