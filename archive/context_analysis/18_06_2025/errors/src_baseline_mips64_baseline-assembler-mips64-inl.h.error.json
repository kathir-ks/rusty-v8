{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/mips64/baseline-assembler-mips64-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/mips64/baseline-assembler-mips64-inl.h\",\n            \"file_name\": \"baseline-assembler-mips64-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"This header file provides inline implementations for the BaselineAssembler class on the MIPS64 architecture. It defines helper functions and macros for generating MIPS64 assembly code within the baseline compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for baseline compilation, code generation interfaces, MIPS64 assembler, and literal objects.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/baseline/baseline-assembler.h\"\n            #include \"src/codegen/interface-descriptors.h\"\n            #include \"src/codegen/mips64/assembler-mips64-inl.h\"\n            #include \"src/objects/literal-objects-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BaselineAssembler::ScratchRegisterScope\",\n                \"about\": \"Manages a scope for acquiring and releasing scratch registers within the BaselineAssembler.  It ensures that registers are available for temporary use during code generation and are properly released when the scope is exited.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"assembler_\",\n                        \"type\": \"BaselineAssembler*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the associated BaselineAssembler instance.\"\n                    },\n                    {\n                        \"name\": \"prev_scope_\",\n                        \"type\": \"ScratchRegisterScope*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous ScratchRegisterScope in a stack, allowing for nested scopes.\"\n                    },\n                    {\n                        \"name\": \"wrapped_scope_\",\n                        \"type\": \"UseScratchRegisterScope\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An instance of UseScratchRegisterScope, which provides the actual register acquisition and release mechanism.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BaselineAssembler\",\n                    \"UseScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class BaselineAssembler::ScratchRegisterScope {\n            public:\n              explicit ScratchRegisterScope(BaselineAssembler* assembler)\n                  : assembler_(assembler),\n                    prev_scope_(assembler->scratch_register_scope_),\n                    wrapped_scope_(assembler->masm()) {\n                if (!assembler_->scratch_register_scope_) {\n                  // If we haven't opened a scratch scope yet, for the first one add a\n                  // couple of extra registers.\n                  wrapped_scope_.Include({t0, t1, t2, t3});\n                }\n                assembler_->scratch_register_scope_ = this;\n              }\n              ~ScratchRegisterScope() { assembler_->scratch_register_scope_ = prev_scope_; }\n\n              Register AcquireScratch() { return wrapped_scope_.Acquire(); }\n\n             private:\n              BaselineAssembler* assembler_;\n              ScratchRegisterScope* prev_scope_;\n              UseScratchRegisterScope wrapped_scope_;\n            };\n        ]]></code>\n    </class>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"detail\",\n                \"about\": \"Contains internal helper functions for the BaselineAssembler, not intended for external use.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace detail {\n\n            #ifdef DEBUG\n            inline bool Clobbers(Register target, MemOperand op) {\n              return op.is_reg() && op.rm() == target;\n            }\n            #endif\n\n            }  // namespace detail\n        ]]></code>\n    </namespace>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RegisterFrameOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the memory operand for accessing an interpreter register within the current stack frame.\",\n                \"logic\": \"Calculates the offset of the register based on its index and the system pointer size, and returns a MemOperand representing that location.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interpreter_register\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The interpreter register to access.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"A memory operand representing the location of the register in the frame.\"\n                },\n                \"dependencies\": [\n                    \"interpreter::Register\",\n                    \"kSystemPointerSize\",\n                    \"fp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::RegisterFrameOperand(\n                interpreter::Register interpreter_register) {\n              return MemOperand(fp, interpreter_register.ToOperand() * kSystemPointerSize);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RegisterFrameAddress\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the memory address for accessing an interpreter register within the current stack frame.\",\n                \"logic\": \"Calculates the offset of the register based on its index and the system pointer size, and loads the address into rscratch.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interpreter_register\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The interpreter register to access.\"\n                    },\n                    {\n                         \"name\": \"rscratch\",\n                         \"type\": \"Register\",\n                         \"purpose\": \"A scratch register to hold address\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"interpreter::Register\",\n                    \"kSystemPointerSize\",\n                    \"fp\",\n                    \"Daddu\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::RegisterFrameAddress(\n                interpreter::Register interpreter_register, Register rscratch) {\n              return __ Daddu(rscratch, fp,\n                              interpreter_register.ToOperand() * kSystemPointerSize);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FeedbackVectorOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Returns a memory operand representing the location of the FeedbackVector in the frame.\",\n                \"logic\": \"Uses the BaselineFrameConstants::kFeedbackVectorFromFp offset from the frame pointer.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"A memory operand representing the FeedbackVector's location.\"\n                },\n                \"dependencies\": [\n                    \"BaselineFrameConstants::kFeedbackVectorFromFp\",\n                    \"fp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::FeedbackVectorOperand() {\n              return MemOperand(fp, BaselineFrameConstants::kFeedbackVectorFromFp);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FeedbackCellOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Returns a memory operand representing the location of the FeedbackCell in the frame.\",\n                \"logic\": \"Uses the BaselineFrameConstants::kFeedbackCellFromFp offset from the frame pointer.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"A memory operand representing the FeedbackCell's location.\"\n                },\n                \"dependencies\": [\n                    \"BaselineFrameConstants::kFeedbackCellFromFp\",\n                    \"fp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::FeedbackCellOperand() {\n              return MemOperand(fp, BaselineFrameConstants::kFeedbackCellFromFp);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Bind\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Binds a label to the current code generation position.\",\n                \"logic\": \"Calls the underlying assembler's bind function.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"label\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to bind.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"bind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::Bind(Label* label) { __ bind(label); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpTarget\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Indicates a potential jump target. Currently a no-op.\",\n                \"logic\": \"Does nothing.  It might be used for padding or other architecture-specific adjustments in the future.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpTarget() {\n              // NOP.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Jump\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Unconditionally jumps to the specified target label.\",\n                \"logic\": \"Calls the underlying assembler's Branch function.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Branch\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::Jump(Label* target, Label::Distance distance) {\n              __ Branch(target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfRoot\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the register value is equal to a root value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare with the root value.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The index of the root value in the root array.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Delegates the actual jump to the underlying assembler's JumpIfRoot method.\",\n                \"dependencies\": [\n                    \"JumpIfRoot\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfRoot(Register value, RootIndex index,\n                                               Label* target, Label::Distance) {\n              __ JumpIfRoot(value, index, target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfNotRoot\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the register value is not equal to a root value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare with the root value.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The index of the root value in the root array.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label (e.g., kNear, kFar).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Delegates the actual jump to the underlying assembler's JumpIfNotRoot method.\",\n                \"dependencies\": [\n                    \"JumpIfNotRoot\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfNotRoot(Register value, RootIndex index,\n                                                  Label* target, Label::Distance) {\n              __ JumpIfNotRoot(value, index, target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the register value is a Smi (Small Integer).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to check for being a Smi.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to if the value is a Smi.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Uses the underlying assembler's JumpIfSmi instruction.\",\n                \"dependencies\": [\n                    \"JumpIfSmi\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfSmi(Register value, Label* target,\n                                             Label::Distance) {\n              __ JumpIfSmi(value, target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfNotSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the register value is not a Smi (Small Integer).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to check for not being a Smi.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to if the value is not a Smi.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Uses the underlying assembler's JumpIfNotSmi instruction.\",\n                \"dependencies\": [\n                    \"JumpIfNotSmi\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,\n                                                  Label::Distance) {\n              __ JumpIfNotSmi(value, target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfImmediate\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the condition is met when comparing a register to an immediate value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                    },\n                    {\n                        \"name\": \"left\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare.\"\n                    },\n                    {\n                        \"name\": \"right\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The immediate value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Delegates to JumpIf with an immediate operand.\",\n                \"dependencies\": [\n                    \"JumpIf\",\n                    \"Operand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,\n                                                 Label* target,\n                                                 Label::Distance distance) {\n              JumpIf(cc, left, Operand(right), target, distance);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TestAndBranch\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Performs a bitwise AND operation and jumps based on the result.\",\n                \"logic\": \"Performs a bitwise AND between the register and the mask, and then jumps to the target label based on the specified condition applied to the result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to test.\"\n                    },\n                    {\n                        \"name\": \"mask\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The mask to apply.\"\n                    },\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check after the AND operation.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"And\",\n                    \"Branch\",\n                    \"Operand\",\n                    \"zero_reg\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::TestAndBranch(Register value, int mask, Condition cc,\n                                               Label* target, Label::Distance) {\n              ScratchRegisterScope temps(this);\n              Register scratch = temps.AcquireScratch();\n              __ And(scratch, value, Operand(mask));\n              __ Branch(target, cc, scratch, Operand(zero_reg));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIf\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the condition is met when comparing a register to an operand.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The left-hand side register to compare.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const Operand&\",\n                        \"purpose\": \"The right-hand side operand to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Uses the underlying assembler's Branch instruction with the given condition and operands.\",\n                \"dependencies\": [\n                    \"Branch\",\n                    \"Operand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIf(Condition cc, Register lhs, const Operand& rhs,\n                                        Label* target, Label::Distance) {\n              __ Branch(target, cc, lhs, Operand(rhs));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfObjectTypeFast\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the object's type matches the specified instance type. Uses a scratch register internally.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the object to check.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The instance type to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Acquires a scratch register and calls JumpIfObjectType to perform the actual comparison.\",\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"JumpIfObjectType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfObjectTypeFast(Condition cc, Register object,\n                                                  InstanceType instance_type,\n                                                  Label* target,\n                                                  Label::Distance distance) {\n              ScratchRegisterScope temps(this);\n              Register scratch = temps.AcquireScratch();\n              JumpIfObjectType(cc, object, instance_type, scratch, target, distance);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfObjectType\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the object's type matches the specified instance type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the object to check.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The instance type to compare against.\"\n                    },\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to store map of the object.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Acquires a scratch register, gets the object type, and then jumps based on the comparison.\",\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"GetObjectType\",\n                    \"Branch\",\n                    \"Operand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfObjectType(Condition cc, Register object,\n                                                  InstanceType instance_type,\n                                                  Register map, Label* target,\n                                                  Label::Distance) {\n              ScratchRegisterScope temps(this);\n              Register type = temps.AcquireScratch();\n              __ GetObjectType(object, map, type);\n              __ Branch(target, cc, type, Operand(instance_type));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfInstanceType\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the instance type of the object matches the specified instance type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the map of the object.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The instance type to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Acquires a scratch register, gets the object type, and then jumps based on the comparison.\",\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"GetObjectType\",\n                    \"Branch\",\n                    \"Operand\",\n                    \"FieldMemOperand\",\n                    \"Map::kInstanceTypeOffset\",\n                    \"v8_flags.debug_code\",\n                    \"AssertNotSmi\",\n                    \"Assert\",\n                    \"AbortReason::kUnexpectedValue\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfInstanceType(Condition cc, Register map,\n                                                    InstanceType instance_type,\n                                                    Label* target, Label::Distance) {\n              ScratchRegisterScope temps(this);\n              Register type = temps.AcquireScratch();\n              if (v8_flags.debug_code) {\n                __ AssertNotSmi(map);\n                __ GetObjectType(map, type, type);\n                __ Assert(eq, AbortReason::kUnexpectedValue, type, Operand(MAP_TYPE));\n              }\n              __ Ld(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n              __ Branch(target, cc, type, Operand(instance_type));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfPointer\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the value in the register is equal to the value at the memory operand.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare.\"\n                    },\n                    {\n                        \"name\": \"operand\",\n                        \"type\": \"MemOperand\",\n                        \"purpose\": \"The memory location to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Loads the value from the memory operand into a scratch register and then performs the comparison and jump.\",\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"Ld\",\n                    \"Branch\",\n                    \"Operand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfPointer(Condition cc, Register value,\n                                                MemOperand operand, Label* target,\n                                                Label::Distance) {\n              ScratchRegisterScope temps(this);\n              Register scratch = temps.AcquireScratch();\n              __ Ld(scratch, operand);\n              __ Branch(target, cc, value, Operand(scratch));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the register value is equal to a specific Smi.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare.\"\n                    },\n                    {\n                        \"name\": \"smi\",\n                        \"type\": \"Tagged<Smi>\",\n                        \"purpose\": \"The Smi value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"logic\": \"Loads the Smi value into a scratch register, untags it, and then performs the comparison and jump.\",\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"li\",\n                    \"Operand\",\n                    \"SmiUntag\",\n                    \"Branch\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfSmi(Condition cc, Register value, Tagged<Smi> smi,\n                                            Label* target, Label::Distance) {\n              ScratchRegisterScope temps(this);\n              Register scratch = temps.AcquireScratch();\n              __ li(scratch, Operand(smi));\n              __ SmiUntag(scratch);\n              __ Branch(target, cc, value, Operand(scratch));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Jumps to the target if the two registers both contain Smi values and the condition is met.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The left-hand side register to compare.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The right-hand side register to compare.\"\n"
}