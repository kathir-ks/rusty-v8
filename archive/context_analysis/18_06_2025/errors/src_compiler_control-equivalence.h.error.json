{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/control-equivalence.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/control-equivalence.h\",\n        \"file_name\": \"control-equivalence.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the ControlEquivalence class for determining control dependence equivalence classes for control nodes in a Turbofan graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for base types, compiler-specific features, global definitions, graph nodes, Turbofan graphs, and zone containers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/compiler-specific.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ControlEquivalence\",\n            \"extends\": \"ZoneObject\",\n            \"about\": \"Determines control dependence equivalence classes for control nodes in a Turbofan graph. It uses cycle equivalence to establish class numbers. Any two nodes are cycle equivalent if they occur in the same set of cycles.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Zone\",\n                \"TFGraph\",\n                \"Node\",\n                \"ZoneObject\",\n                \"ZoneLinkedList\",\n                \"ZoneStack\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE ControlEquivalence final\n    : public NON_EXPORTED_BASE(ZoneObject) {\n public:\n  ControlEquivalence(Zone* zone, TFGraph* graph)\n      : zone_(zone),\n        graph_(graph),\n        dfs_number_(0),\n        class_number_(1),\n        node_data_(graph->NodeCount(), zone) {}\n\n  // Run the main algorithm starting from the {exit} control node. This causes\n  // the following iterations over control edges of the graph:\n  //  1) A breadth-first backwards traversal to determine the set of nodes that\n  //     participate in the next step. Takes O(E) time and O(N) space.\n  //  2) An undirected depth-first backwards traversal that determines class\n  //     numbers for all participating nodes. Takes O(E) time and O(N) space.\n  void Run(Node* exit);\n\n  // Retrieves a previously computed class number.\n  size_t ClassOf(Node* node) {\n    DCHECK_NE(kInvalidClass, GetClass(node));\n    return GetClass(node);\n  }\n\n private:\n  static const size_t kInvalidClass = static_cast<size_t>(-1);\n  enum DFSDirection { kInputDirection, kUseDirection };\n\n  struct Bracket {\n    DFSDirection direction;  // Direction in which this bracket was added.\n    size_t recent_class;     // Cached class when bracket was topmost.\n    size_t recent_size;      // Cached set-size when bracket was topmost.\n    Node* from;              // Node that this bracket originates from.\n    Node* to;                // Node that this bracket points to.\n  };\n\n  // The set of brackets for each node during the DFS walk.\n  using BracketList = ZoneLinkedList<Bracket>;\n\n  struct DFSStackEntry {\n    DFSDirection direction;            // Direction currently used in DFS walk.\n    Node::InputEdges::iterator input;  // Iterator used for \"input\" direction.\n    Node::UseEdges::iterator use;      // Iterator used for \"use\" direction.\n    Node* parent_node;                 // Parent node of entry during DFS walk.\n    Node* node;                        // Node that this stack entry belongs to.\n  };\n\n  // The stack is used during the undirected DFS walk.\n  using DFSStack = ZoneStack<DFSStackEntry>;\n\n  struct NodeData : ZoneObject {\n    explicit NodeData(Zone* zone)\n        : class_number(kInvalidClass),\n          blist(BracketList(zone)),\n          visited(false),\n          on_stack(false) {}\n\n    size_t class_number;  // Equivalence class number assigned to node.\n    BracketList blist;    // List of brackets per node.\n    bool visited : 1;     // Indicates node has already been visited.\n    bool on_stack : 1;    // Indicates node is on DFS stack during walk.\n  };\n\n  // The per-node data computed during the DFS walk.\n  using Data = ZoneVector<NodeData*>;\n\n  // Called at pre-visit during DFS walk.\n  void VisitPre(Node* node);\n\n  // Called at mid-visit during DFS walk.\n  void VisitMid(Node* node, DFSDirection direction);\n\n  // Called at post-visit during DFS walk.\n  void VisitPost(Node* node, Node* parent_node, DFSDirection direction);\n\n  // Called when hitting a back edge in the DFS walk.\n  void VisitBackedge(Node* from, Node* to, DFSDirection direction);\n\n  // Performs and undirected DFS walk of the graph. Conceptually all nodes are\n  // expanded, splitting \"input\" and \"use\" out into separate nodes. During the\n  // traversal, edges towards the representative nodes are preferred.\n  //\n  //   \\ /        - Pre-visit: When N1 is visited in direction D the preferred\n  //    x   N1      edge towards N is taken next, calling VisitPre(N).\n  //    |         - Mid-visit: After all edges out of N2 in direction D have\n  //    |   N       been visited, we switch the direction and start considering\n  //    |           edges out of N1 now, and we call VisitMid(N).\n  //    x   N2    - Post-visit: After all edges out of N1 in direction opposite\n  //   / \\          to D have been visited, we pop N and call VisitPost(N).\n  //\n  // This will yield a true spanning tree (without cross or forward edges) and\n  // also discover proper back edges in both directions.\n  void RunUndirectedDFS(Node* exit);\n\n  void DetermineParticipationEnqueue(ZoneQueue<Node*>& queue, Node* node);\n  void DetermineParticipation(Node* exit);\n\n private:\n  NodeData* GetData(Node* node) {\n    size_t const index = node->id();\n    if (index >= node_data_.size()) node_data_.resize(index + 1);\n    return node_data_[index];\n  }\n  void AllocateData(Node* node) {\n    size_t const index = node->id();\n    if (index >= node_data_.size()) node_data_.resize(index + 1);\n    node_data_[index] = zone_->New<NodeData>(zone_);\n  }\n\n  int NewClassNumber() { return class_number_++; }\n  int NewDFSNumber() { return dfs_number_++; }\n\n  bool Participates(Node* node) { return GetData(node) != nullptr; }\n\n  // Accessors for the equivalence class stored within the per-node data.\n  size_t GetClass(Node* node) { return GetData(node)->class_number; }\n  void SetClass(Node* node, size_t number) {\n    DCHECK(Participates(node));\n    GetData(node)->class_number = number;\n  }\n\n  // Accessors for the bracket list stored within the per-node data.\n  BracketList& GetBracketList(Node* node) {\n    DCHECK(Participates(node));\n    return GetData(node)->blist;\n  }\n  void SetBracketList(Node* node, BracketList& list) {\n    DCHECK(Participates(node));\n    GetData(node)->blist = list;\n  }\n\n  // Mutates the DFS stack by pushing an entry.\n  void DFSPush(DFSStack& stack, Node* node, Node* from, DFSDirection dir);\n\n  // Mutates the DFS stack by popping an entry.\n  void DFSPop(DFSStack& stack, Node* node);\n\n  void BracketListDelete(BracketList& blist, Node* to, DFSDirection direction);\n  void BracketListTRACE(BracketList& blist);\n\n  Zone* const zone_;\n  TFGraph* const graph_;\n  int dfs_number_;    // Generates new DFS pre-order numbers on demand.\n  int class_number_;  // Generates new equivalence class numbers on demand.\n  Data node_data_;    // Per-node data stored as a side-table.\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"ControlEquivalence\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Constructor for the ControlEquivalence class.\",\n            \"logic\": \"Initializes the zone, graph, DFS number, class number, and node data.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"TFGraph*\",\n                    \"purpose\": \"The Turbofan graph to analyze.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TFGraph\",\n                \"Zone\",\n                \"NodeData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  ControlEquivalence(Zone* zone, TFGraph* graph)\n      : zone_(zone),\n        graph_(graph),\n        dfs_number_(0),\n        class_number_(1),\n        node_data_(graph->NodeCount(), zone) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Run\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Runs the main algorithm to determine control equivalence classes.\",\n            \"logic\": \"Performs a breadth-first backwards traversal and an undirected depth-first backwards traversal to determine class numbers for participating nodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exit\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The exit control node to start the analysis from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void Run(Node* exit);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ClassOf\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Retrieves a previously computed class number for a node.\",\n            \"logic\": \"Checks that the class is valid, then returns the class number.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to retrieve the class number for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The equivalence class number assigned to the node.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  size_t ClassOf(Node* node) {\n    DCHECK_NE(kInvalidClass, GetClass(node));\n    return GetClass(node);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitPre\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Called at pre-visit during DFS walk.\",\n            \"logic\": \"Empty implementation, intended to be implemented by derived classes or used for debugging purposes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void VisitPre(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitMid\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Called at mid-visit during DFS walk.\",\n            \"logic\": \"Empty implementation, intended to be implemented by derived classes or used for debugging purposes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to visit.\"\n                },\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the DFS walk.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"DFSDirection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void VisitMid(Node* node, DFSDirection direction);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitPost\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Called at post-visit during DFS walk.\",\n            \"logic\": \"Empty implementation, intended to be implemented by derived classes or used for debugging purposes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to visit.\"\n                },\n                {\n                    \"name\": \"parent_node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The parent node of the current node.\"\n                },\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the DFS walk.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"DFSDirection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void VisitPost(Node* node, Node* parent_node, DFSDirection direction);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitBackedge\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Called when hitting a back edge in the DFS walk.\",\n            \"logic\": \"Empty implementation, intended to be implemented by derived classes or used for debugging purposes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"from\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The source node of the back edge.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The target node of the back edge.\"\n                },\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the DFS walk.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"DFSDirection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void VisitBackedge(Node* from, Node* to, DFSDirection direction);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RunUndirectedDFS\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Performs an undirected DFS walk of the graph.\",\n            \"logic\": \"Conceptually all nodes are expanded, splitting 'input' and 'use' out into separate nodes. During the traversal, edges towards the representative nodes are preferred.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exit\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The exit node to start the DFS from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void RunUndirectedDFS(Node* exit);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DetermineParticipationEnqueue\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Enqueues a node to the participation queue.\",\n            \"logic\": \"Adds the node to the queue if it's not already participating.\",\n            \"parameters\": [\n                {\n                    \"name\": \"queue\",\n                    \"type\": \"ZoneQueue<Node*>&\",\n                    \"purpose\": \"The queue to enqueue the node to.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to enqueue.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"ZoneQueue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DetermineParticipationEnqueue(ZoneQueue<Node*>& queue, Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DetermineParticipation\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Determines the participation of nodes in the equivalence analysis.\",\n            \"logic\": \"Performs a breadth-first backwards traversal to determine the set of nodes that participate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exit\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The exit node to start the participation determination from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DetermineParticipation(Node* exit);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetData\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Retrieves the per-node data for a given node.\",\n            \"logic\": \"Uses the node's ID as an index into the node_data_ vector. Resizes the vector if necessary.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to retrieve the data for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"NodeData*\",\n                \"description\": \"The per-node data associated with the node.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  NodeData* GetData(Node* node) {\n    size_t const index = node->id();\n    if (index >= node_data_.size()) node_data_.resize(index + 1);\n    return node_data_[index];\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllocateData\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Allocates per-node data for a given node.\",\n            \"logic\": \"Uses the node's ID as an index into the node_data_ vector. Resizes the vector if necessary and allocates a new NodeData object in the zone.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to allocate data for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeData\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void AllocateData(Node* node) {\n    size_t const index = node->id();\n    if (index >= node_data_.size()) node_data_.resize(index + 1);\n    node_data_[index] = zone_->New<NodeData>(zone_);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NewClassNumber\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Generates a new equivalence class number.\",\n            \"logic\": \"Increments the class_number_ counter and returns the new value.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The new equivalence class number.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  int NewClassNumber() { return class_number_++; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NewDFSNumber\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Generates a new DFS pre-order number.\",\n            \"logic\": \"Increments the dfs_number_ counter and returns the new value.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The new DFS pre-order number.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  int NewDFSNumber() { return dfs_number_++; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Participates\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Checks if a node participates in the equivalence analysis.\",\n            \"logic\": \"Checks if the per-node data for the node is not null.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node participates, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  bool Participates(Node* node) { return GetData(node) != nullptr; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetClass\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Retrieves the equivalence class number for a node.\",\n            \"logic\": \"Retrieves the class number from the per-node data.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to retrieve the class number for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The equivalence class number.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  size_t GetClass(Node* node) { return GetData(node)->class_number; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetClass\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Sets the equivalence class number for a node.\",\n            \"logic\": \"Sets the class number in the per-node data.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to set the class number for.\"\n                },\n                {\n                    \"name\": \"number\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The equivalence class number to set.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetClass(Node* node, size_t number) {\n    DCHECK(Participates(node));\n    GetData(node)->class_number = number;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetBracketList\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Retrieves the bracket list for a node.\",\n            \"logic\": \"Retrieves the bracket list from the per-node data.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to retrieve the bracket list for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"BracketList&\",\n                \"description\": \"The bracket list for the node.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeData\",\n                \"BracketList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  BracketList& GetBracketList(Node* node) {\n    DCHECK(Participates(node));\n    return GetData(node)->blist;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetBracketList\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Sets the bracket list for a node.\",\n            \"logic\": \"Sets the bracket list in the per-node data.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to set the bracket list for.\"\n                },\n                {\n                    \"name\": \"list\",\n                    \"type\": \"BracketList&\",\n                    \"purpose\": \"The bracket list to set.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeData\",\n                \"BracketList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetBracketList(Node* node, BracketList& list) {\n    DCHECK(Participates(node));\n    GetData(node)->blist = list;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DFSPush\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Pushes an entry onto the DFS stack.\",\n            \"logic\": \"Mutates the DFS stack by pushing an entry.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"DFSStack&\",\n                    \"purpose\": \"The DFS stack.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to push onto the stack.\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The parent node.\"\n                },\n                {\n                    \"name\": \"dir\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the DFS.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DFSStack\",\n                \"Node\",\n                \"DFSDirection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DFSPush(DFSStack& stack, Node* node, Node* from, DFSDirection dir);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DFSPop\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Pops an entry from the DFS stack.\",\n            \"logic\": \"Mutates the DFS stack by popping an entry.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"DFSStack&\",\n                    \"purpose\": \"The DFS stack.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to pop from the stack.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DFSStack\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DFSPop(DFSStack& stack, Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BracketListDelete\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Deletes a bracket from a bracket list.\",\n            \"logic\": \"Removes a bracket from the specified bracket list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"blist\",\n                    \"type\": \"BracketList&\",\n                    \"purpose\": \"The bracket list to modify.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The target node of the bracket to delete.\"\n                },\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction associated with the bracket to delete.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"BracketList\",\n                \"Node\",\n                \"DFSDirection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BracketListDelete(BracketList& blist, Node* to, DFSDirection direction);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BracketListTRACE\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Traces a bracket list (likely for debugging).\",\n            \"logic\": \"Likely used for printing or logging the contents of a bracket list during debugging. Implementation not provided.\",\n            \"parameters\": [\n                {\n                    \"name\": \"blist\",\n                    \"type\": \"BracketList&\",\n                    \"purpose\": \"The bracket list to trace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"BracketList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BracketListTRACE(BracketList& blist);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Bracket\",\n            \"about\": \"Represents a bracket used during the DFS walk to track control dependencies.\",\n            \"attributes\": [\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Direction in which the bracket was added.\"\n                },\n                {\n                    \"name\": \"recent_class\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Cached class when bracket was topmost.\"\n                },\n                {\n                    \"name\": \"recent_size\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Cached set-size when bracket was topmost.\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"Node*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Node that this bracket originates from.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"Node*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Node that this bracket points to.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\",\n                \"DFSDirection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  struct Bracket {\n    DFSDirection direction;  // Direction in which this bracket was added.\n    size_t recent_class;     // Cached class when bracket was topmost.\n    size_t recent"
}