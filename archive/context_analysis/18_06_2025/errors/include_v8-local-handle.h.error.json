{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-local-handle.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-local-handle.h\",\n        \"file_name\": \"v8-local-handle.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines handle management classes (HandleScope, Local, etc.) for V8's garbage collection system.  These classes provide scoped, safe access to JavaScript objects within the V8 engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8 internal headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stddef.h>\n\n            #include <type_traits>\n            #include <vector>\n\n            #include \"v8-handle-base.h\"  // NOLINT(build/include_directory)\n            #include \"v8-internal.h\"     // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HandleScope\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A stack-allocated class that governs a number of local handles.\",\n            \"attributes\": [\n                {\n                    \"name\": \"i_isolate_\",\n                    \"type\": \"internal::Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the internal isolate.\"\n                },\n                {\n                    \"name\": \"prev_next_\",\n                    \"type\": \"internal::Address*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the next handle scope in the list.\"\n                },\n                {\n                    \"name\": \"prev_limit_\",\n                    \"type\": \"internal::Address*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the limit of the previous handle scope.\"\n                },\n                {\n                    \"name\": \"scope_level_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Scope level for debugging (only in DEBUG mode).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"internal::Isolate\",\n                \"internal::Address\",\n                \"LocalBase\",\n                \"Object\",\n                \"Context\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8_NODISCARD HandleScope {\n            public:\n                explicit HandleScope(Isolate* isolate);\n\n                ~HandleScope();\n\n                /**\n                 * Counts the number of allocated handles.\n                 */\n                static int NumberOfHandles(Isolate* isolate);\n\n                V8_INLINE Isolate* GetIsolate() const {\n                    return reinterpret_cast<Isolate*>(i_isolate_);\n                }\n\n                HandleScope(const HandleScope&) = delete;\n                void operator=(const HandleScope&) = delete;\n\n                static internal::Address* CreateHandleForCurrentIsolate(\n                    internal::Address value);\n\n            protected:\n                V8_INLINE HandleScope() = default;\n\n                void Initialize(Isolate* isolate);\n\n                static internal::Address* CreateHandle(internal::Isolate* i_isolate,\n                                                    internal::Address value);\n\n            private:\n                // Declaring operator new and delete as deleted is not spec compliant.\n                // Therefore declare them private instead to disable dynamic alloc\n                void* operator new(size_t size);\n                void* operator new[](size_t size);\n                void operator delete(void*, size_t);\n                void operator delete[](void*, size_t);\n\n                internal::Isolate* i_isolate_;\n                internal::Address* prev_next_;\n                internal::Address* prev_limit_;\n            #ifdef V8_ENABLE_CHECKS\n                int scope_level_ = 0;\n            #endif\n\n                // LocalBase<T>::New uses CreateHandle with an Isolate* parameter.\n                template <typename T>\n                friend class LocalBase;\n\n                // Object::GetInternalField and Context::GetEmbedderData use CreateHandle with\n                // a HeapObject in their shortcuts.\n                friend class Object;\n                friend class Context;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LocalBase\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A base class for local handles. Its implementation depends on whether direct handle support is enabled.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"api_internal::DirectHandleBase\",\n                \"api_internal::IndirectHandleBase\",\n                \"Isolate\",\n                \"internal::Address\",\n                \"HandleScope\",\n                \"internal::ValueHelper\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_DIRECT_HANDLE\n\n            template <typename T>\n            class LocalBase : public api_internal::DirectHandleBase {\n            protected:\n                template <class F>\n                friend class Local;\n\n                V8_INLINE LocalBase() = default;\n\n                V8_INLINE explicit LocalBase(internal::Address ptr) : DirectHandleBase(ptr) {}\n\n                template <typename S>\n                V8_INLINE LocalBase(const LocalBase<S>& other) : DirectHandleBase(other) {}\n\n                V8_INLINE static LocalBase<T> New(Isolate* isolate, internal::Address value) {\n                    return LocalBase<T>(value);\n                }\n\n                V8_INLINE static LocalBase<T> New(Isolate* isolate, T* that) {\n                    return LocalBase<T>::New(isolate,\n                                            internal::ValueHelper::ValueAsAddress(that));\n                }\n\n                V8_INLINE static LocalBase<T> FromSlot(internal::Address* slot) {\n                    if (slot == nullptr) return LocalBase<T>();\n                    return LocalBase<T>(*slot);\n                }\n\n                V8_INLINE static LocalBase<T> FromRepr(\n                    internal::ValueHelper::InternalRepresentationType repr) {\n                    return LocalBase<T>(repr);\n                }\n            };\n\n            #else  // !V8_ENABLE_DIRECT_HANDLE\n\n            template <typename T>\n            class LocalBase : public api_internal::IndirectHandleBase {\n            protected:\n                template <class F>\n                friend class Local;\n\n                V8_INLINE LocalBase() = default;\n\n                V8_INLINE explicit LocalBase(internal::Address* location)\n                    : IndirectHandleBase(location) {}\n\n                template <typename S>\n                V8_INLINE LocalBase(const LocalBase<S>& other) : IndirectHandleBase(other) {}\n\n                V8_INLINE static LocalBase<T> New(Isolate* isolate, internal::Address value) {\n                    return LocalBase(HandleScope::CreateHandle(\n                        reinterpret_cast<internal::Isolate*>(isolate), value));\n                }\n\n                V8_INLINE static LocalBase<T> New(Isolate* isolate, T* that) {\n                    if (internal::ValueHelper::IsEmpty(that)) return LocalBase<T>();\n                    return LocalBase<T>::New(isolate,\n                                            internal::ValueHelper::ValueAsAddress(that));\n                }\n\n                V8_INLINE static LocalBase<T> FromSlot(internal::Address* slot) {\n                    return LocalBase<T>(slot);\n                }\n\n                V8_INLINE static LocalBase<T> FromRepr(\n                    internal::ValueHelper::InternalRepresentationType repr) {\n                    return LocalBase<T>(repr);\n                }\n            };\n\n            #endif  // V8_ENABLE_DIRECT_HANDLE\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Local\",\n            \"extends\": \"LocalBase<T>\",\n            \"implements\": [],\n            \"about\": \"An object reference managed by the v8 garbage collector.  Represents a local handle to a V8 object.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"LocalBase\",\n                \"api_internal::StackAllocated\",\n                \"Isolate\",\n                \"PersistentBase\",\n                \"BasicTracedReference\",\n                \"internal::HandleHelper\",\n                \"Primitive\",\n                \"Boolean\",\n                \"Eternal\",\n                \"Global\",\n                \"MaybeLocal\",\n                \"Persistent\",\n                \"FunctionCallbackInfo\",\n                \"PropertyCallbackInfo\",\n                \"String\",\n                \"Object\",\n                \"Context\",\n                \"Private\",\n                \"internal::CustomArguments\",\n                \"HandleScope\",\n                \"EscapableHandleScope\",\n                \"InternalEscapableScope\",\n                \"PersistentValueMapBase\",\n                \"ReturnValue\",\n                \"Traced\",\n                \"internal::SamplingHeapProfiler\",\n                \"debug::ConsoleCallArguments\",\n                \"internal::LocalUnchecked\",\n                \"TypecheckWitness\",\n                \"Utils\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            class V8_TRIVIAL_ABI Local : public LocalBase<T>,\n            #ifdef V8_ENABLE_LOCAL_OFF_STACK_CHECK\n                                public api_internal::StackAllocated<true>\n            #else\n                                public api_internal::StackAllocated<false>\n            #endif\n            {\n            public:\n                V8_INLINE Local() = default;\n\n                /**\n                 * Constructor for handling automatic up casting.\n                 * Ex. Local<Object> can be passed when Local<Value> is expected but not\n                 * the other way round.\n                 */\n                template <class S>\n                    requires(std::is_base_of_v<T, S>)\n                V8_INLINE Local(Local<S> that) : LocalBase<T>(that) {}\n\n                V8_INLINE T* operator->() const { return this->template value<T>(); }\n\n                V8_INLINE T* operator*() const { return this->operator->(); }\n\n                /**\n                 * Checks whether two handles are equal or different.\n                 * They are equal iff they are both empty or they are both non-empty and the\n                 * objects to which they refer are physically equal.\n                 *\n                 * If both handles refer to JS objects, this is the same as strict\n                 * non-equality. For primitives, such as numbers or strings, a `true` return\n                 * value does not indicate that the values aren't equal in the JavaScript\n                 * sense. Use `Value::StrictEquals()` to check primitives for equality.\n                 */\n\n                template <class S>\n                V8_INLINE bool operator==(const Local<S>& that) const {\n                    return internal::HandleHelper::EqualHandles(*this, that);\n                }\n\n                template <class S>\n                V8_INLINE bool operator==(const PersistentBase<S>& that) const {\n                    return internal::HandleHelper::EqualHandles(*this, that);\n                }\n\n                template <class S>\n                V8_INLINE bool operator!=(const Local<S>& that) const {\n                    return !operator==(that);\n                }\n\n                template <class S>\n                V8_INLINE bool operator!=(const Persistent<S>& that) const {\n                    return !operator==(that);\n                }\n\n                /**\n                 * Cast a handle to a subclass, e.g. Local<Value> to Local<Object>.\n                 * This is only valid if the handle actually refers to a value of the\n                 * target type.\n                 */\n                template <class S>\n                V8_INLINE static Local<T> Cast(Local<S> that) {\n            #ifdef V8_ENABLE_CHECKS\n                    // If we're going to perform the type check then we have to check\n                    // that the handle isn't empty before doing the checked cast.\n                    if (that.IsEmpty()) return Local<T>();\n                    T::Cast(that.template value<S>());\n            #endif\n                    return Local<T>(LocalBase<T>(that));\n                }\n\n                /**\n                 * Calling this is equivalent to Local<S>::Cast().\n                 * In particular, this is only valid if the handle actually refers to a value\n                 * of the target type.\n                 */\n                template <class S>\n                V8_INLINE Local<S> As() const {\n                    return Local<S>::Cast(*this);\n                }\n\n                /**\n                 * Create a local handle for the content of another handle.\n                 * The referee is kept alive by the local handle even when\n                 * the original handle is destroyed/disposed.\n                 */\n                V8_INLINE static Local<T> New(Isolate* isolate, Local<T> that) {\n                    return New(isolate, that.template value<T, true>());\n                }\n\n                V8_INLINE static Local<T> New(Isolate* isolate,\n                                            const PersistentBase<T>& that) {\n                    return New(isolate, that.template value<T, true>());\n                }\n\n                V8_INLINE static Local<T> New(Isolate* isolate,\n                                            const BasicTracedReference<T>& that) {\n                    return New(isolate, that.template value<T, true>());\n                }\n\n            private:\n                friend class TracedReferenceBase;\n                friend class Utils;\n                template <class F>\n                friend class Eternal;\n                template <class F>\n                friend class Global;\n                template <class F>\n                friend class Local;\n                template <class F>\n                friend class MaybeLocal;\n                template <class F, class M>\n                friend class Persistent;\n                template <class F>\n                friend class FunctionCallbackInfo;\n                template <class F>\n                friend class PropertyCallbackInfo;\n                friend class String;\n                friend class Object;\n                friend class Context;\n                friend class Isolate;\n                friend class Private;\n                template <class F>\n                friend class internal::CustomArguments;\n                friend Local<Primitive> Undefined(Isolate* isolate);\n                friend Local<Primitive> Null(Isolate* isolate);\n                friend Local<Boolean> True(Isolate* isolate);\n                friend Local<Boolean> False(Isolate* isolate);\n                friend class HandleScope;\n                friend class EscapableHandleScope;\n                friend class InternalEscapableScope;\n                template <class F1, class F2, class F3>\n                friend class PersistentValueMapBase;\n                template <class F>\n                friend class ReturnValue;\n                template <class F>\n                friend class Traced;\n                friend class internal::SamplingHeapProfiler;\n                friend class internal::HandleHelper;\n                friend class debug::ConsoleCallArguments;\n                friend class internal::LocalUnchecked<T>;\n\n                explicit Local(no_checking_tag do_not_check)\n                    : LocalBase<T>(), StackAllocated(do_not_check) {}\n                explicit Local(const Local<T>& other, no_checking_tag do_not_check)\n                    : LocalBase<T>(other), StackAllocated(do_not_check) {}\n\n                V8_INLINE explicit Local(const LocalBase<T>& other) : LocalBase<T>(other) {}\n\n                V8_INLINE static Local<T> FromRepr(\n                    internal::ValueHelper::InternalRepresentationType repr) {\n                    return Local<T>(LocalBase<T>::FromRepr(repr));\n                }\n\n                V8_INLINE static Local<T> FromSlot(internal::Address* slot) {\n                    return Local<T>(LocalBase<T>::FromSlot(slot));\n                }\n\n            #ifdef V8_ENABLE_DIRECT_HANDLE\n                friend class TypecheckWitness;\n\n                V8_INLINE static Local<T> FromAddress(internal::Address ptr) {\n                    return Local<T>(LocalBase<T>(ptr));\n                }\n            #endif  // V8_ENABLE_DIRECT_HANDLE\n\n                V8_INLINE static Local<T> New(Isolate* isolate, internal::Address value) {\n                    return Local<T>(LocalBase<T>::New(isolate, value));\n                }\n\n                V8_INLINE static Local<T> New(Isolate* isolate, T* that) {\n                    return Local<T>(LocalBase<T>::New(isolate, that));\n                }\n\n                // Unsafe cast, should be avoided.\n                template <class S>\n                V8_INLINE Local<S> UnsafeAs() const {\n                    return Local<S>(LocalBase<S>(*this));\n                }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LocalUnchecked\",\n            \"extends\": \"Local<T>\",\n            \"implements\": [],\n            \"about\": \"A local variant that is suitable for off-stack allocation. Used internally by LocalVector<T>. Not to be used directly!\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Local\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n            // A local variant that is suitable for off-stack allocation.\n            // Used internally by LocalVector<T>. Not to be used directly!\n            template <typename T>\n            class V8_TRIVIAL_ABI LocalUnchecked : public Local<T> {\n            public:\n                LocalUnchecked() : Local<T>(Local<T>::do_not_check) {}\n\n            #if defined(V8_ENABLE_LOCAL_OFF_STACK_CHECK) && V8_HAS_ATTRIBUTE_TRIVIAL_ABI\n                // In this case, the check is also enforced in the copy constructor and we\n                // need to suppress it.\n                LocalUnchecked(\n                    const LocalUnchecked& other) noexcept  // NOLINT(runtime/explicit)\n                    : Local<T>(other, Local<T>::do_not_check) {}\n                LocalUnchecked& operator=(const LocalUnchecked&) noexcept = default;\n            #endif\n\n                // Implicit conversion from Local.\n                LocalUnchecked(const Local<T>& other) noexcept  // NOLINT(runtime/explicit)\n                    : Local<T>(other, Local<T>::do_not_check) {}\n            };\n\n            #ifdef V8_ENABLE_DIRECT_HANDLE\n            // Off-stack allocated direct locals must be registered as strong roots.\n            // For off-stack indirect locals, this is not necessary.\n\n            template <typename T>\n            class StrongRootAllocator<LocalUnchecked<T>> : public StrongRootAllocatorBase {\n            public:\n                using value_type = LocalUnchecked<T>;\n                static_assert(std::is_standard_layout_v<value_type>);\n                static_assert(sizeof(value_type) == sizeof(Address));\n\n                template <typename HeapOrIsolateT>\n                explicit StrongRootAllocator(HeapOrIsolateT* heap_or_isolate)\n                    : StrongRootAllocatorBase(heap_or_isolate) {}\n                template <typename U>\n                StrongRootAllocator(const StrongRootAllocator<U>& other) noexcept\n                    : StrongRootAllocatorBase(other) {}\n\n                value_type* allocate(size_t n) {\n                    return reinterpret_cast<value_type*>(allocate_impl(n));\n                }\n                void deallocate(value_type* p, size_t n) noexcept {\n                    return deallocate_impl(reinterpret_cast<Address*>(p), n);\n                }\n            };\n            #endif  // V8_ENABLE_DIRECT_HANDLE\n            }  // namespace internal\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LocalVector\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A vector of Local handles, optimized for off-stack allocation.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"internal::LocalUnchecked\",\n                \"Isolate\",\n                \"Local\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class LocalVector {\n            private:\n                using element_type = internal::LocalUnchecked<T>;\n\n            #ifdef V8_ENABLE_DIRECT_HANDLE\n                using allocator_type = internal::StrongRootAllocator<element_type>;\n\n                static allocator_type make_allocator(Isolate* isolate) noexcept {\n                    return allocator_type(isolate);\n                }\n            #else\n                using allocator_type = std::allocator<element_type>;\n\n                static allocator_type make_allocator(Isolate* isolate) noexcept {\n                    return allocator_type();\n                }\n            #endif  // V8_ENABLE_DIRECT_HANDLE\n\n                using vector_type = std::vector<element_type, allocator_type>;\n\n            public:\n                using value_type = Local<T>;\n                using reference = value_type&;\n                using const_reference = const value_type&;\n                using size_type = size_t;\n                using difference_type = ptrdiff_t;\n                using iterator =\n                    internal::WrappedIterator<typename vector_type::iterator, Local<T>>;\n                using const_iterator =\n                    internal::WrappedIterator<typename vector_type::const_iterator,\n                                                const Local<T>>;\n\n                explicit LocalVector(Isolate* isolate) : backing_(make_allocator(isolate)) {}\n                LocalVector(Isolate* isolate, size_t n)\n                    : backing_(n, make_allocator(isolate)) {}\n                explicit LocalVector(Isolate* isolate, std::initializer_list<Local<T>> init)\n                    : backing_(make_allocator(isolate)) {\n                    if (init.size() == 0) return;\n                    backing_.reserve(init.size());\n                    backing_.insert(backing_.end(), init.begin(), init.end());\n                }\n\n                iterator begin() noexcept { return iterator(backing_.begin()); }\n                const_iterator begin() const noexcept {\n                    return const_iterator(backing_.begin());\n                }\n                iterator end() noexcept { return iterator(backing_.end()); }\n                const_iterator end() const noexcept { return const_iterator(backing_.end()); }\n\n                size_t size() const noexcept { return backing_.size(); }\n                bool empty() const noexcept { return backing_.empty(); }\n                void reserve(size_t n) { backing_.reserve(n); }\n                void shrink_to_fit() { backing_.shrink_to_fit(); }\n\n                Local<T>& operator[](size_t n) { return backing_[n]; }\n                const Local<T>& operator[](size_t n) const { return backing_[n]; }\n\n                Local<T>& at(size_t n) { return backing_.at(n); }\n                const Local<T>& at(size_t n) const { return backing_.at(n); }\n\n                Local<T>& front() { return backing_.front(); }\n                const Local<T>& front() const { return backing_.front(); }\n                Local<T>& back() { return backing_.back(); }\n                const Local<T>& back() const { return backing_.back(); }\n\n                Local<T>* data() noexcept { return backing_.data(); }\n                const Local<T>* data() const noexcept { return backing_.data(); }\n\n                iterator insert(const_iterator pos, const Local<T>& value) {\n                    return iterator(backing_.insert(pos.base(), value));\n                }\n\n                template <typename InputIt>\n                iterator insert(const_iterator pos, InputIt first, InputIt last) {\n                    return iterator(backing_.insert(pos.base(), first, last));\n                }\n\n                iterator insert(const_iterator pos, std::initializer_list<Local<T>> init) {\n                    return iterator(backing_.insert(pos.base(), init.begin(), init.end()));\n                }\n\n                LocalVector<T>& operator=(std::initializer_list<Local<T>> init) {\n                    backing_.clear();\n                    backing_.reserve(init.size());\n                    backing_.insert(backing_.end(), init.begin(), init.end());\n                    return *this;\n                }\n\n                void push_back(const Local<T>& x) { backing_.push_back(x); }\n                void pop_back() { backing_.pop_back(); }\n\n                template <typename... Args>\n                void emplace_back(Args&&... args) {\n                    backing_.push_back(value_type{std::forward<Args>(args)...});\n                }\n\n                void clear() noexcept { backing_.clear(); }\n                void resize(size_t n) { backing_.resize(n); }\n                void swap(LocalVector<T>& other) { backing_.swap(other.backing_); }\n\n                friend bool operator==(const LocalVector<T>& x, const LocalVector<T>& y) {\n                    return x.backing_ == y.backing_;\n                }\n                friend bool operator!=(const LocalVector<T>& x, const LocalVector<T>& y) {\n                    return x.backing_ != y.backing_;\n                }\n                friend bool operator<(const LocalVector<T>& x, const LocalVector<T>& y) {\n                    return x.backing_ < y.backing_;\n                }\n                friend bool operator>(const LocalVector<T>& x, const LocalVector<T>& y) {\n                    return x.backing_ > y.backing_;\n                }\n                friend bool operator<=(const LocalVector<T>& x, const LocalVector<T>& y) {\n                    return x.backing_ <= y.backing_;\n                }\n                friend bool operator>=(const LocalVector<T>& x, const LocalVector<T>& y) {\n                    return x.backing_ >= y.backing_;\n                }\n\n            private:\n                vector_type backing_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MaybeLocal\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A wrapper around Local<> that enforces a check whether the Local<> is empty before it can be used.\",\n            \"attributes\": [\n                {\n                    \"name\": \"local_\",\n                    \"type\": \"Local<T>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying Local handle.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Local\",\n                \"api_internal::ToLocalEmpty\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            class MaybeLocal {\n            public:\n                V8_INLINE MaybeLocal() : local_() {}\n                template <class S>\n                V8_INLINE MaybeLocal(Local<S> that) : local_(that) {}\n\n                V8_INLINE bool IsEmpty() const { return local_.IsEmpty(); }\n\n                /**\n                 * Converts this MaybeLocal<> to a Local<>. If this MaybeLocal<> is empty,\n                 * |false| is returned and |out| is assigned with nullptr.\n                 */\n                template <class S>\n                V8_WARN_UNUSED_RESULT V8_INLINE bool ToLocal(Local<S>* out) const {\n                    *out = local_;\n                    return !IsEmpty();\n                }\n\n                /**\n                 * Converts this MaybeLocal<> to a Local<>. If this MaybeLocal<> is empty,\n                 * V8 will crash the process.\n                 */\n                V8_INLINE Local<T> ToLocalChecked() {\n                    if (V8_UNLIKELY(IsEmpty())) api_internal::ToLocalEmpty();\n                    return local_;\n                }\n\n                /**\n                 * Converts this MaybeLocal<> to a Local<>, using a default value if this\n                 * MaybeLocal<> is empty.\n                 */\n                template <class S>\n                V8_INLINE Local<S> FromMaybe(Local<S> default_value) const {\n                    return IsEmpty() ? default_value : Local<S>(local_);\n                }\n\n                /**\n                 * Cast a handle to a subclass, e.g. MaybeLocal<Value> to MaybeLocal<Object>.\n                 * This is only valid if the handle actually refers to a value of the target\n                 * type.\n                 */\n                template <class S>\n                V8_INLINE static MaybeLocal<T> Cast(MaybeLocal<S> that) {\n            #ifdef V8_ENABLE_CHECKS\n                    // If we're going to perform the type check then we have to check\n                    // that the handle isn't empty before doing the checked cast.\n                    if (that.IsEmpty()) return MaybeLocal<T>();\n                    T::Cast(that.local_.template value<S>());\n            #endif\n                    return MaybeLocal<T>(that.local_);\n                }\n\n                /**\n                 * Calling this is equivalent to MaybeLocal<S>::Cast().\n                 * In particular, this is only valid if the handle actually refers to a value\n                 * of the target type.\n                 */\n                template <class S>\n                V8_INLINE MaybeLocal<S> As() const {\n                    return MaybeLocal<S>::Cast(*this);\n                }\n\n            private:\n                Local<T> local_;\n\n                template <typename S>\n                friend class MaybeLocal;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EscapableHandleScopeBase\",\n            \"extends\": \"HandleScope\",\n            \"implements\": [],\n            \"about\": \"A HandleScope which first allocates a handle in the current scope which will be later filled with the escape value.\",\n            \"attributes\": [\n                {\n                    \"name\": \"escape_slot_\",\n                    \"type\": \"internal::Address*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The slot where the escaped value is stored.\"\n                }\n            ],\n            \"dependencies\": [\n                \"HandleScope\",\n                \"Isolate\",\n                \"internal::Address\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8_NODISCARD EscapableHandleScopeBase : public HandleScope {\n            public:\n                explicit EscapableHandleScopeBase(Isolate* isolate);\n                V8_INLINE ~EscapableHandleScopeBase() = default;\n\n                EscapableHandleScopeBase(const EscapableHandleScopeBase&) = delete;\n                void operator=(const EscapableHandleScopeBase&) = delete;\n                void* operator new(size_t size) = delete;\n                void* operator new[](size_t size) = delete;\n                void operator delete(void*, size_t) = delete;\n                void operator delete[](void*, size_t) = delete;\n\n            protected:\n                /**\n                 * Pushes the value into the previous scope and returns a handle to it.\n                 * Cannot be called twice.\n                 */\n                internal::Address* EscapeSlot(internal::Address* escape_value);\n\n            private:\n                internal::Address* escape_slot_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EscapableHandleScope\",\n            \"extends\": \"EscapableHandleScopeBase\",\n            \"implements\": [],\n            \"about\": \"A HandleScope that allows a single handle to escape to the outer scope.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"EscapableHandleScopeBase\",\n                \"Isolate\",\n                \"Local\",\n                \"MaybeLocal\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8_NODISCARD EscapableHandleScope\n                : public EscapableHandleScopeBase {\n            public:\n                explicit EscapableHandleScope(Isolate* isolate)\n                    : EscapableHandleScopeBase(isolate) {}\n                V8_INLINE ~EscapableHandleScope() = default;\n                template <class T>\n                V8_INLINE Local<T> Escape(Local<T> value) {\n            #ifdef V8_ENABLE_DIRECT_HANDLE\n                return value;\n            #else\n                if (value.IsEmpty()) return value;\n                return Local<T>::FromSlot(EscapeSlot(value.slot()));\n            #endif\n                }\n\n                template <class T>\n                V8_INLINE MaybeLocal<T> EscapeMaybe(MaybeLocal<T> value) {\n                    return Escape(value.FromMaybe(Local<T>()));\n                }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SealHandleScope\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A SealHandleScope acts like a handle scope in which no handle allocations are allowed. It can be useful for debugging handle leaks. Handles can be allocated within inner normal HandleScopes.\",\n            \"attributes\": [\n                {\n                    \"name\": \"i_isolate_\",\n                    \"type\": \"internal::Isolate* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the internal isolate.\"\n                },\n                {\n                    \"name\": \"prev_limit_\",\n                    \"type\": \"internal::Address*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the previous limit of the handle scope.\"\n                },\n                {\n                    \"name\": \"prev_sealed_level_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the previous sealed level.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"internal::Isolate\",\n                \"internal::Address\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8_NODISCARD SealHandleScope {\n            public:\n                explicit SealHandleScope(Isolate* isolate);\n                ~SealHandleScope();\n\n                SealHandleScope(const SealHandleScope&) = delete;\n                void operator=(const SealHandleScope&) = delete;\n                void* operator new(size_t size) = delete;\n                void* operator new[](size_t size) = delete;\n                void operator delete(void*, size_t) = delete;\n                void operator delete[](void*, size_t) = delete;\n\n            private:\n                internal::Isolate* const i_isolate_;\n                internal::Address* prev_limit_;\n                int prev_sealed_level_;\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of"
}