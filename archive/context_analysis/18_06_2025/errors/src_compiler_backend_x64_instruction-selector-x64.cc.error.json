{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/x64/instruction-selector-x64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/x64/instruction-selector-x64.cc\",\n        \"file_name\": \"instruction-selector-x64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Selects x64 machine instructions from the Turboshaft IR.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8 specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <algorithm>\n#include <cstdint>\n#include <limits>\n#include <optional>\n\n#include \"src/base/bounds.h\"\n#include \"src/base/iterator.h\"\n#include \"src/base/logging.h\"\n#include \"src/base/overflowing-math.h\"\n#include \"src/codegen/cpu-features.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/common/assert-scope.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/backend/instruction-selector-adapter.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/backend/instruction-selector.h\"\n#include \"src/compiler/backend/instruction.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/turboshaft/load-store-simplification-reducer.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/objects/slots-inl.h\"\n#include \"src/roots/roots-inl.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/simd-shuffle.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8::internal::compiler\",\n            \"purpose\": \"Groups the V8 compiler related classes and functions.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nusing namespace turboshaft;\n// using OpIndex;\n// using OptionalOpIndex;\n\nnamespace {\n\nbool IsCompressed(InstructionSelectorT* selector, OpIndex node) {\n  if (!node.valid()) return false;\n  if (selector->is_load(node)) {\n    auto load = selector->load_view(node);\n    return load.loaded_rep().IsCompressed();\n  } else if (selector->IsPhi(node)) {\n    MachineRepresentation phi_rep = selector->phi_representation_of(node);\n    return phi_rep == MachineRepresentation::kCompressed ||\n           phi_rep == MachineRepresentation::kCompressedPointer;\n  }\n  return false;\n}\n\n#ifdef DEBUG\n// {left_idx} and {right_idx} are assumed to be the inputs of a commutative\n// binop. This function checks that {left_idx} is not the only constant input of\n// this binop (since the graph should have been normalized before, putting\n// constants on the right input of binops when possible).\nbool LhsIsNotOnlyConstant(Graph* graph, OpIndex left_idx, OpIndex right_idx) {\n  const Operation& left = graph->Get(left_idx);\n  const Operation& right = graph->Get(right_idx);\n\n  if (right.Is<ConstantOp>()) {\n    // There is a constant on the right.\n    return true;\n  }\n  if (left.Is<ConstantOp>()) {\n    // Constant on the left but not on the right.\n    return false;\n  }\n\n  // Left is not a constant\n  return true;\n}\n\n#endif\n\n}  // namespace\n        ]]></code>\n    </namespace>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ValueFitsIntoImmediate\",\n            \"about\": \"Checks if a 64-bit integer value fits into a 32-bit immediate.\",\n            \"logic\": \"Checks if the given value is within the range of a signed 32-bit integer, considering the additional constraint of kNegativeDisplacement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The value to check\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the value fits into a 32-bit immediate, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool ValueFitsIntoImmediate(int64_t value) {\n  // int32_t min will overflow if displacement mode is kNegativeDisplacement.\n  constexpr int64_t kImmediateMin = std::numeric_limits<int32_t>::min() + 1;\n  constexpr int64_t kImmediateMax = std::numeric_limits<int32_t>::max();\n  static_assert(kImmediateMin ==\n                LoadStoreSimplificationConfiguration::kMinOffset);\n  static_assert(kImmediateMax ==\n                LoadStoreSimplificationConfiguration::kMaxOffset);\n  return kImmediateMin <= value && value <= kImmediateMax;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CanBeImmediate\",\n            \"about\": \"Determines if a Turboshaft IR node represents a constant that can be used as an immediate value in x64 instructions.\",\n            \"logic\": \"Checks if the node is a ConstantOp and then checks the type and value of the constant to see if it fits into an immediate. Handles various constant types like compressed heap objects, word32, word64, smi and number.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The IR node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node represents an immediate value, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"COMPRESS_POINTERS_BOOL\",\n                \"RootsTable\",\n                \"RootIndex\",\n                \"Handle<HeapObject>\",\n                \"Is64\",\n                \"ValueFitsIntoImmediate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool CanBeImmediate(InstructionSelectorT* selector, OpIndex node) {\n  // TODO(dmercadier): this is not in sync with GetImmediateIntegerValue, which\n  // is surprising because we often use the pattern\n  // `if (CanBeImmediate()) { GetImmediateIntegerValue }`. We should make sure\n  // that both functions are in sync.\n  const Operation& op = selector->Get(node);\n  if (!op.Is<ConstantOp>()) return false;\n  const ConstantOp& constant = op.Cast<ConstantOp>();\n  switch (constant.kind) {\n    case ConstantOp::Kind::kCompressedHeapObject: {\n      if (!COMPRESS_POINTERS_BOOL) return false;\n      // For builtin code we need static roots\n      if (selector->isolate()->bootstrapper() && !V8_STATIC_ROOTS_BOOL) {\n        return false;\n      }\n      const RootsTable& roots_table = selector->isolate()->roots_table();\n      RootIndex root_index;\n      Handle<HeapObject> value = constant.handle();\n      if (roots_table.IsRootHandle(value, &root_index)) {\n        return RootsTable::IsReadOnly(root_index);\n      }\n      return false;\n    }\n    case ConstantOp::Kind::kWord32: {\n      const int32_t value = constant.word32();\n      // int32_t min will overflow if displacement mode is\n      // kNegativeDisplacement.\n      return value != std::numeric_limits<int32_t>::min();\n    }\n    case ConstantOp::Kind::kWord64: {\n      const int64_t value = constant.word64();\n      return ValueFitsIntoImmediate(value);\n    }\n    case ConstantOp::Kind::kSmi: {\n      if (Is64()) {\n        const int64_t value = constant.smi().ptr();\n        return ValueFitsIntoImmediate(value);\n      } else {\n        const int32_t value = constant.smi().ptr();\n        // int32_t min will overflow if displacement mode is\n        // kNegativeDisplacement.\n        return value != std::numeric_limits<int32_t>::min();\n      }\n    }\n    case ConstantOp::Kind::kNumber:\n      return constant.number().get_bits() == 0;\n    default:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetImmediateIntegerValue\",\n            \"about\": \"Retrieves the integer value of a constant node, assuming it can be represented as an immediate value.\",\n            \"logic\": \"Assumes that the given node is a ConstantOp that can be represented as an immediate value. Extracts the integer value from the ConstantOp based on its kind (Word32, Word64, Smi, Number).\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The IR node representing the constant.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int32_t\",\n                \"description\": \"The integer value of the immediate.\"\n            },\n            \"dependencies\": [\n                \"CanBeImmediate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint32_t GetImmediateIntegerValue(InstructionSelectorT* selector, OpIndex node) {\n  DCHECK(CanBeImmediate(selector, node));\n  const ConstantOp& constant = selector->Get(node).Cast<ConstantOp>();\n  switch (constant.kind) {\n    case ConstantOp::Kind::kWord32:\n      return constant.word32();\n    case ConstantOp::Kind::kWord64:\n      return static_cast<int32_t>(constant.word64());\n    case ConstantOp::Kind::kSmi:\n      return static_cast<int32_t>(constant.smi().ptr());\n    case ConstantOp::Kind::kNumber:\n      DCHECK_EQ(constant.number().get_bits(), 0);\n      return 0;\n    default:\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ScaledIndexMatch\",\n            \"about\": \"Represents the result of matching a scaled index expression.\",\n            \"attributes\": [\n                {\n                    \"name\": \"base\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The base OpIndex.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The index OpIndex.\"\n                },\n                {\n                    \"name\": \"scale\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The scale factor.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstruct ScaledIndexMatch {\n  OpIndex base;\n  OpIndex index;\n  int scale;\n};\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MatchScaledIndex\",\n            \"about\": \"Matches a scaled index expression of the form `index * scale` or `index << scale`.\",\n            \"logic\": \"Attempts to match a multiplication or left shift operation with a constant scale factor.  It handles both multiplication and left shifts. Determines the index and scale value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The IR node to match.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"OpIndex*\",\n                    \"purpose\": \"Output parameter: The index OpIndex, if matched.\"\n                },\n                {\n                    \"name\": \"scale\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"Output parameter: The scale factor, if matched.\"\n                },\n                {\n                    \"name\": \"power_of_two_plus_one\",\n                    \"type\": \"bool*\",\n                    \"purpose\": \"Output parameter: Indicates if scale is of the form 2^n + 1.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a scaled index expression was matched, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool MatchScaledIndex(InstructionSelectorT* selector, OpIndex node,\n                      OpIndex* index, int* scale, bool* power_of_two_plus_one) {\n  DCHECK_NOT_NULL(index);\n  DCHECK_NOT_NULL(scale);\n\n  auto MatchScaleConstant = [](const Operation& op, int& scale,\n                               bool* plus_one) {\n    const ConstantOp* constant = op.TryCast<ConstantOp>();\n    if (constant == nullptr) return false;\n    if (constant->kind != ConstantOp::Kind::kWord32 &&\n        constant->kind != ConstantOp::Kind::kWord64) {\n      return false;\n    }\n    uint64_t value = constant->integral();\n    if (plus_one) *plus_one = false;\n    if (value == 1) return (scale = 0), true;\n    if (value == 2) return (scale = 1), true;\n    if (value == 4) return (scale = 2), true;\n    if (value == 8) return (scale = 3), true;\n    if (plus_one == nullptr) return false;\n    *plus_one = true;\n    if (value == 3) return (scale = 1), true;\n    if (value == 5) return (scale = 2), true;\n    if (value == 9) return (scale = 3), true;\n    return false;\n  };\n\n  const Operation& op = selector->Get(node);\n  if (const WordBinopOp* binop = op.TryCast<WordBinopOp>()) {\n    if (binop->kind != WordBinopOp::Kind::kMul) return false;\n    if (MatchScaleConstant(selector->Get(binop->right()), *scale,\n                           power_of_two_plus_one)) {\n      *index = binop->left();\n      return true;\n    }\n    if (MatchScaleConstant(selector->Get(binop->left()), *scale,\n                           power_of_two_plus_one)) {\n      *index = binop->right();\n      return true;\n    }\n    return false;\n  } else if (const ShiftOp* shift = op.TryCast<ShiftOp>()) {\n    if (shift->kind != ShiftOp::Kind::kShiftLeft) return false;\n    int64_t scale_value;\n    if (selector->MatchSignedIntegralConstant(shift->right(), &scale_value)) {\n      if (scale_value < 0 || scale_value > 3) return false;\n      *index = shift->left();\n      *scale = static_cast<int>(scale_value);\n      if (power_of_two_plus_one) *power_of_two_plus_one = false;\n      return true;\n    }\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchScaledIndex\",\n            \"about\": \"Tries to match a scaled index expression, returning an optional ScaledIndexMatch structure.\",\n            \"logic\": \"Calls MatchScaledIndex, and if a match is found, creates and returns a ScaledIndexMatch object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The IR node to match.\"\n                },\n                {\n                    \"name\": \"allow_power_of_two_plus_one\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the scale factor can be of the form 2^n + 1.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<ScaledIndexMatch>\",\n                \"description\": \"A ScaledIndexMatch object if a scaled index expression was matched, std::nullopt otherwise.\"\n            },\n            \"dependencies\": [\n                \"MatchScaledIndex\",\n                \"ScaledIndexMatch\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ScaledIndexMatch> TryMatchScaledIndex(\n    InstructionSelectorT* selector, OpIndex node,\n    bool allow_power_of_two_plus_one) {\n  ScaledIndexMatch match;\n  bool plus_one = false;\n  if (MatchScaledIndex(selector, node, &match.index, &match.scale,\n                       allow_power_of_two_plus_one ? &plus_one : nullptr)) {\n    match.base = plus_one ? match.index : OpIndex{};\n    return match;\n  }\n  return std::nullopt;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchScaledIndex32\",\n            \"about\": \"Tries to match a scaled index expression, specifically for 32-bit operations.\",\n            \"logic\": \"A wrapper function around TryMatchScaledIndex.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The IR node to match.\"\n                },\n                {\n                    \"name\": \"allow_power_of_two_plus_one\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the scale factor can be of the form 2^n + 1.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<ScaledIndexMatch>\",\n                \"description\": \"A ScaledIndexMatch object if a scaled index expression was matched, std::nullopt otherwise.\"\n            },\n            \"dependencies\": [\n                \"TryMatchScaledIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ScaledIndexMatch> TryMatchScaledIndex32(\n    InstructionSelectorT* selector, OpIndex node,\n    bool allow_power_of_two_plus_one) {\n  return TryMatchScaledIndex(selector, node, allow_power_of_two_plus_one);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchScaledIndex64\",\n            \"about\": \"Tries to match a scaled index expression, specifically for 64-bit operations.\",\n            \"logic\": \"A wrapper function around TryMatchScaledIndex.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The IR node to match.\"\n                },\n                {\n                    \"name\": \"allow_power_of_two_plus_one\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the scale factor can be of the form 2^n + 1.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<ScaledIndexMatch>\",\n                \"description\": \"A ScaledIndexMatch object if a scaled index expression was matched, std::nullopt otherwise.\"\n            },\n            \"dependencies\": [\n                \"TryMatchScaledIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ScaledIndexMatch> TryMatchScaledIndex64(\n    InstructionSelectorT* selector, OpIndex node,\n    bool allow_power_of_two_plus_one) {\n  return TryMatchScaledIndex(selector, node, allow_power_of_two_plus_one);\n}\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"BaseWithScaledIndexAndDisplacementMatch\",\n            \"about\": \"Represents the result of matching an addressing mode with a base, scaled index, and displacement.\",\n            \"attributes\": [\n                {\n                    \"name\": \"base\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The base OpIndex.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The index OpIndex.\"\n                },\n                {\n                    \"name\": \"scale\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The scale factor.\"\n                },\n                {\n                    \"name\": \"displacement\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The displacement value.\"\n                },\n                {\n                    \"name\": \"displacement_mode\",\n                    \"type\": \"DisplacementMode\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The displacement mode (positive or negative).\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstruct BaseWithScaledIndexAndDisplacementMatch {\n  OpIndex base = {};\n  OpIndex index = {};\n  int scale = 0;\n  int64_t displacement = 0;\n  DisplacementMode displacement_mode = kPositiveDisplacement;\n};\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchBaseWithScaledIndexAndDisplacement64ForWordBinop\",\n            \"about\": \"Helper function to match base with scaled index and displacement for 64-bit word binop.\",\n            \"logic\": \"Matches several patterns to find the components of an effective address calculation (base, index, scale, and displacement) within a WordBinop. The patterns are of the form S + (B + D), where S is a scaled index, B is a base, and D is a displacement.  The is_commutative flag determines whether the order of the inputs can be swapped.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"left\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The left operand of the binop.\"\n                },\n                {\n                    \"name\": \"right\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The right operand of the binop.\"\n                },\n                {\n                    \"name\": \"is_commutative\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the binop is commutative.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<BaseWithScaledIndexAndDisplacementMatch>\",\n                \"description\": \"An optional BaseWithScaledIndexAndDisplacementMatch if a match is found, std::nullopt otherwise.\"\n            },\n            \"dependencies\": [\n                \"MatchScaledIndex\",\n                \"BaseWithScaledIndexAndDisplacementMatch\",\n                \"ValueFitsIntoImmediate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<BaseWithScaledIndexAndDisplacementMatch>\nTryMatchBaseWithScaledIndexAndDisplacement64ForWordBinop(\n    InstructionSelectorT* selector, OpIndex left, OpIndex right,\n    bool is_commutative) {\n  // In the comments of this function, the following letters have the following\n  // meaning:\n  //\n  //   S: scaled index. That is, \"OpIndex * constant\" or \"OpIndex << constant\",\n  //      where \"constant\" is a small power of 2 (1, 2, 4, 8 for the\n  //      multiplication, 0, 1, 2 or 3 for the shift). The \"constant\" is called\n  //      \"scale\" in the BaseWithScaledIndexAndDisplacementMatch struct that is\n  //      returned.\n  //\n  //   B: base. Just a regular OpIndex.\n  //\n  //   D: displacement. An integral constant.\n\n  // Helper to check (S + ...)\n  auto match_S_plus = [&selector](OpIndex left, OpIndex right)\n      -> std::optional<BaseWithScaledIndexAndDisplacementMatch> {\n    BaseWithScaledIndexAndDisplacementMatch result;\n    result.displacement_mode = kPositiveDisplacement;\n\n    // Check (S + ...)\n    if (MatchScaledIndex(selector, left, &result.index, &result.scale,\n                         nullptr)) {\n      result.displacement_mode = kPositiveDisplacement;\n\n      // Check (S + (... binop ...))\n      if (const WordBinopOp* right_binop =\n              selector->Get(right).TryCast<WordBinopOp>()) {\n        // Check (S + (B - D))\n        if (right_binop->kind == WordBinopOp::Kind::kSub) {\n          if (!selector->MatchSignedIntegralConstant(right_binop->right(),\n                                                     &result.displacement)) {\n            return std::nullopt;\n          }\n          result.base = right_binop->left();\n          result.displacement_mode = kNegativeDisplacement;\n          return result;\n        }\n        // Check (S + (... + ...))\n        if (right_binop->kind == WordBinopOp::Kind::kAdd) {\n          if (selector->MatchSignedIntegralConstant(right_binop->right(),\n                                                    &result.displacement)) {\n            // (S + (B + D))\n            result.base = right_binop->left();\n          } else if (selector->MatchSignedIntegralConstant(\n                         right_binop->left(), &result.displacement)) {\n            // (S + (D + B))\n            result.base = right_binop->right();\n          } else {\n            // Treat it as (S + B)\n            result.base = right;\n            result.displacement = 0;\n          }\n          return result;\n        }\n      }\n\n      // Check (S + D)\n      if (selector->MatchSignedIntegralConstant(right, &result.displacement)) {\n        result.base = OpIndex{};\n        return result;\n      }\n\n      // Treat it as (S + B)\n      result.base = right;\n      result.displacement = 0;\n      return result;\n    }\n\n    return std::nullopt;\n  };\n\n  // Helper to check ((S + ...) + ...)\n  auto match_S_plus_plus = [&selector](OpIndex left, OpIndex right,\n                                       OpIndex left_add_left,\n                                       OpIndex left_add_right)\n      -> std::optional<BaseWithScaledIndexAndDisplacementMatch> {\n    DCHECK_EQ(selector->Get(left).Cast<WordBinopOp>().kind,\n              WordBinopOp::Kind::kAdd);\n\n    BaseWithScaledIndexAndDisplacementMatch result;\n    result.displacement_mode = kPositiveDisplacement;\n\n    if (MatchScaledIndex(selector, left_add_left, &result.index, &result.scale,\n                         nullptr)) {\n      result.displacement_mode = kPositiveDisplacement;\n      // Check ((S + D) + B)\n      if (selector->MatchSignedIntegralConstant(left_add_right,\n                                                &result.displacement)) {\n        result.base = right;\n        return result;\n      }\n      // Check ((S + B) + D)\n      if (selector->MatchSignedIntegralConstant(right, &result.displacement)) {\n        result.base = left_add_right;\n        return result;\n      }\n      // Treat it as (B + B) and use index as right B.\n      result.base = left;\n      result.index = right;\n      result.scale = 0;\n      DCHECK_EQ(result.displacement, 0);\n      return result;\n    }\n    return std::nullopt;\n  };\n\n  // Helper to check ((... + ...) + ...)\n  auto match_plus_plus = [&selector, &match_S_plus_plus](OpIndex left,\n                                                         OpIndex right)\n      -> std::optional<BaseWithScaledIndexAndDisplacementMatch> {\n    BaseWithScaledIndexAndDisplacementMatch result;\n    result.displacement_mode = kPositiveDisplacement;\n\n    // Check ((... + ...) + ...)\n    if (const WordBinopOp* left_add =\n            selector->Get(left).TryCast<WordBinopOp>();\n        left_add && left_add->kind == WordBinopOp::Kind::kAdd) {\n      // Check ((S + ...) + ...)\n      auto maybe_res =\n          match_S_plus_plus(left, right, left_add->left(), left_add->right());\n      if (maybe_res) return maybe_res;\n      // Check ((... + S) + ...)\n      maybe_res =\n          match_S_plus_plus(left, right, left_add->right(), left_add->left());\n      if (maybe_res) return maybe_res;\n    }\n\n    return std::nullopt;\n  };\n\n  // Check (S + ...)\n  auto maybe_res = match_S_plus(left, right);\n  if (maybe_res) return maybe_res;\n\n  if (is_commutative) {\n    // Check (... + S)\n    maybe_res = match_S_plus(right, left);\n    if (maybe_res) {\n      return maybe_res;\n    }\n  }\n\n  // Check ((... + ...) + ...)\n  maybe_res = match_plus_plus(left, right);\n  if (maybe_res) return maybe_res;\n\n  if (is_commutative) {\n    // Check (... + (... + ...))\n    maybe_res = match_plus_plus(right, left);\n    if (maybe_res) {\n      return maybe_res;\n    }\n  }\n\n  BaseWithScaledIndexAndDisplacementMatch result;\n  result.displacement_mode = kPositiveDisplacement;\n\n  // Check (B + D)\n  if (selector->MatchSignedIntegralConstant(right, &result.displacement)) {\n    result.base = left;\n    return result;\n  }\n\n  // Treat as (B + B) and use index as left B.\n  result.index = left;\n  result.base = right;\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchBaseWithScaledIndexAndDisplacement64\",\n            \"about\": \"Tries to match a base with a scaled index and displacement for 64-bit operations.\",\n            \"logic\": \"Tries to match various patterns of memory addressing, including scaled index, base, and displacement. Uses the helper function TryMatchBaseWithScaledIndexAndDisplacement64ForWordBinop. Handles LoadOp, StoreOp, and WordBinop.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The IR node to match.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<BaseWithScaledIndexAndDisplacementMatch>\",\n                \"description\": \"A BaseWithScaledIndexAndDisplacementMatch object if a match is found, std::nullopt otherwise.\"\n            },\n            \"dependencies\": [\n                \"BaseWithScaledIndexAndDisplacementMatch\",\n                \"TryMatchBaseWithScaledIndexAndDisplacement64ForWordBinop\",\n                \"COMPRESS_POINTERS_BOOL\",\n                \"GetImmediateIntegerValue\",\n                \"CanBeImmediate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<BaseWithScaledIndexAndDisplacementMatch>\nTryMatchBaseWithScaledIndexAndDisplacement64(InstructionSelectorT* selector,\n                                             OpIndex node) {\n  // The BaseWithIndexAndDisplacementMatcher canonicalizes the order of\n  // displacements and scale factors that are used as inputs, so instead of\n  // enumerating all possible patterns"
}