{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/riscv/instruction-selector-riscv.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/riscv/instruction-selector-riscv.h\",\n            \"file_name\": \"instruction-selector-riscv.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the RISC-V-specific instruction selector for the V8 compiler backend, which translates high-level operations into machine instructions.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard and V8-specific headers for various functionalities like optional types, bit manipulation, logging, code generation, compiler structures, turboshaft operations, flag definitions, and namespace management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n\n            #include \"src/base/bits.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/codegen/machine-type.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/compiler/backend/instruction-codes.h\"\n            #include \"src/compiler/backend/instruction-selector-impl.h\"\n            #include \"src/compiler/backend/instruction-selector.h\"\n            #include \"src/compiler/machine-operator.h\"\n            #include \"src/compiler/turboshaft/operation-matcher.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/opmasks.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/flags/flags.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RiscvOperandGeneratorT\",\n                \"extends\": \"OperandGeneratorT\",\n                \"about\": \"A specialized operand generator for RISC-V architecture, providing methods to create InstructionOperands suitable for RISC-V instructions.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"InstructionSelectorT\",\n                    \"ConstantOp\",\n                    \"RootsTable\",\n                    \"Handle\",\n                    \"HeapObject\",\n                    \"RootIndex\",\n                    \"MacroAssemblerBase\",\n                    \"OptionalOpIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class RiscvOperandGeneratorT final : public OperandGeneratorT {\n            public:\n            explicit RiscvOperandGeneratorT(InstructionSelectorT* selector)\n                : OperandGeneratorT(selector) {}\n\n            InstructionOperand UseOperand(OpIndex node, InstructionCode opcode) {\n                if (CanBeImmediate(node, opcode)) {\n                return UseImmediate(node);\n                }\n                return UseRegister(node);\n            }\n\n            // Use the zero register if the node has the immediate value zero, otherwise\n            // assign a register.\n            InstructionOperand UseRegisterOrImmediateZero(OpIndex node) {\n                if (const ConstantOp* constant =\n                        selector()->Get(node).TryCast<ConstantOp>()) {\n                if ((constant->IsIntegral() && constant->integral() == 0) ||\n                    (constant->kind == ConstantOp::Kind::kFloat32 &&\n                    constant->float32().get_bits() == 0) ||\n                    (constant->kind == ConstantOp::Kind::kFloat64 &&\n                    constant->float64().get_bits() == 0))\n                    return UseImmediate(node);\n                }\n                return UseRegister(node);\n            }\n\n            bool IsIntegerConstant(OpIndex node) {\n                int64_t unused;\n                return selector()->MatchSignedIntegralConstant(node, &unused);\n            }\n\n            bool IsIntegerConstant(OptionalOpIndex node) {\n                return node.has_value() && IsIntegerConstant(node.value());\n            }\n\n            std::optional<int64_t> GetOptionalIntegerConstant(OpIndex operation) {\n                if (int64_t constant; MatchSignedIntegralConstant(operation, &constant)) {\n                return constant;\n                }\n                return std::nullopt;\n            }\n\n            bool CanBeZero(OpIndex node) { return MatchZero(node); }\n\n            bool CanBeImmediate(OpIndex node, InstructionCode mode) {\n                const ConstantOp* constant = selector()->Get(node).TryCast<ConstantOp>();\n                if (!constant) return false;\n                if (constant->kind == ConstantOp::Kind::kCompressedHeapObject) {\n                if (!COMPRESS_POINTERS_BOOL) return false;\n                // For builtin code we need static roots\n                if (selector()->isolate()->bootstrapper() && !V8_STATIC_ROOTS_BOOL) {\n                    return false;\n                }\n                const RootsTable& roots_table = selector()->isolate()->roots_table();\n                RootIndex root_index;\n                Handle<HeapObject> value = constant->handle();\n                if (roots_table.IsRootHandle(value, &root_index)) {\n                    if (!RootsTable::IsReadOnly(root_index)) return false;\n                    return CanBeImmediate(MacroAssemblerBase::ReadOnlyRootPtr(\n                                        root_index, selector()->isolate()),\n                                    mode);\n                }\n                return false;\n                }\n\n                int64_t value;\n                return selector()->MatchSignedIntegralConstant(node, &value) &&\n                    CanBeImmediate(value, mode);\n            }\n\n            bool CanBeImmediate(int64_t value, InstructionCode opcode);\n\n            private:\n            bool ImmediateFitsAddrMode1Instruction(int32_t imm) const {\n                TRACE(\"UNIMPLEMENTED instr_sel: %s at line %d\\n\", __FUNCTION__, __LINE__);\n                return false;\n            }\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitRR\",\n                \"about\": \"Emits a RISC-V instruction that takes two registers as operands.\",\n                \"logic\": \"The function takes an InstructionSelectorT pointer, an ArchOpcode/InstructionCode, and an OpIndex. It defines the destination register using DefineAsRegister and uses the register from input at index 0.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"ArchOpcode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"ArchOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void VisitRR(InstructionSelectorT* selector, ArchOpcode opcode, OpIndex node) {\n            RiscvOperandGeneratorT g(selector);\n            selector->Emit(opcode, g.DefineAsRegister(node),\n                        g.UseRegister(selector->input_at(node, 0)));\n            }\n\n            void VisitRR(InstructionSelectorT* selector, InstructionCode opcode,\n                OpIndex node) {\n            RiscvOperandGeneratorT g(selector);\n            selector->Emit(opcode, g.DefineAsRegister(node),\n                        g.UseRegister(selector->input_at(node, 0)));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitRRI\",\n                \"about\": \"Emits a RISC-V instruction that takes two registers and an immediate value as operands.\",\n                \"logic\": \"The function retrieves the lane value from the Simd128ExtractLaneOp and uses it as an immediate operand.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"ArchOpcode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"ArchOpcode\",\n                    \"Simd128ExtractLaneOp\",\n                    \"Operation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static void VisitRRI(InstructionSelectorT* selector, ArchOpcode opcode,\n                        OpIndex node) {\n            RiscvOperandGeneratorT g(selector);\n            const Operation& op = selector->Get(node);\n            int imm = op.template Cast<Simd128ExtractLaneOp>().lane;\n            selector->Emit(opcode, g.DefineAsRegister(node), g.UseRegister(op.input(0)),\n                        g.UseImmediate(imm));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitSimdShift\",\n                \"about\": \"Emits a RISC-V SIMD shift instruction. Checks if the shift amount is a constant and uses an immediate if possible, otherwise uses a register.\",\n                \"logic\": \"The function checks if the right-hand side (shift amount) is a constant. If it is, it uses UseImmediate for the shift amount; otherwise, it uses UseRegister.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"ArchOpcode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"ArchOpcode\",\n                    \"ConstantOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static void VisitSimdShift(InstructionSelectorT* selector, ArchOpcode opcode,\n                                OpIndex node) {\n            RiscvOperandGeneratorT g(selector);\n            OpIndex rhs = selector->input_at(node, 1);\n            if (selector->Get(rhs).TryCast<ConstantOp>()) {\n                selector->Emit(opcode, g.DefineAsRegister(node),\n                            g.UseRegister(selector->input_at(node, 0)),\n                            g.UseImmediate(selector->input_at(node, 1)));\n            } else {\n                selector->Emit(opcode, g.DefineAsRegister(node),\n                            g.UseRegister(selector->input_at(node, 0)),\n                            g.UseRegister(selector->input_at(node, 1)));\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitRRIR\",\n                \"about\": \"Emits a RISC-V instruction that takes two registers, an immediate, and a unique register as operands.\",\n                \"logic\": \"The function retrieves the lane value from the Simd128ReplaceLaneOp and uses it as an immediate operand. It uses UseUniqueRegister for the last register operand to avoid register conflicts.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"ArchOpcode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"ArchOpcode\",\n                    \"Simd128ReplaceLaneOp\",\n                    \"Operation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static void VisitRRIR(InstructionSelectorT* selector, ArchOpcode opcode,\n                            OpIndex node) {\n            RiscvOperandGeneratorT g(selector);\n            const turboshaft::Simd128ReplaceLaneOp& op =\n                selector->Get(node).template Cast<turboshaft::Simd128ReplaceLaneOp>();\n            selector->Emit(opcode, g.DefineAsRegister(node), g.UseRegister(op.input(0)),\n                        g.UseImmediate(op.lane), g.UseUniqueRegister(op.input(1)));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitRRR\",\n                \"about\": \"Emits a RISC-V instruction that takes three registers as operands.\",\n                \"logic\": \"The function uses UseRegister for all three register operands and defines the destination register using DefineAsRegister.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"InstructionCode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    },\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"OperandGeneratorT::RegisterUseKind\",\n                        \"purpose\": \"Hint for register allocation\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"InstructionCode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void VisitRRR(InstructionSelectorT* selector, InstructionCode opcode,\n                OpIndex node,\n                typename OperandGeneratorT::RegisterUseKind kind =\n                    OperandGeneratorT::RegisterUseKind::kUseRegister) {\n            RiscvOperandGeneratorT g(selector);\n            selector->Emit(opcode, g.DefineAsRegister(node),\n                        g.UseRegister(selector->input_at(node, 0)),\n                        g.UseRegister(selector->input_at(node, 1), kind));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitUniqueRRR\",\n                \"about\": \"Emits a RISC-V instruction that takes three registers as operands, using unique registers for the inputs.\",\n                \"logic\": \"The function uses UseUniqueRegister for all three register operands and defines the destination register using DefineAsRegister. This is used when the input registers must be distinct from the output register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"ArchOpcode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"ArchOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static void VisitUniqueRRR(InstructionSelectorT* selector, ArchOpcode opcode,\n                                OpIndex node) {\n            RiscvOperandGeneratorT g(selector);\n            selector->Emit(opcode, g.DefineAsRegister(node),\n                        g.UseUniqueRegister(selector->input_at(node, 0)),\n                        g.UseUniqueRegister(selector->input_at(node, 1)));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitRRRR\",\n                \"about\": \"Emits a RISC-V instruction that takes four registers as operands.\",\n                \"logic\": \"The function uses UseRegister for all four register operands and defines the destination register to be the same as the first source register using DefineSameAsFirst.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"ArchOpcode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"ArchOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void VisitRRRR(InstructionSelectorT* selector, ArchOpcode opcode,\n                OpIndex node) {\n            RiscvOperandGeneratorT g(selector);\n            selector->Emit(opcode, g.DefineSameAsFirst(node),\n                        g.UseRegister(selector->input_at(node, 0)),\n                        g.UseRegister(selector->input_at(node, 1)),\n                        g.UseRegister(selector->input_at(node, 2)));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitRRO\",\n                \"about\": \"Emits a RISC-V instruction that takes a register and an operand.\",\n                \"logic\": \"The function takes an InstructionSelectorT pointer, an ArchOpcode, and an OpIndex. It defines the destination register using DefineAsRegister, uses a register from input at index 0 and uses the operand at input index 1.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"ArchOpcode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"ArchOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static void VisitRRO(InstructionSelectorT* selector, ArchOpcode opcode,\n                        OpIndex node) {\n            RiscvOperandGeneratorT g(selector);\n            selector->Emit(opcode, g.DefineAsRegister(node),\n                        g.UseRegister(selector->input_at(node, 0)),\n                        g.UseOperand(selector->input_at(node, 1), opcode));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TryMatchImmediate\",\n                \"about\": \"Attempts to match an immediate operand for a RISC-V instruction.\",\n                \"logic\": \"Checks if a node can be represented as an immediate value. If so, it modifies the opcode to indicate MRI addressing mode and returns true, providing the immediate operand.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"opcode_return\",\n                        \"type\": \"InstructionCode*\",\n                        \"purpose\": \"Pointer to the opcode to modify.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    },\n                    {\n                        \"name\": \"input_count_return\",\n                        \"type\": \"size_t*\",\n                        \"purpose\": \"Pointer to store the number of inputs.\"\n                    },\n                    {\n                        \"name\": \"inputs\",\n                        \"type\": \"InstructionOperand*\",\n                        \"purpose\": \"Array to store the immediate operand.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if an immediate was matched, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"InstructionCode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool TryMatchImmediate(InstructionSelectorT* selector,\n                        InstructionCode* opcode_return, OpIndex node,\n                        size_t* input_count_return, InstructionOperand* inputs) {\n            RiscvOperandGeneratorT g(selector);\n            if (g.CanBeImmediate(node, *opcode_return)) {\n                *opcode_return |= AddressingModeField::encode(kMode_MRI);\n                inputs[0] = g.UseImmediate(node);\n                *input_count_return = 1;\n                return true;\n            }\n            return false;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"VisitBinop\",\n                \"about\": \"Shared routine for multiple binary operations. Tries to match immediate operands.\",\n                \"logic\": \"The function attempts to match immediate operands for either the left or right input nodes, and emits the corresponding instruction. It also handles flags continuations for deoptimization.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"InstructionCode\",\n                        \"purpose\": \"The RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"has_reverse_opcode\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether there is a reverse opcode.\"\n                    },\n                    {\n                        \"name\": \"reverse_opcode\",\n                        \"type\": \"InstructionCode\",\n                        \"purpose\": \"The reverse RISC-V opcode.\"\n                    },\n                    {\n                        \"name\": \"cont\",\n                        \"type\": \"FlagsContinuationT*\",\n                        \"purpose\": \"Flags continuation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\",\n                    \"OpIndex\",\n                    \"InstructionCode\",\n                    \"FlagsContinuationT\",\n                    \"Operation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename Matcher>\n            static void VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                        InstructionCode opcode, bool has_reverse_opcode,\n                        InstructionCode reverse_opcode,\n                        FlagsContinuationT* cont) {\n            RiscvOperandGeneratorT g(selector);\n            InstructionOperand inputs[2];\n            size_t input_count = 0;\n            InstructionOperand outputs[1];\n            size_t output_count = 0;\n\n            const Operation& binop = selector->Get(node);\n            OpIndex left_node = binop.input(0);\n            OpIndex right_node = binop.input(1);\n\n            if (TryMatchImmediate(selector, &opcode, right_node, &input_count,\n                                &inputs[1])) {\n                inputs[0] = g.UseRegisterOrImmediateZero(left_node);\n                input_count++;\n            } else if (has_reverse_opcode &&\n                        TryMatchImmediate(selector, &reverse_opcode, left_node,\n                                        &input_count, &inputs[1])) {\n                inputs[0] = g.UseRegisterOrImmediateZero(right_node);\n                opcode = reverse_opcode;\n                input_count++;\n            } else {\n                inputs[input_count++] = g.UseRegister(left_node);\n                inputs[input_count++] = g.UseOperand(right_node, opcode);\n            }\n\n            if (cont->IsDeoptimize()) {\n                // If we can deoptimize as a result of the binop, we need to make sure that\n                // the deopt inputs are not overwritten by the binop result. One way\n                // to achieve that is to declare the output register as same-as-first.\n                outputs[output_count++] = g.DefineSameAsFirst(node);\n            } else {\n                outputs[output_count++] = g.DefineAsRegister(node);\n            }\n\n            DCHECK_NE(0u, input_count);\n            DCHECK_EQ(1u, output_count);\n            DCHECK_GE(arraysize(inputs), input_count);\n            DCHECK_GE(arraysize(outputs), output_count);\n\n            selector->EmitWithContinuation(opcode, output_count, outputs, input_count,\n                                        inputs, cont);\n            }\n\n            template <typename Matcher>\n            static void VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                        InstructionCode opcode, bool has_reverse_opcode,\n                        InstructionCode reverse_opcode) {\n            FlagsContinuationT cont;\n            VisitBinop<Matcher>(selector, node, opcode, has_reverse_opcode,\n                                reverse_opcode, &cont);\n            }\n\n            template <typename Matcher>\n            static void VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                        InstructionCode opcode, FlagsContinuationT* cont) {\n            VisitBinop<Matcher>(selector, node, opcode, false, kArchNop, cont);\n            }\n\n            template <typename Matcher>\n            static void VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                        InstructionCode opcode) {\n            VisitBinop<Matcher>(selector, node, opcode, false, kArchNop);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitStackSlot\",\n                \"parent\": \"InstructionSelectorT\",\n                \"about\": \"Visits a stack slot node.\",\n                \"logic\": \"Allocates a spill slot in the frame and emits an instruction to access it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"StackSlotOp\",\n                    \"OperandGenerator\",\n                    \"frame_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void InstructionSelectorT::VisitStackSlot(OpIndex node) {\n            const StackSlotOp& stack_slot = Cast<StackSlotOp>(node);\n            int slot = frame_->AllocateSpillSlot(stack_slot.size, stack_slot.alignment,\n                                        stack_slot.is_tagged);\n            OperandGenerator g(this);\n\n            Emit(kArchStackSlot, g.DefineAsRegister(node),\n                sequence()->AddImmediate(Constant(slot)), 0, nullptr);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitAbortCSADcheck\",\n                \"parent\": \"InstructionSelectorT\",\n                \"about\": \"Emits an instruction to abort a CSAD check.\",\n                \"logic\": \"Emits kArchAbortCSADcheck with input at index 0 in register a0.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\",\n                    \"InstructionSelectorT\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void InstructionSelectorT::VisitAbortCSADcheck(OpIndex node) {\n            RiscvOperandGeneratorT g(this);\n            Emit(kArchAbortCSADcheck, g.NoOutput(),\n                g.UseFixed(this->input_at(node, 0), a0));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"EmitS128Load\",\n                \"about\": \"Helper function to emit S128 load instructions\",\n                \"logic\": \"Emits S128 load instructions with specified opcode, VSew, and Vlmul\",\n                \"parameters\": [\n                    {\n                        \"name\": \"selector\",\n                        \"type\": \"InstructionSelectorT*\",\n                        \"purpose\": \"The instruction selector.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    },\n                    {\n                        \"name\": \"opcode\",\n                        \"type\": \"InstructionCode\",\n                        \"purpose\": \"The instruction code.\"\n                    },\n                    {\n                        \"name\": \"sew\",\n                        \"type\": \"VSew\",\n                        \"purpose\": \"The vector sew.\"\n                    },\n                    {\n                        \"name\": \"lmul\",\n                        \"type\": \"Vlmul\",\n                        \"purpose\": \"The vector lmul.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RiscvOperandGeneratorT\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void EmitS128Load(InstructionSelectorT* selector, OpIndex node,\n                        InstructionCode opcode, VSew sew, Vlmul lmul);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitLoadTransform\",\n                \"parent\": \"InstructionSelectorT\",\n                \"about\": \"Visits a SIMD 128-bit load transform operation.\",\n                \"logic\": \"Selects the appropriate RISC-V instruction based on the transform kind and emits the instruction.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The node being visited.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Simd128LoadTransformOp\",\n                    \"RiscvOperandGeneratorT\",\n                    \"EmitS128Load\",\n                    \"UNIMPLEMENTED\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void InstructionSelectorT::VisitLoadTransform(OpIndex node) {\n            const Simd128LoadTransformOp& op =\n                this->Get(node).Cast<Simd128LoadTransformOp>();\n            bool is_protected = (op.load_kind.with_trap_handler);\n            InstructionCode opcode = kArchNop;\n            switch (op.transform_kind) {\n                case Simd128LoadTransformOp::TransformKind::k8Splat:\n                opcode = kRiscvS128LoadSplat;\n                if (is_protected) {\n                    opcode |= AccessModeField::encode(kMemoryAccessProtectedMemOutOfBounds);\n                }\n                EmitS128Load(this, node, opcode, E8, m1);\n                break;\n                case Simd128LoadTransformOp::TransformKind::k16Splat:\n                opcode = kRiscvS128LoadSplat;\n                if (is_protected) {\n                    opcode |= AccessModeField::encode(kMemoryAccessProtectedMemOutOfBounds);\n                }\n                EmitS128Load(this, node, opcode, E16, m1);\n                break;\n                case Simd128LoadTransformOp::TransformKind::k32Splat:\n                opcode = kRiscvS128LoadSplat;\n                if (is_protected) {\n                    opcode |= AccessModeField::encode(kMemoryAccessProtectedMemOutOfBounds);\n                }\n                EmitS128Load(this, node, opcode, E"
}