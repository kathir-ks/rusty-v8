// Converted from V8 C++ source files:
// Header: embedded-file-writer.h
// Implementation: embedded-file-writer.cc
// 
// This file combines both header and implementation into idiomatic Rust code.

// src/snapshot/embedded/embedded-file-writer.h
pub mod embedded_file_writer {
    use crate::base::platform::wrappers::Fclose;
    use crate::base::strings::EmbeddedVector;
    use crate::common::globals::kDefaultEmbeddedVariant;
    use crate::objects::code_inl::Code;
    use crate::snapshot::embedded::embedded_data::EmbeddedData;
    use crate::snapshot::embedded::embedded_file_writer_interface::EmbeddedFileWriterInterface;
    use crate::snapshot::embedded::platform_embedded_file_writer_base::{
        DataDirective, PlatformEmbeddedFileWriterBase,
    };
    use crate::Builtin;
    use crate::Builtins;
    use crate::Isolate;
    use crate::SourcePositionTable;
    use crate::TrustedByteArray;
    use std::collections::HashMap;
    use std::fs::File;
    use std::io::Write;
    use std::path::Path;
    use std::ptr;
    use std::slice;
    use std::str;
    use win64_unwindinfo::BuiltinUnwindInfo;

    #[cfg(target_os = "windows")]
    use std::os::windows::io::{AsRawHandle, RawHandle};

    pub struct LabelInfo {
        pub offset: u32,
        pub name: String,
    }

    #[cfg(target_os = "windows")]
    mod win64_unwindinfo {
        pub struct BuiltinUnwindInfo {}
    }

    pub struct EmbeddedFileWriter {
        source_positions: [Vec<u8>; Builtins::kBuiltinCount],
        label_info: [Vec<LabelInfo>; Builtins::kBuiltinCount],

        #[cfg(target_os = "windows")]
        unwind_infos: [win64_unwindinfo::BuiltinUnwindInfo; Builtins::kBuiltinCount],

        external_filenames: HashMap<String, i32>,
        external_filenames_by_index: Vec<String>,

        // The file to generate or nullptr.
        embedded_src_path: Option<String>,

        // The variant is only used in multi-snapshot builds and otherwise set to
        // "Default".
        embedded_variant: String,

        // {target_arch} and {target_os} control the generated assembly format. Note
        // these may differ from both host- and target-platforms specified through
        // e.g. V8_OS_* and V8_TARGET_ARCH_* defines.
        target_arch: Option<String>,
        target_os: Option<String>,
    }

    impl EmbeddedFileWriter {
        pub fn new() -> Self {
            EmbeddedFileWriter {
                source_positions: [(); Builtins::kBuiltinCount].map(|_| Vec::new()),
                label_info: [(); Builtins::kBuiltinCount].map(|_| Vec::new()),

                #[cfg(target_os = "windows")]
                unwind_infos: [win64_unwindinfo::BuiltinUnwindInfo {}; Builtins::kBuiltinCount],

                external_filenames: HashMap::new(),
                external_filenames_by_index: Vec::new(),
                embedded_src_path: None,
                embedded_variant: kDefaultEmbeddedVariant.to_string(),
                target_arch: None,
                target_os: None,
            }
        }

        fn maybe_write_embedded_file(&self, blob: &EmbeddedData) -> Result<(), std::io::Error> {
            if self.embedded_src_path.is_none() {
                return Ok(());
            }

            let embedded_src_path = self.embedded_src_path.as_ref().unwrap();
            let mut fp = self.get_file_descriptor_or_die(embedded_src_path)?;

            let mut writer = self.new_platform_embedded_file_writer();
            writer.set_file(Box::new(fp));

            self.write_file_prologue(&mut writer);
            self.write_external_filenames(&mut writer);
            self.write_data_section(&mut writer, blob)?;
            self.write_code_section(&mut writer, blob)?;
            self.write_file_epilogue(&mut writer, blob)?;

            Ok(())
        }

        #[cfg(not(target_os = "windows"))]
        fn get_file_descriptor_or_die(&self, filename: &str) -> Result<File, std::io::Error> {
            File::create(filename)
        }

        #[cfg(target_os = "windows")]
        fn get_file_descriptor_or_die(&self, filename: &str) -> Result<File, std::io::Error> {
            File::create(filename)
        }

        fn write_file_prologue(&self, w: &mut PlatformEmbeddedFileWriterBase) {
            w.comment("Autogenerated file. Do not edit.");
            w.newline();
            w.file_prologue();
        }

        fn write_external_filenames(&self, w: &mut PlatformEmbeddedFileWriterBase) {
            w.comment("Source positions in the embedded blob refer to filenames by id.");
            w.comment("Assembly directives here map the id to a filename.");
            w.newline();

            // Write external filenames.
            let size = self.external_filenames_by_index.len();
            for i in 0..size {
                w.declare_external_filename(
                    self.external_filename_index_to_id(i),
                    self.external_filenames_by_index[i].as_str(),
                );
            }
        }

        // Fairly arbitrary but should fit all symbol names.
        const K_TEMPORARY_STRING_LENGTH: usize = 256;

        fn embedded_blob_code_symbol(&self) -> String {
            let mut embedded_blob_code_symbol: EmbeddedVector<char, { Self::K_TEMPORARY_STRING_LENGTH }> =
                EmbeddedVector::new();
            let format_string = format!("v8_{}_embedded_blob_code_", self.embedded_variant);
            for (i, c) in format_string.chars().enumerate() {
                embedded_blob_code_symbol.push(c);
            }

            embedded_blob_code_symbol.to_string()
        }

        fn embedded_blob_data_symbol(&self) -> String {
            let mut embedded_blob_data_symbol: EmbeddedVector<char, { Self::K_TEMPORARY_STRING_LENGTH }> =
                EmbeddedVector::new();
            let format_string = format!("v8_{}_embedded_blob_data_", self.embedded_variant);
            for (i, c) in format_string.chars().enumerate() {
                embedded_blob_data_symbol.push(c);
            }
            embedded_blob_data_symbol.to_string()
        }

        fn write_data_section(
            &self,
            w: &mut PlatformEmbeddedFileWriterBase,
            blob: &EmbeddedData,
        ) -> Result<(), std::io::Error> {
            w.comment("The embedded blob data section starts here.");
            w.section_ro_data();
            w.align_to_data_alignment();
            w.declare_symbol_global(self.embedded_blob_data_symbol().as_str());
            w.declare_label_prolog(self.embedded_blob_data_symbol().as_str());
            w.declare_label(self.embedded_blob_data_symbol().as_str());

            Self::write_binary_contents_as_inline_assembly(w, blob.data(), blob.data_size())?;
            w.declare_label_epilogue();
            w.newline();
            Ok(())
        }

        fn write_builtin(
            &self,
            w: &mut PlatformEmbeddedFileWriterBase,
            blob: &EmbeddedData,
            builtin: Builtin,
        ) -> Result<(), std::io::Error> {
            let is_default_variant = self.embedded_variant == kDefaultEmbeddedVariant;

            let builtin_symbol_name = if is_default_variant {
                format!("Builtins_{}", Builtins::name(builtin))
            } else {
                format!("{}_Builtins_{}", self.embedded_variant, Builtins::name(builtin))
            };

            w.declare_function_begin(
                builtin_symbol_name.as_str(),
                blob.instruction_size_of(builtin),
            );
            let builtin_id = builtin as usize;
            let current_positions = &self.source_positions[builtin_id];
            // The code below interleaves bytes of assembly code for the builtin
            // function with source positions at the appropriate offsets.
            let vpos = current_positions.as_slice();
            let mut positions = SourcePositionTableIterator::new(vpos, SourcePositionTableIteratorMode::ExternalOnly);

            let current_labels = &self.label_info[builtin_id];
            let mut label = current_labels.iter();

            let data = blob.instruction_start_of(builtin) as *const u8;
            let data = unsafe { slice::from_raw_parts(data, blob.padded_instruction_size_of(builtin) as usize) };
            let size = blob.padded_instruction_size_of(builtin);
            let mut i: u32 = 0;
            let mut next_source_pos_offset =
                if positions.done() { size } else { positions.code_offset() as u32 };
            let mut next_label_offset = match label.next() {
                Some(l) => l.offset,
                None => size,
            };

            while i < size {
                if i == next_source_pos_offset {
                    // Write source directive.

                    if let Some(filename) = self.get_externally_compiled_filename(positions.source_position().external_file_id()) {
                        w.source_info(
                            positions.source_position().external_file_id(),
                            filename,
                            positions.source_position().external_line(),
                        );
                    }
                    positions.advance();
                    next_source_pos_offset =
                        if positions.done() { size } else { positions.code_offset() as u32 };
                }

                if i == next_label_offset {
                    if let Some(label_info) = label.next() {
                        self.write_builtin_labels(w, label_info.name.clone())?;
                        next_label_offset = match label.next() {
                            Some(l) => l.offset,
                            None => size,
                        };
                    }
                }
                let next_offset = std::cmp::min(next_source_pos_offset, next_label_offset);
                Self::write_binary_contents_as_inline_assembly(w, &data[i as usize..next_offset as usize], next_offset - i)?;
                i = next_offset;
            }
            w.declare_function_end(builtin_symbol_name.as_str());
            Ok(())
        }

        fn write_builtin_labels(
            &self,
            w: &mut PlatformEmbeddedFileWriterBase,
            name: String,
        ) -> Result<(), std::io::Error> {
            w.declare_label(name.as_str());
            Ok(())
        }

        fn write_code_section(
            &self,
            w: &mut PlatformEmbeddedFileWriterBase,
            blob: &EmbeddedData,
        ) -> Result<(), std::io::Error> {
            w.comment("The embedded blob code section starts here. It contains the builtin");
            w.comment("instruction streams.");
            w.section_text();

            w.align_to_code_alignment();
            w.declare_symbol_global(self.embedded_blob_code_symbol().as_str());
            w.declare_label_prolog(self.embedded_blob_code_symbol().as_str());
            w.declare_label(self.embedded_blob_code_symbol().as_str());

            for embedded_index in 0..Builtins::kBuiltinCount {
                let builtin = blob.get_builtin_id(embedded_index);
                self.write_builtin(w, blob, builtin)?;
            }
            w.align_to_page_size_if_needed();
            w.declare_label_epilogue();
            w.newline();
            Ok(())
        }

        fn write_file_epilogue(
            &self,
            w: &mut PlatformEmbeddedFileWriterBase,
            blob: &EmbeddedData,
        ) -> Result<(), std::io::Error> {
            {
                let mut embedded_blob_code_size_symbol: EmbeddedVector<char, { Self::K_TEMPORARY_STRING_LENGTH }> =
                    EmbeddedVector::new();
                let format_string = format!("v8_{}_embedded_blob_code_size_", self.embedded_variant);
                for (i, c) in format_string.chars().enumerate() {
                    embedded_blob_code_size_symbol.push(c);
                }

                w.comment("The size of the embedded blob code in bytes.");
                w.section_ro_data();
                w.align_to_data_alignment();
                w.declare_uint32(
                    embedded_blob_code_size_symbol.begin(),
                    blob.code_size(),
                );
                w.newline();

                let mut embedded_blob_data_size_symbol: EmbeddedVector<char, { Self::K_TEMPORARY_STRING_LENGTH }> =
                    EmbeddedVector::new();
                let format_string = format!("v8_{}_embedded_blob_data_size_", self.embedded_variant);
                for (i, c) in format_string.chars().enumerate() {
                    embedded_blob_data_size_symbol.push(c);
                }

                w.comment("The size of the embedded blob data section in bytes.");
                w.declare_uint32(
                    embedded_blob_data_size_symbol.begin(),
                    blob.data_size(),
                );
                w.newline();
            }

            w.file_epilogue();
            Ok(())
        }

        // static
        fn write_binary_contents_as_inline_assembly(
            w: &mut PlatformEmbeddedFileWriterBase,
            data: &[u8],
            size: u32,
        ) -> Result<(), std::io::Error> {
            let mut current_line_length: i32 = 0;
            let mut i: u32 = 0;

            // Begin by writing out byte chunks.
            let directive: DataDirective = w.byte_chunk_data_directive();
            let byte_chunk_size: i32 = w.data_directive_size(directive) as i32;

            while (i as i32) + byte_chunk_size < size as i32 {
                current_line_length =
                    write_directive_or_separator(w, current_line_length, directive) as i32;
                let chunk_data = &data[i as usize..(i as i32 + byte_chunk_size) as usize];
                current_line_length += w.write_byte_chunk(chunk_data) as i32;
                current_line_length =
                    write_line_end_if_needed(w, current_line_length, byte_chunk_size as usize) as i32;
                i += byte_chunk_size as u32;
            }
            if current_line_length != 0 {
                w.newline();
            }
            current_line_length = 0;

            // Write any trailing bytes one-by-one.
            while i < size {
                current_line_length = write_directive_or_separator(w, current_line_length, DataDirective::Byte) as i32;
                current_line_length += w.hex_literal(data[i as usize]) as i32;
                current_line_length = write_line_end_if_needed(w, current_line_length, 1) as i32;
                i += 1;
            }

            if current_line_length != 0 {
                w.newline();
            }
            Ok(())
        }

        // In assembly directives, filename ids need to begin with 1.
        const K_FIRST_EXTERNAL_FILENAME_ID: i32 = 1;

        fn external_filename_index_to_id(&self, index: usize) -> i32 {
            Self::K_FIRST_EXTERNAL_FILENAME_ID + index as i32
        }
        fn external_filename_id_to_index(&self, id: i32) -> i32 {
            id - Self::K_FIRST_EXTERNAL_FILENAME_ID
        }
    }

    impl EmbeddedFileWriterInterface for EmbeddedFileWriter {
        fn lookup_or_add_externally_compiled_filename(&mut self, filename: &str) -> i32 {
            if let Some(id) = self.external_filenames.get(filename) {
                return *id;
            }

            let new_id = self.external_filename_index_to_id(self.external_filenames.len());
            self.external_filenames
                .insert(filename.to_string(), new_id);
            self.external_filenames_by_index.push(filename.to_string());
            new_id
        }

        fn get_externally_compiled_filename(&self, fileid: i32) -> Option<&str> {
            let index = self.external_filename_id_to_index(fileid) as usize;

            if index < self.external_filenames_by_index.len() {
                Some(self.external_filenames_by_index[index].as_str())
            } else {
                None
            }
        }

        fn get_externally_compiled_filename_count(&self) -> i32 {
            self.external_filenames.len() as i32
        }

        fn prepare_builtin_source_position_map(&mut self, builtins: &mut Builtins) {
            for builtin in Builtins::kFirst..=Builtins::kLast {
                // Retrieve the SourcePositionTable and copy it.
                let code = builtins.code(builtin);
                if !code.has_source_position_table() {
                    continue;
                }
                let source_position_table = code.source_position_table();
                let data: Vec<u8> = source_position_table.to_vec();
                self.source_positions[builtin as usize] = data;
            }
        }
    }

    impl EmbeddedFileWriter {
        pub fn set_embedded_file(&mut self, embedded_src_path: &str) {
            self.embedded_src_path = Some(embedded_src_path.to_string());
        }

        pub fn set_embedded_variant(&mut self, embedded_variant: Option<&str>) {
            if let Some(variant) = embedded_variant {
                self.embedded_variant = variant.to_string();
            }
        }

        pub fn set_target_arch(&mut self, target_arch: &str) {
            self.target_arch = Some(target_arch.to_string());
        }

        pub fn set_target_os(&mut self, target_os: &str) {
            self.target_os = Some(target_os.to_string());
        }

        pub fn write_embedded(&self, blob: &EmbeddedData) -> Result<(), std::io::Error> {
            self.maybe_write_embedded_file(blob)
        }

        fn new_platform_embedded_file_writer(&self) -> PlatformEmbeddedFileWriterBase {
            PlatformEmbeddedFileWriterBase::new()
        }
    }

    fn write_directive_or_separator(
        w: &mut PlatformEmbeddedFileWriterBase,
        current_line_length: i32,
        directive: DataDirective,
    ) -> usize {
        if current_line_length == 0 {
            w.indented_data_directive(directive)
        } else {
            w.fp().write(b",").unwrap();
            1
        }
    }

    fn write_line_end_if_needed(
        w: &mut PlatformEmbeddedFileWriterBase,
        current_line_length: i32,
        write_size: usize,
    ) -> usize {
        const K_TEXT_WIDTH: usize = 100;
        if (current_line_length as usize) + 3 + write_size * 2 > K_TEXT_WIDTH {
            w.fp().write(b"\n").unwrap();
            0
        } else {
            current_line_length as usize
        }
    }

    pub enum SourcePositionTableIteratorMode {
        ExternalOnly,
    }

    pub struct SourcePositionTableIterator<'a> {
        data: &'a [u8],
        offset: usize,
        mode: SourcePositionTableIteratorMode,
    }

    impl<'a> SourcePositionTableIterator<'a> {
        pub fn new(data: &'a [u8], mode: SourcePositionTableIteratorMode) -> Self {
            SourcePositionTableIterator { data, offset: 0, mode }
        }

        pub fn advance(&mut self) {
            if !self.done() {
                self.offset += 4;
            }
        }

        pub fn done(&self) -> bool {
            self.offset >= self.data.len()
        }

        pub fn code_offset(&self) -> usize {
            self.offset
        }

        pub fn source_position(&self) -> SourcePosition {
            let file_id = self.data[self.offset] as i32;
            let line = u16::from_le_bytes([self.data[self.offset + 1], self.data[self.offset + 2]]) as i32;
            SourcePosition {
                external_file_id: file_id,
                external_line: line,
            }
        }
    }

    pub struct SourcePosition {
        pub external_file_id: i32,
        pub external_line: i32,
    }
}

// src/snapshot/embedded/embedded-file-writer.cc
pub mod win64_unwindinfo {
    pub struct BuiltinUnwindInfo {}
}
