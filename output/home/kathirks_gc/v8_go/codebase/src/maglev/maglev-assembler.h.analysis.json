{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/maglev/maglev-assembler.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/maglev/maglev-assembler.h\",\n  \"imports\": [\n    \"src/codegen/machine-type.h\",\n    \"src/codegen/macro-assembler.h\",\n    \"src/common/globals.h\",\n    \"src/flags/flags.h\",\n    \"src/interpreter/bytecode-flags-and-tokens.h\",\n    \"src/maglev/maglev-code-gen-state.h\",\n    \"src/maglev/maglev-ir.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"ZoneLabelRef\",\n      \"properties\": [\n        \"label_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ZoneLabelRef\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor that creates a new ZoneLabelRef with a zone-allocated label.\"\n        },\n        {\n          \"name\": \"ZoneLabelRef\",\n          \"parameters\": [\n            \"MaglevAssembler* masm\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor that creates a new ZoneLabelRef with a label allocated within the MaglevAssembler's compilation zone.\"\n        },\n        {\n          \"name\": \"UnsafeFromLabelPointer\",\n          \"parameters\": [\n            \"Label* label\"\n          ],\n          \"return_type\": \"ZoneLabelRef\",\n          \"logic\": \"Creates a ZoneLabelRef from a raw Label pointer, requiring the caller to ensure that the label is zone-allocated. This is an unsafe operation.\"\n        },\n        {\n          \"name\": \"operator*\",\n          \"parameters\": [],\n          \"return_type\": \"Label*\",\n          \"logic\": \"Returns the underlying Label*.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"StackSlot\",\n      \"properties\": [\n        \"index\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"MapCompare\",\n      \"properties\": [\n        \"masm_\",\n        \"object_\",\n        \"map_count_\",\n        \"map_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"MapCompare\",\n          \"parameters\": [\n            \"MaglevAssembler* masm\",\n            \"Register object\",\n            \"size_t map_count\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor for MapCompare helper class. Initializes the class with the assembler, object register and the map count.\"\n        },\n        {\n          \"name\": \"Generate\",\n          \"parameters\": [\n            \"Handle<Map> map\",\n            \"Condition cond\",\n            \"Label* if_true\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Generates code to compare the map of an object with a given map, and jumps to a label based on the specified condition.\"\n        },\n        {\n          \"name\": \"GetObject\",\n          \"parameters\": [],\n          \"return_type\": \"Register\",\n          \"logic\": \"Returns the register containing the object being compared.\"\n        },\n        {\n          \"name\": \"GetMap\",\n          \"parameters\": [],\n          \"return_type\": \"Register\",\n          \"logic\": \"Returns the register holding the loaded map.\"\n        },\n        {\n          \"name\": \"TemporaryCount\",\n          \"parameters\": [\n            \"size_t map_count\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Calculates the number of temporary registers required for map comparison operations.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MaglevAssembler\",\n      \"properties\": [\n        \"code_gen_state_\",\n        \"scratch_register_scope_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"MaglevAssembler\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"Zone* zone\",\n            \"MaglevCodeGenState* code_gen_state\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor for the MaglevAssembler. Initializes the MacroAssembler and stores the code generation state.\"\n        },\n        {\n          \"name\": \"GetAllocatableRegisters\",\n          \"parameters\": [],\n          \"return_type\": \"RegList\",\n          \"logic\": \"Returns the list of allocatable general-purpose registers for the target architecture. Excludes the extra scratch register on ARM and RISCV64, and the flags register on RISCV64.\"\n        },\n        {\n          \"name\": \"GetFlagsRegister\",\n          \"parameters\": [],\n          \"return_type\": \"Register\",\n          \"logic\": \"Returns the register to store flags, only used on RISCV64 architecture.\"\n        },\n        {\n          \"name\": \"GetAllocatableDoubleRegisters\",\n          \"parameters\": [],\n          \"return_type\": \"DoubleRegList\",\n          \"logic\": \"Returns the list of allocatable double-precision registers.\"\n        },\n        {\n          \"name\": \"GetStackSlot\",\n          \"parameters\": [\n            \"const compiler::AllocatedOperand& operand\"\n          ],\n          \"return_type\": \"MemOperand\",\n          \"logic\": \"Returns a MemOperand representing a stack slot based on the given AllocatedOperand.\"\n        },\n        {\n          \"name\": \"ToMemOperand\",\n          \"parameters\": [\n            \"const compiler::InstructionOperand& operand\"\n          ],\n          \"return_type\": \"MemOperand\",\n          \"logic\": \"Converts an InstructionOperand to a MemOperand.\"\n        },\n        {\n          \"name\": \"ToMemOperand\",\n          \"parameters\": [\n            \"const ValueLocation& location\"\n          ],\n          \"return_type\": \"MemOperand\",\n          \"logic\": \"Converts a ValueLocation to a MemOperand.\"\n        },\n        {\n          \"name\": \"GetFramePointer\",\n          \"parameters\": [],\n          \"return_type\": \"Register\",\n          \"logic\": \"Returns the frame pointer register.\"\n        },\n        {\n          \"name\": \"GetFramePointerOffsetForStackSlot\",\n          \"parameters\": [\n            \"const compiler::AllocatedOperand& operand\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Calculates the offset from the frame pointer for a stack slot, considering whether the slot is tagged or not.\"\n        },\n        {\n          \"name\": \"MoveRepr\",\n          \"parameters\": [\n            \"MachineRepresentation repr\",\n            \"Dest dst\",\n            \"Source src\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Moves data between registers or memory locations, handling different machine representations. Uses a template for generality.\"\n        },\n        {\n          \"name\": \"Allocate\",\n          \"parameters\": [\n            \"RegisterSnapshot register_snapshot\",\n            \"Register result\",\n            \"int size_in_bytes\",\n            \"AllocationType alloc_type\",\n            \"AllocationAlignment alignment\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Allocates a block of memory in the heap of a specified size and type, storing the pointer to the allocated memory in the result register.\"\n        },\n        {\n          \"name\": \"Allocate\",\n          \"parameters\": [\n            \"RegisterSnapshot register_snapshot\",\n            \"Register result\",\n            \"Register size_in_bytes\",\n            \"AllocationType alloc_type\",\n            \"AllocationAlignment alignment\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Allocates a block of memory in the heap of a specified size (given by a register) and type, storing the pointer to the allocated memory in the result register.\"\n        },\n        {\n          \"name\": \"AllocateHeapNumber\",\n          \"parameters\": [\n            \"RegisterSnapshot register_snapshot\",\n            \"Register result\",\n            \"DoubleRegister value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Allocates a HeapNumber object and initializes it with the provided double value.\"\n        },\n        {\n          \"name\": \"AllocateTwoByteString\",\n          \"parameters\": [\n            \"RegisterSnapshot register_snapshot\",\n            \"Register result\",\n            \"int length\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Allocates a two-byte string (UTF-16) of the specified length.\"\n        },\n        {\n          \"name\": \"LoadSingleCharacterString\",\n          \"parameters\": [\n            \"Register result\",\n            \"int char_code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a single-character string for a given character code into the specified register.\"\n        },\n        {\n          \"name\": \"LoadSingleCharacterString\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register char_code\",\n            \"Register scratch\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a single-character string using a register containing the character code. A scratch register is provided for intermediate calculations.\"\n        },\n        {\n          \"name\": \"EnsureWritableFastElements\",\n          \"parameters\": [\n            \"RegisterSnapshot register_snapshot\",\n            \"Register elements\",\n            \"Register object\",\n            \"Register scratch\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Ensures that the elements array of an object is writable in fast mode. May trigger a transition to dictionary elements if necessary.\"\n        },\n        {\n          \"name\": \"BindJumpTarget\",\n          \"parameters\": [\n            \"Label* label\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Binds a jump target (Label) to the current code position.\"\n        },\n        {\n          \"name\": \"BindBlock\",\n          \"parameters\": [\n            \"BasicBlock* block\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Binds a basic block to the current code position.\"\n        },\n        {\n          \"name\": \"IsRootConstant\",\n          \"parameters\": [\n            \"Input input\",\n            \"RootIndex root_index\"\n          ],\n          \"return_type\": \"Condition\",\n          \"logic\": \"Checks if an input value is a specific root constant.\"\n        },\n        {\n          \"name\": \"Branch\",\n          \"parameters\": [\n            \"Condition condition\",\n            \"BasicBlock* if_true\",\n            \"BasicBlock* if_false\",\n            \"BasicBlock* next_block\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Generates a branch instruction to different basic blocks based on a condition.\"\n        },\n        {\n          \"name\": \"Branch\",\n          \"parameters\": [\n            \"Condition condition\",\n            \"Label* if_true\",\n            \"Label::Distance true_distance\",\n            \"bool fallthrough_when_true\",\n            \"Label* if_false\",\n            \"Label::Distance false_distance\",\n            \"bool fallthrough_when_false\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Generates a conditional branch with fine-grained control over fallthrough behavior and label distances.\"\n        },\n        {\n          \"name\": \"FromAnyToRegister\",\n          \"parameters\": [\n            \"const Input& input\",\n            \"Register scratch\"\n          ],\n          \"return_type\": \"Register\",\n          \"logic\": \"Loads the value of an Input into a register, using a scratch register if necessary.\"\n        },\n        {\n          \"name\": \"LoadTaggedField\",\n          \"parameters\": [\n            \"Register result\",\n            \"MemOperand operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a tagged field from memory into a register, decompressing it if necessary (Smi-decoding).\"\n        },\n        {\n          \"name\": \"LoadTaggedField\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register object\",\n            \"int offset\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a tagged field from an object at a specified offset into a register, decompressing it if necessary (Smi-decoding).\"\n        },\n        {\n          \"name\": \"LoadTaggedFieldWithoutDecompressing\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register object\",\n            \"int offset\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a tagged field from an object at a specified offset into a register, without decompressing it (no Smi-decoding).\"\n        },\n        {\n          \"name\": \"LoadTaggedSignedField\",\n          \"parameters\": [\n            \"Register result\",\n            \"MemOperand operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a signed, tagged field from memory into a register (Smi-decoding is performed, and the result is treated as signed).\"\n        },\n        {\n          \"name\": \"LoadTaggedSignedField\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register object\",\n            \"int offset\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a signed, tagged field from an object at a specified offset into a register (Smi-decoding is performed, and the result is treated as signed).\"\n        },\n        {\n          \"name\": \"LoadAndUntagTaggedSignedField\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register object\",\n            \"int offset\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a tagged field, treats it as a signed Smi, and untags the value into an int32 register.\"\n        },\n        {\n          \"name\": \"LoadTaggedFieldByIndex\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register object\",\n            \"Register index\",\n            \"int scale\",\n            \"int offset\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a tagged field from an object at an offset calculated by an index register, scale, and base offset.\"\n        },\n        {\n          \"name\": \"LoadBoundedSizeFromObject\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register object\",\n            \"int offset\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads bounded size value from an object\"\n        },\n        {\n          \"name\": \"LoadExternalPointerField\",\n          \"parameters\": [\n            \"Register result\",\n            \"MemOperand operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads external pointer field from memory into a register.\"\n        },\n        {\n          \"name\": \"LoadFixedArrayElement\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register array\",\n            \"Register index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads an element from a FixedArray at a specified index into a register (Smi-decoding if necessary).\"\n        },\n        {\n          \"name\": \"LoadFixedArrayElementWithoutDecompressing\",\n          \"parameters\": [\n            \"Register result\",\n            \"Register array\",\n            \"Register index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads an element from a FixedArray at a specified index into a register, without decompressing it.\"\n        },\n        {\n          \"name\": \"LoadFixedDoubleArrayElement\",\n          \"parameters\": [\n            \"DoubleRegister result\",\n            \"Register array\",\n            \"Register index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads an element from a FixedDoubleArray at a specified index into a double register.\"\n        },\n        {\n          \"name\": \"StoreFixedDoubleArrayElement\",\n          \"parameters\": [\n            \"Register array\",\n            \"Register index\",\n            \"DoubleRegister value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores a double value from a double register into a FixedDoubleArray at a specified index.\"\n        },\n        {\n          \"name\": \"LoadSignedField\",\n          \"parameters\": [\n            \"Register result\",\n            \"MemOperand operand\",\n            \"int element_size\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a signed field from memory, with a specified element size, into a register.\"\n        },\n        {\n          \"name\": \"LoadUnsignedField\",\n          \"parameters\": [\n            \"Register result\",\n            \"MemOperand operand\",\n            \"int element_size\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads an unsigned field from memory, with a specified element size, into a register.\"\n        },\n        {\n          \"name\": \"LoadBitField\",\n          \"parameters\": [\n            \"MemOperand operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Loads a bit field from memory and decodes it. Uses a template argument for the BitField type.\"\n        },\n        {\n          \"name\": \"SetSlotAddressForTaggedField\",\n          \"parameters\": [\n            \"Register slot_reg\",\n            \"Register object\",\n            \"int offset\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Calculates and sets the memory address of a tagged field within an object.\"\n        },\n        {\n          \"name\": \"SetSlotAddressForFixedArrayElement\",\n          \"parameters\": [\n            \"Register slot_reg\",\n            \"Register object\",\n            \"Register index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Calculates and sets the memory address of an element within a FixedArray.\"\n        },\n        {\n          \"name\": \"CheckAndEmitDeferredWriteBarrier\",\n          \"parameters\": [\n            \"Register object\",\n            \"OffsetTypeFor<store_mode> offset\",\n            \"Register value\",\n            \"RegisterSnapshot register_snapshot\",\n            \"ValueIsCompressed value_is_compressed\",\n            \"ValueCanBeSmi value_can_be_smi\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Conditionally emits a deferred write barrier call if needed based on compression and Smi-ability flags. It's templated to support field and element store modes.\"\n        },\n        {\n          \"name\": \"CheckAndEmitDeferredIndirectPointerWriteBarrier\",\n          \"parameters\": [\n            \"Register object\",\n            \"int offset\",\n            \"Register value\",\n            \"RegisterSnapshot register_snapshot\",\n            \"IndirectPointerTag tag\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Conditionally emits a deferred indirect pointer write barrier call if needed.\"\n        },\n        {\n          \"name\": \"StoreTaggedFieldWithWriteBarrier\",\n          \"parameters\": [\n            \"Register object\",\n            \"int offset\",\n            \"Register value\",\n            \"RegisterSnapshot register_snapshot\",\n            \"ValueIsCompressed value_is_compressed\",\n            \"ValueCanBeSmi value_can_be_smi\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores a tagged field in an object, including a write barrier to track memory dependencies and GC needs.\"\n        },\n        {\n          \"name\": \"StoreTaggedFieldNoWriteBarrier\",\n          \"parameters\": [\n            \"Register object\",\n            \"int offset\",\n            \"Register value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores a tagged field in an object, without a write barrier. This is typically used for writes within the young generation or to non-heap objects.\"\n        },\n        {\n          \"name\": \"StoreTaggedSignedField\",\n          \"parameters\": [\n            \"Register object\",\n            \"int offset\",\n            \"Register value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores a tagged, signed field (Smi) in an object.\"\n        },\n        {\n          \"name\": \"StoreTaggedSignedField\",\n          \"parameters\": [\n            \"Register object\",\n            \"int offset\",\n            \"Tagged<Smi> value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores a tagged, signed field (Smi) in an object.\"\n        },\n        {\n          \"name\": \"StoreInt32Field\",\n          \"parameters\": [\n            \"Register object\",\n            \"int offset\",\n            \"int32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores a 32-bit integer value in an object at the specified offset.\"\n        },\n        {\n          \"name\": \"StoreTrustedPointerFieldWithWriteBarrier\",\n          \"parameters\": [\n            \"Register object\",\n            \"int offset\",\n            \"Register value\",\n            \"RegisterSnapshot register_snapshot\",\n            \"IndirectPointerTag tag\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores a trusted pointer field with a write barrier\"\n        },\n        {\n          \"name\": \"StoreTrustedPointerFieldNoWriteBarrier\",\n          \"parameters\": [\n            \"Register object\",\n            \"int offset\",\n            \"Register value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores a trusted pointer field without a write barrier.\"\n        },\n        {\n          \"name\": \"StoreField\",\n          \"parameters\": [\n            \"MemOperand operand\",\n            \"Register value\",\n            \"int element_size\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Stores the value of a register in memory. Element size specifies the memory write size.\"\n        },\n        {\n          \"name\": \"ReverseByteOrder\",\n          \"parameters\": [\n            \"Register value\",\n            \"int element_size\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Reverses the byte order of a value in a register (used for endianness conversion).\"\n        },\n        {\n          \"name\": \"BuildTypedArrayDataPointer\",\n          \"parameters\": [\n            \"Register data_pointer\",\n            \"Register object\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Calculates the data pointer for a TypedArray, placing the result in the specified register.\"\n        },\n        {\n          \"name\": \"TypedArrayElementOperand\",\n          \"parameters\": [\n            \"Register data_pointer\",\n            \"Register index\",\n            \"int element_size\"\n          ],\n          \"return_type\": \"MemOperand\",\n          \"logic\": \"Calculates the MemOperand to access an element in a TypedArray, using the data pointer, index and element size.\"\n        },\n        {\n          \"name\": \"DataViewElementOperand\",\n          \"parameters\": [\n            \"Register data_pointer\",\n            \"Register index\"\n          ],\n          \"return_type\": \"MemOperand\",\n          \"logic\": \"Calculates the MemOperand to access an element in a DataView, using the data pointer and index.\"\n        },\n        {\n          \"name\": \"StringCharCodeOrCodePointAt\",\n          \"parameters\": [\n            \"BuiltinStringPrototypeCharCodeOrCodePointAt::Mode mode\",\n            \"RegisterSnapshot& register_snapshot\",\n            \"Register result\",\n            \"Register string\",\n            \"Register index\",\n            \"Register scratch1\",\n            \"Register scratch2\",\n            \"Label* result_fits_one_byte\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Implements String.charCodeAt or String.codePointAt using registers for string, index etc. Performs checks, handles surrogates and sets the result.\"\n        },\n        {\n          \"name\": \"StringFromCharCode\",\n          \"parameters\": [\n            \"RegisterSnapshot register_snapshot\",\n            \"Label* char_code_fits_one_byte\",\n            \"Register result\",\n            \"Register char_code\",\n            \"Register scratch\",\n            \"CharCodeMaskMode mask_mode\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Implements String.fromCharCode using registers. Allocates the string, and populates it with a character.\"\n        },\n        {\n          \"name\": \"ToBoolean\",\n          \"parameters\": [\n            \"Register value\",\n            \"CheckType check_type\",\n            \"ZoneLabelRef is_true\",\n            \"ZoneLabelRef is_false\",\n            \"bool fallthrough_when_true\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Converts a value to a boolean, branching to the appropriate label based on whether it's true or false.\"\n        },\n        {\n          \"name\": \"TestTypeOf\",\n          \"parameters\": [\n            \"Register object\",\n            \"interpreter::TestTypeOfFlags::LiteralFlag literal\",\n            \"Label* if_true\",\n            \"Label::Distance true_distance\",\n            \"bool fallthrough_when_true\",\n            \"Label* if_false\",\n            \"Label::Distance false_distance\",\n            \"bool fallthrough_when_false\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Tests the type of an object using the TestTypeOf bytecode and branches to the corresponding label.\"\n        },\n        {\n          \"name\": \"SmiTagInt32AndJumpIfFail\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an int32 value in a register and jumps to a failure label if the tagging fails (overflow).\"\n        },\n        {\n          \"name\": \"SmiTagInt32AndJumpIfFail\",\n          \"parameters\": [\n            \"Register reg\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an int32 value in a register and jumps to a failure label if the tagging fails (overflow).\"\n        },\n        {\n          \"name\": \"SmiTagInt32AndJumpIfSuccess\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\",\n            \"Label* success\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an int32 value in a register and jumps to a success label if the tagging succeeds (no overflow).\"\n        },\n        {\n          \"name\": \"SmiTagInt32AndJumpIfSuccess\",\n          \"parameters\": [\n            \"Register reg\",\n            \"Label* success\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an int32 value in a register and jumps to a success label if the tagging succeeds (no overflow).\"\n        },\n        {\n          \"name\": \"UncheckedSmiTagInt32\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Smi-tags an int32 value in a register without checking for overflow. This is unsafe and should only be used when overflow is impossible.\"\n        },\n        {\n          \"name\": \"UncheckedSmiTagInt32\",\n          \"parameters\": [\n            \"Register reg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Smi-tags an int32 value in a register without checking for overflow. This is unsafe and should only be used when overflow is impossible.\"\n        },\n        {\n          \"name\": \"SmiTagUint32AndJumpIfFail\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an uint32 value in a register and jumps to a failure label if the tagging fails (overflow).\"\n        },\n        {\n          \"name\": \"SmiTagUint32AndJumpIfFail\",\n          \"parameters\": [\n            \"Register reg\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an uint32 value in a register and jumps to a failure label if the tagging fails (overflow).\"\n        },\n        {\n          \"name\": \"SmiTagIntPtrAndJumpIfFail\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an intptr value in a register and jumps to a failure label if the tagging fails (overflow).\"\n        },\n        {\n          \"name\": \"SmiTagUint32AndJumpIfSuccess\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\",\n            \"Label* success\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an uint32 value in a register and jumps to a success label if the tagging succeeds (no overflow).\"\n        },\n        {\n          \"name\": \"SmiTagUint32AndJumpIfSuccess\",\n          \"parameters\": [\n            \"Register reg\",\n            \"Label* success\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an uint32 value in a register and jumps to a success label if the tagging succeeds (no overflow).\"\n        },\n        {\n          \"name\": \"SmiTagIntPtrAndJumpIfSuccess\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\",\n            \"Label* success\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to Smi-tag an intptr value in a register and jumps to a success label if the tagging succeeds (no overflow).\"\n        },\n        {\n          \"name\": \"UncheckedSmiTagUint32\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Smi-tags an uint32 value in a register without checking for overflow. This is unsafe and should only be used when overflow is impossible.\"\n        },\n        {\n          \"name\": \"UncheckedSmiTagUint32\",\n          \"parameters\": [\n            \"Register reg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Smi-tags an uint32 value in a register without checking for overflow. This is unsafe and should only be used when overflow is impossible.\"\n        },\n        {\n          \"name\": \"CheckInt32IsSmi\",\n          \"parameters\": [\n            \"Register obj\",\n            \"Label* fail\",\n            \"Register scratch\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Checks if an int32 is a valid smi value and jumps to fail if it's not. Uses optional scratch register.\"\n        },\n        {\n          \"name\": \"CheckIntPtrIsSmi\",\n          \"parameters\": [\n            \"Register obj\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Checks if an intptr is a valid smi value and jumps to fail if it's not.\"\n        },\n        {\n          \"name\": \"SmiAddConstant\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\",\n            \"int value\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds a constant value to a smi and jumps to fail label if it overflows.\"\n        },\n        {\n          \"name\": \"SmiAddConstant\",\n          \"parameters\": [\n            \"Register reg\",\n            \"int value\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds a constant value to a smi and jumps to fail label if it overflows.\"\n        },\n        {\n          \"name\": \"SmiSubConstant\",\n          \"parameters\": [\n            \"Register dst\",\n            \"Register src\",\n            \"int value\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Subtracts a constant value from a smi and jumps to fail label if it overflows.\"\n        },\n        {\n          \"name\": \"SmiSubConstant\",\n          \"parameters\": [\n            \"Register reg\",\n            \"int value\",\n            \"Label* fail\",\n            \"Label::Distance distance\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Subtracts a constant value from a smi and jumps to fail label if it overflows.\"\n        },\n        {\n          \"name\": \"MoveHeapNumber\",\n          \"parameters\": [\n            \"Register dst\",\n            \"double value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Moves a floating-point value into a heap number object. Allocates a HeapNumber if one is not available.\"\n        },\n        {\n          \"name\": \"CheckSmi\",\n          \"parameters\": [\n            \"Register src\"\n          ],\n          \"return_type\": \"Condition\",\n          \"logic\": \"Checks if a register is a Smi, returns a condition\"\n        },\n        {\n          \"name\": \"AssertMap\",\n          \"parameters\": [\n            \"Register object\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Asserts that the given register contains a Map. Only enabled when debug code is enabled.\"\n        },\n        {\n          \"name\": \"CompareRoot\",\n          \"parameters\": [\n            \"const Register& obj\",\n            \"RootIndex index\",\n            \"ComparisonMode mode\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Compares the value in a register with a root value from the isolate's root table.\"\n        },\n        {\n          \"name\": \"CmpTagged\",\n          \"parameters\": [\n            \"const Register& rs1\",\n            \"const Register& rs2\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Compares two tagged registers.\"\n        },\n        {\n          \"name\": \"CompareTaggedRoot\",\n          \"parameters\": [\n            \"const Register& obj\",\n            \"RootIndex index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Compares the value in a tagged register with a root value from the"
}