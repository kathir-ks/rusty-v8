{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/maglev/maglev-interpreter-frame-state.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/maglev/maglev-interpreter-frame-state.h\",\n  \"imports\": [\n    \"<optional>\",\n    \"src/base/threaded-list.h\",\n    \"src/compiler/bytecode-analysis.h\",\n    \"src/compiler/bytecode-liveness-map.h\",\n    \"src/interpreter/bytecode-register.h\",\n    \"src/maglev/maglev-compilation-unit.h\",\n    \"src/maglev/maglev-ir.h\",\n    \"src/maglev/maglev-regalloc-data.h\",\n    \"src/maglev/maglev-register-frame-array.h\",\n    \"src/zone/zone.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"NodeInfo\",\n      \"properties\": [\n        \"type_\",\n        \"any_map_is_unstable_\",\n        \"possible_maps_are_known_\",\n        \"possible_maps_\",\n        \"alternative_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"NodeInfo\",\n          \"parameters\": [],\n          \"return_type\": \"NodeInfo\",\n          \"logic\": \"Default constructor, initializes all properties to default values\"\n        },\n        {\n          \"name\": \"NodeInfo\",\n          \"parameters\": [\n            \"ClearUnstableMapsOnCopy other\"\n          ],\n          \"return_type\": \"NodeInfo\",\n          \"logic\": \"Copy constructor that conditionally copies possible_maps_ based on stability and known status.\"\n        },\n        {\n          \"name\": \"type\",\n          \"parameters\": [],\n          \"return_type\": \"NodeType\",\n          \"logic\": \"Returns the NodeType of the node.\"\n        },\n        {\n          \"name\": \"CombineType\",\n          \"parameters\": [\n            \"NodeType other\"\n          ],\n          \"return_type\": \"NodeType\",\n          \"logic\": \"Combines the current NodeType with another NodeType using maglev::CombineType.\"\n        },\n        {\n          \"name\": \"IntersectType\",\n          \"parameters\": [\n            \"NodeType other\"\n          ],\n          \"return_type\": \"NodeType\",\n          \"logic\": \"Intersects the current NodeType with another NodeType using maglev::IntersectType.\"\n        },\n        {\n          \"name\": \"alternative\",\n          \"parameters\": [],\n          \"return_type\": \"const AlternativeNodes&\",\n          \"logic\": \"Returns a const reference to the AlternativeNodes object.\"\n        },\n        {\n          \"name\": \"alternative\",\n          \"parameters\": [],\n          \"return_type\": \"AlternativeNodes&\",\n          \"logic\": \"Returns a reference to the AlternativeNodes object.\"\n        },\n        {\n          \"name\": \"no_info_available\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if no information is available for the node (type is Unknown, no alternatives, and possible maps are unknown).\"\n        },\n        {\n          \"name\": \"is_smi\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node type represents a Smi.\"\n        },\n        {\n          \"name\": \"is_any_heap_object\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node type represents any heap object.\"\n        },\n        {\n          \"name\": \"is_string\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node type represents a string.\"\n        },\n        {\n          \"name\": \"is_internalized_string\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node type represents an internalized string.\"\n        },\n        {\n          \"name\": \"is_symbol\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node type represents a symbol.\"\n        },\n        {\n          \"name\": \"MergeWith\",\n          \"parameters\": [\n            \"const NodeInfo& other\",\n            \"Zone* zone\",\n            \"bool& any_merged_map_is_unstable\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges information from another NodeInfo, taking the subset of information valid in both inputs. Includes type intersection and map union. Handles unstable maps.\"\n        },\n        {\n          \"name\": \"possible_maps_are_unstable\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if any of the possible maps are unstable.\"\n        },\n        {\n          \"name\": \"ClearUnstableMaps\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Clears possible maps if any map is unstable.\"\n        },\n        {\n          \"name\": \"ClearUnstableMapsIfAny\",\n          \"parameters\": [\n            \"const Function& condition\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Clears unstable maps if any map satisfies the provided condition.\"\n        },\n        {\n          \"name\": \"possible_maps_are_known\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the possible maps are known.\"\n        },\n        {\n          \"name\": \"possible_maps\",\n          \"parameters\": [],\n          \"return_type\": \"const PossibleMaps&\",\n          \"logic\": \"Returns the set of possible maps. Requires that the possible maps are known.\"\n        },\n        {\n          \"name\": \"SetPossibleMaps\",\n          \"parameters\": [\n            \"const PossibleMaps& possible_maps\",\n            \"bool any_map_is_unstable\",\n            \"NodeType possible_type\",\n            \"compiler::JSHeapBroker* broker\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the possible maps for the node, along with an indication of whether any map is unstable. Combines the provided NodeType with the current NodeType.\"\n        },\n        {\n          \"name\": \"any_map_is_unstable\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if any map is unstable.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"NodeInfo::AlternativeNodes\",\n      \"properties\": [\n        \"store_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"AlternativeNodes\",\n          \"parameters\": [],\n          \"return_type\": \"AlternativeNodes\",\n          \"logic\": \"Constructor, initializes the store_ with null values.\"\n        },\n        {\n          \"name\": \"tagged\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the tagged ValueNode.\"\n        },\n        {\n          \"name\": \"set_tagged\",\n          \"parameters\": [\n            \"ValueNode* val\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Sets the tagged ValueNode.\"\n        },\n        {\n          \"name\": \"get_or_set_tagged\",\n          \"parameters\": [\n            \"Function create\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the tagged ValueNode, creating it if it doesn't exist using the provided function.\"\n        },\n        {\n          \"name\": \"int32\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the int32 ValueNode.\"\n        },\n        {\n          \"name\": \"set_int32\",\n          \"parameters\": [\n            \"ValueNode* val\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Sets the int32 ValueNode.\"\n        },\n        {\n          \"name\": \"get_or_set_int32\",\n          \"parameters\": [\n            \"Function create\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the int32 ValueNode, creating it if it doesn't exist using the provided function.\"\n        },\n        {\n          \"name\": \"truncated_int32_to_number\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the truncated_int32_to_number ValueNode.\"\n        },\n        {\n          \"name\": \"set_truncated_int32_to_number\",\n          \"parameters\": [\n            \"ValueNode* val\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Sets the truncated_int32_to_number ValueNode.\"\n        },\n        {\n          \"name\": \"get_or_set_truncated_int32_to_number\",\n          \"parameters\": [\n            \"Function create\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the truncated_int32_to_number ValueNode, creating it if it doesn't exist using the provided function.\"\n        },\n        {\n          \"name\": \"float64\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the Float64 ValueNode.\"\n        },\n        {\n          \"name\": \"set_float64\",\n          \"parameters\": [\n            \"ValueNode* val\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Sets the Float64 ValueNode.\"\n        },\n        {\n          \"name\": \"get_or_set_float64\",\n          \"parameters\": [\n            \"Function create\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the Float64 ValueNode, creating it if it doesn't exist using the provided function.\"\n        },\n        {\n          \"name\": \"checked_value\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the checked_value ValueNode.\"\n        },\n        {\n          \"name\": \"set_checked_value\",\n          \"parameters\": [\n            \"ValueNode* val\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Sets the checked_value ValueNode.\"\n        },\n        {\n          \"name\": \"get_or_set_checked_value\",\n          \"parameters\": [\n            \"Function create\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the checked_value ValueNode, creating it if it doesn't exist using the provided function.\"\n        },\n        {\n          \"name\": \"has_none\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if all alternative nodes are null.\"\n        },\n        {\n          \"name\": \"MergeWith\",\n          \"parameters\": [\n            \"const AlternativeNodes& other\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges the alternative nodes, setting to null if different.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"KnownNodeAspects\",\n      \"properties\": [\n        \"any_map_for_any_node_is_unstable\",\n        \"loaded_constant_properties\",\n        \"loaded_properties\",\n        \"loaded_context_constants\",\n        \"loaded_context_slots\",\n        \"available_expressions\",\n        \"effect_epoch_\",\n        \"node_infos\",\n        \"may_have_aliasing_contexts_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Clone\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"KnownNodeAspects*\",\n          \"logic\": \"Creates a copy of the KnownNodeAspects object in the specified zone.\"\n        },\n        {\n          \"name\": \"CloneForLoopHeader\",\n          \"parameters\": [\n            \"bool optimistic_initial_state\",\n            \"LoopEffects* loop_effects\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"KnownNodeAspects*\",\n          \"logic\": \"Creates a specialized clone for loop headers, handling stable and unstable maps differently.\"\n        },\n        {\n          \"name\": \"ClearUnstableNodeAspects\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Placeholder function, currently does nothing.\"\n        },\n        {\n          \"name\": \"ClearUnstableMaps\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Clears the unstable maps for all NodeInfos, resets the unstable map flag.\"\n        },\n        {\n          \"name\": \"ClearUnstableMapsIfAny\",\n          \"parameters\": [\n            \"const Function& condition\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Clears unstable maps based on a condition for each NodeInfo.\"\n        },\n        {\n          \"name\": \"ClearAvailableExpressions\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Clears all available expressions.\"\n        },\n        {\n          \"name\": \"FindInfo\",\n          \"parameters\": [\n            \"ValueNode* node\"\n          ],\n          \"return_type\": \"NodeInfos::iterator\",\n          \"logic\": \"Finds the NodeInfo associated with a ValueNode.\"\n        },\n        {\n          \"name\": \"FindInfo\",\n          \"parameters\": [\n            \"ValueNode* node\"\n          ],\n          \"return_type\": \"NodeInfos::const_iterator\",\n          \"logic\": \"Finds the NodeInfo associated with a ValueNode (const version).\"\n        },\n        {\n          \"name\": \"IsValid\",\n          \"parameters\": [\n            \"NodeInfos::iterator& it\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the iterator is valid.\"\n        },\n        {\n          \"name\": \"IsValid\",\n          \"parameters\": [\n            \"NodeInfos::const_iterator& it\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the iterator is valid (const version).\"\n        },\n        {\n          \"name\": \"TryGetInfoFor\",\n          \"parameters\": [\n            \"ValueNode* node\"\n          ],\n          \"return_type\": \"const NodeInfo*\",\n          \"logic\": \"Tries to get NodeInfo for a node (const version).\"\n        },\n        {\n          \"name\": \"TryGetInfoFor\",\n          \"parameters\": [\n            \"ValueNode* node\"\n          ],\n          \"return_type\": \"NodeInfo*\",\n          \"logic\": \"Tries to get NodeInfo for a node.\"\n        },\n        {\n          \"name\": \"GetOrCreateInfoFor\",\n          \"parameters\": [\n            \"ValueNode* node\",\n            \"compiler::JSHeapBroker* broker\",\n            \"LocalIsolate* isolate\"\n          ],\n          \"return_type\": \"NodeInfo*\",\n          \"logic\": \"Gets or creates NodeInfo for a ValueNode, combining the static type information from the broker and isolate.\"\n        },\n        {\n          \"name\": \"NodeTypeFor\",\n          \"parameters\": [\n            \"ValueNode* node\"\n          ],\n          \"return_type\": \"NodeType\",\n          \"logic\": \"Gets the NodeType for a ValueNode based on its stored NodeInfo.\"\n        },\n        {\n          \"name\": \"Merge\",\n          \"parameters\": [\n            \"const KnownNodeAspects& other\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges the information from another KnownNodeAspects object.\"\n        },\n        {\n          \"name\": \"IsCompatibleWithLoopHeader\",\n          \"parameters\": [\n            \"const KnownNodeAspects& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this object can merge loop information without removing information.\"\n        },\n        {\n          \"name\": \"UpdateMayHaveAliasingContexts\",\n          \"parameters\": [\n            \"ValueNode* context\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates the aliasing contexts based on the context node\"\n        },\n        {\n          \"name\": \"may_have_aliasing_contexts\",\n          \"parameters\": [],\n          \"return_type\": \"ContextSlotLoadsAlias\",\n          \"logic\": \"Return type of aliasing contexts. Makes sure the value is initialized first\"\n        },\n        {\n          \"name\": \"effect_epoch\",\n          \"parameters\": [],\n          \"return_type\": \"uint32_t\",\n          \"logic\": \"Return effect epoch.\"\n        },\n        {\n          \"name\": \"increment_effect_epoch\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Increment the current epoch.\"\n        },\n        {\n          \"name\": \"KnownNodeAspects\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"KnownNodeAspects\",\n          \"logic\": \"Constructor\"\n        }\n      ]\n    },\n    {\n      \"name\": \"KnownNodeAspects::LoadedPropertyMapKey\",\n      \"properties\": [\n        \"data_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Elements\",\n          \"parameters\": [],\n          \"return_type\": \"LoadedPropertyMapKey\",\n          \"logic\": \"Returns a LoadedPropertyMapKey for elements.\"\n        },\n        {\n          \"name\": \"TypedArrayLength\",\n          \"parameters\": [],\n          \"return_type\": \"LoadedPropertyMapKey\",\n          \"logic\": \"Returns a LoadedPropertyMapKey for typed array length.\"\n        },\n        {\n          \"name\": \"StringLength\",\n          \"parameters\": [],\n          \"return_type\": \"LoadedPropertyMapKey\",\n          \"logic\": \"Returns a LoadedPropertyMapKey for string length.\"\n        },\n        {\n          \"name\": \"LoadedPropertyMapKey\",\n          \"parameters\": [\n            \"compiler::NameRef ref\"\n          ],\n          \"return_type\": \"LoadedPropertyMapKey\",\n          \"logic\": \"Constructor, creates the LoadedPropertyMapKey from a name reference.\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\n            \"const LoadedPropertyMapKey& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Equality operator.\"\n        },\n        {\n          \"name\": \"operator<\",\n          \"parameters\": [\n            \"const LoadedPropertyMapKey& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Less-than operator.\"\n        },\n        {\n          \"name\": \"name\",\n          \"parameters\": [],\n          \"return_type\": \"compiler::NameRef\",\n          \"logic\": \"Returns name if type is Name.\"\n        },\n        {\n          \"name\": \"type\",\n          \"parameters\": [],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of the map key.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"KnownNodeAspects::AvailableExpression\",\n      \"properties\": [\n        \"node\",\n        \"effect_epoch\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"InterpreterFrameState\",\n      \"properties\": [\n        \"frame_\",\n        \"known_node_aspects_\",\n        \"virtual_objects_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"InterpreterFrameState\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"KnownNodeAspects* known_node_aspects\",\n            \"VirtualObjectList virtual_objects\"\n          ],\n          \"return_type\": \"InterpreterFrameState\",\n          \"logic\": \"Constructor that initializes the frame with known aspects and virtual objects\"\n        },\n        {\n          \"name\": \"InterpreterFrameState\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\"\n          ],\n          \"return_type\": \"InterpreterFrameState\",\n          \"logic\": \"Constructor that initializes the frame, creates new known node aspects, and a new virtual object list.\"\n        },\n        {\n          \"name\": \"CopyFrom\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"MergePointInterpreterFrameState& state\",\n            \"bool preserve_known_node_aspects\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Copies the frame state from a merge point, optionally preserving known node aspects\"\n        },\n        {\n          \"name\": \"set_accumulator\",\n          \"parameters\": [\n            \"ValueNode* value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the accumulator register.\"\n        },\n        {\n          \"name\": \"accumulator\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Gets the accumulator register.\"\n        },\n        {\n          \"name\": \"set\",\n          \"parameters\": [\n            \"interpreter::Register reg\",\n            \"ValueNode* value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the value of a given register.\"\n        },\n        {\n          \"name\": \"get\",\n          \"parameters\": [\n            \"interpreter::Register reg\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Gets the value of a given register.\"\n        },\n        {\n          \"name\": \"frame\",\n          \"parameters\": [],\n          \"return_type\": \"const RegisterFrameArray<ValueNode*>&\",\n          \"logic\": \"Returns the frame array.\"\n        },\n        {\n          \"name\": \"known_node_aspects\",\n          \"parameters\": [],\n          \"return_type\": \"KnownNodeAspects*\",\n          \"logic\": \"Returns a pointer to the KnownNodeAspects object.\"\n        },\n        {\n          \"name\": \"known_node_aspects\",\n          \"parameters\": [],\n          \"return_type\": \"const KnownNodeAspects*\",\n          \"logic\": \"Returns a const pointer to the KnownNodeAspects object.\"\n        },\n        {\n          \"name\": \"set_known_node_aspects\",\n          \"parameters\": [\n            \"KnownNodeAspects* known_node_aspects\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the KnownNodeAspects object.\"\n        },\n        {\n          \"name\": \"clear_known_node_aspects\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Clears the KnownNodeAspects object.\"\n        },\n        {\n          \"name\": \"add_object\",\n          \"parameters\": [\n            \"VirtualObject* vobject\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds an object to the virtual objects list.\"\n        },\n        {\n          \"name\": \"virtual_objects\",\n          \"parameters\": [],\n          \"return_type\": \"const VirtualObjectList&\",\n          \"logic\": \"Returns the virtual objects list.\"\n        },\n        {\n          \"name\": \"set_virtual_objects\",\n          \"parameters\": [\n            \"const VirtualObjectList& virtual_objects\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the virtual objects list.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CompactInterpreterFrameState\",\n      \"properties\": [\n        \"live_registers_and_accumulator_\",\n        \"liveness_\",\n        \"virtual_objects_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"CompactInterpreterFrameState\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"const compiler::BytecodeLivenessState* liveness\"\n          ],\n          \"return_type\": \"CompactInterpreterFrameState\",\n          \"logic\": \"Constructor that allocates memory for live registers and accumulator based on liveness information.\"\n        },\n        {\n          \"name\": \"CompactInterpreterFrameState\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"const compiler::BytecodeLivenessState* liveness\",\n            \"const InterpreterFrameState& state\"\n          ],\n          \"return_type\": \"CompactInterpreterFrameState\",\n          \"logic\": \"Constructor that copies the values from the InterpreterFrameState to the compact state.\"\n        },\n        {\n          \"name\": \"ForEachParameter\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over all parameters and calls the provided function.\"\n        },\n        {\n          \"name\": \"ForEachParameter\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over all parameters and calls the provided function.\"\n        },\n        {\n          \"name\": \"ForEachLocal\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over all live local registers and calls the provided function (const version).\"\n        },\n        {\n          \"name\": \"ForEachLocal\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over all live local registers and calls the provided function.\"\n        },\n        {\n          \"name\": \"ForEachRegister\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over parameters, context, and locals.\"\n        },\n        {\n          \"name\": \"ForEachRegister\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over parameters, context, and locals (const version).\"\n        },\n        {\n          \"name\": \"ForEachValue\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over all registers and the accumulator (const version).\"\n        },\n        {\n          \"name\": \"ForEachValue\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over all registers and the accumulator.\"\n        },\n        {\n          \"name\": \"liveness\",\n          \"parameters\": [],\n          \"return_type\": \"const compiler::BytecodeLivenessState*\",\n          \"logic\": \"Returns the liveness state.\"\n        },\n        {\n          \"name\": \"accumulator\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\"\n          ],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the accumulator value (const version).\"\n        },\n        {\n          \"name\": \"accumulator\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\"\n          ],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the accumulator value.\"\n        },\n        {\n          \"name\": \"context\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\"\n          ],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the context value (const version).\"\n        },\n        {\n          \"name\": \"context\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\"\n          ],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the context value.\"\n        },\n        {\n          \"name\": \"GetValueOf\",\n          \"parameters\": [\n            \"interpreter::Register reg\",\n            \"const MaglevCompilationUnit& info\"\n          ],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Gets the value of a specific register, using liveness information. Returns nullptr if the register isn't live.\"\n        },\n        {\n          \"name\": \"size\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\"\n          ],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the size of the live registers array.\"\n        },\n        {\n          \"name\": \"virtual_objects\",\n          \"parameters\": [],\n          \"return_type\": \"const VirtualObjectList&\",\n          \"logic\": \"Returns the virtual objects.\"\n        },\n        {\n          \"name\": \"virtual_objects\",\n          \"parameters\": [],\n          \"return_type\": \"VirtualObjectList&\",\n          \"logic\": \"Returns the virtual objects.\"\n        },\n        {\n          \"name\": \"set_virtual_objects\",\n          \"parameters\": [\n            \"const VirtualObjectList& vos\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the virtual objects.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MergePointRegisterState\",\n      \"properties\": [\n        \"values_\",\n        \"double_values_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"is_initialized\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Return if the state is initialized.\"\n        },\n        {\n          \"name\": \"ForEachGeneralRegister\",\n          \"parameters\": [\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over all allocatable general registers and calls the provided function.\"\n        },\n        {\n          \"name\": \"ForEachDoubleRegister\",\n          \"parameters\": [\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates over all allocatable double registers and calls the provided function.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MergePointInterpreterFrameState\",\n      \"properties\": [\n        \"merge_offset_\",\n        \"predecessor_count_\",\n        \"predecessors_so_far_\",\n        \"bitfield_\",\n        \"predecessors_\",\n        \"phis_\",\n        \"frame_state_\",\n        \"register_state_\",\n        \"known_node_aspects_\",\n        \"per_predecessor_alternatives_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"New\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& info\",\n            \"const InterpreterFrameState& state\",\n            \"int merge_offset\",\n            \"int predecessor_count\",\n            \"BasicBlock* predecessor\",\n            \"const compiler::BytecodeLivenessState* liveness\"\n          ],\n          \"return_type\": \"MergePointInterpreterFrameState*\",\n          \"logic\": \"Creates a new MergePointInterpreterFrameState based on the given state and parameters.\"\n        },\n        {\n          \"name\": \"NewForLoop\",\n          \"parameters\": [\n            \"const InterpreterFrameState& start_state\",\n            \"const MaglevCompilationUnit& info\",\n            \"int merge_offset\",\n            \"int predecessor_count\",\n            \"const compiler::BytecodeLivenessState* liveness\",\n            \"const compiler::LoopInfo* loop_info\",\n            \"bool has_been_peeled\"\n          ],\n          \"return_type\": \"MergePointInterpreterFrameState*\",\n          \"logic\": \"Creates a new MergePointInterpreterFrameState specifically for loops.\"\n        },\n        {\n          \"name\": \"NewForCatchBlock\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& unit\",\n            \"const compiler::BytecodeLivenessState* liveness\",\n            \"int handler_offset\",\n            \"bool was_used\",\n            \"interpreter::Register context_register\",\n            \"Graph* graph\"\n          ],\n          \"return_type\": \"MergePointInterpreterFrameState*\",\n          \"logic\": \"Creates a new MergePointInterpreterFrameState specifically for catch blocks.\"\n        },\n        {\n          \"name\": \"Merge\",\n          \"parameters\": [\n            \"MaglevGraphBuilder* graph_builder\",\n            \"InterpreterFrameState& unmerged\",\n            \"BasicBlock* predecessor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges an unmerged frame state with this frame state.\"\n        },\n        {\n          \"name\": \"Merge\",\n          \"parameters\": [\n            \"MaglevGraphBuilder* graph_builder\",\n            \"MaglevCompilationUnit& compilation_unit\",\n            \"InterpreterFrameState& unmerged\",\n            \"BasicBlock* predecessor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges an unmerged frame state with this frame state, taking into account compilation unit.\"\n        },\n        {\n          \"name\": \"InitializeLoop\",\n          \"parameters\": [\n            \"MaglevGraphBuilder* graph_builder\",\n            \"MaglevCompilationUnit& compilation_unit\",\n            \"InterpreterFrameState& unmerged\",\n            \"BasicBlock* predecessor\",\n            \"bool optimistic_initial_state\",\n            \"LoopEffects* loop_effects\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes frame state for loops.\"\n        },\n        {\n          \"name\": \"InitializeWithBasicBlock\",\n          \"parameters\": [\n            \"BasicBlock* current_block\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes with basic block.\"\n        },\n        {\n          \"name\": \"MergeLoop\",\n          \"parameters\": [\n            \"MaglevGraphBuilder* graph_builder\",\n            \"InterpreterFrameState& loop_end_state\",\n            \"BasicBlock* loop_end_block\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges frame state for loop, updating the state to the new one\"\n        },\n        {\n          \"name\": \"MergeLoop\",\n          \"parameters\": [\n            \"MaglevGraphBuilder* graph_builder\",\n            \"MaglevCompilationUnit& compilation_unit\",\n            \"InterpreterFrameState& loop_end_state\",\n            \"BasicBlock* loop_end_block\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges frame state for loop, also including compilation unit.\"\n        },\n        {\n          \"name\": \"set_loop_effects\",\n          \"parameters\": [\n            \"LoopEffects"
}