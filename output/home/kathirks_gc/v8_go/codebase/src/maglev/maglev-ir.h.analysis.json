{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/maglev/maglev-ir.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/maglev/maglev-ir.h\",\n  \"imports\": [\n    \"<optional>\",\n    \"src/base/bit-field.h\",\n    \"src/base/bits.h\",\n    \"src/base/bounds.h\",\n    \"src/base/discriminated-union.h\",\n    \"src/base/enum-set.h\",\n    \"src/base/logging.h\",\n    \"src/base/macros.h\",\n    \"src/base/small-vector.h\",\n    \"src/base/threaded-list.h\",\n    \"src/codegen/external-reference.h\",\n    \"src/codegen/label.h\",\n    \"src/codegen/machine-type.h\",\n    \"src/codegen/reglist.h\",\n    \"src/codegen/source-position.h\",\n    \"src/common/globals.h\",\n    \"src/common/operation.h\",\n    \"src/compiler/access-info.h\",\n    \"src/compiler/backend/instruction.h\",\n    \"src/compiler/compilation-dependencies.h\",\n    \"src/compiler/feedback-source.h\",\n    \"src/compiler/heap-refs.h\",\n    \"src/compiler/js-heap-broker.h\",\n    \"src/compiler/turboshaft/snapshot-table.h\",\n    \"src/compiler/turboshaft/utils.h\",\n    \"src/deoptimizer/deoptimize-reason.h\",\n    \"src/interpreter/bytecode-flags-and-tokens.h\",\n    \"src/interpreter/bytecode-register.h\",\n    \"src/maglev/maglev-compilation-unit.h\",\n    \"src/objects/arguments.h\",\n    \"src/objects/heap-number.h\",\n    \"src/objects/property-details.h\",\n    \"src/objects/smi.h\",\n    \"src/objects/tagged-index.h\",\n    \"src/roots/roots.h\",\n    \"src/sandbox/js-dispatch-table.h\",\n    \"src/utils/utils.h\",\n    \"src/zone/zone.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"BasicBlockRef\",\n      \"properties\": [\n        \"BasicBlock* block_ptr_\",\n        \"BasicBlockRef* next_ref_\",\n        \"enum { kBlockPointer, kRefList } state_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"BasicBlockRef\",\n          \"parameters\": [],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Default constructor. Initializes a ref-list mode BasicBlockRef.\"\n        },\n        {\n          \"name\": \"BasicBlockRef\",\n          \"parameters\": [\n            \"BasicBlock* block\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor to create a BasicBlockRef that directly holds a BasicBlock pointer.\"\n        },\n        {\n          \"name\": \"BasicBlockRef\",\n          \"parameters\": [\n            \"BasicBlockRef* ref_list_head\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructs a new ref-list mode BasicBlockRef and adds it to the given ref list.\"\n        },\n        {\n          \"name\": \"SetToBlockAndReturnNext\",\n          \"parameters\": [\n            \"BasicBlock* block\"\n          ],\n          \"return_type\": \"BasicBlockRef*\",\n          \"logic\": \"Changes this ref to a direct basic block pointer and returns the old 'next' pointer.\"\n        },\n        {\n          \"name\": \"Reset\",\n          \"parameters\": [],\n          \"return_type\": \"BasicBlockRef*\",\n          \"logic\": \"Resets this ref list to null, returning the old ref list (i.e., the old 'next' pointer).\"\n        },\n        {\n          \"name\": \"MoveToRefList\",\n          \"parameters\": [\n            \"BasicBlockRef* ref_list_head\"\n          ],\n          \"return_type\": \"BasicBlockRef*\",\n          \"logic\": \"Moves this ref to the given ref list, returning the old 'next' pointer.\"\n        },\n        {\n          \"name\": \"Bind\",\n          \"parameters\": [\n            \"BasicBlock* block\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Resolves all BasicBlockRefs in a list to point to a given BasicBlock.\"\n        },\n        {\n          \"name\": \"block_ptr\",\n          \"parameters\": [],\n          \"return_type\": \"BasicBlock*\",\n          \"logic\": \"Returns the BasicBlock pointer.\"\n        },\n        {\n          \"name\": \"set_block_ptr\",\n          \"parameters\": [\n            \"BasicBlock* block\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the BasicBlock pointer\"\n        },\n        {\n          \"name\": \"next_ref\",\n          \"parameters\": [],\n          \"return_type\": \"BasicBlockRef*\",\n          \"logic\": \"Returns pointer to the next BasicBlockRef in the list\"\n        },\n        {\n          \"name\": \"has_ref\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Indicates whether this BasicBlockRef has a reference\"\n        }\n      ]\n    },\n    {\n      \"name\": \"OpProperties\",\n      \"properties\": [\n        \"uint32_t bitfield_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"is_call\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation is a non-deferred call.\"\n        },\n        {\n          \"name\": \"is_any_call\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation is any kind of call (deferred or non-deferred).\"\n        },\n        {\n          \"name\": \"can_eager_deopt\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation can eagerly deoptimize.\"\n        },\n        {\n          \"name\": \"can_lazy_deopt\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation can lazily deoptimize.\"\n        },\n        {\n          \"name\": \"is_deopt_checkpoint\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if operation is a deoptimization checkpoint\"\n        },\n        {\n          \"name\": \"can_deopt\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation can deoptimize (eagerly or lazily).\"\n        },\n        {\n          \"name\": \"can_throw\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation can throw an exception.\"\n        },\n        {\n          \"name\": \"can_read\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation can read memory.\"\n        },\n        {\n          \"name\": \"can_write\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation can write to memory.\"\n        },\n        {\n          \"name\": \"can_allocate\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation can allocate memory.\"\n        },\n        {\n          \"name\": \"not_idempotent\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Indicates if the instruction produces new values on each execution\"\n        },\n        {\n          \"name\": \"value_representation\",\n          \"parameters\": [],\n          \"return_type\": \"ValueRepresentation\",\n          \"logic\": \"Returns the representation of the value produced by the operation.\"\n        },\n        {\n          \"name\": \"is_tagged\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation produces a tagged value.\"\n        },\n        {\n          \"name\": \"is_conversion\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation is a type conversion.\"\n        },\n        {\n          \"name\": \"needs_register_snapshot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation needs a register snapshot.\"\n        },\n        {\n          \"name\": \"is_pure\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation is pure (no side effects).\"\n        },\n        {\n          \"name\": \"is_required_when_unused\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if the node is required when its result isn't used.\"\n        },\n        {\n          \"name\": \"can_participate_in_cse\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if the instruction can participate in CSE (Common Subexpression Elimination).\"\n        },\n        {\n          \"name\": \"operator|\",\n          \"parameters\": [\n            \"const OpProperties& that\"\n          ],\n          \"return_type\": \"OpProperties\",\n          \"logic\": \"Bitwise OR operation to combine OpProperties.\"\n        },\n        {\n          \"name\": \"OpProperties\",\n          \"parameters\": [\n            \"uint32_t bitfield\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor. Initializes the OpProperties with the given bitfield.\"\n        },\n        {\n          \"name\": \"WithNewValueRepresentation\",\n          \"parameters\": [\n            \"ValueRepresentation new_repr\"\n          ],\n          \"return_type\": \"OpProperties\",\n          \"logic\": \"Returns a new OpProperties instance with the value_representation set to new_repr\"\n        },\n        {\n          \"name\": \"WithoutDeopt\",\n          \"parameters\": [],\n          \"return_type\": \"OpProperties\",\n          \"logic\": \"Returns a new OpProperties instance with the eager/lazy deopt bits set to 'none'\"\n        },\n        {\n          \"name\": \"is_deferred_call\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if operation is a deferred call.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ValueLocation\",\n      \"properties\": [\n        \"compiler::InstructionOperand operand_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"SetUnallocated\",\n          \"parameters\": [\n            \"Args&&... args\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the operand to an unallocated operand.\"\n        },\n        {\n          \"name\": \"SetAllocated\",\n          \"parameters\": [\n            \"Args&&... args\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the operand to an allocated operand.\"\n        },\n        {\n          \"name\": \"InjectLocation\",\n          \"parameters\": [\n            \"compiler::InstructionOperand location\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets location for inputs that inherit allocation.\"\n        },\n        {\n          \"name\": \"Cloberred\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks whether the operand will be clobbered.\"\n        },\n        {\n          \"name\": \"SetConstant\",\n          \"parameters\": [\n            \"Args&&... args\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the operand to a constant operand.\"\n        },\n        {\n          \"name\": \"AssignedGeneralRegister\",\n          \"parameters\": [],\n          \"return_type\": \"Register\",\n          \"logic\": \"Returns the assigned general register.\"\n        },\n        {\n          \"name\": \"AssignedDoubleRegister\",\n          \"parameters\": [],\n          \"return_type\": \"DoubleRegister\",\n          \"logic\": \"Returns the assigned double register.\"\n        },\n        {\n          \"name\": \"IsAnyRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is any register.\"\n        },\n        {\n          \"name\": \"IsGeneralRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a general register.\"\n        },\n        {\n          \"name\": \"IsDoubleRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a double register.\"\n        },\n        {\n          \"name\": \"operand\",\n          \"parameters\": [],\n          \"return_type\": \"const compiler::InstructionOperand&\",\n          \"logic\": \"Returns const reference to the InstructionOperand\"\n        },\n        {\n          \"name\": \"operand\",\n          \"parameters\": [],\n          \"return_type\": \"compiler::InstructionOperand&\",\n          \"logic\": \"Returns non-const reference to the InstructionOperand\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InputLocation\",\n      \"properties\": [\n        \"NodeIdT next_use_id_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"next_use_id\",\n          \"parameters\": [],\n          \"return_type\": \"NodeIdT\",\n          \"logic\": \"Returns the ID of the next use of the input.\"\n        },\n        {\n          \"name\": \"get_next_use_id_address\",\n          \"parameters\": [],\n          \"return_type\": \"NodeIdT*\",\n          \"logic\": \"Returns the address of the next_use_id_ field.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Input\",\n      \"properties\": [\n        \"ValueNode* node_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Input\",\n          \"parameters\": [\n            \"ValueNode* node\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor. Initializes with a ValueNode.\"\n        },\n        {\n          \"name\": \"node\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the ValueNode.\"\n        },\n        {\n          \"name\": \"set_node\",\n          \"parameters\": [\n            \"ValueNode* node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the ValueNode.\"\n        },\n        {\n          \"name\": \"clear\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Clears the ValueNode.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DeoptFrame\",\n      \"properties\": [\n        \"FrameData data_\",\n        \"DeoptFrame* const parent_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"DeoptFrame\",\n          \"parameters\": [\n            \"FrameData&& data\",\n            \"DeoptFrame* parent\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor that takes an rvalue reference to a FrameData\"\n        },\n        {\n          \"name\": \"DeoptFrame\",\n          \"parameters\": [\n            \"const FrameData& data\",\n            \"DeoptFrame* parent\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor that takes a const reference to a FrameData\"\n        },\n        {\n          \"name\": \"type\",\n          \"parameters\": [],\n          \"return_type\": \"FrameType\",\n          \"logic\": \"Returns the type of the deoptimization frame.\"\n        },\n        {\n          \"name\": \"parent\",\n          \"parameters\": [],\n          \"return_type\": \"DeoptFrame*\",\n          \"logic\": \"Returns a pointer to the parent frame.\"\n        },\n        {\n          \"name\": \"parent\",\n          \"parameters\": [],\n          \"return_type\": \"const DeoptFrame*\",\n          \"logic\": \"Returns a const pointer to the parent frame.\"\n        },\n        {\n          \"name\": \"as_interpreted\",\n          \"parameters\": [],\n          \"return_type\": \"const InterpretedDeoptFrame&\",\n          \"logic\": \"Casts this DeoptFrame to an InterpretedDeoptFrame. Only valid if the type is kInterpretedFrame.\"\n        },\n        {\n          \"name\": \"as_inlined_arguments\",\n          \"parameters\": [],\n          \"return_type\": \"const InlinedArgumentsDeoptFrame&\",\n          \"logic\": \"Casts this DeoptFrame to an InlinedArgumentsDeoptFrame. Only valid if the type is kInlinedArgumentsFrame.\"\n        },\n        {\n          \"name\": \"as_construct_stub\",\n          \"parameters\": [],\n          \"return_type\": \"const ConstructInvokeStubDeoptFrame&\",\n          \"logic\": \"Casts this DeoptFrame to a ConstructInvokeStubDeoptFrame. Only valid if the type is kConstructInvokeStubFrame.\"\n        },\n        {\n          \"name\": \"as_builtin_continuation\",\n          \"parameters\": [],\n          \"return_type\": \"const BuiltinContinuationDeoptFrame&\",\n          \"logic\": \"Casts this DeoptFrame to a BuiltinContinuationDeoptFrame. Only valid if the type is kBuiltinContinuationFrame.\"\n        },\n        {\n          \"name\": \"as_interpreted\",\n          \"parameters\": [],\n          \"return_type\": \"InterpretedDeoptFrame&\",\n          \"logic\": \"Casts this DeoptFrame to an InterpretedDeoptFrame. Only valid if the type is kInterpretedFrame.\"\n        },\n        {\n          \"name\": \"as_inlined_arguments\",\n          \"parameters\": [],\n          \"return_type\": \"InlinedArgumentsDeoptFrame&\",\n          \"logic\": \"Casts this DeoptFrame to an InlinedArgumentsDeoptFrame. Only valid if the type is kInlinedArgumentsFrame.\"\n        },\n        {\n          \"name\": \"as_construct_stub\",\n          \"parameters\": [],\n          \"return_type\": \"ConstructInvokeStubDeoptFrame&\",\n          \"logic\": \"Casts this DeoptFrame to a ConstructInvokeStubDeoptFrame. Only valid if the type is kConstructInvokeStubFrame.\"\n        },\n        {\n          \"name\": \"as_builtin_continuation\",\n          \"parameters\": [],\n          \"return_type\": \"BuiltinContinuationDeoptFrame&\",\n          \"logic\": \"Casts this DeoptFrame to a BuiltinContinuationDeoptFrame. Only valid if the type is kBuiltinContinuationFrame.\"\n        },\n        {\n          \"name\": \"IsJsFrame\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if it is a Javascript Frame\"\n        },\n        {\n          \"name\": \"GetCompilationUnit\",\n          \"parameters\": [],\n          \"return_type\": \"const MaglevCompilationUnit&\",\n          \"logic\": \"Returns the compilation unit associated with the frame.\"\n        },\n        {\n          \"name\": \"GetBytecodeOffset\",\n          \"parameters\": [],\n          \"return_type\": \"BytecodeOffset\",\n          \"logic\": \"Returns the bytecode offset associated with the frame.\"\n        },\n        {\n          \"name\": \"GetSourcePosition\",\n          \"parameters\": [],\n          \"return_type\": \"SourcePosition\",\n          \"logic\": \"Returns the source position associated with the frame.\"\n        },\n        {\n          \"name\": \"GetSharedFunctionInfo\",\n          \"parameters\": [],\n          \"return_type\": \"compiler::SharedFunctionInfoRef\",\n          \"logic\": \"Returns the shared function info associated with the frame.\"\n        },\n        {\n          \"name\": \"GetBytecodeArray\",\n          \"parameters\": [],\n          \"return_type\": \"compiler::BytecodeArrayRef\",\n          \"logic\": \"Returns the bytecode array associated with the frame.\"\n        },\n        {\n          \"name\": \"GetVirtualObjects\",\n          \"parameters\": [],\n          \"return_type\": \"VirtualObjectList\",\n          \"logic\": \"Returns the virtual objects associated with the frame\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InterpretedDeoptFrame\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"InterpretedDeoptFrame\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& unit\",\n            \"const CompactInterpreterFrameState* frame_state\",\n            \"ValueNode* closure\",\n            \"BytecodeOffset bytecode_position\",\n            \"SourcePosition source_position\",\n            \"DeoptFrame* parent\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructs an InterpretedDeoptFrame.\"\n        },\n        {\n          \"name\": \"unit\",\n          \"parameters\": [],\n          \"return_type\": \"const MaglevCompilationUnit&\",\n          \"logic\": \"Returns the compilation unit.\"\n        },\n        {\n          \"name\": \"frame_state\",\n          \"parameters\": [],\n          \"return_type\": \"const CompactInterpreterFrameState*\",\n          \"logic\": \"Returns the compact interpreter frame state.\"\n        },\n        {\n          \"name\": \"closure\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the closure ValueNode.\"\n        },\n        {\n          \"name\": \"closure\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the closure ValueNode.\"\n        },\n        {\n          \"name\": \"bytecode_position\",\n          \"parameters\": [],\n          \"return_type\": \"BytecodeOffset\",\n          \"logic\": \"Returns the bytecode position.\"\n        },\n        {\n          \"name\": \"source_position\",\n          \"parameters\": [],\n          \"return_type\": \"SourcePosition\",\n          \"logic\": \"Returns the source position.\"\n        },\n        {\n          \"name\": \"ComputeReturnOffset\",\n          \"parameters\": [\n            \"interpreter::Register result_location\",\n            \"int result_size\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Computes the offset required for a return.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InlinedArgumentsDeoptFrame\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"InlinedArgumentsDeoptFrame\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& unit\",\n            \"BytecodeOffset bytecode_position\",\n            \"ValueNode* closure\",\n            \"base::Vector<ValueNode*> arguments\",\n            \"DeoptFrame* parent\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructs an InlinedArgumentsDeoptFrame.\"\n        },\n        {\n          \"name\": \"unit\",\n          \"parameters\": [],\n          \"return_type\": \"const MaglevCompilationUnit&\",\n          \"logic\": \"Returns the compilation unit.\"\n        },\n        {\n          \"name\": \"bytecode_position\",\n          \"parameters\": [],\n          \"return_type\": \"BytecodeOffset\",\n          \"logic\": \"Returns the bytecode position.\"\n        },\n        {\n          \"name\": \"closure\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the closure ValueNode.\"\n        },\n        {\n          \"name\": \"closure\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the closure ValueNode.\"\n        },\n        {\n          \"name\": \"arguments\",\n          \"parameters\": [],\n          \"return_type\": \"base::Vector<ValueNode*>\",\n          \"logic\": \"Returns the arguments\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ConstructInvokeStubDeoptFrame\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ConstructInvokeStubDeoptFrame\",\n          \"parameters\": [\n            \"const MaglevCompilationUnit& unit\",\n            \"SourcePosition source_position\",\n            \"ValueNode* receiver\",\n            \"ValueNode* context\",\n            \"DeoptFrame* parent\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructs a ConstructInvokeStubDeoptFrame\"\n        },\n        {\n          \"name\": \"unit\",\n          \"parameters\": [],\n          \"return_type\": \"const MaglevCompilationUnit&\",\n          \"logic\": \"Returns the compilation unit.\"\n        },\n        {\n          \"name\": \"receiver\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the receiver ValueNode.\"\n        },\n        {\n          \"name\": \"receiver\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the receiver ValueNode.\"\n        },\n        {\n          \"name\": \"context\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the context ValueNode.\"\n        },\n        {\n          \"name\": \"context\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the context ValueNode.\"\n        },\n        {\n          \"name\": \"source_position\",\n          \"parameters\": [],\n          \"return_type\": \"SourcePosition\",\n          \"logic\": \"Returns the source position.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BuiltinContinuationDeoptFrame\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"BuiltinContinuationDeoptFrame\",\n          \"parameters\": [\n            \"Builtin builtin_id\",\n            \"base::Vector<ValueNode*> parameters\",\n            \"ValueNode* context\",\n            \"compiler::OptionalJSFunctionRef maybe_js_target\",\n            \"DeoptFrame* parent\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructs a BuiltinContinuationDeoptFrame.\"\n        },\n        {\n          \"name\": \"builtin_id\",\n          \"parameters\": [],\n          \"return_type\": \"const Builtin&\",\n          \"logic\": \"Returns the builtin id\"\n        },\n        {\n          \"name\": \"parameters\",\n          \"parameters\": [],\n          \"return_type\": \"base::Vector<ValueNode*>\",\n          \"logic\": \"Returns the parameters\"\n        },\n        {\n          \"name\": \"context\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*&\",\n          \"logic\": \"Returns a reference to the context ValueNode.\"\n        },\n        {\n          \"name\": \"context\",\n          \"parameters\": [],\n          \"return_type\": \"ValueNode*\",\n          \"logic\": \"Returns the context ValueNode.\"\n        },\n        {\n          \"name\": \"is_javascript\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check whether the frame is Javascript\"\n        },\n        {\n          \"name\": \"javascript_target\",\n          \"parameters\": [],\n          \"return_type\": \"compiler::JSFunctionRef\",\n          \"logic\": \"Return Javascript target\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DeoptInfo\",\n      \"properties\": [\n        \"DeoptFrame top_frame_\",\n        \"const compiler::FeedbackSource feedback_to_update_\",\n        \"InputLocation* input_locations_\",\n        \"Label deopt_entry_label_\",\n        \"int translation_index_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"DeoptInfo\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"const DeoptFrame top_frame\",\n            \"compiler::FeedbackSource feedback_to_update\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor.\"\n        },\n        {\n          \"name\": \"top_frame\",\n          \"parameters\": [],\n          \"return_type\": \"DeoptFrame&\",\n          \"logic\": \"Returns a reference to the top frame.\"\n        },\n        {\n          \"name\": \"top_frame\",\n          \"parameters\": [],\n          \"return_type\": \"const DeoptFrame&\",\n          \"logic\": \"Returns a const reference to the top frame.\"\n        },\n        {\n          \"name\": \"feedback_to_update\",\n          \"parameters\": [],\n          \"return_type\": \"const compiler::FeedbackSource&\",\n          \"logic\": \"Returns a const reference to the feedback source to update.\"\n        },\n        {\n          \"name\": \"has_input_locations\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the deopt info has input locations.\"\n        },\n        {\n          \"name\": \"input_locations\",\n          \"parameters\": [],\n          \"return_type\": \"InputLocation*\",\n          \"logic\": \"Returns the input locations.\"\n        },\n        {\n          \"name\": \"InitializeInputLocations\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"size_t count\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes the input locations array.\"\n        },\n        {\n          \"name\": \"deopt_entry_label\",\n          \"parameters\": [],\n          \"return_type\": \"Label*\",\n          \"logic\": \"Returns the entry label for deoptimization.\"\n        },\n        {\n          \"name\": \"translation_index\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the translation index.\"\n        },\n        {\n          \"name\": \"set_translation_index\",\n          \"parameters\": [\n            \"int index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the translation index.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegisterSnapshot\",\n      \"properties\": [\n        \"RegList live_registers\",\n        \"RegList live_tagged_registers\",\n        \"DoubleRegList live_double_registers\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"EagerDeoptInfo\",\n      \"properties\": [\n        \"DeoptimizeReason reason_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"EagerDeoptInfo\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"const DeoptFrame top_frame\",\n            \"compiler::FeedbackSource feedback_to_update\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor.\"\n        },\n        {\n          \"name\": \"reason\",\n          \"parameters\": [],\n          \"return_type\": \"DeoptimizeReason\",\n          \"logic\": \"Returns the deoptimization reason.\"\n        },\n        {\n          \"name\": \"set_reason\",\n          \"parameters\": [\n            \"DeoptimizeReason reason\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the deoptimization reason.\"\n        },\n        {\n          \"name\": \"ForEachInput\",\n          \"parameters\": [\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterate the inputs of the EagerDeoptInfo.\"\n        },\n        {\n          \"name\": \"ForEachInput\",\n          \"parameters\": [\n            \"Function&& f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterate the inputs of the EagerDeoptInfo (const version).\"\n        }\n      ]\n    },\n    {\n      \"name\": \"LazyDeoptInfo\",\n      \"properties\": [\n        \"interpreter::Register result_location_\",\n        \"uint32_t bitfield_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"LazyDeoptInfo\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"const DeoptFrame top_frame\",\n            \"interpreter::Register result_location\",\n            \"int result_size\",\n            \"compiler::FeedbackSource feedback_to_update\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor.\"\n        },\n        {\n          \"name\": \"result_location\",\n          \"parameters\": [],\n          \"return_type\": \"interpreter::Register\",\n          \"logic\": \"Returns the register where the result of the deoptimizing call will be stored.\"\n        },\n        {\n          \"name\": \"result_size\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the size (in number of registers) of the result.\"\n        },\n        {\n          \"name\": \"IsResultRegister\",\n          \"parameters\": [\n            \"interpreter::Register reg\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check whether a given register is part of the result register range.\"\n        },\n        {\n          \"name\": \"UpdateResultLocation\",\n          \"parameters\": [\n            \"interpreter::Register result_location\",\n            \"int result_size\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates the location to which result of the deoptimizing call is saved.\"\n        },\n        {\n          \"name\": \"HasResultLocation\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns a boolean determining whether we have a result location\"\n        },\n        {\n          \"name\": \"GetFrameForExceptionHandler\",\n          \"parameters\": [\n            \"const ExceptionHandlerInfo* handler_info\"\n          ],\n          \"return_type\": \"const InterpretedDeoptFrame&\",\n          \"logic\": \"Returns the appropriate frame for the exception handler, given the handler information.\"\n        },\n        {\n          \"name\": \"deopting_call_return_pc\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the return program counter of the deoptimizing call.\"\n        },\n        {\n          \"name\": \"set_deopting_call_return_pc\",\n          \"parameters\": [\n            \"int pc\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the return program counter of the deoptimizing call.\"\n        },\n        {\n          \"name\": \"InReturnValues\",\n          \"parameters\": [\n            \"interpreter::Register reg\",\n"
}