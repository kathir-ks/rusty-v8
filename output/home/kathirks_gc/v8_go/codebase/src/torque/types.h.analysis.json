{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/torque/types.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/torque/types.h\",\n  \"imports\": [\n    \"<algorithm>\",\n    \"<optional>\",\n    \"<set>\",\n    \"<string>\",\n    \"<vector>\",\n    \"src/torque/ast.h\",\n    \"src/torque/constants.h\",\n    \"src/torque/source-positions.h\",\n    \"src/torque/utils.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"TypeBase\",\n      \"properties\": [\n        \"Kind kind_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"~TypeBase\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Virtual destructor\"\n        },\n        {\n          \"name\": \"IsTopType\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is the TopType\"\n        },\n        {\n          \"name\": \"IsAbstractType\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is an AbstractType\"\n        },\n        {\n          \"name\": \"IsBuiltinPointerType\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is a BuiltinPointerType\"\n        },\n        {\n          \"name\": \"IsUnionType\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is a UnionType\"\n        },\n        {\n          \"name\": \"IsBitFieldStructType\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is a BitFieldStructType\"\n        },\n        {\n          \"name\": \"IsStructType\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is a StructType\"\n        },\n        {\n          \"name\": \"IsClassType\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is a ClassType\"\n        },\n        {\n          \"name\": \"IsAggregateType\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is either a StructType or a ClassType\"\n        },\n        {\n          \"name\": \"kind\",\n          \"parameters\": [],\n          \"return_type\": \"Kind\",\n          \"logic\": \"Returns the kind of the TypeBase\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Type\",\n      \"properties\": [\n        \"const Type* parent_\",\n        \"mutable std::set<std::string> aliases_\",\n        \"size_t id_\",\n        \"MaybeSpecializationKey specialized_from_\",\n        \"mutable const Type* constexpr_version_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"operator=\",\n          \"parameters\": [\"const Type& other\"],\n          \"return_type\": \"Type&\",\n          \"logic\": \"Deleted copy assignment operator.\"\n        },\n        {\n          \"name\": \"IsSubtypeOf\",\n          \"parameters\": [\"const Type* supertype\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this type is a subtype of the given type\"\n        },\n        {\n          \"name\": \"ToString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the type\"\n        },\n        {\n          \"name\": \"SimpleName\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a simplified name for the type\"\n        },\n        {\n          \"name\": \"GetHandleTypeName\",\n          \"parameters\": [\"HandleKind kind\", \"const std::string& type_name\"],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the name of the handle type\"\n        },\n        {\n          \"name\": \"TagglifiedCppTypeName\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the tagglified C++ type name\"\n        },\n        {\n          \"name\": \"HandlifiedCppTypeName\",\n          \"parameters\": [\"HandleKind kind\"],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the handlified C++ type name\"\n        },\n        {\n          \"name\": \"parent\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the parent type\"\n        },\n        {\n          \"name\": \"IsVoid\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is Void\"\n        },\n        {\n          \"name\": \"IsNever\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is Never\"\n        },\n        {\n          \"name\": \"IsBool\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is Bool\"\n        },\n        {\n          \"name\": \"IsConstexprBool\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is ConstexprBool\"\n        },\n        {\n          \"name\": \"IsVoidOrNever\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is Void or Never\"\n        },\n        {\n          \"name\": \"IsFloat32\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is Float32\"\n        },\n        {\n          \"name\": \"IsFloat64\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is Float64\"\n        },\n        {\n          \"name\": \"GetGeneratedTypeName\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated type name\"\n        },\n        {\n          \"name\": \"GetGeneratedTNodeTypeName\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated TNode type name\"\n        },\n        {\n          \"name\": \"IsConstexpr\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is a constexpr type\"\n        },\n        {\n          \"name\": \"IsTransient\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is transient\"\n        },\n        {\n          \"name\": \"NonConstexprVersion\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Gets the non-constexpr version of this type\"\n        },\n        {\n          \"name\": \"GetConstexprGeneratedTypeName\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated type name for constexpr\"\n        },\n        {\n          \"name\": \"ClassSupertype\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<const ClassType*>\",\n          \"logic\": \"Gets the ClassSupertype, if this is or inherits from a class.\"\n        },\n        {\n          \"name\": \"StructSupertype\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<const StructType*>\",\n          \"logic\": \"Gets the StructSupertype, if this is or inherits from a struct.\"\n        },\n        {\n          \"name\": \"AggregateSupertype\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<const AggregateType*>\",\n          \"logic\": \"Gets the AggregateSupertype, if this is or inherits from an aggregate type (class or struct).\"\n        },\n        {\n          \"name\": \"GetTypeCheckers\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<TypeChecker>\",\n          \"logic\": \"Gets the type checkers for this type\"\n        },\n        {\n          \"name\": \"GetRuntimeType\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the runtime type name\"\n        },\n        {\n          \"name\": \"GetDebugType\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the debug type name\"\n        },\n        {\n          \"name\": \"CommonSupertype\",\n          \"parameters\": [\"const Type* a\", \"const Type* b\"],\n          \"return_type\": \"static const Type*\",\n          \"logic\": \"Finds the common supertype of two types\"\n        },\n        {\n          \"name\": \"AddAlias\",\n          \"parameters\": [\"std::string alias\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds an alias to the type\"\n        },\n        {\n          \"name\": \"id\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the id of the type\"\n        },\n        {\n          \"name\": \"GetSpecializedFrom\",\n          \"parameters\": [],\n          \"return_type\": \"const MaybeSpecializationKey&\",\n          \"logic\": \"Returns the specialization key, if it exists.\"\n        },\n        {\n          \"name\": \"MatchUnaryGeneric\",\n          \"parameters\": [\"const Type* type\", \"GenericType* generic\"],\n          \"return_type\": \"static std::optional<const Type*>\",\n          \"logic\": \"Matches a type against a unary generic type\"\n        },\n        {\n          \"name\": \"ComputeName\",\n          \"parameters\": [\"const std::string& basename\", \"MaybeSpecializationKey specialized_from\"],\n          \"return_type\": \"static std::string\",\n          \"logic\": \"Computes the name of a specialized type\"\n        },\n        {\n          \"name\": \"SetConstexprVersion\",\n          \"parameters\": [\"const Type* type\"],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Sets the constexpr version of a type.\"\n        },\n        {\n          \"name\": \"ConstexprVersion\",\n          \"parameters\": [],\n          \"return_type\": \"virtual const Type*\",\n          \"logic\": \"Gets the constexpr version of a type.\"\n        },\n        {\n          \"name\": \"AlignmentLog2\",\n          \"parameters\": [],\n          \"return_type\": \"virtual size_t\",\n          \"logic\": \"Returns the base-2 logarithm of the alignment requirements of a type\"\n        }\n      ]\n    },\n    {\n      \"name\": \"TypeChecker\",\n      \"properties\": [\n        \"std::string type\",\n        \"std::string weak_ref_to\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"TopType\",\n      \"properties\": [\n        \"std::string reason_\",\n        \"const Type* source_type_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetGeneratedTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns an empty string\"\n        },\n        {\n          \"name\": \"GetGeneratedTNodeTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated TNode type name\"\n        },\n        {\n          \"name\": \"ToExplicitString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the type\"\n        },\n        {\n          \"name\": \"source_type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the source type\"\n        },\n        {\n          \"name\": \"reason\",\n          \"parameters\": [],\n          \"return_type\": \"const std::string&\",\n          \"logic\": \"Returns the reason why the type is inaccessible.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AbstractType\",\n      \"properties\": [\n        \"AbstractTypeFlags flags_\",\n        \"const std::string name_\",\n        \"const std::string generated_type_\",\n        \"const Type* non_constexpr_version_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"name\",\n          \"parameters\": [],\n          \"return_type\": \"const std::string&\",\n          \"logic\": \"Returns the name of the abstract type\"\n        },\n        {\n          \"name\": \"ToExplicitString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the type\"\n        },\n        {\n          \"name\": \"GetGeneratedTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated type name implementation\"\n        },\n        {\n          \"name\": \"GetGeneratedTNodeTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated TNode type name implementation\"\n        },\n        {\n          \"name\": \"IsConstexpr\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is a constexpr type\"\n        },\n        {\n          \"name\": \"NonConstexprVersion\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Gets the non-constexpr version of this type\"\n        },\n        {\n          \"name\": \"GetTypeCheckers\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<TypeChecker>\",\n          \"logic\": \"Gets the type checkers for this type\"\n        },\n        {\n          \"name\": \"AlignmentLog2\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the base-2 logarithm of the alignment requirements of a type\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BuiltinPointerType\",\n      \"properties\": [\n        \"const TypeVector parameter_types_\",\n        \"const Type* const return_type_\",\n        \"const size_t function_pointer_type_id_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ToExplicitString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the type\"\n        },\n        {\n          \"name\": \"GetGeneratedTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated type name\"\n        },\n        {\n          \"name\": \"GetGeneratedTNodeTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated TNode type name\"\n        },\n        {\n          \"name\": \"parameter_types\",\n          \"parameters\": [],\n          \"return_type\": \"const TypeVector&\",\n          \"logic\": \"Returns the parameter types of the builtin pointer\"\n        },\n        {\n          \"name\": \"return_type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the return type of the builtin pointer\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\"const BuiltinPointerType& other\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks for equality with another BuiltinPointerType\"\n        },\n        {\n          \"name\": \"function_pointer_type_id\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the id of the function pointer type.\"\n        },\n        {\n          \"name\": \"GetTypeCheckers\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<TypeChecker>\",\n          \"logic\": \"Gets the type checkers for this type\"\n        },\n        {\n          \"name\": \"HasContextParameter\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this builtin pointer type has a Context parameter.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"UnionType\",\n      \"properties\": [\n        \"std::set<const Type*, TypeLess> types_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetGeneratedTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated type name\"\n        },\n        {\n          \"name\": \"GetGeneratedTNodeTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated TNode type name\"\n        },\n        {\n          \"name\": \"GetRuntimeType\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns the RuntimeType\"\n        },\n        {\n          \"name\": \"GetDebugType\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns the DebugType\"\n        },\n        {\n          \"name\": \"GetConstexprGeneratedTypeName\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated name for a constexpr type\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\"const UnionType& other\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks for equality with another UnionType\"\n        },\n        {\n          \"name\": \"GetSingleMember\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<const Type*>\",\n          \"logic\": \"Returns the single type if this union consists of a single element only\"\n        },\n        {\n          \"name\": \"IsSubtypeOf\",\n          \"parameters\": [\"const Type* other\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this type is a subtype of the given type\"\n        },\n        {\n          \"name\": \"IsSupertypeOf\",\n          \"parameters\": [\"const Type* other\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check whether it is a supertype of the given other type.\"\n        },\n        {\n          \"name\": \"IsTransient\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is transient\"\n        },\n        {\n          \"name\": \"IsConstexpr\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is a constexpr type\"\n        },\n        {\n          \"name\": \"NonConstexprVersion\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Gets the non-constexpr version of this type\"\n        },\n        {\n          \"name\": \"Extend\",\n          \"parameters\": [\"const Type* t\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Extends the union type with another type.\"\n        },\n        {\n          \"name\": \"ToExplicitString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the type.\"\n        },\n        {\n          \"name\": \"Subtract\",\n          \"parameters\": [\"const Type* t\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Subtracts a given type t from the union.\"\n        },\n        {\n          \"name\": \"GetTypeCheckers\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<TypeChecker>\",\n          \"logic\": \"Gets all type checkers associated with union members\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BitFieldStructType\",\n      \"properties\": [\n        \"Namespace* namespace_\",\n        \"const BitFieldStructDeclaration* decl_\",\n        \"std::vector<BitField> fields_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ToExplicitString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the type\"\n        },\n        {\n          \"name\": \"GetGeneratedTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated type name\"\n        },\n        {\n          \"name\": \"GetGeneratedTNodeTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated TNode type name\"\n        },\n        {\n          \"name\": \"GetTypeCheckers\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<TypeChecker>\",\n          \"logic\": \"Gets the type checkers for this type\"\n        },\n        {\n          \"name\": \"SetConstexprVersion\",\n          \"parameters\": [\"const Type*\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Raises an error as it is unreachable\"\n        },\n        {\n          \"name\": \"ConstexprVersion\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the constexpr version\"\n        },\n        {\n          \"name\": \"RegisterField\",\n          \"parameters\": [\"BitField field\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Registers a field with the bitfield struct.\"\n        },\n        {\n          \"name\": \"name\",\n          \"parameters\": [],\n          \"return_type\": \"const std::string&\",\n          \"logic\": \"Returns the name of the bitfield struct.\"\n        },\n        {\n          \"name\": \"fields\",\n          \"parameters\": [],\n          \"return_type\": \"const std::vector<BitField>&\",\n          \"logic\": \"Returns the fields of the struct.\"\n        },\n        {\n          \"name\": \"LookupField\",\n          \"parameters\": [\"const std::string& name\"],\n          \"return_type\": \"const BitField&\",\n          \"logic\": \"Lookup the information associated with a field given a field name.\"\n        },\n        {\n          \"name\": \"GetPosition\",\n          \"parameters\": [],\n          \"return_type\": \"const SourcePosition\",\n          \"logic\": \"Returns the source position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AggregateType\",\n      \"properties\": [\n        \"mutable bool is_finalized_\",\n        \"std::vector<Field> fields_\",\n        \"Namespace* namespace_\",\n        \"std::string name_\",\n        \"std::vector<Method*> methods_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetGeneratedTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns an empty string\"\n        },\n        {\n          \"name\": \"GetGeneratedTNodeTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns an empty string\"\n        },\n        {\n          \"name\": \"Finalize\",\n          \"parameters\": [],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Marks this type as finalized.\"\n        },\n        {\n          \"name\": \"SetFields\",\n          \"parameters\": [\"std::vector<Field> fields\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the fields of the aggregate type\"\n        },\n        {\n          \"name\": \"fields\",\n          \"parameters\": [],\n          \"return_type\": \"const std::vector<Field>&\",\n          \"logic\": \"Gets the fields of this type, finalizing it first.\"\n        },\n        {\n          \"name\": \"HasField\",\n          \"parameters\": [\"const std::string& name\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the aggregate type has the specified field.\"\n        },\n        {\n          \"name\": \"LookupField\",\n          \"parameters\": [\"const std::string& name\"],\n          \"return_type\": \"const Field&\",\n          \"logic\": \"Looks up a field by name, finalizing the type first.\"\n        },\n        {\n          \"name\": \"name\",\n          \"parameters\": [],\n          \"return_type\": \"const std::string&\",\n          \"logic\": \"Returns the name of the aggregate type\"\n        },\n        {\n          \"name\": \"nspace\",\n          \"parameters\": [],\n          \"return_type\": \"Namespace*\",\n          \"logic\": \"Returns the namespace of the aggregate type\"\n        },\n        {\n          \"name\": \"RegisterField\",\n          \"parameters\": [\"Field field\"],\n          \"return_type\": \"virtual const Field&\",\n          \"logic\": \"Registers a new field in the struct\"\n        },\n        {\n          \"name\": \"RegisterMethod\",\n          \"parameters\": [\"Method* method\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Registers a method with this Aggregate Type.\"\n        },\n        {\n          \"name\": \"Methods\",\n          \"parameters\": [],\n          \"return_type\": \"const std::vector<Method*>&\",\n          \"logic\": \"Gets all registered methods of the aggregate type, finalizing it first.\"\n        },\n        {\n          \"name\": \"Methods\",\n          \"parameters\": [\"const std::string& name\"],\n          \"return_type\": \"std::vector<Method*>\",\n          \"logic\": \"Gets all registered methods of the aggregate type, finalizing it first, with the provided name.\"\n        },\n        {\n          \"name\": \"GetHierarchy\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<const AggregateType*>\",\n          \"logic\": \"Gets the inheritance hierarchy of this type.\"\n        },\n        {\n          \"name\": \"GetTypeCheckers\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<TypeChecker>\",\n          \"logic\": \"Gets the type checkers for this type\"\n        },\n        {\n          \"name\": \"LastField\",\n          \"parameters\": [],\n          \"return_type\": \"const Field&\",\n          \"logic\": \"Returns the last field added to the type or any of its base types.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"StructType\",\n      \"properties\": [\n        \"const StructDeclaration* decl_\",\n        \"std::string generated_type_name_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetGeneratedTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated type name\"\n        },\n        {\n          \"name\": \"PackedSize\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the size of the struct when packed\"\n        },\n        {\n          \"name\": \"AlignmentLog2\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the base-2 logarithm of the alignment requirements of a type\"\n        },\n        {\n          \"name\": \"ClassifyContents\",\n          \"parameters\": [],\n          \"return_type\": \"Classification\",\n          \"logic\": \"Classifies a struct as containing tagged data, untagged data, or both.\"\n        },\n        {\n          \"name\": \"GetPosition\",\n          \"parameters\": [],\n          \"return_type\": \"SourcePosition\",\n          \"logic\": \"Gets the source code position where this struct was defined.\"\n        },\n        {\n          \"name\": \"Finalize\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Finalizes the struct type.  Checks for duplicate fields.\"\n        },\n        {\n          \"name\": \"ToExplicitString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the type\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ClassType\",\n      \"properties\": [\n        \"size_t header_size_\",\n        \"ResidueClass size_\",\n        \"mutable ClassFlags flags_\",\n        \"const std::string generates_\",\n        \"const ClassDeclaration* decl_\",\n        \"const TypeAlias* alias_\",\n        \"mutable std::optional<int> own_instance_type_\",\n        \"mutable std::optional<std::pair<int, int>> instance_type_range_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ToExplicitString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the type\"\n        },\n        {\n          \"name\": \"GetGeneratedTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated type name implementation\"\n        },\n        {\n          \"name\": \"GetGeneratedTNodeTypeNameImpl\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Gets the generated TNode type name implementation\"\n        },\n        {\n          \"name\": \"IsExtern\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the class is defined externally\"\n        },\n        {\n          \"name\": \"ShouldGeneratePrint\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a print function should be generated\"\n        },\n        {\n          \"name\": \"ShouldGenerateVerify\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a verification function should be generated\"\n        },\n        {\n          \"name\": \"ShouldGenerateBodyDescriptor\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a body descriptor should be generated\"\n        },\n        {\n          \"name\": \"DoNotGenerateCast\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the cast should be not generated\"\n        },\n        {\n          \"name\": \"IsTransient\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type is transient\"\n        },\n        {\n          \"name\": \"IsAbstract\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the class is abstract\"\n        },\n        {\n          \"name\": \"IsLayoutDefinedInCpp\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the class layout is defined in C++\"\n        },\n        {\n          \"name\": \"HasSameInstanceTypeAsParent\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the class has the same instance type as its parent\"\n        },\n        {\n          \"name\": \"ShouldGenerateCppClassDefinitions\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if C++ class definitions should be generated\"\n        },\n        {\n          \"name\": \"ShouldGenerateCppObjectDefinitionAsserts\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if assertions for C++ object definitions should be generated\"\n        },\n        {\n          \"name\": \"ShouldGenerateCppObjectLayoutDefinitionAsserts\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if assertions for C++ object layout definitions should be generated\"\n        },\n        {\n          \"name\": \"ShouldGenerateFullClassDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the full class definition should be generated\"\n        },\n        {\n          \"name\": \"ShouldGenerateUniqueMap\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a unique map should be generated\"\n        },\n        {\n          \"name\": \"ShouldGenerateFactoryFunction\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a factory function should be generated\"\n        },\n        {\n          \"name\": \"ShouldExport\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the class should be exported\"\n        },\n        {\n          \"name\": \"IsShape\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the class is a shape.\"\n        },\n        {\n          \"name\": \"HasStaticSize\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines whether the class has static size.\"\n        },\n        {\n          \"name\": \"header_size\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the header size.\"\n        },\n        {\n          \"name\": \"size\",\n          \"parameters\": [],\n          \"return_type\": \"ResidueClass\",\n          \"logic\": \"Returns the size.\"\n        },\n        {\n          \"name\": \"GetSuperClass\",\n          \"parameters\": [],\n          \"return_type\": \"const ClassType*\",\n          \"logic\": \"Returns the super class.\"\n        },\n        {\n          \"name\": \"GenerateAccessors\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Generates accessors for the class's fields.\"\n        },\n        {\n          \"name\": \"AllowInstantiation\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks whether this class can be instantiated.  Currently this is just the negation of isAbstract.\"\n        },\n        {\n          \"name\": \"RegisterField\",\n          \"parameters\": [\"Field field\"],\n          \"return_type\": \"virtual const Field&\",\n          \"logic\": \"Registers a new field with this class.\"\n        },\n        {\n          \"name\": \"Finalize\",\n          \"parameters\": [],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Finalizes the class type. This includes resolving the field layout, and computing the size, classification and accessors. Also performs duplicate checks.\"\n        },\n        {\n          \"name\": \"ComputeAllFields\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<Field>\",\n          \"logic\":"
}