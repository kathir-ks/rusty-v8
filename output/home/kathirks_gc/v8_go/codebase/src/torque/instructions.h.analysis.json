{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/torque/instructions.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/torque/instructions.h\",\n  \"imports\": [\n    \"<memory>\",\n    \"<optional>\",\n    \"src/torque/ast.h\",\n    \"src/torque/source-positions.h\",\n    \"src/torque/types.h\",\n    \"src/torque/utils.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"DefinitionLocation\",\n      \"properties\": [\n        \"Kind kind_\",\n        \"const void* location_\",\n        \"std::size_t index_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"DefinitionLocation\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Default constructor, initializes the location to invalid.\"\n        },\n        {\n          \"name\": \"Parameter\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Creates a DefinitionLocation representing a function parameter.\"\n        },\n        {\n          \"name\": \"Phi\",\n          \"parameters\": [\n            \"const Block* block\",\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Creates a DefinitionLocation representing a phi node in a block.\"\n        },\n        {\n          \"name\": \"Instruction\",\n          \"parameters\": [\n            \"const InstructionBase* instruction\",\n            \"std::size_t index = 0\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Creates a DefinitionLocation representing an instruction.\"\n        },\n        {\n          \"name\": \"GetKind\",\n          \"parameters\": [],\n          \"return_type\": \"Kind\",\n          \"logic\": \"Returns the kind of definition location.\"\n        },\n        {\n          \"name\": \"IsValid\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the definition location is valid.\"\n        },\n        {\n          \"name\": \"IsParameter\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the definition location is a parameter.\"\n        },\n        {\n          \"name\": \"IsPhi\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the definition location is a phi node.\"\n        },\n        {\n          \"name\": \"IsInstruction\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the definition location is an instruction.\"\n        },\n        {\n          \"name\": \"GetParameterIndex\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the index of the parameter.\"\n        },\n        {\n          \"name\": \"GetPhiBlock\",\n          \"parameters\": [],\n          \"return_type\": \"const Block*\",\n          \"logic\": \"Returns the block associated with the phi node.\"\n        },\n        {\n          \"name\": \"IsPhiFromBlock\",\n          \"parameters\": [\n            \"const Block* block\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a phi comes from a specific block.\"\n        },\n        {\n          \"name\": \"GetPhiIndex\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the index of the phi node.\"\n        },\n        {\n          \"name\": \"GetInstruction\",\n          \"parameters\": [],\n          \"return_type\": \"const InstructionBase*\",\n          \"logic\": \"Returns the instruction associated with the definition location.\"\n        },\n        {\n          \"name\": \"GetInstructionIndex\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the index of the instruction within the location.\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\n            \"const DefinitionLocation& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two DefinitionLocation objects for equality.\"\n        },\n        {\n          \"name\": \"operator!=\",\n          \"parameters\": [\n            \"const DefinitionLocation& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two DefinitionLocation objects for inequality.\"\n        },\n        {\n          \"name\": \"operator<\",\n          \"parameters\": [\n            \"const DefinitionLocation& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two DefinitionLocation objects for less than comparison.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InstructionBase\",\n      \"properties\": [\n        \"SourcePosition pos\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"InstructionBase\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionBase\",\n          \"logic\": \"Constructor that initializes the source position.\"\n        },\n        {\n          \"name\": \"Clone\",\n          \"parameters\": [],\n          \"return_type\": \"std::unique_ptr<InstructionBase>\",\n          \"logic\": \"Pure virtual function to clone the instruction.\"\n        },\n        {\n          \"name\": \"Assign\",\n          \"parameters\": [\n            \"const InstructionBase& other\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pure virtual function to assign the data of another instruction.\"\n        },\n        {\n          \"name\": \"~InstructionBase\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionBase\",\n          \"logic\": \"Virtual destructor\"\n        },\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pure virtual function to perform type checking for the instruction.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pure virtual function to recompute the definition locations of the instruction.\"\n        },\n        {\n          \"name\": \"InvalidateTransientTypes\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Invalidates transient types on the stack.\"\n        },\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Virtual function to check if the instruction is a block terminator.\"\n        },\n        {\n          \"name\": \"AppendSuccessorBlocks\",\n          \"parameters\": [\n            \"std::vector<Block*>* block_list\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Virtual function to append successor blocks.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Instruction\",\n      \"properties\": [\n        \"InstructionKind kind_\",\n        \"std::unique_ptr<InstructionBase> instruction_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Instruction (template)\",\n          \"parameters\": [\n            \"T instr\"\n          ],\n          \"return_type\": \"Instruction\",\n          \"logic\": \"Constructor for a specific instruction type.\"\n        },\n        {\n          \"name\": \"Cast (template)\",\n          \"parameters\": [],\n          \"return_type\": \"T&\",\n          \"logic\": \"Casts the underlying instruction to a specific type (non-const).\"\n        },\n        {\n          \"name\": \"Cast (template, const)\",\n          \"parameters\": [],\n          \"return_type\": \"const T&\",\n          \"logic\": \"Casts the underlying instruction to a specific type (const).\"\n        },\n        {\n          \"name\": \"Is (template)\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the instruction is of a specific type.\"\n        },\n        {\n          \"name\": \"DynamicCast (template)\",\n          \"parameters\": [],\n          \"return_type\": \"T*\",\n          \"logic\": \"Dynamically casts the underlying instruction to a specific type (non-const), returning nullptr if the cast fails.\"\n        },\n        {\n          \"name\": \"DynamicCast (template, const)\",\n          \"parameters\": [],\n          \"return_type\": \"const T*\",\n          \"logic\": \"Dynamically casts the underlying instruction to a specific type (const), returning nullptr if the cast fails.\"\n        },\n        {\n          \"name\": \"Instruction\",\n          \"parameters\": [\n            \"const Instruction& other\"\n          ],\n          \"return_type\": \"Instruction\",\n          \"logic\": \"Copy constructor\"\n        },\n        {\n          \"name\": \"operator=\",\n          \"parameters\": [\n            \"const Instruction& other\"\n          ],\n          \"return_type\": \"Instruction&\",\n          \"logic\": \"Assignment operator\"\n        },\n        {\n          \"name\": \"kind\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionKind\",\n          \"logic\": \"Returns the instruction kind.\"\n        },\n        {\n          \"name\": \"Mnemonic\",\n          \"parameters\": [],\n          \"return_type\": \"const char*\",\n          \"logic\": \"Returns the mnemonic string for the instruction.\"\n        },\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Calls TypeInstruction on the underlying instruction.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Calls RecomputeDefinitionLocations on the underlying instruction.\"\n        },\n        {\n          \"name\": \"operator-> (non-const)\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionBase*\",\n          \"logic\": \"Allows accessing the members of the underlying InstructionBase class via the arrow operator (non-const).\"\n        },\n        {\n          \"name\": \"operator-> (const)\",\n          \"parameters\": [],\n          \"return_type\": \"const InstructionBase*\",\n          \"logic\": \"Allows accessing the members of the underlying InstructionBase class via the arrow operator (const).\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PeekInstruction\",\n      \"properties\": [\n        \"BottomOffset slot\",\n        \"std::optional<const Type*> widened_type\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"PokeInstruction\",\n      \"properties\": [\n        \"BottomOffset slot\",\n        \"std::optional<const Type*> widened_type\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"DeleteRangeInstruction\",\n      \"properties\": [\n        \"StackRange range\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"PushUninitializedInstruction\",\n      \"properties\": [\n        \"const Type* type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of the pushed value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PushBuiltinPointerInstruction\",\n      \"properties\": [\n        \"std::string external_name\",\n        \"const Type* type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of the pushed value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"NamespaceConstantInstruction\",\n      \"properties\": [\n        \"NamespaceConstant* constant\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of value definitions.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of a value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"LoadReferenceInstruction\",\n      \"properties\": [\n        \"const Type* type\",\n        \"FieldSynchronization synchronization\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of the loaded value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"StoreReferenceInstruction\",\n      \"properties\": [\n        \"const Type* type\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"LoadBitFieldInstruction\",\n      \"properties\": [\n        \"const Type* bit_field_struct_type\",\n        \"BitField bit_field\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of the loaded value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"StoreBitFieldInstruction\",\n      \"properties\": [\n        \"const Type* bit_field_struct_type\",\n        \"BitField bit_field\",\n        \"bool starts_as_zero\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of the stored value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallIntrinsicInstruction\",\n      \"properties\": [\n        \"Intrinsic* intrinsic\",\n        \"TypeVector specialization_types\",\n        \"std::vector<std::string> constexpr_arguments\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of value definitions.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of a value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallCsaMacroInstruction\",\n      \"properties\": [\n        \"Macro* macro\",\n        \"std::vector<std::string> constexpr_arguments\",\n        \"std::optional<Block*> catch_block\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"AppendSuccessorBlocks\",\n          \"parameters\": [\n            \"std::vector<Block*>* block_list\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the catch block to the list of successor blocks, if present.\"\n        },\n        {\n          \"name\": \"GetExceptionObjectDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<DefinitionLocation>\",\n          \"logic\": \"Returns the location where the exception object is defined, if any.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of value definitions.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of a value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallCsaMacroAndBranchInstruction\",\n      \"properties\": [\n        \"Macro* macro\",\n        \"std::vector<std::string> constexpr_arguments\",\n        \"std::optional<Block*> return_continuation\",\n        \"std::vector<Block*> label_blocks\",\n        \"std::optional<Block*> catch_block\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true because this instruction terminates a block.\"\n        },\n        {\n          \"name\": \"AppendSuccessorBlocks\",\n          \"parameters\": [\n            \"std::vector<Block*>* block_list\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the catch block, return continuation and label blocks to the list of successor blocks, if present.\"\n        },\n        {\n          \"name\": \"GetLabelCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of labels.\"\n        },\n        {\n          \"name\": \"GetLabelValueDefinitionCount\",\n          \"parameters\": [\n            \"std::size_t label\"\n          ],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of value definitions for a label.\"\n        },\n        {\n          \"name\": \"GetLabelValueDefinition\",\n          \"parameters\": [\n            \"std::size_t label\",\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of a value for a label.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of value definitions.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of a value.\"\n        },\n        {\n          \"name\": \"GetExceptionObjectDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<DefinitionLocation>\",\n          \"logic\": \"Returns the location where the exception object is defined, if any.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MakeLazyNodeInstruction\",\n      \"properties\": [\n        \"Macro* macro\",\n        \"const Type* result_type\",\n        \"std::vector<std::string> constexpr_arguments\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of the lazy node.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallBuiltinInstruction\",\n      \"properties\": [\n        \"bool is_tailcall\",\n        \"Builtin* builtin\",\n        \"size_t argc\",\n        \"std::optional<Block*> catch_block\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether this call is a tailcall or not.\"\n        },\n        {\n          \"name\": \"AppendSuccessorBlocks\",\n          \"parameters\": [\n            \"std::vector<Block*>* block_list\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the catch block to the list of successor blocks, if present.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of value definitions.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of a value.\"\n        },\n        {\n          \"name\": \"GetExceptionObjectDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<DefinitionLocation>\",\n          \"logic\": \"Returns the location where the exception object is defined, if any.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallBuiltinPointerInstruction\",\n      \"properties\": [\n        \"bool is_tailcall\",\n        \"const BuiltinPointerType* type\",\n        \"size_t argc\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether this call is a tailcall or not.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of value definitions.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of a value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallRuntimeInstruction\",\n      \"properties\": [\n        \"bool is_tailcall\",\n        \"RuntimeFunction* runtime_function\",\n        \"size_t argc\",\n        \"std::optional<Block*> catch_block\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether this call is a tailcall or not.\"\n        },\n        {\n          \"name\": \"AppendSuccessorBlocks\",\n          \"parameters\": [\n            \"std::vector<Block*>* block_list\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the catch block to the list of successor blocks, if present.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Retrieves the number of value definitions.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of a value.\"\n        },\n        {\n          \"name\": \"GetExceptionObjectDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<DefinitionLocation>\",\n          \"logic\": \"Returns the location where the exception object is defined, if any.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BranchInstruction\",\n      \"properties\": [\n        \"Block* if_true\",\n        \"Block* if_false\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true because this instruction terminates a block.\"\n        },\n        {\n          \"name\": \"AppendSuccessorBlocks\",\n          \"parameters\": [\n            \"std::vector<Block*>* block_list\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the if_true and if_false blocks to the list of successor blocks.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ConstexprBranchInstruction\",\n      \"properties\": [\n        \"std::string condition\",\n        \"Block* if_true\",\n        \"Block* if_false\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true because this instruction terminates a block.\"\n        },\n        {\n          \"name\": \"AppendSuccessorBlocks\",\n          \"parameters\": [\n            \"std::vector<Block*>* block_list\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the if_true and if_false blocks to the list of successor blocks.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"GotoInstruction\",\n      \"properties\": [\n        \"Block* destination\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true because this instruction terminates a block.\"\n        },\n        {\n          \"name\": \"AppendSuccessorBlocks\",\n          \"parameters\": [\n            \"std::vector<Block*>* block_list\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the destination block to the list of successor blocks.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"GotoExternalInstruction\",\n      \"properties\": [\n        \"std::string destination\",\n        \"std::vector<std::string> variable_names\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true because this instruction terminates a block.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ReturnInstruction\",\n      \"properties\": [\n        \"size_t count\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true because this instruction terminates a block.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PrintErrorInstruction\",\n      \"properties\": [\n        \"std::string message\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"AbortInstruction\",\n      \"properties\": [\n        \"Kind kind\",\n        \"std::string message\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if the instruction is an abort (Unreachable or AssertionFailure) other wise false(DebugBreak).\"\n        },\n        {\n          \"name\": \"KindToString\",\n          \"parameters\": [\n            \"Kind kind\"\n          ],\n          \"return_type\": \"const char*\",\n          \"logic\": \"Returns a string representation of the AbortInstruction::Kind.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"UnsafeCastInstruction\",\n      \"properties\": [\n        \"const Type* destination_type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Retrieves the definition location of the cast value.\"\n        }\n      ]\n    }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& stream\",\n        \"const DefinitionLocation& loc\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for DefinitionLocation to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const PeekInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for PeekInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const PokeInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for PokeInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const DeleteRangeInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for DeleteRangeInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const PushUninitializedInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for PushUninitializedInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const PushBuiltinPointerInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for PushBuiltinPointerInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const NamespaceConstantInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for NamespaceConstantInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const LoadReferenceInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for LoadReferenceInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const StoreReferenceInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for StoreReferenceInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const LoadBitFieldInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for LoadBitFieldInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const StoreBitFieldInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for StoreBitFieldInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallIntrinsicInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for CallIntrinsicInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallCsaMacroInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for CallCsaMacroInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallCsaMacroAndBranchInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for CallCsaMacroAndBranchInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const MakeLazyNodeInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for MakeLazyNodeInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallBuiltinInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for CallBuiltinInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallBuiltinPointerInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for CallBuiltinPointerInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallRuntimeInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for CallRuntimeInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const BranchInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for BranchInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const ConstexprBranchInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for ConstexprBranchInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const GotoInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator for GotoInstruction to provide a string representation for debugging.\"\n    },\n    {\n      \"name\": \"operator<<\","
}