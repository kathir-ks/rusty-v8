{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/torque/type-oracle.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/torque/type-oracle.h\",\n  \"imports\": [\n    \"<memory>\",\n    \"<optional>\",\n    \"src/base/contextual.h\",\n    \"src/torque/constants.h\",\n    \"src/torque/declarable.h\",\n    \"src/torque/declarations.h\",\n    \"src/torque/types.h\",\n    \"src/torque/utils.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"TypeOracle\",\n      \"properties\": [\n        \"function_pointer_types_\",\n        \"all_builtin_pointer_types_\",\n        \"union_types_\",\n        \"nominal_types_\",\n        \"aggregate_types_\",\n        \"bit_field_struct_types_\",\n        \"top_types_\",\n        \"generic_type_instantiation_namespaces_\",\n        \"next_type_id_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GetAbstractType\",\n          \"parameters\": [\n            \"const Type* parent\",\n            \"std::string name\",\n            \"AbstractTypeFlags flags\",\n            \"std::string generated\",\n            \"const Type* non_constexpr_version\",\n            \"MaybeSpecializationKey specialized_from\"\n          ],\n          \"return_type\": \"const AbstractType*\",\n          \"logic\": \"Creates and returns a new AbstractType object. It also sets the constexpr version if provided and stores the type in the nominal_types_ vector.\"\n        },\n        {\n          \"name\": \"GetStructType\",\n          \"parameters\": [\n            \"const StructDeclaration* decl\",\n            \"MaybeSpecializationKey specialized_from\"\n          ],\n          \"return_type\": \"StructType*\",\n          \"logic\": \"Creates and returns a new StructType object, stores it in the aggregate_types_ vector.\"\n        },\n        {\n          \"name\": \"GetBitFieldStructType\",\n          \"parameters\": [\n            \"const Type* parent\",\n            \"const BitFieldStructDeclaration* decl\"\n          ],\n          \"return_type\": \"BitFieldStructType*\",\n          \"logic\": \"Creates and returns a new BitFieldStructType object, stores it in the bit_field_struct_types_ vector.\"\n        },\n        {\n          \"name\": \"GetClassType\",\n          \"parameters\": [\n            \"const Type* parent\",\n            \"const std::string& name\",\n            \"ClassFlags flags\",\n            \"const std::string& generates\",\n            \"ClassDeclaration* decl\",\n            \"const TypeAlias* alias\"\n          ],\n          \"return_type\": \"ClassType*\",\n          \"logic\": \"Creates and returns a new ClassType object, and stores it in aggregate_types_.\"\n        },\n        {\n          \"name\": \"GetBuiltinPointerType\",\n          \"parameters\": [\n            \"TypeVector argument_types\",\n            \"const Type* return_type\"\n          ],\n          \"return_type\": \"const BuiltinPointerType*\",\n          \"logic\": \"Creates or retrieves a BuiltinPointerType, deduplicates it and stores it in all_builtin_pointer_types_. Returns the deduplicated type.\"\n        },\n        {\n          \"name\": \"GetGenericTypeInstance\",\n          \"parameters\": [\n            \"GenericType* generic_type\",\n            \"TypeVector arg_types\"\n          ],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Retrieves or creates an instance of a generic type with the given arguments.  The implementation is not present in this header file.\"\n        },\n        {\n          \"name\": \"GetReferenceGeneric\",\n          \"parameters\": [\n            \"bool is_const\"\n          ],\n          \"return_type\": \"GenericType*\",\n          \"logic\": \"Looks up and returns the generic type for either a const or mutable reference.\"\n        },\n        {\n          \"name\": \"GetConstReferenceGeneric\",\n          \"parameters\": [],\n          \"return_type\": \"GenericType*\",\n          \"logic\": \"Returns the generic type for a const reference.\"\n        },\n        {\n          \"name\": \"GetMutableReferenceGeneric\",\n          \"parameters\": [],\n          \"return_type\": \"GenericType*\",\n          \"logic\": \"Returns the generic type for a mutable reference.\"\n        },\n        {\n          \"name\": \"MatchReferenceGeneric\",\n          \"parameters\": [\n            \"const Type* reference_type\",\n            \"bool* is_const\"\n          ],\n          \"return_type\": \"std::optional<const Type*>\",\n          \"logic\": \"Tries to match a given type to the reference generic and if it does, it returns the type the reference refers to.\"\n        },\n        {\n          \"name\": \"GetMutableSliceGeneric\",\n          \"parameters\": [],\n          \"return_type\": \"GenericType*\",\n          \"logic\": \"Looks up and returns the generic type for a mutable slice.\"\n        },\n        {\n          \"name\": \"GetConstSliceGeneric\",\n          \"parameters\": [],\n          \"return_type\": \"GenericType*\",\n          \"logic\": \"Looks up and returns the generic type for a const slice.\"\n        },\n        {\n          \"name\": \"GetWeakGeneric\",\n          \"parameters\": [],\n          \"return_type\": \"GenericType*\",\n          \"logic\": \"Looks up and returns the generic type for the 'weak' type.\"\n        },\n        {\n          \"name\": \"GetSmiTaggedGeneric\",\n          \"parameters\": [],\n          \"return_type\": \"GenericType*\",\n          \"logic\": \"Looks up and returns the generic type for the 'SmiTagged' type.\"\n        },\n        {\n          \"name\": \"GetLazyGeneric\",\n          \"parameters\": [],\n          \"return_type\": \"GenericType*\",\n          \"logic\": \"Looks up and returns the generic type for the 'Lazy' type.\"\n        },\n        {\n          \"name\": \"GetReferenceType\",\n          \"parameters\": [\n            \"const Type* referenced_type\",\n            \"bool is_const\"\n          ],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns a reference type to referenced_type.  If `is_const` is true, returns a const reference; otherwise returns a mutable reference.\"\n        },\n        {\n          \"name\": \"GetConstReferenceType\",\n          \"parameters\": [\n            \"const Type* referenced_type\"\n          ],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns a const reference type to referenced_type.\"\n        },\n        {\n          \"name\": \"GetMutableReferenceType\",\n          \"parameters\": [\n            \"const Type* referenced_type\"\n          ],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns a mutable reference type to referenced_type.\"\n        },\n        {\n          \"name\": \"GetMutableSliceType\",\n          \"parameters\": [\n            \"const Type* referenced_type\"\n          ],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns a mutable slice type to referenced_type.\"\n        },\n        {\n          \"name\": \"GetConstSliceType\",\n          \"parameters\": [\n            \"const Type* referenced_type\"\n          ],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns a const slice type to referenced_type.\"\n        },\n        {\n          \"name\": \"AllBuiltinPointerTypes\",\n          \"parameters\": [],\n          \"return_type\": \"const std::vector<const BuiltinPointerType*>&\",\n          \"logic\": \"Returns a reference to the vector of all builtin pointer types.\"\n        },\n        {\n          \"name\": \"GetUnionType\",\n          \"parameters\": [\n            \"UnionType type\"\n          ],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Gets a union type, creating it if it doesn't exist. If the UnionType contains only one type, returns the single type rather than constructing a new union.\"\n        },\n        {\n          \"name\": \"GetUnionType\",\n          \"parameters\": [\n            \"const Type* a\",\n            \"const Type* b\"\n          ],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Gets a union type of two types, creating it if it doesn't exist.\"\n        },\n        {\n          \"name\": \"GetTopType\",\n          \"parameters\": [\n            \"std::string reason\",\n            \"const Type* source_type\"\n          ],\n          \"return_type\": \"const TopType*\",\n          \"logic\": \"Creates and returns a new TopType object, and stores it in top_types_. Represents a type error.\"\n        },\n        {\n          \"name\": \"GetArgumentsType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Arguments' type.\"\n        },\n        {\n          \"name\": \"GetBoolType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Bool' type.\"\n        },\n        {\n          \"name\": \"GetConstexprBoolType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ConstexprBool' type.\"\n        },\n        {\n          \"name\": \"GetConstexprStringType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ConstexprString' type.\"\n        },\n        {\n          \"name\": \"GetConstexprIntPtrType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ConstexprIntPtr' type.\"\n        },\n        {\n          \"name\": \"GetConstexprInstanceTypeType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ConstexprInstanceType' type.\"\n        },\n        {\n          \"name\": \"GetVoidType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Void' type.\"\n        },\n        {\n          \"name\": \"GetRawPtrType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'RawPtr' type.\"\n        },\n        {\n          \"name\": \"GetExternalPointerType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ExternalPtr' type.\"\n        },\n        {\n          \"name\": \"GetCppHeapPointerType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'CppHeapPtr' type.\"\n        },\n        {\n          \"name\": \"GetTrustedPointerType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'TrustedPtr' type.\"\n        },\n        {\n          \"name\": \"GetProtectedPointerType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ProtectedPtr' type.\"\n        },\n        {\n          \"name\": \"GetDispatchHandleType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'DispatchHandle' type.\"\n        },\n        {\n          \"name\": \"GetMapType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Map' type.\"\n        },\n        {\n          \"name\": \"GetObjectType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Object' type.\"\n        },\n        {\n          \"name\": \"GetHeapObjectType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'HeapObject' type.\"\n        },\n        {\n          \"name\": \"GetTaggedZeroPatternType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'TaggedZeroPattern' type.\"\n        },\n        {\n          \"name\": \"GetJSAnyType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'JSAny' type.\"\n        },\n        {\n          \"name\": \"GetJSObjectType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'JSObject' type.\"\n        },\n        {\n          \"name\": \"GetTaggedType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Tagged' type.\"\n        },\n        {\n          \"name\": \"GetStrongTaggedType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'StrongTagged' type.\"\n        },\n        {\n          \"name\": \"GetUninitializedType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Uninitialized' type.\"\n        },\n        {\n          \"name\": \"GetUninitializedHeapObjectType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'UninitializedHeapObject' type.\"\n        },\n        {\n          \"name\": \"GetSmiType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Smi' type.\"\n        },\n        {\n          \"name\": \"GetConstStringType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ConstString' type.\"\n        },\n        {\n          \"name\": \"GetStringType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'String' type.\"\n        },\n        {\n          \"name\": \"GetNumberType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Number' type.\"\n        },\n        {\n          \"name\": \"GetIntPtrType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'IntPtr' type.\"\n        },\n        {\n          \"name\": \"GetUIntPtrType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'UIntPtr' type.\"\n        },\n        {\n          \"name\": \"GetInt64Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Int64' type.\"\n        },\n        {\n          \"name\": \"GetUint64Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Uint64' type.\"\n        },\n        {\n          \"name\": \"GetInt32Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Int32' type.\"\n        },\n        {\n          \"name\": \"GetUint32Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Uint32' type.\"\n        },\n        {\n          \"name\": \"GetUint31Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Uint31' type.\"\n        },\n        {\n          \"name\": \"GetInt16Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Int16' type.\"\n        },\n        {\n          \"name\": \"GetUint16Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Uint16' type.\"\n        },\n        {\n          \"name\": \"GetInt8Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Int8' type.\"\n        },\n        {\n          \"name\": \"GetUint8Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Uint8' type.\"\n        },\n        {\n          \"name\": \"GetFloat64Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Float64' type.\"\n        },\n        {\n          \"name\": \"GetFloat64OrUndefinedOrHoleType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Float64OrUndefinedOrHole' type.\"\n        },\n        {\n          \"name\": \"GetConstFloat64Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ConstFloat64' type.\"\n        },\n        {\n          \"name\": \"GetIntegerLiteralType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'IntegerLiteral' type.\"\n        },\n        {\n          \"name\": \"GetNeverType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Never' type.\"\n        },\n        {\n          \"name\": \"GetConstInt31Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ConstInt31' type.\"\n        },\n        {\n          \"name\": \"GetConstInt32Type\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'ConstInt32' type.\"\n        },\n        {\n          \"name\": \"GetContextType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'Context' type.\"\n        },\n        {\n          \"name\": \"GetNoContextType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'NoContext' type.\"\n        },\n        {\n          \"name\": \"GetNativeContextType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'NativeContext' type.\"\n        },\n        {\n          \"name\": \"GetJSFunctionType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'JSFunction' type.\"\n        },\n        {\n          \"name\": \"GetUninitializedIteratorType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'UninitializedIterator' type.\"\n        },\n        {\n          \"name\": \"GetFixedArrayBaseType\",\n          \"parameters\": [],\n          \"return_type\": \"const Type*\",\n          \"logic\": \"Returns the 'FixedArrayBase' type.\"\n        },\n        {\n          \"name\": \"ImplicitlyConvertableFrom\",\n          \"parameters\": [\n            \"const Type* to\",\n            \"const Type* from\"\n          ],\n          \"return_type\": \"std::optional<const Type*>\",\n          \"logic\": \"Checks if a type 'from' can be implicitly converted to type 'to' by recursively checking parent types and looking up FromConstexpr macros.\"\n        },\n        {\n          \"name\": \"GetAggregateTypes\",\n          \"parameters\": [],\n          \"return_type\": \"const std::vector<std::unique_ptr<AggregateType>>&\",\n          \"logic\": \"Returns a reference to the vector of aggregate types.\"\n        },\n        {\n          \"name\": \"GetBitFieldStructTypes\",\n          \"parameters\": [],\n          \"return_type\": \"const std::vector<std::unique_ptr<BitFieldStructType>>&\",\n          \"logic\": \"Returns a reference to the vector of bit field struct types.\"\n        },\n        {\n          \"name\": \"GetClasses\",\n          \"parameters\": [],\n          \"return_type\": \"std::vector<const ClassType*>\",\n          \"logic\": \"Returns a vector of ClassType pointers that are topologically sorted by inheritance.\"\n        },\n        {\n          \"name\": \"FinalizeAggregateTypes\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Finalizes aggregate types. The implementation is not present in this header file.\"\n        },\n        {\n          \"name\": \"FreshTypeId\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns a unique type ID.\"\n        },\n        {\n          \"name\": \"CreateGenericTypeInstantiationNamespace\",\n          \"parameters\": [],\n          \"return_type\": \"Namespace*\",\n          \"logic\": \"Creates and returns a new namespace to store generic type instantiations. The implementation is not present in this header file.\"\n        }\n      ]\n    }\n  ],\n  \"functions\": [],\n  \"raw_content\": \"// Copyright 2017 the V8 project authors.\\n// Use of this source code is governed by a BSD-style license that can be\\n// found in the LICENSE file.\\n\\n#ifndef V8_TORQUE_TYPE_ORACLE_H_\\n#define V8_TORQUE_TYPE_ORACLE_H_\\n\\n#include <memory>\\n#include <optional>\\n\\n#include \\\"src/base/contextual.h\\\"\\n#include \\\"src/torque/constants.h\\\"\\n#include \\\"src/torque/declarable.h\\\"\\n#include \\\"src/torque/declarations.h\\\"\\n#include \\\"src/torque/types.h\\\"\\n#include \\\"src/torque/utils.h\\\"\\n\\nnamespace v8::internal::torque {\\n\\nclass TypeOracle : public base::ContextualClass<TypeOracle> {\\n public:\\n  static const AbstractType* GetAbstractType(\\n      const Type* parent, std::string name, AbstractTypeFlags flags,\\n      std::string generated, const Type* non_constexpr_version,\\n      MaybeSpecializationKey specialized_from) {\\n    auto ptr = std::unique_ptr<AbstractType>(\\n        new AbstractType(parent, flags, std::move(name), std::move(generated),\\n                         non_constexpr_version, specialized_from));\\n    const AbstractType* result = ptr.get();\\n    if (non_constexpr_version) {\\n      DCHECK(ptr->IsConstexpr());\\n      non_constexpr_version->SetConstexprVersion(result);\\n    }\\n    Get().nominal_types_.push_back(std::move(ptr));\\n    return result;\\n  }\\n\\n  static StructType* GetStructType(const StructDeclaration* decl,\\n                                   MaybeSpecializationKey specialized_from) {\\n    auto ptr = std::unique_ptr<StructType>(\\n        new StructType(CurrentNamespace(), decl, specialized_from));\\n    StructType* result = ptr.get();\\n    Get().aggregate_types_.push_back(std::move(ptr));\\n    return result;\\n  }\\n\\n  static BitFieldStructType* GetBitFieldStructType(\\n      const Type* parent, const BitFieldStructDeclaration* decl) {\\n    auto ptr = std::unique_ptr<BitFieldStructType>(\\n        new BitFieldStructType(CurrentNamespace(), parent, decl));\\n    BitFieldStructType* result = ptr.get();\\n    Get().bit_field_struct_types_.push_back(std::move(ptr));\\n    return result;\\n  }\\n\\n  static ClassType* GetClassType(const Type* parent, const std::string& name,\\n                                 ClassFlags flags, const std::string& generates,\\n                                 ClassDeclaration* decl,\\n                                 const TypeAlias* alias) {\\n    std::unique_ptr<ClassType> type(new ClassType(\\n        parent, CurrentNamespace(), name, flags, generates, decl, alias));\\n    ClassType* result = type.get();\\n    Get().aggregate_types_.push_back(std::move(type));\\n    return result;\\n  }\\n\\n  static const BuiltinPointerType* GetBuiltinPointerType(\\n      TypeVector argument_types, const Type* return_type) {\\n    TypeOracle& self = Get();\\n    const Type* builtin_type = self.GetBuiltinType(BUILTIN_POINTER_TYPE_STRING);\\n    const BuiltinPointerType* result = self.function_pointer_types_.Add(\\n        BuiltinPointerType(builtin_type, std::move(argument_types), return_type,\\n                           self.all_builtin_pointer_types_.size()));\\n    if (result->function_pointer_type_id() ==\\n        self.all_builtin_pointer_types_.size()) {\\n      self.all_builtin_pointer_types_.push_back(result);\\n    }\\n    return result;\\n  }\\n\\n  static const Type* GetGenericTypeInstance(GenericType* generic_type,\\n                                            TypeVector arg_types);\\n\\n  static GenericType* GetReferenceGeneric(bool is_const) {\\n    return Declarations::LookupUniqueGenericType(\\n        QualifiedName({TORQUE_INTERNAL_NAMESPACE_STRING},\\n                      is_const ? CONST_REFERENCE_TYPE_STRING\\n                               : MUTABLE_REFERENCE_TYPE_STRING));\\n  }\\n  static GenericType* GetConstReferenceGeneric() {\\n    return GetReferenceGeneric(true);\\n  }\\n  static GenericType* GetMutableReferenceGeneric() {\\n    return GetReferenceGeneric(false);\\n  }\\n\\n  static std::optional<const Type*> MatchReferenceGeneric(\\n      const Type* reference_type, bool* is_const = nullptr);\\n\\n  static GenericType* GetMutableSliceGeneric() {\\n    return Declarations::LookupUniqueGenericType(\\n        QualifiedName(MUTABLE_SLICE_TYPE_STRING));\\n  }\\n  static GenericType* GetConstSliceGeneric() {\\n    return Declarations::LookupUniqueGenericType(\\n        QualifiedName(CONST_SLICE_TYPE_STRING));\\n  }\\n\\n  static GenericType* GetWeakGeneric() {\\n    return Declarations::LookupGlobalUniqueGenericType(WEAK_TYPE_STRING);\\n  }\\n\\n  static GenericType* GetSmiTaggedGeneric() {\\n    return Declarations::LookupGlobalUniqueGenericType(SMI_TAGGED_TYPE_STRING);\\n  }\\n\\n  static GenericType* GetLazyGeneric() {\\n    return Declarations::LookupGlobalUniqueGenericType(LAZY_TYPE_STRING);\\n  }\\n\\n  static const Type* GetReferenceType(const Type* referenced_type,\\n                                      bool is_const) {\\n    return GetGenericTypeInstance(GetReferenceGeneric(is_const),\\n                                  {referenced_type});\\n  }\\n  static const Type* GetConstReferenceType(const Type* referenced_type) {\\n    return GetReferenceType(referenced_type, true);\\n  }\\n  static const Type* GetMutableReferenceType(const Type* referenced_type) {\\n    return GetReferenceType(referenced_type, false);\\n  }\\n\\n  static const Type* GetMutableSliceType(const Type* referenced_type) {\\n    return GetGenericTypeInstance(GetMutableSliceGeneric(), {referenced_type});\\n  }\\n  static const Type* GetConstSliceType(const Type* referenced_type) {\\n    return GetGenericTypeInstance(GetConstSliceGeneric(), {referenced_type});\\n  }\\n\\n  static const std::vector<const BuiltinPointerType*>&\\n  AllBuiltinPointerTypes() {\\n    return Get().all_builtin_pointer_types_;\\n  }\\n\\n  static const Type* GetUnionType(UnionType type) {\\n    if (std::optional<const Type*> single = type.GetSingleMember()) {\\n      return *single;\\n    }\\n    return Get().union_types_.Add(std::move(type));\\n  }\\n\\n  static const Type* GetUnionType(const Type* a, const Type* b) {\\n    if (a->IsSubtypeOf(b)) return b;\\n    if (b->IsSubtypeOf(a)) return a;\\n    UnionType result = UnionType::FromType(a);\\n    result.Extend(b);\\n    return GetUnionType(std::move(result));\\n  }\\n\\n  static const TopType* GetTopType(std::string reason,\\n                                   const Type* source_type) {\\n    std::unique_ptr<TopType> type(new TopType(std::move(reason), source_type));\\n    TopType* result = type.get();\\n    Get().top_types_.push_back(std::move(type));\\n    return result;\\n  }\\n\\n  static const Type* GetArgumentsType() {\\n    return Get().GetBuiltinType(ARGUMENTS_TYPE_STRING);\\n  }\\n\\n  static const Type* GetBoolType() {\\n    return Get().GetBuiltinType(BOOL_TYPE_STRING);\\n  }\\n\\n  static const Type* GetConstexprBoolType() {\\n    return Get().GetBuiltinType(CONSTEXPR_BOOL_TYPE_STRING);\\n  }\\n\\n  static const Type* GetConstexprStringType() {\\n    return Get().GetBuiltinType(CONSTEXPR_STRING_TYPE_STRING);\\n  }\\n\\n  static const Type* GetConstexprIntPtrType() {\\n    return Get().GetBuiltinType(CONSTEXPR_INTPTR_TYPE_STRING);\\n  }\\n\\n  static const Type* GetConstexprInstanceTypeType() {\\n    return Get().GetBuiltinType(CONSTEXPR_INSTANCE_TYPE_TYPE_STRING);\\n  }\\n\\n  static const Type* GetVoidType() {\\n    return Get().GetBuiltinType(VOID_TYPE_STRING);\\n  }\\n\\n  static const Type* GetRawPtrType() {\\n    return Get().GetBuiltinType(RAWPTR_TYPE_STRING);\\n  }\\n\\n  static const Type* GetExternalPointerType() {\\n    return Get().GetBuiltinType(EXTERNALPTR_TYPE_STRING);\\n  }\\n\\n  static const Type* GetCppHeapPointerType() {\\n    return Get().GetBuiltinType(CPPHEAPPTR_TYPE_STRING);\\n  }\\n\\n  static const Type* GetTrustedPointerType() {\\n    return Get().GetBuiltinType(TRUSTEDPTR_TYPE_STRING);\\n  }\\n\\n  static const Type* GetProtectedPointerType() {\\n    return Get().GetBuiltinType(PROTECTEDPTR_TYPE_STRING);\\n  }\\n\\n  static const Type* GetDispatchHandleType() {\\n    return Get().GetBuiltinType(DISPATCH_HANDLE_TYPE_STRING);\\n  }\\n\\n  static const Type* GetMapType() {\\n    return Get().GetBuiltinType(MAP_TYPE_STRING);\\n  }\\n\\n  static const Type* GetObjectType() {\\n    return Get().GetBuiltinType(OBJECT_TYPE_STRING);\\n  }\\n\\n  static const Type* GetHeapObjectType() {\\n    return Get().GetBuiltinType(HEAP_OBJECT_TYPE_STRING);\\n  }\\n\\n  static const Type* GetTaggedZeroPatternType() {\\n    return Get().GetBuiltinType(TAGGED_ZERO_PATTERN_TYPE_STRING);\\n  }\\n\\n  static const Type* GetJSAnyType() {\\n    return Get().GetBuiltinType(JSANY_TYPE_STRING);\\n  }\\n\\n  static const Type* GetJSObjectType() {\\n    return Get().GetBuiltinType(JSOBJECT_TYPE_STRING);\\n  }\\n\\n  static const Type* GetTaggedType() {\\n    return Get().GetBuiltinType(TAGGED_TYPE_STRING);\\n  }\\n\\n  static const Type* GetStrongTaggedType() {\\n    return Get().GetBuiltinType(STRONG_TAGGED_TYPE_STRING);\\n  }\\n\\n  static const Type* GetUninitializedType() {\\n    return Get().GetBuiltinType(UNINITIALIZED_TYPE_STRING);\\n  }\\n\\n  static const Type* GetUninitializedHeapObjectType() {\\n    return Get().GetBuiltinType(\\n        QualifiedName({TORQUE_INTERNAL_NAMESPACE_STRING},\\n                      UNINITIALIZED_HEAP_OBJECT_TYPE_STRING));\\n  }\\n\\n  static const Type* GetSmiType() {\\n    return Get().GetBuiltinType(SMI_TYPE_STRING);\\n  }\\n\\n  static const Type* GetConstStringType() {\\n    return Get().GetBuiltinType(CONST_STRING_TYPE_STRING);\\n  }\\n\\n  static const Type* GetStringType() {\\n    return Get().GetBuiltinType(STRING_TYPE_STRING);\\n  }\\n\\n  static const Type* GetNumberType() {\\n    return Get().GetBuiltinType(NUMBER_TYPE_STRING);\\n  }\\n\\n  static const Type* GetIntPtrType() {\\n    return Get().GetBuiltinType(INTPTR_TYPE_STRING);\\n  }\\n\\n  static const Type* GetUIntPtrType() {\\n    return Get().GetBuiltinType(UINTPTR_TYPE_STRING);\\n  }\\n\\n  static const Type* GetInt64Type() {\\n    return Get().GetBuiltinType(INT64_TYPE_STRING);\\n  }\\n\\n  static const Type* GetUint64Type() {\\n    return Get().GetBuiltinType(UINT64_TYPE_STRING);\\n  }\\n\\n  static const Type* GetInt32Type() {\\n    return Get().GetBuiltinType(INT32_TYPE_STRING);\\n  }\\n\\n  static const Type* GetUint32Type() {\\n    return Get().GetBuiltinType(UINT32_TYPE_STRING);\\n  }\\n\\n  static const Type* GetUint31Type() {\\n    return Get().GetBuiltinType(UINT31_TYPE_STRING);\\n  }\\n\\n  static const Type* GetInt16Type() {\\n    return Get().GetBuiltinType(INT16_TYPE_STRING);\\n  }\\n\\n  static const Type* GetUint16Type() {\\n    return Get().GetBuiltinType(UINT16_TYPE_STRING);\\n  }\\n\\n  static const Type* GetInt8Type() {\\n    return Get().GetBuiltinType(INT8_TYPE_STRING);\\n  }\\n\\n  static const Type* GetUint8Type() {\\n    return Get().GetBuiltinType(UINT8_TYPE_STRING);\\n  }\\n\\n  static const Type* GetFloat64Type() {\\n    return Get().GetBuiltinType(FLOAT64_TYPE_STRING);\\n  }\\n\\n  static const Type* GetFloat64OrUndefinedOrHoleType() {\\n    return Get().GetBuiltinType(FLOAT64_OR_UNDEFINED_OR_HOLE_TYPE_STRING);\\n  }\\n\\n  static const"
}