{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/compiler/backend/register-allocator.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/compiler/backend/register-allocator.h\",\n  \"imports\": [\n    \"src/base/bits.h\",\n    \"src/base/compiler-specific.h\",\n    \"src/codegen/register-configuration.h\",\n    \"src/common/globals.h\",\n    \"src/compiler/backend/instruction.h\",\n    \"src/compiler/backend/register-allocation.h\",\n    \"src/flags/flags.h\",\n    \"src/utils/ostreams.h\",\n    \"src/utils/sparse-bit-vector.h\",\n    \"src/zone/zone-containers.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"LifetimePosition\",\n      \"properties\": [\n        \"static const int kHalfStep = 2\",\n        \"static const int kStep = 2 * kHalfStep\",\n        \"int value_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"GapFromInstructionIndex\",\n          \"parameters\": [\n            \"int index\"\n          ],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the LifetimePosition for the beginning of a gap at the given index.\"\n        },\n        {\n          \"name\": \"InstructionFromInstructionIndex\",\n          \"parameters\": [\n            \"int index\"\n          ],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the LifetimePosition for the beginning of an instruction at the given index.\"\n        },\n        {\n          \"name\": \"ExistsGapPositionBetween\",\n          \"parameters\": [\n            \"LifetimePosition pos1\",\n            \"LifetimePosition pos2\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a gap position exists between two given lifetime positions.\"\n        },\n        {\n          \"name\": \"value\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the numeric representation of this LifetimePosition.\"\n        },\n        {\n          \"name\": \"ToInstructionIndex\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the index of the instruction to which this LifetimePosition corresponds.\"\n        },\n        {\n          \"name\": \"IsStart\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if this LifetimePosition corresponds to a START value.\"\n        },\n        {\n          \"name\": \"IsEnd\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if this LifetimePosition corresponds to an END value.\"\n        },\n        {\n          \"name\": \"IsFullStart\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if this LifetimePosition corresponds to a gap START value.\"\n        },\n        {\n          \"name\": \"IsGapPosition\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if this LifetimePosition corresponds to a gap position.\"\n        },\n        {\n          \"name\": \"IsInstructionPosition\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if this LifetimePosition corresponds to an instruction position.\"\n        },\n        {\n          \"name\": \"Start\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the LifetimePosition for the current START.\"\n        },\n        {\n          \"name\": \"FullStart\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the LifetimePosition for the current gap START.\"\n        },\n        {\n          \"name\": \"End\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the LifetimePosition for the current END.\"\n        },\n        {\n          \"name\": \"NextStart\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the LifetimePosition for the beginning of the next START.\"\n        },\n        {\n          \"name\": \"NextFullStart\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the LifetimePosition for the beginning of the next gap START.\"\n        },\n        {\n          \"name\": \"PrevStart\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the LifetimePosition for the beginning of the previous START.\"\n        },\n        {\n          \"name\": \"IsValid\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if this LifetimePosition corresponds to some instruction.\"\n        },\n        {\n          \"name\": \"operator<\",\n          \"parameters\": [\n            \"const LifetimePosition& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two LifetimePositions for less than.\"\n        },\n        {\n          \"name\": \"operator<=\",\n          \"parameters\": [\n            \"const LifetimePosition& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two LifetimePositions for less than or equal to.\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\n            \"const LifetimePosition& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two LifetimePositions for equality.\"\n        },\n        {\n          \"name\": \"operator!=\",\n          \"parameters\": [\n            \"const LifetimePosition& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two LifetimePositions for inequality.\"\n        },\n        {\n          \"name\": \"operator>\",\n          \"parameters\": [\n            \"const LifetimePosition& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two LifetimePositions for greater than.\"\n        },\n        {\n          \"name\": \"operator>=\",\n          \"parameters\": [\n            \"const LifetimePosition& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two LifetimePositions for greater than or equal to.\"\n        },\n        {\n          \"name\": \"Print\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints debugging information about the LifetimePosition.\"\n        },\n        {\n          \"name\": \"Invalid\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns an invalid LifetimePosition.\"\n        },\n        {\n          \"name\": \"MaxPosition\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the maximum possible LifetimePosition.\"\n        },\n        {\n          \"name\": \"FromInt\",\n          \"parameters\": [\n            \"int value\"\n          ],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Creates a LifetimePosition from an integer value.\"\n        },\n        {\n          \"name\": \"LifetimePosition\",\n          \"parameters\": [\n            \"int value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for LifetimePosition.\"\n        },\n        {\n          \"name\": \"LifetimePosition\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Default constructor for LifetimePosition (creates an invalid position).\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegisterAllocationData\",\n      \"properties\": [\n        \"static constexpr int kNumberOfFixedRangesPerRegister = 2\",\n        \"Zone* const allocation_zone_\",\n        \"Frame* const frame_\",\n        \"InstructionSequence* const code_\",\n        \"const char* const debug_name_\",\n        \"const RegisterConfiguration* const config_\",\n        \"PhiMap phi_map_\",\n        \"ZoneVector<SparseBitVector*> live_in_sets_\",\n        \"ZoneVector<SparseBitVector*> live_out_sets_\",\n        \"ZoneVector<TopLevelLiveRange*> live_ranges_\",\n        \"ZoneVector<TopLevelLiveRange*> fixed_live_ranges_\",\n        \"ZoneVector<TopLevelLiveRange*> fixed_float_live_ranges_\",\n        \"ZoneVector<TopLevelLiveRange*> fixed_double_live_ranges_\",\n        \"ZoneVector<TopLevelLiveRange*> fixed_simd128_live_ranges_\",\n        \"DelayedReferences delayed_references_\",\n        \"BitVector* assigned_registers_\",\n        \"BitVector* assigned_double_registers_\",\n        \"BitVector* assigned_simd128_registers_\",\n        \"BitVector* fixed_register_use_\",\n        \"BitVector* fixed_fp_register_use_\",\n        \"BitVector* fixed_simd128_register_use_\",\n        \"int virtual_register_count_\",\n        \"RangesWithPreassignedSlots preassigned_slot_ranges_\",\n        \"ZoneVector<ZoneVector<LiveRange*>> spill_state_\",\n        \"TickCounter* const tick_counter_\",\n        \"ZoneMap<TopLevelLiveRange*, AllocatedOperand*> slot_for_const_range_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RegisterAllocationData\",\n          \"parameters\": [\n            \"const RegisterConfiguration* config\",\n            \"Zone* allocation_zone\",\n            \"Frame* frame\",\n            \"InstructionSequence* code\",\n            \"TickCounter* tick_counter\",\n            \"const char* debug_name = nullptr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for the RegisterAllocationData class.\"\n        },\n        {\n          \"name\": \"live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"const ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of live ranges.\"\n        },\n        {\n          \"name\": \"live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of live ranges (mutable).\"\n        },\n        {\n          \"name\": \"fixed_live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"const ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of fixed live ranges.\"\n        },\n        {\n          \"name\": \"fixed_live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of fixed live ranges (mutable).\"\n        },\n         {\n          \"name\": \"fixed_float_live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of fixed float live ranges (mutable).\"\n        },\n        {\n          \"name\": \"fixed_float_live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"const ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of fixed float live ranges.\"\n        },\n         {\n          \"name\": \"fixed_double_live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of fixed double live ranges (mutable).\"\n        },\n        {\n          \"name\": \"fixed_double_live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"const ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of fixed double live ranges.\"\n        },\n         {\n          \"name\": \"fixed_simd128_live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of fixed simd128 live ranges (mutable).\"\n        },\n        {\n          \"name\": \"fixed_simd128_live_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"const ZoneVector<TopLevelLiveRange*>&\",\n          \"logic\": \"Returns the list of fixed simd128 live ranges.\"\n        },\n        {\n          \"name\": \"live_in_sets\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneVector<SparseBitVector*>&\",\n          \"logic\": \"Returns the list of live-in sets (mutable).\"\n        },\n        {\n          \"name\": \"live_out_sets\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneVector<SparseBitVector*>&\",\n          \"logic\": \"Returns the list of live-out sets (mutable).\"\n        },\n        {\n          \"name\": \"delayed_references\",\n          \"parameters\": [],\n          \"return_type\": \"DelayedReferences&\",\n          \"logic\": \"Returns the list of delayed references (mutable).\"\n        },\n        {\n          \"name\": \"code\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionSequence*\",\n          \"logic\": \"Returns the instruction sequence.\"\n        },\n        {\n          \"name\": \"allocation_zone\",\n          \"parameters\": [],\n          \"return_type\": \"Zone*\",\n          \"logic\": \"Returns the zone for allocation.\"\n        },\n        {\n          \"name\": \"code_zone\",\n          \"parameters\": [],\n          \"return_type\": \"Zone*\",\n          \"logic\": \"Returns the code zone.\"\n        },\n        {\n          \"name\": \"frame\",\n          \"parameters\": [],\n          \"return_type\": \"Frame*\",\n          \"logic\": \"Returns the frame.\"\n        },\n        {\n          \"name\": \"debug_name\",\n          \"parameters\": [],\n          \"return_type\": \"const char*\",\n          \"logic\": \"Returns the debug name.\"\n        },\n        {\n          \"name\": \"config\",\n          \"parameters\": [],\n          \"return_type\": \"const RegisterConfiguration*\",\n          \"logic\": \"Returns the register configuration.\"\n        },\n        {\n          \"name\": \"RepresentationFor\",\n          \"parameters\": [\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"MachineRepresentation\",\n          \"logic\": \"Returns the machine representation for a given virtual register.\"\n        },\n        {\n          \"name\": \"GetLiveRangeFor\",\n          \"parameters\": [\n            \"int index\"\n          ],\n          \"return_type\": \"TopLevelLiveRange*\",\n          \"logic\": \"Returns the live range for a given index.\"\n        },\n        {\n          \"name\": \"NewLiveRange\",\n          \"parameters\": [\n            \"int index\",\n            \"MachineRepresentation rep\"\n          ],\n          \"return_type\": \"TopLevelLiveRange*\",\n          \"logic\": \"Creates a new live range.\"\n        },\n        {\n          \"name\": \"AssignSpillRangeToLiveRange\",\n          \"parameters\": [\n            \"TopLevelLiveRange* range\",\n            \"SpillMode spill_mode\"\n          ],\n          \"return_type\": \"SpillRange*\",\n          \"logic\": \"Assigns a spill range to a live range.\"\n        },\n        {\n          \"name\": \"CreateSpillRangeForLiveRange\",\n          \"parameters\": [\n            \"TopLevelLiveRange* range\"\n          ],\n          \"return_type\": \"SpillRange*\",\n          \"logic\": \"Creates a spill range for a live range.\"\n        },\n        {\n          \"name\": \"AddGapMove\",\n          \"parameters\": [\n            \"int index\",\n            \"Instruction::GapPosition position\",\n            \"const InstructionOperand& from\",\n            \"const InstructionOperand& to\"\n          ],\n          \"return_type\": \"MoveOperands*\",\n          \"logic\": \"Adds a gap move.\"\n        },\n        {\n          \"name\": \"ExistsUseWithoutDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a use exists without a definition.\"\n        },\n        {\n          \"name\": \"RangesDefinedInDeferredStayInDeferred\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if ranges defined in deferred code stay in deferred code.\"\n        },\n        {\n          \"name\": \"MarkFixedUse\",\n          \"parameters\": [\n            \"MachineRepresentation rep\",\n            \"int index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks a fixed use.\"\n        },\n        {\n          \"name\": \"HasFixedUse\",\n          \"parameters\": [\n            \"MachineRepresentation rep\",\n            \"int index\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a fixed use exists.\"\n        },\n        {\n          \"name\": \"MarkAllocated\",\n          \"parameters\": [\n            \"MachineRepresentation rep\",\n            \"int index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks a register as allocated.\"\n        },\n        {\n          \"name\": \"InitializePhiMap\",\n          \"parameters\": [\n            \"const InstructionBlock* block\",\n            \"PhiInstruction* phi\"\n          ],\n          \"return_type\": \"PhiMapValue*\",\n          \"logic\": \"Initializes a PhiMap.\"\n        },\n        {\n          \"name\": \"GetPhiMapValueFor\",\n          \"parameters\": [\n            \"TopLevelLiveRange* top_range\"\n          ],\n          \"return_type\": \"PhiMapValue*\",\n          \"logic\": \"Returns the PhiMap value for a given live range.\"\n        },\n        {\n          \"name\": \"GetPhiMapValueFor\",\n          \"parameters\": [\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"PhiMapValue*\",\n          \"logic\": \"Returns the PhiMap value for a given virtual register.\"\n        },\n        {\n          \"name\": \"IsBlockBoundary\",\n          \"parameters\": [\n            \"LifetimePosition pos\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a position is a block boundary.\"\n        },\n        {\n          \"name\": \"preassigned_slot_ranges\",\n          \"parameters\": [],\n          \"return_type\": \"RangesWithPreassignedSlots&\",\n          \"logic\": \"Returns the list of ranges with preassigned slots (mutable).\"\n        },\n        {\n          \"name\": \"RememberSpillState\",\n          \"parameters\": [\n            \"RpoNumber block\",\n            \"const ZoneVector<LiveRange*>& state\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Remembers the spill state for a given block.\"\n        },\n        {\n          \"name\": \"GetSpillState\",\n          \"parameters\": [\n            \"RpoNumber block\"\n          ],\n          \"return_type\": \"ZoneVector<LiveRange*>&\",\n          \"logic\": \"Returns the spill state for a given block.\"\n        },\n        {\n          \"name\": \"ResetSpillState\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Resets the spill state.\"\n        },\n        {\n          \"name\": \"tick_counter\",\n          \"parameters\": [],\n          \"return_type\": \"TickCounter*\",\n          \"logic\": \"Returns the tick counter.\"\n        },\n        {\n          \"name\": \"slot_for_const_range\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneMap<TopLevelLiveRange*, AllocatedOperand*>&\",\n          \"logic\": \"Returns the map from live ranges to their assigned slots (mutable).\"\n        }\n      ],\n      \"classes\": [\n        {\n          \"name\": \"PhiMapValue\",\n          \"properties\": [\n            \"PhiInstruction* const phi_\",\n            \"const InstructionBlock* const block_\",\n            \"ZoneVector<InstructionOperand*> incoming_operands_\",\n            \"int assigned_register_\"\n          ],\n          \"methods\": [\n            {\n              \"name\": \"PhiMapValue\",\n              \"parameters\": [\n                \"PhiInstruction* phi\",\n                \"const InstructionBlock* block\",\n                \"Zone* zone\"\n              ],\n              \"return_type\": \"void\",\n              \"logic\": \"Constructor for PhiMapValue.\"\n            },\n            {\n              \"name\": \"phi\",\n              \"parameters\": [],\n              \"return_type\": \"const PhiInstruction*\",\n              \"logic\": \"Returns the phi instruction.\"\n            },\n            {\n              \"name\": \"block\",\n              \"parameters\": [],\n              \"return_type\": \"const InstructionBlock*\",\n              \"logic\": \"Returns the instruction block.\"\n            },\n            {\n              \"name\": \"assigned_register\",\n              \"parameters\": [],\n              \"return_type\": \"int\",\n              \"logic\": \"Returns the assigned register.\"\n            },\n            {\n              \"name\": \"set_assigned_register\",\n              \"parameters\": [\n                \"int register_code\"\n              ],\n              \"return_type\": \"void\",\n              \"logic\": \"Sets the assigned register.\"\n            },\n            {\n              \"name\": \"UnsetAssignedRegister\",\n              \"parameters\": [],\n              \"return_type\": \"void\",\n              \"logic\": \"Unsets the assigned register.\"\n            },\n            {\n              \"name\": \"AddOperand\",\n              \"parameters\": [\n                \"InstructionOperand* operand\"\n              ],\n              \"return_type\": \"void\",\n              \"logic\": \"Adds an operand.\"\n            },\n            {\n              \"name\": \"CommitAssignment\",\n              \"parameters\": [\n                \"const InstructionOperand& operand\"\n              ],\n              \"return_type\": \"void\",\n              \"logic\": \"Commits the assignment.\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"name\": \"UseInterval\",\n      \"properties\": [\n        \"LifetimePosition start_\",\n        \"LifetimePosition end_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"UseInterval\",\n          \"parameters\": [\n            \"LifetimePosition start\",\n            \"LifetimePosition end\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for UseInterval.\"\n        },\n        {\n          \"name\": \"start\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the start position of the interval.\"\n        },\n        {\n          \"name\": \"set_start\",\n          \"parameters\": [\n            \"LifetimePosition start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the start position of the interval.\"\n        },\n        {\n          \"name\": \"end\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the end position of the interval.\"\n        },\n        {\n          \"name\": \"set_end\",\n          \"parameters\": [\n            \"LifetimePosition end\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the end position of the interval.\"\n        },\n        {\n          \"name\": \"SplitAt\",\n          \"parameters\": [\n            \"LifetimePosition pos\"\n          ],\n          \"return_type\": \"UseInterval\",\n          \"logic\": \"Splits this interval at the given position.\"\n        },\n        {\n          \"name\": \"Intersect\",\n          \"parameters\": [\n            \"const UseInterval& other\"\n          ],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"If this interval intersects with other return smallest position that belongs to both of them.\"\n        },\n        {\n          \"name\": \"Contains\",\n          \"parameters\": [\n            \"LifetimePosition point\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the interval contains a given point.\"\n        },\n        {\n          \"name\": \"FirstGapIndex\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the index of the first gap covered by this interval.\"\n        },\n        {\n          \"name\": \"LastGapIndex\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the index of the last gap covered by this interval.\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\n            \"const UseInterval& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two UseIntervals for equality.\"\n        },\n        {\n          \"name\": \"operator!=\",\n          \"parameters\": [\n            \"const UseInterval& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two UseIntervals for inequality.\"\n        },\n        {\n          \"name\": \"operator<\",\n          \"parameters\": [\n            \"const UseInterval& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two UseIntervals for less than.\"\n        },\n        {\n          \"name\": \"PrettyPrint\",\n          \"parameters\": [\n            \"std::ostream& os\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints a formatted representation of the UseInterval to the output stream.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"UsePosition\",\n      \"properties\": [\n        \"InstructionOperand* const operand_\",\n        \"void* hint_\",\n        \"LifetimePosition const pos_\",\n        \"uint32_t flags_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"UsePosition\",\n          \"parameters\": [\n            \"LifetimePosition pos\",\n            \"InstructionOperand* operand\",\n            \"void* hint\",\n            \"UsePositionHintType hint_type\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for UsePosition.\"\n        },\n        {\n          \"name\": \"operand\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionOperand*\",\n          \"logic\": \"Returns the operand.\"\n        },\n        {\n          \"name\": \"HasOperand\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if an operand is present.\"\n        },\n        {\n          \"name\": \"RegisterIsBeneficial\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if using a register is beneficial for this position.\"\n        },\n        {\n          \"name\": \"SpillDetrimental\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if spilling is detrimental for this position.\"\n        },\n        {\n          \"name\": \"type\",\n          \"parameters\": [],\n          \"return_type\": \"UsePositionType\",\n          \"logic\": \"Returns the use position type.\"\n        },\n        {\n          \"name\": \"set_type\",\n          \"parameters\": [\n            \"UsePositionType type\",\n            \"bool register_beneficial\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the use position type.\"\n        },\n        {\n          \"name\": \"pos\",\n          \"parameters\": [],\n          \"return_type\": \"LifetimePosition\",\n          \"logic\": \"Returns the position.\"\n        },\n        {\n          \"name\": \"set_assigned_register\",\n          \"parameters\": [\n            \"int register_code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the assigned register.\"\n        },\n        {\n          \"name\": \"set_spill_detrimental\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the spill_detrimental flag.\"\n        },\n        {\n          \"name\": \"hint_type\",\n          \"parameters\": [],\n          \"return_type\": \"UsePositionHintType\",\n          \"logic\": \"Returns the hint type.\"\n        },\n        {\n          \"name\": \"HasHint\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if the UsePosition has a hint.\"\n        },\n        {\n          \"name\": \"HintRegister\",\n          \"parameters\": [\n            \"int* register_code\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Get the register code from the hint.\"\n        },\n        {\n          \"name\": \"SetHint\",\n          \"parameters\": [\n            \"UsePosition* use_pos\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Set a hint.\"\n        },\n        {\n          \"name\": \"ResolveHint\",\n          \"parameters\": [\n            \"UsePosition* use_pos\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Resolve a hint.\"\n        },\n        {\n          \"name\": \"IsResolved\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if a hint is resolved.\"\n        },\n        {\n          \"name\": \"HintTypeForOperand\",\n          \"parameters\": [\n            \"const InstructionOperand& op\"\n          ],\n          \"return_type\": \"UsePositionHintType\",\n          \"logic\": \"Get the hint type for a given operand.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DoubleEndedSplitVector\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"size\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the number of elements in the vector.\"\n        },\n        {\n          \"name\": \"empty\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if the vector is empty.\"\n        },\n        {\n          \"name\": \"capacity\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the capacity of the vector.\"\n        },\n        {\n          \"name\": \"data\",\n          \"parameters\": [],\n          \"return_type\": \"T*\",\n          \"logic\": \"Returns a pointer to the underlying data.\"\n        },\n        {\n          \"name\": \"clear\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Removes all elements from the vector.\"\n        },\n        {\n          \"name\": \"operator[]\",\n          \"parameters\": [\n            \"size_t position\"\n          ],\n          \"return_type\": \"T&\",\n          \"logic\": \"Returns a reference to the element at the specified position.\"\n        },\n        {\n          \"name\": \"operator[]\",\n          \"parameters\": [\n            \"size_t position\"\n          ],\n          \"return_type\": \"const T&\",\n          \"logic\": \"Returns a const reference to the element at the specified position.\"\n        },\n        {\n          \"name\": \"begin\",\n          \"parameters\": [],\n          \"return_type\": \"iterator\",\n          \"logic\": \"Returns an iterator to the beginning of the vector.\"\n        },\n        {\n          \"name\": \"begin\",\n          \"parameters\": [],\n          \"return_type\": \"const_iterator\",\n          \"logic\": \"Returns a const iterator to the beginning of the vector.\"\n        },\n        {\n          \"name\": \"end\",\n          \"parameters\": [],\n          \"return_type\": \"iterator\",\n          \"logic\": \"Returns an iterator to the end of the vector.\"\n        },\n        {\n          \"name\": \"end\",\n          \"parameters\": [],\n          \"return_type\": \"const_iterator\",\n          \"logic\": \"Returns a const iterator to the end of the vector.\"\n        },\n        {\n          \"name\": \"front\",\n          \"parameters\": [],\n          \"return_type\": \"T&\",\n          \"logic\": \"Returns a reference to the first element in the vector.\"\n        },\n        {\n          \"name\": \"front\",\n          \"parameters\": [],\n          \"return_type\": \"const T&\",\n          \"logic\": \"Returns a const reference to the first element in the vector.\"\n        },\n        {\n          \"name\": \"back\",\n          \"parameters\": [],\n          \"return_type\": \"T&\",\n          \"logic\": \"Returns a reference to the last element in the vector.\"\n        },\n        {\n          \"name\": \"back\",\n          \"parameters\": [],\n          \"return_type\": \"const T&\",\n          \"logic\": \"Returns a const reference to the last element in the vector.\"\n        },\n        {\n          \"name\": \"push_front\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"const T& value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Inserts a new element at the beginning of the vector.\"\n        },\n        {\n          \"name\": \"pop_front\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Removes the first element from the vector.\"\n        },\n        {\n          \"name\": \"insert\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"const_iterator position\",\n            \"const T& value\"\n          ],\n          \"return_type\": \"iterator\",\n          \"logic\": \"Inserts a new element at the specified position in the vector.\"\n        },\n        {\n          \"name\": \"SplitAt\",\n          \"parameters\": [\n            \"const_iterator split_begin_const\"\n          ],\n          \"return_type\": \"DoubleEndedSplitVector<T>\",\n          \"logic\": \"Splits the vector into two parts at the specified position.\"\n        },\n        {\n          \"name\": \"Append\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"DoubleEndedSplitVector<T> other\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the elements from another vector to the end of this vector.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"LiveRange\",\n      \"properties\": [\n        \"int relative_id_\",\n        \"uint32_t bits_\",\n        \"UseIntervalVector intervals_\",\n        \"base::Vector<UsePosition*> positions_span_\",\n        \"TopLevelLiveRange* top_level_\",\n        \"LiveRange* next_\",\n        \"UseIntervalVector::iterator current_interval_\",\n        \"size_t current_hint_position_index_ = 0\",\n        \"LifetimePosition next_start_\",\n        \"LifetimePosition start_\",\n        \"LifetimePosition end_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"intervals\",\n          \"parameters\": [],\n          \"return_type\": \"const UseIntervalVector&\",\n          \"logic\": \"Returns the vector of use intervals.\"\n        },\n        {\n          \"name\": \"positions\",\n          \"parameters\": [],\n          \"return_type\": \"base::Vector<UsePosition*>\",\n          \"logic\": \"Returns a span of use positions.\"\n        },\n        {\n          \""
}