{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/compiler/backend/instruction-selector.cc",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/compiler/backend/instruction-selector.cc\",\n  \"imports\": [\n    \"src/compiler/backend/instruction-selector.h\",\n    \"limits\",\n    \"optional\",\n    \"include/v8-internal.h\",\n    \"src/base/iterator.h\",\n    \"src/codegen/machine-type.h\",\n    \"src/codegen/tick-counter.h\",\n    \"src/common/globals.h\",\n    \"src/compiler/backend/instruction-selector-adapter.h\",\n    \"src/compiler/backend/instruction-selector-impl.h\",\n    \"src/compiler/backend/instruction.h\",\n    \"src/compiler/compiler-source-position-table.h\",\n    \"src/compiler/globals.h\",\n    \"src/compiler/js-heap-broker.h\",\n    \"src/compiler/state-values-utils.h\",\n    \"src/compiler/turboshaft/operations.h\",\n    \"src/compiler/turboshaft/opmasks.h\",\n    \"src/compiler/turboshaft/representations.h\",\n    \"src/numbers/conversions-inl.h\",\n    \"src/zone/zone-containers.h\",\n    \"src/wasm/simd-shuffle.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"InstructionSelectorT\",\n      \"properties\": [\n        \"zone_\",\n        \"linkage_\",\n        \"sequence_\",\n        \"source_positions_\",\n        \"source_position_mode_\",\n        \"features_\",\n        \"schedule_\",\n        \"current_block_\",\n        \"instructions_\",\n        \"continuation_inputs_\",\n        \"continuation_outputs_\",\n        \"continuation_temps_\",\n        \"defined_\",\n        \"used_\",\n        \"effect_level_\",\n        \"virtual_registers_\",\n        \"virtual_register_rename_\",\n        \"scheduler_\",\n        \"enable_scheduling_\",\n        \"enable_roots_relative_addressing_\",\n        \"enable_switch_jump_table_\",\n        \"state_values_cache_\",\n        \"frame_\",\n        \"instruction_selection_failed_\",\n        \"instr_origins_\",\n        \"trace_turbo_\",\n        \"tick_counter_\",\n        \"broker_\",\n        \"max_unoptimized_frame_height_\",\n        \"max_pushed_argument_count_\",\n        \"node_count_\",\n        \"phi_states_\",\n        \"turboshaft_use_map_\",\n        \"protected_loads_to_remove_\",\n        \"additional_protected_instructions_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"InstructionSelectorT\",\n          \"parameters\": [\n            \"zone\",\n            \"node_count\",\n            \"linkage\",\n            \"sequence\",\n            \"schedule\",\n            \"source_positions\",\n            \"frame\",\n            \"enable_switch_jump_table\",\n            \"tick_counter\",\n            \"broker\",\n            \"max_unoptimized_frame_height\",\n            \"max_pushed_argument_count\",\n            \"source_position_mode\",\n            \"features\",\n            \"enable_scheduling\",\n            \"enable_roots_relative_addressing\",\n            \"trace_turbo\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for InstructionSelectorT, initializes various members related to instruction selection.\"\n        },\n        {\n          \"name\": \"SelectInstructions\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<BailoutReason>\",\n          \"logic\": \"Performs instruction selection for the entire graph. Marks used nodes, visits blocks, schedules instructions, and validates SSA form.\"\n        },\n        {\n          \"name\": \"StartBlock\",\n          \"parameters\": [\n            \"RpoNumber rpo\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Starts processing a basic block.  Delegates to the scheduler or the sequence depending on whether instruction scheduling is enabled.\"\n        },\n        {\n          \"name\": \"EndBlock\",\n          \"parameters\": [\n            \"RpoNumber rpo\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Ends processing a basic block.  Delegates to the scheduler or the sequence depending on whether instruction scheduling is enabled.\"\n        },\n        {\n          \"name\": \"AddTerminator\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds a terminator instruction to the current block. Delegates to the scheduler or sequence based on scheduling mode.\"\n        },\n        {\n          \"name\": \"AddInstruction\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds an instruction to the current block. Delegates to the scheduler or sequence based on scheduling mode.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with given opcode, output, and temporary operands.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with given opcode, output, input a, and temporary operands.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with given opcode, output, inputs a and b, and temporary operands.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with given opcode, output, inputs a, b, and c, and temporary operands.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"InstructionOperand d\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with given opcode, output, inputs a, b, c, and d, and temporary operands.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"InstructionOperand d\",\n            \"InstructionOperand e\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with given opcode, output, inputs a, b, c, d and e, and temporary operands.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"InstructionOperand d\",\n            \"InstructionOperand e\",\n            \"InstructionOperand f\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with given opcode, output, inputs a, b, c, d, e, and f, and temporary operands.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"InstructionOperand d\",\n            \"InstructionOperand e\",\n            \"InstructionOperand f\",\n            \"InstructionOperand g\",\n            \"InstructionOperand h\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with given opcode, output, inputs a, b, c, d, e, f, g, and h, and temporary operands.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"size_t output_count\",\n            \"InstructionOperand* outputs\",\n            \"size_t input_count\",\n            \"InstructionOperand* inputs\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with generic lists of inputs, outputs and temporaries.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Adds the given instruction to the instruction list.\"\n        },\n        {\n          \"name\": \"CanCover\",\n          \"parameters\": [\n            \"OpIndex user\",\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if a node can be covered by a user based on block membership, effect level, and exclusive use.\"\n        },\n        {\n          \"name\": \"CanCoverProtectedLoad\",\n          \"parameters\": [\n            \"OpIndex user\",\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if a protected load node can be covered by a user based on control flow effects and required when unused properties.\"\n        },\n        {\n          \"name\": \"IsOnlyUserOfNodeInSameBlock\",\n          \"parameters\": [\n            \"OpIndex user\",\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if a node has only one user within the same basic block.\"\n        },\n        {\n          \"name\": \"FindProjection\",\n          \"parameters\": [\n            \"OpIndex node\",\n            \"size_t projection_index\"\n          ],\n          \"return_type\": \"OptionalOpIndex\",\n          \"logic\": \"Finds a projection node with a specific index immediately following a given node.\"\n        },\n        {\n          \"name\": \"UpdateRenames\",\n          \"parameters\": [\n            \"Instruction* instruction\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Tries to rename virtual registers in the input operands of an instruction.\"\n        },\n        {\n          \"name\": \"UpdateRenamesInPhi\",\n          \"parameters\": [\n            \"PhiInstruction* phi\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates renames in phi instruction operands.\"\n        },\n        {\n          \"name\": \"GetRename\",\n          \"parameters\": [\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Gets the renamed virtual register.\"\n        },\n        {\n          \"name\": \"TryRename\",\n          \"parameters\": [\n            \"InstructionOperand* op\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Tries to rename the virtual register of an instruction operand.\"\n        },\n        {\n          \"name\": \"SetRename\",\n          \"parameters\": [\n            \"OpIndex node\",\n            \"OpIndex rename\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a rename for a virtual register.\"\n        },\n        {\n          \"name\": \"GetVirtualRegister\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Gets the virtual register for a node, allocating a new one if it doesn't exist.\"\n        },\n        {\n          \"name\": \"GetVirtualRegistersForTesting\",\n          \"parameters\": [],\n          \"return_type\": \"const std::map<uint32_t, int>\",\n          \"logic\": \"Returns a map of node IDs to virtual registers, used for testing purposes.\"\n        },\n        {\n          \"name\": \"IsDefined\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a node has been defined.\"\n        },\n        {\n          \"name\": \"MarkAsDefined\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks a node as defined.\"\n        },\n        {\n          \"name\": \"IsUsed\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a node is used.\"\n        },\n        {\n          \"name\": \"IsReallyUsed\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a node is really used.\"\n        },\n        {\n          \"name\": \"MarkAsUsed\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks a node as used.\"\n        },\n        {\n          \"name\": \"GetEffectLevel\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Gets the effect level of a node.\"\n        },\n        {\n          \"name\": \"GetEffectLevel\",\n          \"parameters\": [\n            \"OpIndex node\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Gets the effect level of a node, handling branch continuations.\"\n        },\n        {\n          \"name\": \"SetEffectLevel\",\n          \"parameters\": [\n            \"OpIndex node\",\n            \"int effect_level\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the effect level of a node.\"\n        },\n        {\n          \"name\": \"CanAddressRelativeToRootsRegister\",\n          \"parameters\": [\n            \"const ExternalReference& reference\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if a reference can be addressed relative to the roots register.\"\n        },\n        {\n          \"name\": \"CanUseRootsRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if the roots register can be used.\"\n        },\n        {\n          \"name\": \"MarkAsRepresentation\",\n          \"parameters\": [\n            \"MachineRepresentation rep\",\n            \"const InstructionOperand& op\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks an instruction operand as having a specific machine representation.\"\n        },\n        {\n          \"name\": \"MarkAsRepresentation\",\n          \"parameters\": [\n            \"MachineRepresentation rep\",\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks a node as having a specific machine representation.\"\n        },\n        {\n          \"name\": \"AddInputsToFrameStateDescriptor\",\n          \"parameters\": [\n            \"FrameStateDescriptor* descriptor\",\n            \"OpIndex state_node\",\n            \"OperandGenerator* g\",\n            \"TurboshaftStateObjectDeduplicator* deduplicator\",\n            \"InstructionOperandVector* inputs\",\n            \"FrameStateInputKind kind\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Adds inputs to a frame state descriptor for deoptimization.\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand a\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with a continuation, encoding flags and branch targets.\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with a continuation and two input operands.\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with a continuation and three input operands.\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"size_t output_count\",\n            \"InstructionOperand* outputs\",\n            \"size_t input_count\",\n            \"InstructionOperand* inputs\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with a continuation, multiple outputs, and multiple inputs.\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"size_t output_count\",\n            \"InstructionOperand* outputs\",\n            \"size_t input_count\",\n            \"InstructionOperand* inputs\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with a continuation, multiple outputs, multiple inputs, and temporary operands.\"\n        },\n        {\n          \"name\": \"AppendDeoptimizeArguments\",\n          \"parameters\": [\n            \"InstructionOperandVector* args\",\n            \"DeoptimizeReason reason\",\n            \"uint32_t node_id\",\n            \"FeedbackSource const& feedback\",\n            \"OpIndex frame_state\",\n            \"DeoptimizeKind kind\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the deoptimization arguments to a list of instruction operands.\"\n        },\n        {\n          \"name\": \"InitializeCallBuffer\",\n          \"parameters\": [\n            \"OpIndex node\",\n            \"CallBuffer* buffer\",\n            \"CallBufferFlags flags\",\n            \"int stack_param_delta\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes the call buffer with information about the call, its arguments, and outputs.\"\n        },\n        {\n          \"name\": \"UpdateSourcePosition\",\n          \"parameters\": [\n            \"Instruction* instruction\",\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates the source position of an instruction.\"\n        },\n        {\n          \"name\": \"IsSourcePositionUsed\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the source position is used for a given node.\"\n        },\n        {\n          \"name\": \"VisitBlock\",\n          \"parameters\": [\n            \"const Block* block\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a basic block, generating code for each node in the block in reverse order.\"\n        },\n        {\n          \"name\": \"GetComparisonFlagCondition\",\n          \"parameters\": [\n            \"const ComparisonOp& op\"\n          ],\n          \"return_type\": \"FlagsCondition\",\n          \"logic\": \"Retrieves the comparison flag condition corresponding to a ComparisonOp.\"\n        },\n        {\n          \"name\": \"MarkPairProjectionsAsWord32\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks the projections of a pair operation as Word32.\"\n        },\n        {\n          \"name\": \"ConsumeEqualZero\",\n          \"parameters\": [\n            \"OpIndex* user\",\n            \"OpIndex* value\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Attempts to combine an equal zero comparison with a branch by inverting the branch.\"\n        },\n        {\n          \"name\": \"VisitI8x16RelaxedSwizzle\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits an I8x16 relaxed swizzle operation. Calls VisitI8x16Swizzle.\"\n        },\n        {\n          \"name\": \"VisitStackPointerGreaterThan\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a stack pointer greater than operation, setting a condition flag.\"\n        },\n        {\n          \"name\": \"VisitLoadStackCheckOffset\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a load stack check offset operation, emitting code to load the stack check offset.\"\n        },\n        {\n          \"name\": \"VisitLoadFramePointer\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a load frame pointer operation, emitting code to load the frame pointer.\"\n        },\n        {\n          \"name\": \"VisitLoadParentFramePointer\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a load parent frame pointer operation, emitting code to load the parent frame pointer.\"\n        },\n        {\n          \"name\": \"VisitLoadRootRegister\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a load root register operation. Does nothing; subsequent loads/stores will use kMode_Root.\"\n        },\n        {\n          \"name\": \"VisitFloat64Acos\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Acos operation and emits code using Ieee754Float64Acos.\"\n        },\n        {\n          \"name\": \"VisitFloat64Acosh\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Acosh operation and emits code using Ieee754Float64Acosh.\"\n        },\n        {\n          \"name\": \"VisitFloat64Asin\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Asin operation and emits code using Ieee754Float64Asin.\"\n        },\n        {\n          \"name\": \"VisitFloat64Asinh\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Asinh operation and emits code using Ieee754Float64Asinh.\"\n        },\n        {\n          \"name\": \"VisitFloat64Atan\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Atan operation and emits code using Ieee754Float64Atan.\"\n        },\n        {\n          \"name\": \"VisitFloat64Atanh\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Atanh operation and emits code using Ieee754Float64Atanh.\"\n        },\n        {\n          \"name\": \"VisitFloat64Atan2\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Atan2 operation and emits code using Ieee754Float64Atan2.\"\n        },\n        {\n          \"name\": \"VisitFloat64Cbrt\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Cbrt operation and emits code using Ieee754Float64Cbrt.\"\n        },\n        {\n          \"name\": \"VisitFloat64Cos\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Cos operation and emits code using Ieee754Float64Cos.\"\n        },\n        {\n          \"name\": \"VisitFloat64Cosh\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Cosh operation and emits code using Ieee754Float64Cosh.\"\n        },\n        {\n          \"name\": \"VisitFloat64Exp\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Exp operation and emits code using Ieee754Float64Exp.\"\n        },\n        {\n          \"name\": \"VisitFloat64Expm1\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Expm1 operation and emits code using Ieee754Float64Expm1.\"\n        },\n        {\n          \"name\": \"VisitFloat64Log\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Log operation and emits code using Ieee754Float64Log.\"\n        },\n        {\n          \"name\": \"VisitFloat64Log1p\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Log1p operation and emits code using Ieee754Float64Log1p.\"\n        },\n        {\n          \"name\": \"VisitFloat64Log2\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Log2 operation and emits code using Ieee754Float64Log2.\"\n        },\n        {\n          \"name\": \"VisitFloat64Log10\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Log10 operation and emits code using Ieee754Float64Log10.\"\n        },\n        {\n          \"name\": \"VisitFloat64Pow\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Pow operation and emits code using Ieee754Float64Pow.\"\n        },\n        {\n          \"name\": \"VisitFloat64Sin\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Sin operation and emits code using Ieee754Float64Sin.\"\n        },\n        {\n          \"name\": \"VisitFloat64Sinh\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Sinh operation and emits code using Ieee754Float64Sinh.\"\n        },\n        {\n          \"name\": \"VisitFloat64Tan\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Tan operation and emits code using Ieee754Float64Tan.\"\n        },\n        {\n          \"name\": \"VisitFloat64Tanh\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Float64 Tanh operation and emits code using Ieee754Float64Tanh.\"\n        },\n        {\n          \"name\": \"EmitTableSwitch\",\n          \"parameters\": [\n            \"const SwitchInfo& sw\",\n            \"InstructionOperand const& index_operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits a table switch instruction.\"\n        },\n        {\n          \"name\": \"EmitBinarySearchSwitch\",\n          \"parameters\": [\n            \"const SwitchInfo& sw\",\n            \"InstructionOperand const& value_operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits a binary search switch instruction.\"\n        },\n        {\n          \"name\": \"VisitBitcastTaggedToWord\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a BitcastTaggedToWord operation, emitting an identity.\"\n        },\n        {\n          \"name\": \"VisitBitcastWordToTagged\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a BitcastWordToTagged operation, emitting a nop instruction.\"\n        },\n        {\n          \"name\": \"VisitBitcastSmiToWord\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a BitcastSmiToWord operation, emitting an identity (or a nop in DEBUG mode).\"\n        },\n        {\n          \"name\": \"VisitParameter\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a parameter node, defining a location for the parameter.\"\n        },\n        {\n          \"name\": \"VisitIfException\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits an IfException node, defining it as being in the exception register.\"\n        },\n        {\n          \"name\": \"VisitOsrValue\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits an OsrValue node, defining a location for the OSR value.\"\n        },\n        {\n          \"name\": \"VisitPhi\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Phi node, creating a PhiInstruction in the instruction block.\"\n        },\n        {\n          \"name\": \"VisitProjection\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a Projection node, emitting identity or simply marking as used based on the value operation.\"\n        },\n        {\n          \"name\": \"CanDoBranchIfOverflowFusion\",\n          \"parameters\": [\n            \"OpIndex binop\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a branch-if-overflow fusion can be done with a binop operation.\"\n        },\n        {\n          \"name\": \"VisitConstant\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a constant node, emitting a NOP.\"\n        },\n        {\n          \"name\": \"UpdateMaxPushedArgumentCount\",\n          \"parameters\": [\n            \"size_t count\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates the maximum pushed argument count.\"\n        },\n        {\n          \"name\": \"VisitCall\",\n          \"parameters\": [\n            \"OpIndex node\",\n            \"Block* handler\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a call node, generating instructions for the call and its arguments and outputs.\"\n        },\n        {\n          \"name\": \"VisitTailCall\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a tail call node, generating instructions for a tail call.\"\n        },\n        {\n          \"name\": \"VisitGoto\",\n          \"parameters\": [\n            \"Block* target\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a goto, emitting code to jump to a target block.\"\n        },\n        {\n          \"name\": \"VisitReturn\",\n          \"parameters\": [\n            \"OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a return node, emitting code for returning from a function.\"\n        },\n        {\n          \"name\": \"VisitBranch\",\n          \"parameters\": [\n            \"OpIndex branch_node\",\n            \"Block* tbranch\",\n            \"Block* fbranch\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Visits a branch, emitting conditional jump to either the true or false block.\"\n        },\n        {\n          \"name\": \"TryPrepareScheduleFirstProjection\",\n          \"parameters\": [\n            \"OpIndex maybe_projection\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Tries to prepare (i.e., schedule and define) the first projection of a BinopOverflow operation.\"\n        },\n        {\n          \"name\": \"VisitDeoptimizeIf\","
}