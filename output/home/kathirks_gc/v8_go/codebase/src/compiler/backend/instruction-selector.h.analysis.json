{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/compiler/backend/instruction-selector.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/compiler/backend/instruction-selector.h\",\n  \"imports\": [\n    \"<map>\",\n    \"<optional>\",\n    \"src/codegen/cpu-features.h\",\n    \"src/codegen/machine-type.h\",\n    \"src/compiler/backend/instruction-scheduler.h\",\n    \"src/compiler/backend/instruction-selector-adapter.h\",\n    \"src/compiler/backend/instruction.h\",\n    \"src/compiler/feedback-source.h\",\n    \"src/compiler/linkage.h\",\n    \"src/compiler/node-matchers.h\",\n    \"src/compiler/turboshaft/operations.h\",\n    \"src/compiler/turboshaft/representations.h\",\n    \"src/compiler/turboshaft/utils.h\",\n    \"src/utils/bit-vector.h\",\n    \"src/zone/zone-containers.h\",\n    \"src/wasm/simd-shuffle.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"InstructionSelector\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ForTurboshaft\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"size_t node_count\",\n            \"Linkage* linkage\",\n            \"InstructionSequence* sequence\",\n            \"turboshaft::Graph* schedule\",\n            \"Frame* frame\",\n            \"EnableSwitchJumpTable enable_switch_jump_table\",\n            \"TickCounter* tick_counter\",\n            \"JSHeapBroker* broker\",\n            \"size_t* max_unoptimized_frame_height\",\n            \"size_t* max_pushed_argument_count\",\n            \"SourcePositionMode source_position_mode\",\n            \"Features features\",\n            \"EnableScheduling enable_scheduling\",\n            \"EnableRootsRelativeAddressing enable_roots_relative_addressing\",\n            \"EnableTraceTurboJson trace_turbo\"\n          ],\n          \"return_type\": \"InstructionSelector\",\n          \"logic\": \"Creates an InstructionSelector instance for Turboshaft backend.\"\n        },\n        {\n          \"name\": \"~InstructionSelector\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Destructor for the InstructionSelector class.\"\n        },\n        {\n          \"name\": \"SelectInstructions\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<BailoutReason>\",\n          \"logic\": \"Selects instructions based on the compiled graph, potentially returning a bailout reason.\"\n        },\n        {\n          \"name\": \"IsSupported\",\n          \"parameters\": [\n            \"CpuFeature feature\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a specific CPU feature is supported.\"\n        },\n        {\n          \"name\": \"SupportedFeatures\",\n          \"parameters\": [],\n          \"return_type\": \"Features\",\n          \"logic\": \"Returns the supported CPU features.\"\n        },\n        {\n          \"name\": \"instr_origins\",\n          \"parameters\": [],\n          \"return_type\": \"const ZoneVector<std::pair<int, int>>&\",\n          \"logic\": \"Returns the instruction origins (source positions).\"\n        },\n        {\n          \"name\": \"GetVirtualRegistersForTesting\",\n          \"parameters\": [],\n          \"return_type\": \"const std::map<NodeId, int>\",\n          \"logic\": \"Returns virtual registers for testing purposes.\"\n        },\n        {\n          \"name\": \"SupportedMachineOperatorFlags\",\n          \"parameters\": [],\n          \"return_type\": \"MachineOperatorBuilder::Flags\",\n          \"logic\": \"Returns the supported machine operator flags.\"\n        },\n        {\n          \"name\": \"AlignmentRequirements\",\n          \"parameters\": [],\n          \"return_type\": \"MachineOperatorBuilder::AlignmentRequirements\",\n          \"logic\": \"Returns the alignment requirements for memory access.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InstructionSelector::Features\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"Features\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Default constructor initializing bits_ to 0.\"\n        },\n        {\n          \"name\": \"Features\",\n          \"parameters\": [\n            \"unsigned bits\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor initializing bits_ with the provided value.\"\n        },\n        {\n          \"name\": \"Features\",\n          \"parameters\": [\n            \"CpuFeature f\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor initializing bits_ with the bit corresponding to a CPU feature.\"\n        },\n        {\n          \"name\": \"Features\",\n          \"parameters\": [\n            \"CpuFeature f1\",\n            \"CpuFeature f2\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor initializing bits_ with the bits corresponding to two CPU features.\"\n        },\n        {\n          \"name\": \"Contains\",\n          \"parameters\": [\n            \"CpuFeature f\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the feature f is contained in the feature set.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"FlagsContinuationT\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ForBranch\",\n          \"parameters\": [\n            \"FlagsCondition condition\",\n            \"turboshaft::Block* true_block\",\n            \"turboshaft::Block* false_block\"\n          ],\n          \"return_type\": \"FlagsContinuationT\",\n          \"logic\": \"Creates a flags continuation for a branch instruction.\"\n        },\n        {\n          \"name\": \"ForConditionalBranch\",\n          \"parameters\": [\n            \"compare_chain_t& compares\",\n            \"uint32_t num_conditional_compares\",\n            \"FlagsCondition branch_condition\",\n            \"turboshaft::Block* true_block\",\n            \"turboshaft::Block* false_block\"\n          ],\n          \"return_type\": \"FlagsContinuationT\",\n          \"logic\": \"Creates a flags continuation for a conditional branch instruction.\"\n        },\n        {\n          \"name\": \"ForDeoptimize\",\n          \"parameters\": [\n            \"FlagsCondition condition\",\n            \"DeoptimizeReason reason\",\n            \"uint32_t node_id\",\n            \"FeedbackSource const& feedback\",\n            \"turboshaft::OpIndex frame_state\"\n          ],\n          \"return_type\": \"FlagsContinuationT\",\n          \"logic\": \"Creates a flags continuation for a deoptimization exit.\"\n        },\n        {\n          \"name\": \"ForDeoptimizeForTesting\",\n          \"parameters\": [\n            \"FlagsCondition condition\",\n            \"DeoptimizeReason reason\",\n            \"uint32_t node_id\",\n            \"FeedbackSource const& feedback\",\n            \"turboshaft::OpIndex frame_state\"\n          ],\n          \"return_type\": \"FlagsContinuationT\",\n          \"logic\": \"Creates a flags continuation for a deoptimization exit, used in testing.\"\n        },\n        {\n          \"name\": \"ForSet\",\n          \"parameters\": [\n            \"FlagsCondition condition\",\n            \"turboshaft::OpIndex result\"\n          ],\n          \"return_type\": \"FlagsContinuationT\",\n          \"logic\": \"Creates a flags continuation for setting a boolean value based on flags.\"\n        },\n        {\n          \"name\": \"ForConditionalSet\",\n          \"parameters\": [\n            \"compare_chain_t& compares\",\n            \"uint32_t num_conditional_compares\",\n            \"FlagsCondition set_condition\",\n            \"turboshaft::OpIndex result\"\n          ],\n          \"return_type\": \"FlagsContinuationT\",\n          \"logic\": \"Creates a flags continuation for conditional set instruction\"\n        },\n        {\n          \"name\": \"ForTrap\",\n          \"parameters\": [\n            \"FlagsCondition condition\",\n            \"TrapId trap_id\"\n          ],\n          \"return_type\": \"FlagsContinuationT\",\n          \"logic\": \"Creates a flags continuation for a wasm trap instruction.\"\n        },\n        {\n          \"name\": \"ForSelect\",\n          \"parameters\": [\n            \"FlagsCondition condition\",\n            \"turboshaft::OpIndex result\",\n            \"turboshaft::OpIndex true_value\",\n            \"turboshaft::OpIndex false_value\"\n          ],\n          \"return_type\": \"FlagsContinuationT\",\n          \"logic\": \"Creates a flags continuation for a select instruction.\"\n        },\n        {\n          \"name\": \"IsNone\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the flags continuation is none.\"\n        },\n        {\n          \"name\": \"IsBranch\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the flags continuation is for a branch.\"\n        },\n        {\n          \"name\": \"IsConditionalBranch\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the flags continuation is for a conditional branch.\"\n        },\n        {\n          \"name\": \"IsDeoptimize\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the flags continuation is for a deoptimization.\"\n        },\n        {\n          \"name\": \"IsSet\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the flags continuation is for a set instruction.\"\n        },\n        {\n          \"name\": \"IsConditionalSet\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the flags continuation is for a conditional set instruction.\"\n        },\n        {\n          \"name\": \"IsTrap\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the flags continuation is for a trap instruction.\"\n        },\n        {\n          \"name\": \"IsSelect\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the flags continuation is for a select instruction.\"\n        },\n        {\n          \"name\": \"condition\",\n          \"parameters\": [],\n          \"return_type\": \"FlagsCondition\",\n          \"logic\": \"Returns the condition for the flags continuation.\"\n        },\n        {\n          \"name\": \"final_condition\",\n          \"parameters\": [],\n          \"return_type\": \"FlagsCondition\",\n          \"logic\": \"Returns the final condition of conditional branching.\"\n        },\n        {\n          \"name\": \"reason\",\n          \"parameters\": [],\n          \"return_type\": \"DeoptimizeReason\",\n          \"logic\": \"Returns the deoptimization reason.\"\n        },\n        {\n          \"name\": \"node_id\",\n          \"parameters\": [],\n          \"return_type\": \"uint32_t\",\n          \"logic\": \"Returns the node id for the deoptimization.\"\n        },\n        {\n          \"name\": \"feedback\",\n          \"parameters\": [],\n          \"return_type\": \"FeedbackSource const&\",\n          \"logic\": \"Returns the feedback source for the deoptimization.\"\n        },\n        {\n          \"name\": \"frame_state\",\n          \"parameters\": [],\n          \"return_type\": \"turboshaft::OpIndex\",\n          \"logic\": \"Returns the frame state for deoptimization.\"\n        },\n        {\n          \"name\": \"result\",\n          \"parameters\": [],\n          \"return_type\": \"turboshaft::OpIndex\",\n          \"logic\": \"Returns the result node for a set instruction.\"\n        },\n        {\n          \"name\": \"trap_id\",\n          \"parameters\": [],\n          \"return_type\": \"TrapId\",\n          \"logic\": \"Returns the trap id for wasm trap.\"\n        },\n        {\n          \"name\": \"true_block\",\n          \"parameters\": [],\n          \"return_type\": \"turboshaft::Block*\",\n          \"logic\": \"Returns the true block for a branch.\"\n        },\n        {\n          \"name\": \"false_block\",\n          \"parameters\": [],\n          \"return_type\": \"turboshaft::Block*\",\n          \"logic\": \"Returns the false block for a branch.\"\n        },\n        {\n          \"name\": \"true_value\",\n          \"parameters\": [],\n          \"return_type\": \"turboshaft::OpIndex\",\n          \"logic\": \"Returns the true_value for select.\"\n        },\n        {\n          \"name\": \"false_value\",\n          \"parameters\": [],\n          \"return_type\": \"turboshaft::OpIndex\",\n          \"logic\": \"Returns the false_value for select.\"\n        },\n        {\n          \"name\": \"compares\",\n          \"parameters\": [],\n          \"return_type\": \"const compare_chain_t&\",\n          \"logic\": \"Returns compares_\"\n        },\n        {\n          \"name\": \"num_conditional_compares\",\n          \"parameters\": [],\n          \"return_type\": \"uint32_t\",\n          \"logic\": \"Returns num_conditional_compares_\"\n        },\n        {\n          \"name\": \"Negate\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Negates the flags condition.\"\n        },\n        {\n          \"name\": \"Commute\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Commutes the flags condition.\"\n        },\n        {\n          \"name\": \"Overwrite\",\n          \"parameters\": [\n            \"FlagsCondition condition\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Overwrites the flags condition with a new condition.\"\n        },\n        {\n          \"name\": \"OverwriteAndNegateIfEqual\",\n          \"parameters\": [\n            \"FlagsCondition condition\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Overwrites and negates\"\n        },\n        {\n          \"name\": \"OverwriteUnsignedIfSigned\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Changes signed to unsigned conditions when applicable.\"\n        },\n        {\n          \"name\": \"Encode\",\n          \"parameters\": [\n            \"InstructionCode opcode\"\n          ],\n          \"return_type\": \"InstructionCode\",\n          \"logic\": \"Encodes the flags continuation information into the instruction opcode.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PushParameterT\",\n      \"properties\": [\n          \"turboshaft::OpIndex node\",\n          \"LinkageLocation location\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"PushParameterT\",\n          \"parameters\": [\n            \"turboshaft::OpIndex n\",\n            \"LinkageLocation l\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that initializes the node and location of the parameter\"\n        }\n      ]\n    },\n    {\n      \"name\": \"InstructionSelectorT\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"InstructionSelectorT\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"size_t node_count\",\n            \"Linkage* linkage\",\n            \"InstructionSequence* sequence\",\n            \"turboshaft::Graph* schedule\",\n            \"source_position_table_t* source_positions\",\n            \"Frame* frame\",\n            \"InstructionSelector::EnableSwitchJumpTable enable_switch_jump_table\",\n            \"TickCounter* tick_counter\",\n            \"JSHeapBroker* broker\",\n            \"size_t* max_unoptimized_frame_height\",\n            \"size_t* max_pushed_argument_count\",\n            \"InstructionSelector::SourcePositionMode source_position_mode\",\n            \"Features features\",\n            \"InstructionSelector::EnableScheduling enable_scheduling\",\n            \"InstructionSelector::EnableRootsRelativeAddressing enable_roots_relative_addressing\",\n            \"InstructionSelector::EnableTraceTurboJson trace_turbo\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for the InstructionSelectorT class.\"\n        },\n        {\n          \"name\": \"SelectInstructions\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<BailoutReason>\",\n          \"logic\": \"Selects instructions for the given graph.\"\n        },\n        {\n          \"name\": \"StartBlock\",\n          \"parameters\": [\n            \"RpoNumber rpo\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks the beginning of a basic block for instruction selection.\"\n        },\n        {\n          \"name\": \"EndBlock\",\n          \"parameters\": [\n            \"RpoNumber rpo\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks the end of a basic block.\"\n        },\n        {\n          \"name\": \"AddInstruction\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds an instruction to the instruction sequence.\"\n        },\n        {\n          \"name\": \"AddTerminator\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds a terminator instruction.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with a single output.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with one input and one output.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with two inputs and one output.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with three inputs and one output.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"InstructionOperand d\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with four inputs and one output.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"InstructionOperand d\",\n            \"InstructionOperand e\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with five inputs and one output.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"InstructionOperand d\",\n            \"InstructionOperand e\",\n            \"InstructionOperand f\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with six inputs and one output.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand output\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"InstructionOperand d\",\n            \"InstructionOperand e\",\n            \"InstructionOperand f\",\n            \"InstructionOperand g\",\n            \"InstructionOperand h\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with eight inputs and one output.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"size_t output_count\",\n            \"InstructionOperand* outputs\",\n            \"size_t input_count\",\n            \"InstructionOperand* inputs\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits an instruction with multiple inputs and outputs.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emits a pre-constructed instruction.\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emit instruction with FlagsContinuation\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand a\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emit instruction with FlagsContinuation\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emit instruction with FlagsContinuation\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"InstructionOperand a\",\n            \"InstructionOperand b\",\n            \"InstructionOperand c\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emit instruction with FlagsContinuation\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"size_t output_count\",\n            \"InstructionOperand* outputs\",\n            \"size_t input_count\",\n            \"InstructionOperand* inputs\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emit instruction with FlagsContinuation\"\n        },\n        {\n          \"name\": \"EmitWithContinuation\",\n          \"parameters\": [\n            \"InstructionCode opcode\",\n            \"size_t output_count\",\n            \"InstructionOperand* outputs\",\n            \"size_t input_count\",\n            \"InstructionOperand* inputs\",\n            \"size_t temp_count\",\n            \"InstructionOperand* temps\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"Instruction*\",\n          \"logic\": \"Emit instruction with FlagsContinuation\"\n        },\n        {\n          \"name\": \"EmitIdentity\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits an identity instruction for a node.\"\n        },\n        {\n          \"name\": \"IsSupported\",\n          \"parameters\": [\n            \"CpuFeature feature\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the specific CPU feature is supported.\"\n        },\n        {\n          \"name\": \"SupportedFeatures\",\n          \"parameters\": [],\n          \"return_type\": \"Features\",\n          \"logic\": \"Returns supported CPU features.\"\n        },\n        {\n          \"name\": \"CanCover\",\n          \"parameters\": [\n            \"turboshaft::OpIndex user\",\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if a node can be covered by the instruction selection of its user.\"\n        },\n        {\n          \"name\": \"CanCoverProtectedLoad\",\n          \"parameters\": [\n            \"turboshaft::OpIndex user\",\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if a ProtectedLoad node can be covered by its user.\"\n        },\n        {\n          \"name\": \"IsOnlyUserOfNodeInSameBlock\",\n          \"parameters\": [\n            \"turboshaft::OpIndex user\",\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a node has only one user in the same basic block.\"\n        },\n        {\n          \"name\": \"IsDefined\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if code has already been generated for a node.\"\n        },\n        {\n          \"name\": \"IsUsed\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node is used and requires code generation.\"\n        },\n        {\n          \"name\": \"IsReallyUsed\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node is really used, ignoring `IsRequiredWhenUnused`.\"\n        },\n        {\n          \"name\": \"IsLive\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node is live (used but not defined).\"\n        },\n                {\n          \"name\": \"IsReallyLive\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the node is really live, ignoring `IsRequiredWhenUnused`.\"\n        },\n        {\n          \"name\": \"GetEffectLevel\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Gets the effect level of a node.\"\n        },\n        {\n          \"name\": \"GetEffectLevel\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\",\n            \"FlagsContinuation* cont\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Gets the effect level of a node, adjusted for the flags continuation.\"\n        },\n        {\n          \"name\": \"GetVirtualRegister\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the virtual register assigned to a node.\"\n        },\n        {\n          \"name\": \"GetVirtualRegistersForTesting\",\n          \"parameters\": [],\n          \"return_type\": \"const std::map<uint32_t, int>\",\n          \"logic\": \"Returns virtual registers for testing purposes.\"\n        },\n        {\n          \"name\": \"CanAddressRelativeToRootsRegister\",\n          \"parameters\": [\n            \"const ExternalReference& reference\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a memory access can be done relative to the roots register.\"\n        },\n        {\n          \"name\": \"CanUseRootsRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if using the roots register is allowed.\"\n        },\n        {\n          \"name\": \"isolate\",\n          \"parameters\": [],\n          \"return_type\": \"Isolate*\",\n          \"logic\": \"Returns the isolate.\"\n        },\n        {\n          \"name\": \"instr_origins\",\n          \"parameters\": [],\n          \"return_type\": \"const ZoneVector<std::pair<int, int>>&\",\n          \"logic\": \"Returns instruction origins.\"\n        },\n        {\n          \"name\": \"FindProjection\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\",\n            \"size_t projection_index\"\n          ],\n          \"return_type\": \"turboshaft::OptionalOpIndex\",\n          \"logic\": \"Finds a projection of a node.\"\n        },\n        {\n          \"name\": \"Inputs\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"auto\",\n          \"logic\": \"Generic function that returns a tuple of the input nodes from a given operation.\"\n        },\n        {\n          \"name\": \"CanDoBranchIfOverflowFusion\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if we can do branch-if-overflow fusion.\"\n        },\n        {\n          \"name\": \"SetProtectedLoadToRemove\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Records that this ProtectedLoad node can be deleted if not used, even though it has a required_when_unused effect.\"\n        },\n        {\n          \"name\": \"MarkAsProtected\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks that this node embeds a ProtectedLoad as operand, and so it is itself a protected instruction, for which we'll need to record the source position.\"\n        },\n        {\n          \"name\": \"UpdateSourcePosition\",\n          \"parameters\": [\n            \"Instruction* instruction\",\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates the source position of the instruction based on the given node.\"\n        },\n        {\n          \"name\": \"AppendDeoptimizeArguments\",\n          \"parameters\": [\n            \"InstructionOperandVector* args\",\n            \"DeoptimizeReason reason\",\n            \"uint32_t node_id\",\n            \"FeedbackSource const& feedback\",\n            \"turboshaft::OpIndex frame_state\",\n            \"DeoptimizeKind kind\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Helper to create arguments required for the deoptimize instructions.\"\n        },\n        {\n          \"name\": \"TryRename\",\n          \"parameters\": [\n            \"InstructionOperand* op\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Try rename virtual register for operands.\"\n        },\n        {\n          \"name\": \"GetRename\",\n          \"parameters\": [\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Retrieves the rename register.\"\n        },\n        {\n          \"name\": \"SetRename\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\",\n            \"turboshaft::OpIndex rename\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a rename for a given node.\"\n        },\n        {\n          \"name\": \"UpdateRenames\",\n          \"parameters\": [\n            \"Instruction* instruction\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates renames.\"\n        },\n        {\n          \"name\": \"UpdateRenamesInPhi\",\n          \"parameters\": [\n            \"PhiInstruction* phi\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Update renames of instruction in phi.\"\n        },\n        {\n          \"name\": \"MarkAsDefined\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Inform the instruction selection that {node} was just defined.\"\n        },\n        {\n          \"name\": \"MarkAsUsed\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Inform the instruction selection that {node} has at least one use and we will need to generate code for it.\"\n        },\n        {\n          \"name\": \"SetEffectLevel\",\n          \"parameters\": [\n            \"turboshaft::OpIndex node\",\n            \"int effect_level\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the effect level of {node}.\"\n        },\n        {\n          \"name\": \"MarkAsRepresentation\",\n          \"parameters\": [\n            \"MachineRepresentation rep\",\n            \"turboshaft::OpIndex node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Inform the register allocation of the representation of the value produced by {node}.\"\n        },\n        {\n          \"name\": \"MarkAsRepresentation\",\n          \"parameters\": [\n            \"MachineRepresentation rep\",\n            \"const InstructionOperand& op\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Inform the register allocation of the representation of the unallocated operand {op}.\"\n        },\n        {\n          \"name\": \"InitializeCallBuffer\",\n          \"parameters\": [\n            \"turboshaft::OpIndex call\",\n            \"CallBuffer* buffer\",\n            \"CallBufferFlags flags\",\n            \"int stack_slot_delta\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initialize the call buffer with the InstructionOperands, nodes, etc, corresponding to the inputs and outputs of the call.\"\n        },\n        {\n          \"name\": \"IsTailCallAddressImmediate\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks whether this is a tail call with an immediate address.\"\n        },\n        {\n          \"name\": \"UpdateMaxPushedArgumentCount\",\n          \"parameters\": [\n            \"size_t count\"\n          ],\n"
}