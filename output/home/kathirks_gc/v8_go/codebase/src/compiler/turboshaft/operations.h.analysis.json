{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/compiler/turboshaft/operations.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/compiler/turboshaft/operations.h\",\n  \"imports\": [\n    \"<cmath>\",\n    \"<cstdint>\",\n    \"<cstring>\",\n    \"<limits>\",\n    \"<optional>\",\n    \"<tuple>\",\n    \"<type_traits>\",\n    \"<utility>\",\n    \"src/base/logging.h\",\n    \"src/base/macros.h\",\n    \"src/base/platform/mutex.h\",\n    \"src/base/small-vector.h\",\n    \"src/base/template-utils.h\",\n    \"src/base/vector.h\",\n    \"src/codegen/external-reference.h\",\n    \"src/common/globals.h\",\n    \"src/compiler/common-operator.h\",\n    \"src/compiler/fast-api-calls.h\",\n    \"src/compiler/globals.h\",\n    \"src/compiler/simplified-operator.h\",\n    \"src/compiler/turboshaft/deopt-data.h\",\n    \"src/compiler/turboshaft/fast-hash.h\",\n    \"src/compiler/turboshaft/index.h\",\n    \"src/compiler/turboshaft/representations.h\",\n    \"src/compiler/turboshaft/snapshot-table.h\",\n    \"src/compiler/turboshaft/types.h\",\n    \"src/compiler/turboshaft/utils.h\",\n    \"src/compiler/turboshaft/zone-with-name.h\",\n    \"src/compiler/write-barrier-kind.h\",\n    \"src/flags/flags.h\",\n    \"src/wasm/wasm-module.h\",\n    \"src/wasm/wasm-objects.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"VariableData\",\n      \"properties\": [\n        \"rep\",\n        \"loop_invariant\",\n        \"active_loop_variables_index\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"InputsRepFactory\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"EffectDimensions\",\n      \"properties\": [\n        \"load_heap_memory\",\n        \"load_off_heap_memory\",\n        \"store_heap_memory\",\n        \"store_off_heap_memory\",\n        \"before_raw_heap_access\",\n        \"after_raw_heap_access\",\n        \"control_flow\",\n        \"unused_padding\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"EffectDimensions\",\n          \"parameters\": [],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Default constructor, initializes all flags to false.\"\n        },\n        {\n          \"name\": \"bits\",\n          \"parameters\": [],\n          \"return_type\": \"Bits\",\n          \"logic\": \"Returns a bit representation of the EffectDimensions.\"\n        },\n        {\n          \"name\": \"FromBits\",\n          \"parameters\": [\n            \"bits\"\n          ],\n          \"return_type\": \"EffectDimensions\",\n          \"logic\": \"Creates an EffectDimensions object from a bit representation.\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two EffectDimensions objects for equality.\"\n        },\n        {\n          \"name\": \"operator!=\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two EffectDimensions objects for inequality.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"OpEffects\",\n      \"properties\": [\n        \"produces\",\n        \"consumes\",\n        \"can_create_identity\",\n        \"can_allocate\",\n        \"required_when_unused\",\n        \"unused_padding_1\",\n        \"unused_padding_2\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"OpEffects\",\n          \"parameters\": [],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Default constructor, initializes all flags to false.\"\n        },\n        {\n          \"name\": \"bits\",\n          \"parameters\": [],\n          \"return_type\": \"Bits\",\n          \"logic\": \"Returns a bit representation of the OpEffects.\"\n        },\n        {\n          \"name\": \"FromBits\",\n          \"parameters\": [\n            \"bits\"\n          ],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Creates an OpEffects object from a bit representation.\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two OpEffects objects for equality.\"\n        },\n        {\n          \"name\": \"operator!=\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two OpEffects objects for inequality.\"\n        },\n        {\n          \"name\": \"operator|\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Bitwise OR of two OpEffects objects.\"\n        },\n        {\n          \"name\": \"operator&\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Bitwise AND of two OpEffects objects.\"\n        },\n        {\n          \"name\": \"IsSubsetOf\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the current OpEffects object is a subset of another.\"\n        },\n        {\n          \"name\": \"AssumesConsistentHeap\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Adds constraints to ensure the operation executes with a consistent heap state.\"\n        },\n        {\n          \"name\": \"CanAllocateWithoutIdentity\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation can allocate immutable objects, with constraints for heap consistency.\"\n        },\n        {\n          \"name\": \"CanAllocate\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation can allocate and create a fresh identity, with constraints for heap consistency.\"\n        },\n        {\n          \"name\": \"CanDoRawHeapAccess\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation performs raw heap access, adding constraints against GC.\"\n        },\n        {\n          \"name\": \"CanReadHeapMemory\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation reads mutable heap memory.\"\n        },\n        {\n          \"name\": \"CanReadOffHeapMemory\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation reads off-heap memory.\"\n        },\n        {\n          \"name\": \"CanWriteOffHeapMemory\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation writes to off-heap memory.\"\n        },\n        {\n          \"name\": \"CanWriteHeapMemory\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation writes to heap memory.\"\n        },\n        {\n          \"name\": \"CanWriteMemory\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation writes to any memory (on- or off-heap).\"\n        },\n        {\n          \"name\": \"CanReadMemory\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation reads any memory (on- or off-heap).\"\n        },\n        {\n          \"name\": \"CanReadImmutableMemory\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation reads immutable data from heap.\"\n        },\n        {\n          \"name\": \"CanDependOnChecks\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation depends on previous checks.\"\n        },\n        {\n          \"name\": \"CanChangeControlFlow\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation can change control flow (branch, deopt, throw, crash).\"\n        },\n        {\n          \"name\": \"CanLeaveCurrentFunction\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation can exit the current function (return, deopt, exception throw, abort/trap).\"\n        },\n        {\n          \"name\": \"CanDeopt\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation can deoptimize.\"\n        },\n        {\n          \"name\": \"CanCreateIdentity\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation produces a fresh identity.\"\n        },\n        {\n          \"name\": \"CanCallAnything\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation can perform almost any side-effect (call, allocate, read/write memory, etc).\"\n        },\n        {\n          \"name\": \"RequiredWhenUnused\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Marks that the operation is required even when its result is not used.\"\n        },\n        {\n          \"name\": \"is_required_when_unused\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if an instruction must exist regardless of use.\"\n        },\n        {\n          \"name\": \"hoistable_before_a_branch\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the instruction can safely be moved before branches or checks.\"\n        },\n        {\n          \"name\": \"repetition_is_eliminatable\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if identical instances of the instruction can be eliminated (via GVN).\"\n        },\n        {\n          \"name\": \"can_read_mutable_memory\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the instruction can read from mutable memory.\"\n        },\n        {\n          \"name\": \"requires_consistent_heap\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the instruction requires the heap to be in consistent state.\"\n        },\n        {\n          \"name\": \"can_write\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the instruction has writing capabilities.\"\n        },\n        {\n          \"name\": \"can_be_constant_folded\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Whether the operation can be constant folded.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"SaturatedUint8\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"Incr\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Increments the value, saturating at the maximum.\"\n        },\n        {\n          \"name\": \"Decr\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Decrements the value, saturating at zero.\"\n        },\n        {\n          \"name\": \"SetToZero\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the value to zero.\"\n        },\n        {\n          \"name\": \"SetToOne\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the value to one.\"\n        },\n        {\n          \"name\": \"IsZero\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the value is zero.\"\n        },\n        {\n          \"name\": \"IsOne\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the value is one.\"\n        },\n        {\n          \"name\": \"IsSaturated\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the value is saturated (maximum).\"\n        },\n        {\n          \"name\": \"Get\",\n          \"parameters\": [],\n          \"return_type\": \"uint8_t\",\n          \"logic\": \"Returns the current value.\"\n        },\n        {\n          \"name\": \"operator+=\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"SaturatedUint8&\",\n          \"logic\": \"Adds another SaturatedUint8 to this instance.\"\n        },\n        {\n          \"name\": \"FromSize\",\n          \"parameters\": [\n            \"value\"\n          ],\n          \"return_type\": \"SaturatedUint8\",\n          \"logic\": \"Creates a SaturatedUint8 from a size_t value.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"underlying_operation\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"Operation\",\n      \"properties\": [\n        \"opcode\",\n        \"saturated_use_count\",\n        \"input_count\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"inputs\",\n          \"parameters\": [],\n          \"return_type\": \"base::Vector<const OpIndex>\",\n          \"logic\": \"Returns the vector of input OpIndices.\"\n        },\n        {\n          \"name\": \"input\",\n          \"parameters\": [\n            \"i\"\n          ],\n          \"return_type\": \"OpIndex\",\n          \"logic\": \"Returns the i-th input OpIndex.\"\n        },\n        {\n          \"name\": \"StorageSlotCount\",\n          \"parameters\": [\n            \"opcode\",\n            \"input_count\"\n          ],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the number of storage slots required for an operation with the given opcode and input count.\"\n        },\n        {\n          \"name\": \"StorageSlotCount\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the number of storage slots required for this operation.\"\n        },\n        {\n          \"name\": \"outputs_rep\",\n          \"parameters\": [],\n          \"return_type\": \"base::Vector<const RegisterRepresentation>\",\n          \"logic\": \"Returns the vector of output RegisterRepresentations.\"\n        },\n        {\n          \"name\": \"inputs_rep\",\n          \"parameters\": [\n            \"storage\"\n          ],\n          \"return_type\": \"base::Vector<const MaybeRegisterRepresentation>\",\n          \"logic\": \"Returns the vector of input MaybeRegisterRepresentations.\"\n        },\n        {\n          \"name\": \"Is\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation is of the given type.\"\n        },\n        {\n          \"name\": \"Cast\",\n          \"parameters\": [],\n          \"return_type\": \"Op&\",\n          \"logic\": \"Casts the operation to the given type (unsafe).\"\n        },\n        {\n          \"name\": \"TryCast\",\n          \"parameters\": [],\n          \"return_type\": \"Op*\",\n          \"logic\": \"Tries to cast the operation to the given type (safe).\"\n        },\n        {\n          \"name\": \"Effects\",\n          \"parameters\": [],\n          \"return_type\": \"OpEffects\",\n          \"logic\": \"Returns the OpEffects of the operation.\"\n        },\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation is a block terminator.\"\n        },\n        {\n          \"name\": \"IsRequiredWhenUnused\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operation is required even when its result is not used.\"\n        },\n        {\n          \"name\": \"ToString\",\n          \"parameters\": [],\n          \"return_type\": \"std::string\",\n          \"logic\": \"Returns a string representation of the operation.\"\n        },\n        {\n          \"name\": \"PrintInputs\",\n          \"parameters\": [\n            \"os\",\n            \"op_index_prefix\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints the inputs of the operation to the given output stream.\"\n        },\n        {\n          \"name\": \"PrintOptions\",\n          \"parameters\": [\n            \"os\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints the options of the operation to the given output stream.\"\n        },\n        {\n          \"name\": \"IsOnlyUserOf\",\n          \"parameters\": [\n            \"value\",\n            \"graph\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the current Operation is the only user of the given value Operation.\"\n        },\n        {\n          \"name\": \"Print\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints the Operation to standard out. Uses OperationPrintStyle.\"\n        },\n        {\n          \"name\": \"Operation\",\n          \"parameters\": [\n            \"opcode\",\n            \"input_count\"\n          ],\n          \"return_type\": \"constructor\",\n          \"logic\": \"Constructor for the Operation, initializing its opcode and input_count.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"OperationPrintStyle\",\n      \"properties\": [\n        \"op\",\n        \"op_index_prefix\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"HasStaticEffects\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"OperationT\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"Effects\",\n          \"parameters\": [],\n          \"return_type\": \"static constexpr OpEffects\",\n          \"logic\": \"Returns static op effects.\"\n        },\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"static constexpr bool\",\n          \"logic\": \"Determines if opcode is block terminator.\"\n        },\n        {\n          \"name\": \"IsRequiredWhenUnused\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Whether it's required even if result not used.\"\n        },\n         {\n          \"name\": \"EffectsIfStatic\",\n          \"parameters\": [],\n          \"return_type\": \"static constexpr std::optional<OpEffects>\",\n          \"logic\": \"Returns static op effects wrapped in std::optional.\"\n        },\n        {\n          \"name\": \"inputs\",\n          \"parameters\": [],\n          \"return_type\": \"base::Vector<OpIndex>\",\n          \"logic\": \"Returns vector of OpIndex inputs.\"\n        },\n        {\n          \"name\": \"input\",\n          \"parameters\": [\n            \"i\"\n          ],\n          \"return_type\": \"OpIndex\",\n          \"logic\": \"Returns individual OpIndex at index i.\"\n        },\n        {\n          \"name\": \"StorageSlotCount\",\n          \"parameters\": [\n            \"input_count\"\n          ],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns number of required slots.\"\n        },\n        {\n          \"name\": \"New\",\n          \"parameters\": [\n            \"graph\",\n            \"input_count\",\n            \"args...\"\n          ],\n          \"return_type\": \"Derived&\",\n          \"logic\": \"Allocates storage in graph's zone.\"\n        },\n        {\n          \"name\": \"EqualsForGVN\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compare if equal.\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Operator overloading.\"\n        },\n        {\n          \"name\": \"HashWithOptions\",\n          \"parameters\": [\n            \"Args&...\"\n          ],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Get HashValue.\"\n        },\n        {\n          \"name\": \"hash_value\",\n          \"parameters\": [\n            \"strategy\"\n          ],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Hashing for option settings.\"\n        },\n        {\n          \"name\": \"PrintInputs\",\n          \"parameters\": [\n            \"os\",\n            \"op_index_prefix\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Print inputs to os.\"\n        },\n        {\n          \"name\": \"PrintOptions\",\n          \"parameters\": [\n            \"os\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Print options to os.\"\n        },\n        {\n          \"name\": \"Validate\",\n          \"parameters\": [\n            \"graph\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Validate invariant on graph.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"FixedArityOperationT\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"New\",\n          \"parameters\": [\n            \"graph\",\n            \"args...\"\n          ],\n          \"return_type\": \"Derived&\",\n          \"logic\": \"Allocates memory and constructs object via variadic templates.\"\n        },\n        {\n          \"name\": \"ExplodeImpl\",\n          \"parameters\": [\n            \"fn\",\n            \"mapper\",\n            \"InputI...\",\n            \"OptionI...\"\n          ],\n          \"return_type\": \"auto\",\n          \"logic\": \"Expands inputs/options into separate parameters via indexes.\"\n        },\n        {\n          \"name\": \"Explode\",\n          \"parameters\": [\n            \"fn\",\n            \"mapper\"\n          ],\n          \"return_type\": \"auto\",\n          \"logic\": \"Expands operations into separate parameters.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"SupportedOperations\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"Initialize\",\n          \"parameters\": [],\n          \"return_type\": \"static void\",\n          \"logic\": \"Initializes supported operations.\"\n        },\n        {\n          \"name\": \"IsUnalignedLoadSupported\",\n          \"parameters\": [\n            \"repr\"\n          ],\n          \"return_type\": \"static bool\",\n          \"logic\": \"Checks if unaligned loads are supported.\"\n        },\n        {\n          \"name\": \"IsUnalignedStoreSupported\",\n          \"parameters\": [\n            \"repr\"\n          ],\n          \"return_type\": \"static bool\",\n          \"logic\": \"Checks if unaligned stores are supported.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DeadOp\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"AbortCSADcheckOp\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"GenericBinopOp\",\n      \"properties\": [\n        \"kind\",\n        \"lazy_deopt_on_throw\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"GenericUnopOp\",\n      \"properties\": [\n        \"kind\",\n        \"lazy_deopt_on_throw\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"ToNumberOrNumericOp\",\n      \"properties\": [\n        \"kind\",\n        \"lazy_deopt_on_throw\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"Word32SignHintOp\",\n      \"properties\": [\n        \"sign\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"WordBinopOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsCommutative\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if commute.\"\n        },\n        {\n          \"name\": \"IsCommutative\",\n          \"parameters\": [\n            \"kind\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if commute.\"\n        },\n        {\n          \"name\": \"IsAssociative\",\n          \"parameters\": [\n            \"kind\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if associates.\"\n        },\n        {\n          \"name\": \"AllowsWord64ToWord32Truncation\",\n          \"parameters\": [\n            \"kind\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if truncation allowed.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"FloatBinopOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsCommutative\",\n          \"parameters\": [\n            \"kind\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if commutes.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Word32PairBinopOp\",\n      \"properties\": [\n        \"kind\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"WordBinopDeoptOnOverflowOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\",\n        \"feedback\",\n        \"mode\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"OverflowCheckedBinopOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsCommutative\",\n          \"parameters\": [\n            \"kind\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if can commute.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"WordUnaryOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"OverflowCheckedUnaryOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"FloatUnaryOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"ShiftOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsRightShift\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if right shift.\"\n        },\n        {\n          \"name\": \"IsRightShift\",\n          \"parameters\": [\n            \"kind\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if right shift.\"\n        },\n        {\n          \"name\": \"AllowsWord64ToWord32Truncation\",\n          \"parameters\": [\n            \"kind\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if word64 -> word32 is valid.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ComparisonOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsCommutative\",\n          \"parameters\": [\n            \"kind\"\n          ],\n          \"return_type\": \"static bool\",\n          \"logic\": \"Check is a commute?\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ChangeOp\",\n      \"properties\": [\n        \"kind\",\n        \"assumption\",\n        \"from\",\n        \"to\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"IsReversible\",\n          \"parameters\": [\n            \"kind\",\n            \"assumption\",\n            \"from\",\n            \"to\",\n            \"reverse_kind\",\n            \"signalling_nan_possible\"\n          ],\n          \"return_type\": \"static bool\",\n          \"logic\": \"Check is reversible.\"\n        },\n        {\n          \"name\": \"IsReversibleBy\",\n          \"parameters\": [\n            \"reverse_kind\",\n            \"signalling_nan_possible\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check reverse and not nan.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ChangeOrDeoptOp\",\n      \"properties\": [\n        \"kind\",\n        \"minus_zero_mode\",\n        \"feedback\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"TryChangeOp\",\n      \"properties\": [\n        \"kind\",\n        \"from\",\n        \"to\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"BitcastWord32PairToFloat64Op\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"TaggedBitcastOp\",\n      \"properties\": [\n        \"kind\",\n        \"from\",\n        \"to\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"SelectOp\",\n      \"properties\": [\n        \"rep\",\n        \"hint\",\n        \"implem\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"PhiOp\",\n      \"properties\": [\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"PendingLoopPhiOp\",\n      \"properties\": [\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"ConstantOp\",\n      \"properties\": [\n        \"kind\",\n        \"rep\",\n        \"storage\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"LoadRootRegisterOp\",\n      \"properties\": [\n        \"index\",\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"LoadOp\",\n      \"properties\": [\n        \"rep\",\n        \"kind\",\n        \"offset\",\n        \"machine_type\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"StoreOp\",\n      \"properties\": [\n        \"kind\",\n        \"offset\",\n        \"rep\",\n        \"write_barrier_kind\",\n        \"machine_type\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"RetainOp\",\n      \"properties\": [\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"ParameterOp\",\n      \"properties\": [\n        \"index\",\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"OsrValueOp\",\n      \"properties\": [\n        \"index\",\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"StackPointerGreaterThanOp\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"StackSlotOp\",\n      \"properties\": [\n        \"index\",\n        \"rep\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"FrameConstantOp\",\n      \"properties\": [\n        \"type\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"CheckExceptionOp\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"GotoOp\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"TailCallOp\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"UnreachableOp\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"ReturnOp\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"BranchOp\",\n      \"properties\": [\n        \"hint\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"SwitchOp\",\n      \"properties\": [\n        \"case_count\",\n        \"default_index\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"DeoptimizeOp\",\n      \"properties\": [\n        \"reason\",\n        \"deopt_id\",\n        \"deopt_kind\"\n      ],\n      \"methods\": []\n    },\n    {\n      \"name\": \"DeoptimizeIfOp\",\n      \"properties\": [\n        \"reason\",\n        \"deopt_id\",\n        \"deopt_kind\"\n      ],\n      \"methods\": [\n         {\n          \"name\": \"EqualsForGVN\",\n          \"parameters\": [\n            \"other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Override that can be GVNed ignoring the condition.\"\n        },\n        {\n          \"name\": \"hash_value\",\n          \"parameters\": [\n            \"strategy\"\n          ],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Overriding that can ignore condition.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"TrapIfOp\",\n      \"properties\": [\n        \"trap_id\"\n      ],\n      \"methods\": []\n    },\n    "
}