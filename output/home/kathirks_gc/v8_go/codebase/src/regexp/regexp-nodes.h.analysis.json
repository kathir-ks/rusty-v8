{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/regexp/regexp-nodes.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/regexp/regexp-nodes.h\",\n  \"imports\": [\n    \"src/codegen/label.h\",\n    \"src/regexp/regexp-macro-assembler.h\",\n    \"src/zone/zone.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"NodeInfo\",\n      \"properties\": [\n        \"being_analyzed\",\n        \"been_analyzed\",\n        \"follows_word_interest\",\n        \"follows_newline_interest\",\n        \"follows_start_interest\",\n        \"at_end\",\n        \"visited\",\n        \"replacement_calculated\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"NodeInfo\",\n          \"parameters\": [],\n          \"return_type\": \"NodeInfo\",\n          \"logic\": \"Constructor. Initializes all boolean flags to false.\"\n        },\n        {\n          \"name\": \"Matches\",\n          \"parameters\": [\n            \"NodeInfo* that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares the interest flags and `at_end` flag of this NodeInfo with another NodeInfo. Returns true if they match.\"\n        },\n        {\n          \"name\": \"AddFromPreceding\",\n          \"parameters\": [\n            \"NodeInfo* that\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates this NodeInfo's interest flags and `at_end` flag by taking the bitwise OR with the corresponding flags from another NodeInfo, effectively inheriting preceding node's interest.\"\n        },\n        {\n          \"name\": \"HasLookbehind\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if any of the lookbehind interest flags (follows_word_interest, follows_newline_interest, follows_start_interest) are set.\"\n        },\n        {\n          \"name\": \"AddFromFollowing\",\n          \"parameters\": [\n            \"NodeInfo* that\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Updates this NodeInfo's lookbehind interest flags by taking the bitwise OR with the corresponding flags from another NodeInfo, effectively inheriting following node's interest.\"\n        },\n        {\n          \"name\": \"ResetCompilationState\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Resets the being_analyzed and been_analyzed flags to false.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"EatsAtLeastInfo\",\n      \"properties\": [\n        \"eats_at_least_from_possibly_start\",\n        \"eats_at_least_from_not_start\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"EatsAtLeastInfo\",\n          \"parameters\": [],\n          \"return_type\": \"EatsAtLeastInfo\",\n          \"logic\": \"Default constructor, initializes both `eats_at_least` values to 0.\"\n        },\n        {\n          \"name\": \"EatsAtLeastInfo\",\n          \"parameters\": [\n            \"uint8_t eats\"\n          ],\n          \"return_type\": \"EatsAtLeastInfo\",\n          \"logic\": \"Constructor, initializes both `eats_at_least` values to the given `eats` value.\"\n        },\n        {\n          \"name\": \"SetMin\",\n          \"parameters\": [\n            \"const EatsAtLeastInfo& other\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the eats_at_least fields to the minimum of the current values and the values from the other EatsAtLeastInfo object.\"\n        },\n        {\n          \"name\": \"IsZero\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if both eats_at_least fields are zero.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpNode\",\n      \"properties\": [\n        \"replacement_\",\n        \"on_work_list_\",\n        \"trace_count_\",\n        \"bm_info_\",\n        \"zone_\",\n        \"info_\",\n        \"eats_at_least_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RegExpNode\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"RegExpNode\",\n          \"logic\": \"Constructor. Initializes member variables.\"\n        },\n        {\n          \"name\": \"~RegExpNode\",\n          \"parameters\": [],\n          \"return_type\": \"virtual\",\n          \"logic\": \"Virtual destructor.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"NodeVisitor* visitor\"\n          ],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Abstract method to accept a visitor (visitor pattern).\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* trace\"\n          ],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Abstract method to emit code during compilation.\"\n        },\n        {\n          \"name\": \"EatsAtLeast\",\n          \"parameters\": [\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"uint32_t\",\n          \"logic\": \"Returns the minimum number of characters this node consumes. If not_at_start is true, it means the current position is not the start of the input string.\"\n        },\n        {\n          \"name\": \"EatsAtLeastFromLoopEntry\",\n          \"parameters\": [],\n          \"return_type\": \"virtual EatsAtLeastInfo\",\n          \"logic\": \"Returns how many characters this node must consume in order to succeed, given that this is a LoopChoiceNode whose counter register is in a newly-initialized state at the current position in the generated code.\"\n        },\n        {\n          \"name\": \"EmitQuickCheck\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* bounds_check_trace\",\n            \"Trace* trace\",\n            \"bool preload_has_checked_bounds\",\n            \"Label* on_possible_success\",\n            \"QuickCheckDetails* details_return\",\n            \"bool fall_through_on_failure\",\n            \"ChoiceNode* predecessor\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Emits quick check code to determine if the node might match.  Jumps to on_possible_success if there is a chance of a match, falls through otherwise. Returns true if a quick check was possible, false otherwise.\"\n        },\n        {\n          \"name\": \"GetQuickCheckDetails\",\n          \"parameters\": [\n            \"QuickCheckDetails* details\",\n            \"RegExpCompiler* compiler\",\n            \"int characters_filled_in\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Abstract method to get quick check details.\"\n        },\n        {\n          \"name\": \"GetQuickCheckDetailsFromLoopEntry\",\n          \"parameters\": [\n            \"QuickCheckDetails* details\",\n            \"RegExpCompiler* compiler\",\n            \"int characters_filled_in\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Fills in quick check details for this node, given that this is a LoopChoiceNode whose counter register is in a newly-initialized state.\"\n        },\n        {\n          \"name\": \"GreedyLoopTextLength\",\n          \"parameters\": [],\n          \"return_type\": \"virtual int\",\n          \"logic\": \"Returns the length of text this node can consume in a greedy loop. Returns kNodeIsTooComplexForGreedyLoops if the node is too complex.\"\n        },\n        {\n          \"name\": \"GetSuccessorOfOmnivorousTextNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"virtual RegExpNode*\",\n          \"logic\": \"Only returns the successor for a text node of length 1 that matches any character and that has no guards on it.\"\n        },\n        {\n          \"name\": \"KeepRecursing\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks whether the compiler has enough budget to keep recursing (for FillInBMInfo).\"\n        },\n        {\n          \"name\": \"FillInBMInfo\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"int offset\",\n            \"int budget\",\n            \"BoyerMooreLookahead* bm\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Fills in Boyer-Moore lookahead information for the node.  Used for optimized string search.\"\n        },\n        {\n          \"name\": \"FilterOneByte\",\n          \"parameters\": [\n            \"int depth\",\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"virtual RegExpNode*\",\n          \"logic\": \"Filters the node if the input is one-byte. Returns a node that can be substituted for itself, or nullptr if the node can never match.\"\n        },\n        {\n          \"name\": \"replacement\",\n          \"parameters\": [],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Returns the replacement node (used by FilterOneByte).\"\n        },\n        {\n          \"name\": \"set_replacement\",\n          \"parameters\": [\n            \"RegExpNode* replacement\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Sets the replacement node (used by FilterOneByte).\"\n        },\n        {\n          \"name\": \"SaveBMInfo\",\n          \"parameters\": [\n            \"BoyerMooreLookahead* bm\",\n            \"bool not_at_start\",\n            \"int offset\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Saves the Boyer-Moore lookahead information.\"\n        },\n        {\n          \"name\": \"label\",\n          \"parameters\": [],\n          \"return_type\": \"Label*\",\n          \"logic\": \"Returns the label associated with the node.\"\n        },\n        {\n          \"name\": \"on_work_list\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether the node is on the work list.\"\n        },\n        {\n          \"name\": \"set_on_work_list\",\n          \"parameters\": [\n            \"bool value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets whether the node is on the work list.\"\n        },\n        {\n          \"name\": \"info\",\n          \"parameters\": [],\n          \"return_type\": \"NodeInfo*\",\n          \"logic\": \"Returns the NodeInfo associated with the node.\"\n        },\n        {\n          \"name\": \"eats_at_least_info\",\n          \"parameters\": [],\n          \"return_type\": \"const EatsAtLeastInfo*\",\n          \"logic\": \"Returns the EatsAtLeastInfo object associated with the node.\"\n        },\n        {\n          \"name\": \"set_eats_at_least_info\",\n          \"parameters\": [\n            \"const EatsAtLeastInfo& eats_at_least\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the EatsAtLeastInfo object for the node.\"\n        },\n        {\n          \"name\": \"SetDoNotInline\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the trace count to maximum to prevent inlining.\"\n        },\n        {\n          \"name\": \"bm_info\",\n          \"parameters\": [\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"BoyerMooreLookahead*\",\n          \"logic\": \"Returns the BoyerMooreLookahead info for the node.\"\n        },\n        {\n          \"name\": \"AsEndNode\",\n          \"parameters\": [],\n          \"return_type\": \"EndNode*\",\n          \"logic\": \"Casts to EndNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"AsActionNode\",\n          \"parameters\": [],\n          \"return_type\": \"ActionNode*\",\n          \"logic\": \"Casts to ActionNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"AsChoiceNode\",\n          \"parameters\": [],\n          \"return_type\": \"ChoiceNode*\",\n          \"logic\": \"Casts to ChoiceNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"AsLoopChoiceNode\",\n          \"parameters\": [],\n          \"return_type\": \"LoopChoiceNode*\",\n          \"logic\": \"Casts to LoopChoiceNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"AsNegativeLookaroundChoiceNode\",\n          \"parameters\": [],\n          \"return_type\": \"NegativeLookaroundChoiceNode*\",\n          \"logic\": \"Casts to NegativeLookaroundChoiceNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"AsBackReferenceNode\",\n          \"parameters\": [],\n          \"return_type\": \"BackReferenceNode*\",\n          \"logic\": \"Casts to BackReferenceNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"AsAssertionNode\",\n          \"parameters\": [],\n          \"return_type\": \"AssertionNode*\",\n          \"logic\": \"Casts to AssertionNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"AsTextNode\",\n          \"parameters\": [],\n          \"return_type\": \"TextNode*\",\n          \"logic\": \"Casts to TextNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"AsSeqRegExpNode\",\n          \"parameters\": [],\n          \"return_type\": \"SeqRegExpNode*\",\n          \"logic\": \"Casts to SeqRegExpNode (returns nullptr if not of that type).\"\n        },\n        {\n          \"name\": \"zone\",\n          \"parameters\": [],\n          \"return_type\": \"Zone*\",\n          \"logic\": \"Returns the zone the node is allocated in.\"\n        },\n        {\n          \"name\": \"LimitVersions\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* trace\"\n          ],\n          \"return_type\": \"LimitResult\",\n          \"logic\": \"Helper function to determine if we can generate code for a node or need to generate a goto.\"\n        },\n        {\n          \"name\": \"set_bm_info\",\n          \"parameters\": [\n            \"bool not_at_start\",\n            \"BoyerMooreLookahead* bm\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the Boyer Moore lookahead info.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"SeqRegExpNode\",\n      \"properties\": [\n        \"on_success_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"SeqRegExpNode\",\n          \"parameters\": [\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"SeqRegExpNode\",\n          \"logic\": \"Constructor. Initializes the successor node.\"\n        },\n        {\n          \"name\": \"on_success\",\n          \"parameters\": [],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Returns the successor node.\"\n        },\n        {\n          \"name\": \"set_on_success\",\n          \"parameters\": [\n            \"RegExpNode* node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the successor node.\"\n        },\n        {\n          \"name\": \"FilterOneByte\",\n          \"parameters\": [\n            \"int depth\",\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Filters the node if the input is one-byte by filtering the successor.\"\n        },\n        {\n          \"name\": \"FillInBMInfo\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"int offset\",\n            \"int budget\",\n            \"BoyerMooreLookahead* bm\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Fills in Boyer-Moore lookahead information for the node by filling in the successor.\"\n        },\n        {\n          \"name\": \"AsSeqRegExpNode\",\n          \"parameters\": [],\n          \"return_type\": \"SeqRegExpNode*\",\n          \"logic\": \"Returns itself.\"\n        },\n        {\n          \"name\": \"FilterSuccessor\",\n          \"parameters\": [\n            \"int depth\",\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Helper function to filter the successor.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ActionNode\",\n      \"properties\": [\n        \"data_\",\n        \"action_type_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"SetRegisterForLoop\",\n          \"parameters\": [\n            \"int reg\",\n            \"int val\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to set a register for a loop.\"\n        },\n        {\n          \"name\": \"IncrementRegister\",\n          \"parameters\": [\n            \"int reg\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to increment a register.\"\n        },\n        {\n          \"name\": \"StorePosition\",\n          \"parameters\": [\n            \"int reg\",\n            \"bool is_capture\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to store the current position in a register.\"\n        },\n        {\n          \"name\": \"ClearCaptures\",\n          \"parameters\": [\n            \"Interval range\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to clear captures in a range.\"\n        },\n        {\n          \"name\": \"BeginPositiveSubmatch\",\n          \"parameters\": [\n            \"int stack_pointer_reg\",\n            \"int position_reg\",\n            \"RegExpNode* body\",\n            \"ActionNode* success_node\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to begin a positive submatch.\"\n        },\n        {\n          \"name\": \"BeginNegativeSubmatch\",\n          \"parameters\": [\n            \"int stack_pointer_reg\",\n            \"int position_reg\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to begin a negative submatch.\"\n        },\n        {\n          \"name\": \"PositiveSubmatchSuccess\",\n          \"parameters\": [\n            \"int stack_pointer_reg\",\n            \"int restore_reg\",\n            \"int clear_capture_count\",\n            \"int clear_capture_from\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to indicate success of a positive submatch.\"\n        },\n        {\n          \"name\": \"EmptyMatchCheck\",\n          \"parameters\": [\n            \"int start_register\",\n            \"int repetition_register\",\n            \"int repetition_limit\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to check for empty matches to prevent infinite loops.\"\n        },\n        {\n          \"name\": \"ModifyFlags\",\n          \"parameters\": [\n            \"RegExpFlags flags\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static ActionNode*\",\n          \"logic\": \"Creates an ActionNode to modify the regexp flags.\"\n        },\n        {\n          \"name\": \"ActionNode\",\n          \"parameters\": [\n            \"ActionType action_type\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"ActionNode\",\n          \"logic\": \"Protected constructor.\"\n        },\n        {\n          \"name\": \"AsActionNode\",\n          \"parameters\": [],\n          \"return_type\": \"ActionNode*\",\n          \"logic\": \"Returns itself.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"NodeVisitor* visitor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Accepts a visitor.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* trace\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits code for the action.\"\n        },\n        {\n          \"name\": \"GetQuickCheckDetails\",\n          \"parameters\": [\n            \"QuickCheckDetails* details\",\n            \"RegExpCompiler* compiler\",\n            \"int filled_in\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Gets quick check details.\"\n        },\n        {\n          \"name\": \"FillInBMInfo\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"int offset\",\n            \"int budget\",\n            \"BoyerMooreLookahead* bm\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Fills in Boyer-Moore lookahead information.\"\n        },\n        {\n          \"name\": \"action_type\",\n          \"parameters\": [],\n          \"return_type\": \"ActionType\",\n          \"logic\": \"Returns the action type.\"\n        },\n        {\n          \"name\": \"GreedyLoopTextLength\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the length of text this node can consume in a greedy loop.\"\n        },\n        {\n          \"name\": \"flags\",\n          \"parameters\": [],\n          \"return_type\": \"RegExpFlags\",\n          \"logic\": \"Returns the flags (for MODIFY_FLAGS action).\"\n        },\n        {\n          \"name\": \"success_node\",\n          \"parameters\": [],\n          \"return_type\": \"ActionNode*\",\n          \"logic\": \"Returns the success node (for BEGIN_POSITIVE_SUBMATCH action).\"\n        }\n      ]\n    },\n    {\n      \"name\": \"TextNode\",\n      \"properties\": [\n        \"elms_\",\n        \"read_backward_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TextNode\",\n          \"parameters\": [\n            \"ZoneList<TextElement>* elms\",\n            \"bool read_backward\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"TextNode\",\n          \"logic\": \"Constructor.\"\n        },\n        {\n          \"name\": \"TextNode\",\n          \"parameters\": [\n            \"RegExpClassRanges* that\",\n            \"bool read_backward\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"TextNode\",\n          \"logic\": \"Constructor for a single character class.\"\n        },\n        {\n          \"name\": \"CreateForCharacterRanges\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"ZoneList<CharacterRange>* ranges\",\n            \"bool read_backward\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static TextNode*\",\n          \"logic\": \"Creates a TextNode for a single character class for the given ranges.\"\n        },\n        {\n          \"name\": \"CreateForSurrogatePair\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"CharacterRange lead\",\n            \"ZoneList<CharacterRange>* trail_ranges\",\n            \"bool read_backward\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static TextNode*\",\n          \"logic\": \"Creates TextNode for a surrogate pair (i.e. match a sequence of two uc16 code unit ranges).\"\n        },\n        {\n          \"name\": \"CreateForSurrogatePair\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"ZoneList<CharacterRange>* lead_ranges\",\n            \"CharacterRange trail\",\n            \"bool read_backward\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static TextNode*\",\n          \"logic\": \"Creates TextNode for a surrogate pair (i.e. match a sequence of two uc16 code unit ranges).\"\n        },\n        {\n          \"name\": \"AsTextNode\",\n          \"parameters\": [],\n          \"return_type\": \"TextNode*\",\n          \"logic\": \"Returns itself.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"NodeVisitor* visitor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Accepts a visitor.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* trace\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits code for the text.\"\n        },\n        {\n          \"name\": \"GetQuickCheckDetails\",\n          \"parameters\": [\n            \"QuickCheckDetails* details\",\n            \"RegExpCompiler* compiler\",\n            \"int characters_filled_in\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Gets quick check details.\"\n        },\n        {\n          \"name\": \"elements\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneList<TextElement>*\",\n          \"logic\": \"Returns the list of text elements.\"\n        },\n        {\n          \"name\": \"read_backward\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether the text is read backward.\"\n        },\n        {\n          \"name\": \"MakeCaseIndependent\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"bool is_one_byte\",\n            \"RegExpFlags flags\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Makes the text case independent.\"\n        },\n        {\n          \"name\": \"GreedyLoopTextLength\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the length of text this node can consume in a greedy loop.\"\n        },\n        {\n          \"name\": \"GetSuccessorOfOmnivorousTextNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Returns the successor of an omnivorous text node.\"\n        },\n        {\n          \"name\": \"FillInBMInfo\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"int offset\",\n            \"int budget\",\n            \"BoyerMooreLookahead* bm\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Fills in Boyer-Moore lookahead information.\"\n        },\n        {\n          \"name\": \"CalculateOffsets\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Calculates offsets.\"\n        },\n        {\n          \"name\": \"FilterOneByte\",\n          \"parameters\": [\n            \"int depth\",\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Filters the node if the input is one-byte.\"\n        },\n        {\n          \"name\": \"Length\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the length of the text.\"\n        },\n        {\n          \"name\": \"TextEmitPass\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"TextEmitPassType pass\",\n            \"bool preloaded\",\n            \"Trace* trace\",\n            \"bool first_element_checked\",\n            \"int* checked_up_to\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits code for a specific pass in the text matching process.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AssertionNode\",\n      \"properties\": [\n        \"assertion_type_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"AtEnd\",\n          \"parameters\": [\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static AssertionNode*\",\n          \"logic\": \"Creates an AssertionNode for AT_END assertion.\"\n        },\n        {\n          \"name\": \"AtStart\",\n          \"parameters\": [\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static AssertionNode*\",\n          \"logic\": \"Creates an AssertionNode for AT_START assertion.\"\n        },\n        {\n          \"name\": \"AtBoundary\",\n          \"parameters\": [\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static AssertionNode*\",\n          \"logic\": \"Creates an AssertionNode for AT_BOUNDARY assertion.\"\n        },\n        {\n          \"name\": \"AtNonBoundary\",\n          \"parameters\": [\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static AssertionNode*\",\n          \"logic\": \"Creates an AssertionNode for AT_NON_BOUNDARY assertion.\"\n        },\n        {\n          \"name\": \"AfterNewline\",\n          \"parameters\": [\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"static AssertionNode*\",\n          \"logic\": \"Creates an AssertionNode for AFTER_NEWLINE assertion.\"\n        },\n        {\n          \"name\": \"AssertionNode\",\n          \"parameters\": [\n            \"AssertionType t\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"AssertionNode\",\n          \"logic\": \"Private constructor.\"\n        },\n        {\n          \"name\": \"AsAssertionNode\",\n          \"parameters\": [],\n          \"return_type\": \"AssertionNode*\",\n          \"logic\": \"Returns itself.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"NodeVisitor* visitor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Accepts a visitor.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* trace\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits code for the assertion.\"\n        },\n        {\n          \"name\": \"GetQuickCheckDetails\",\n          \"parameters\": [\n            \"QuickCheckDetails* details\",\n            \"RegExpCompiler* compiler\",\n            \"int filled_in\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Gets quick check details.\"\n        },\n        {\n          \"name\": \"FillInBMInfo\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"int offset\",\n            \"int budget\",\n            \"BoyerMooreLookahead* bm\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Fills in Boyer-Moore lookahead information.\"\n        },\n        {\n          \"name\": \"assertion_type\",\n          \"parameters\": [],\n          \"return_type\": \"AssertionType\",\n          \"logic\": \"Returns the assertion type.\"\n        },\n        {\n          \"name\": \"EmitBoundaryCheck\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* trace\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits the boundary check.\"\n        },\n        {\n          \"name\": \"BacktrackIfPrevious\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* trace\",\n            \"IfPrevious backtrack_if_previous\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Backtracks if the previous character is a word or non-word character.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BackReferenceNode\",\n      \"properties\": [\n        \"start_reg_\",\n        \"end_reg_\",\n        \"read_backward_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"BackReferenceNode\",\n          \"parameters\": [\n            \"int start_reg\",\n            \"int end_reg\",\n            \"bool read_backward\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"BackReferenceNode\",\n          \"logic\": \"Constructor.\"\n        },\n        {\n          \"name\": \"AsBackReferenceNode\",\n          \"parameters\": [],\n          \"return_type\": \"BackReferenceNode*\",\n          \"logic\": \"Returns itself.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"NodeVisitor* visitor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Accepts a visitor.\"\n        },\n        {\n          \"name\": \"start_register\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the start register.\"\n        },\n        {\n          \"name\": \"end_register\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the end register.\"\n        },\n        {\n          \"name\": \"read_backward\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether the backreference is read backward.\"\n        },\n        {\n          \"name\": \"Emit\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"Trace* trace\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Emits code for the backreference.\"\n        },\n        {\n          \"name\": \"GetQuickCheckDetails\",\n          \"parameters\": [\n            "
}