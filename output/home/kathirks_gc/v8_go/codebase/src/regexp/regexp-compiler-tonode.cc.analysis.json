{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/regexp/regexp-compiler-tonode.cc",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/regexp/regexp-compiler-tonode.cc\",\n  \"imports\": [\n    \"src/common/globals.h\",\n    \"src/execution/isolate.h\",\n    \"src/objects/string.h\",\n    \"src/regexp/regexp-compiler.h\",\n    \"src/regexp/regexp.h\",\n    \"src/strings/unicode-inl.h\",\n    \"src/zone/zone-list-inl.h\",\n    \"src/base/strings.h\",\n    \"src/regexp/special-case.h\",\n    \"unicode/locid.h\",\n    \"unicode/uniset.h\",\n    \"unicode/utypes.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"RegExpAtom\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the RegExpAtom to a TextNode, which represents a sequence of literal characters to match. It creates a ZoneList of TextElement, add the atom itself and create TextNode using this list.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpText\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the RegExpText to a TextNode. RegExpText already contain a list of TextElement. Create TextNode using this list.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpClassRanges\",\n      \"properties\": [\n        \"set_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"is_standard\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the character class represents one of the standard character sets (e.g., whitespace, word characters) and sets the standard_set_type_ if found. Uses CompareRanges and CompareInverseRanges to compare the ranges with known standard ranges.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the character class to a RegExpNode. This involves potentially case-folding, handling Unicode character classes, splitting ranges for surrogates, and creating a TextNode or ChoiceNode depending on the complexity of the character class. Uses UnicodeRangeSplitter and associated helper functions for Unicode handling.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"UnicodeRangeSplitter\",\n      \"properties\": [\n        \"bmp_\",\n        \"lead_surrogates_\",\n        \"trail_surrogates_\",\n        \"non_bmp_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"UnicodeRangeSplitter\",\n          \"parameters\": [\n            \"ZoneList<CharacterRange>* base\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor: takes a ZoneList of CharacterRange and split the range into BMP characters, Lead Surrogate, trail Surrogate and Non-BMP characters to use with unicode regular expression\"\n        },\n        {\n          \"name\": \"AddRange\",\n          \"parameters\": [\n            \"CharacterRange range\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Add a CharacterRange to the appropriate range of the splitter based on unicode characteristics.\"\n        },\n        {\n          \"name\": \"bmp\",\n          \"parameters\": [],\n          \"return_type\": \"CharacterRangeVector*\",\n          \"logic\": \"Returns the bmp_ CharacterRangeVector.\"\n        },\n        {\n          \"name\": \"lead_surrogates\",\n          \"parameters\": [],\n          \"return_type\": \"CharacterRangeVector*\",\n          \"logic\": \"Returns the lead_surrogates_ CharacterRangeVector.\"\n        },\n        {\n          \"name\": \"trail_surrogates\",\n          \"parameters\": [],\n          \"return_type\": \"CharacterRangeVector*\",\n          \"logic\": \"Returns the trail_surrogates_ CharacterRangeVector.\"\n        },\n        {\n          \"name\": \"non_bmp\",\n          \"parameters\": [],\n          \"return_type\": \"CharacterRangeVector*\",\n          \"logic\": \"Returns the non_bmp_ CharacterRangeVector.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpClassSetOperand\",\n      \"properties\": [\n        \"strings_\",\n        \"ranges_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts a RegExpClassSetOperand to a RegExpNode.  It creates a RegExpDisjunction if there are multiple alternatives. Alternatives can be strings and character ranges.\"\n        },\n        {\n          \"name\": \"Union\",\n          \"parameters\": [\n            \"RegExpClassSetOperand* other\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Performs a union operation between this and another RegExpClassSetOperand. It adds all ranges and strings from the other operand to this operand.\"\n        },\n        {\n          \"name\": \"Intersect\",\n          \"parameters\": [\n            \"RegExpClassSetOperand* other\",\n            \"ZoneList<CharacterRange>* temp_ranges\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Performs an intersection operation between this and another RegExpClassSetOperand.  It calculates the intersection of the ranges and keeps the strings that are present in both operands.\"\n        },\n        {\n          \"name\": \"Subtract\",\n          \"parameters\": [\n            \"RegExpClassSetOperand* other\",\n            \"ZoneList<CharacterRange>* temp_ranges\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Performs a subtraction operation between this and another RegExpClassSetOperand.  It subtracts the ranges of the other operand from this operand and removes any strings that are present in the other operand.\"\n        },\n        {\n          \"name\": \"ranges\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneList<CharacterRange>*\",\n          \"logic\": \"Returns the ranges_ property of the ClassSetOperand.\"\n        },\n        {\n            \"name\": \"has_strings\",\n            \"parameters\": [],\n            \"return_type\": \"bool\",\n            \"logic\": \"Determines if there are any strings in the class set.\"\n        },\n        {\n            \"name\": \"strings\",\n            \"parameters\": [],\n            \"return_type\": \"CharacterClassStrings*\",\n            \"logic\": \"Returns a pointer to the CharacterClassStrings data structure.\"\n        }\n\n      ]\n    },\n    {\n      \"name\": \"RegExpClassSetExpression\",\n      \"properties\": [\n        \"operation_\",\n        \"is_negated_\",\n        \"operands_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts a RegExpClassSetExpression to a RegExpNode. It computes the expression by calling ComputeExpression and then converts the resulting RegExpClassSetOperand to a node.\"\n        },\n        {\n          \"name\": \"ComputeExpression\",\n          \"parameters\": [\n            \"RegExpTree* root\",\n            \"ZoneList<CharacterRange>* temp_ranges\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"RegExpClassSetOperand*\",\n          \"logic\": \"Recursively computes the value of the class set expression by applying the specified operations (union, intersection, subtraction) to the operands. It also handles negation.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpDisjunction\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"SortConsecutiveAtoms\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Sorts consecutive atom nodes (RegExpAtom) within the disjunction to improve optimization opportunities.  Handles case-insensitive sorting by using appropriate comparison functions.\"\n        },\n        {\n          \"name\": \"RationalizeConsecutiveAtoms\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Identifies and optimizes consecutive atom nodes (RegExpAtom) with common prefixes, transforming 'ab|ac|az' to 'a(?:b|c|z)'.\"\n        },\n        {\n          \"name\": \"FixSingleCharacterDisjunctions\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Optimizes disjunctions of single-character atoms by converting them to character classes, transforming 'b|c|z' to '[bcz]'.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the disjunction to a ChoiceNode, representing the alternation of multiple regular expression alternatives. Calls SortConsecutiveAtoms, RationalizeConsecutiveAtoms, and FixSingleCharacterDisjunctions to optimize before creating the ChoiceNode.\"\n        },\n        {\n          \"name\": \"alternatives\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneList<RegExpTree*>*\",\n          \"logic\": \"Returns ZoneList of the alternative regular expression trees.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpQuantifier\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the quantifier to a sequence of nodes to represent the loops and optional repetitions. Utilizes the recursive ToNode with min and max values.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"int min\",\n            \"int max\",\n            \"bool is_greedy\",\n            \"RegExpTree* body\",\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\",\n            \"bool not_at_start\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Creates the regexp graph nodes to represent the min, max quantification with the body. Contains loops to handle different iterations. It handles empty bodies and store position to track match lengths and counter logic.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpAssertion\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the assertion (e.g., start of line, end of input) to an AssertionNode or, in certain cases for boundary assertions under Unicode awareness, lookarounds. The function handles start of line, start of input, boundary, end of input and end of line.\"\n        },\n        {\n            \"name\": \"assertion_type\",\n            \"parameters\": [],\n            \"return_type\": \"Type\",\n            \"logic\": \"Returns assertion type.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpBackReference\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the backreference to a BackReferenceNode, which references a previously captured group in the regular expression.\"\n        },\n        {\n            \"name\": \"captures\",\n            \"parameters\": [],\n            \"return_type\": \"ZoneList<RegExpCapture*>*\",\n            \"logic\": \"Returns ZoneList of captures\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpEmpty\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Represents an empty regular expression element.  It simply returns the on_success node.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpGroup\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts a group to a series of nodes with flags. Applies local flags for part of the regular expressions and then reset the flags to initial state. If there are no flags changed then it returns body nodes.\"\n        },\n        {\n            \"name\": \"flags\",\n            \"parameters\": [],\n            \"return_type\": \"RegExpFlags\",\n            \"logic\": \"Returns the flags of a RegExpGroup.\"\n        },\n        {\n            \"name\": \"body\",\n            \"parameters\": [],\n            \"return_type\": \"RegExpTree*\",\n            \"logic\": \"Returns the body of a RegExpGroup.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpLookaround::Builder\",\n      \"properties\": [\n        \"is_positive_\",\n        \"on_success_\",\n        \"stack_pointer_register_\",\n        \"position_register_\",\n        \"on_match_success_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Builder\",\n          \"parameters\": [\n            \"bool is_positive\",\n            \"RegExpNode* on_success\",\n            \"int stack_pointer_register\",\n            \"int position_register\",\n            \"int capture_register_count\",\n            \"int capture_register_start\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructs a builder object. It initializes the instance's flags to determine how match success or failure should be handled.\"\n        },\n        {\n          \"name\": \"ForMatch\",\n          \"parameters\": [\n            \"RegExpNode* match\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Creates the node which runs the positive or negative lookahead. Depending on the value, this function creates different type of regular expression nodes.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpLookaround\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the lookaround (lookahead or lookbehind) assertion to a series of nodes. Allocates stack and position registers, builds a Builder object to correctly handle lookaround, sets whether read direction is backwards or forward depending if its a lookbehind or lookahead.\"\n        },\n        {\n            \"name\": \"capture_count\",\n            \"parameters\": [],\n            \"return_type\": \"int\",\n            \"logic\": \"Returns capture count\"\n        },\n        {\n            \"name\": \"capture_from\",\n            \"parameters\": [],\n            \"return_type\": \"int\",\n            \"logic\": \"Returns capture from\"\n        },\n        {\n            \"name\": \"is_positive\",\n            \"parameters\": [],\n            \"return_type\": \"bool\",\n            \"logic\": \"Returns if lookaround should be positive or negative\"\n        },\n        {\n            \"name\": \"body\",\n            \"parameters\": [],\n            \"return_type\": \"RegExpTree*\",\n            \"logic\": \"Returns body of the lookaround\"\n        },\n        {\n            \"name\": \"type\",\n            \"parameters\": [],\n            \"return_type\": \"Type\",\n            \"logic\": \"Returns the type of lookaround. Lookahead or lookbehind.\"\n        }\n\n      ]\n    },\n    {\n      \"name\": \"RegExpCapture\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the capture to a sequence of ActionNodes that store the start and end positions of the captured substring.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpTree* body\",\n            \"int index\",\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the capture with body, index into Action nodes for storing start and end positions.\"\n        },\n        {\n            \"name\": \"StartRegister\",\n            \"parameters\": [\n              \"int index\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Returns the start register based on index.\"\n        },\n        {\n            \"name\": \"EndRegister\",\n            \"parameters\": [\n              \"int index\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Returns the end register based on index.\"\n        },\n        {\n            \"name\": \"index\",\n            \"parameters\": [],\n            \"return_type\": \"int\",\n            \"logic\": \"Returns index\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AssertionSequenceRewriter\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"MaybeRewrite\",\n          \"parameters\": [\n            \"ZoneList<RegExpTree*>* terms\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Static method. Rewrites a sequence of assertions in the AST to simplify or optimize them. Folds duplicates and collapses failures (e.g., \\\\b\\\\B).\"\n        },\n        {\n          \"name\": \"Rewrite\",\n          \"parameters\": [\n            \"int from\",\n            \"int to\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Rewrites consecutive assertions.  Folds repeated assertions ( \\\\b\\\\b to \\\\b) and collapses certain failure sequences (\\\\b\\\\B becomes a failure\"\n        },\n        {\n          \"name\": \"ReplaceSequenceWithFailure\",\n          \"parameters\": [\n            \"int from\",\n            \"int to\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Replaces a range in a sequence of RegExp trees with a RegExpClassRanges to signal a failure condition. Replace from..to ranges with fail node.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpAlternative\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"RegExpNode* on_success\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the alternative to a sequence of nodes by concatenating the nodes representing the alternative's children (nodes in nodes()). If reading direction is backwards then loop from start to end, else loop from end to start.\"\n        },\n        {\n            \"name\": \"nodes\",\n            \"parameters\": [],\n            \"return_type\": \"ZoneList<RegExpTree*>*\",\n            \"logic\": \"Returns ZoneList of the alternative nodes.\"\n        }\n      ]\n    },\n        {\n            \"name\": \"ModifiersScope\",\n            \"properties\": [\n              \"compiler_\",\n              \"previous_flags_\"\n            ],\n            \"methods\": [\n              {\n                \"name\": \"ModifiersScope\",\n                \"parameters\": [\n                  \"RegExpCompiler* compiler\",\n                  \"RegExpFlags flags\"\n                ],\n                \"return_type\": \"void\",\n                \"logic\": \"Constructor.  It stores compiler object and previous flags before settings to new flags.\"\n              },\n              {\n                \"name\": \"~ModifiersScope\",\n                \"parameters\": [],\n                \"return_type\": \"void\",\n                \"logic\": \"Destructor. It restore the flags of given compiler object.\"\n              }\n            ]\n          },\n    {\n      \"name\": \"RegExpExpansionLimiter\",\n      \"properties\": [\n        \"compiler_\",\n        \"saved_expansion_factor_\",\n        \"ok_to_expand_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RegExpExpansionLimiter\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\",\n            \"int factor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"The constructor. This limiter stores old expansion factor and set ok_to_expand_ to true if factor is acceptable for graph.\"\n        },\n        {\n          \"name\": \"~RegExpExpansionLimiter\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"The destructor. It restore the saved expansion factor.\"\n        },\n        {\n          \"name\": \"ok_to_expand\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"The ok_to_expand status checker. if factor is acceptable for graph.\"\n        }\n      ]\n    }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"CompareInverseRanges\",\n      \"parameters\": [\n        \"ZoneList<CharacterRange>* ranges\",\n        \"const int* special_class\",\n        \"int length\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Compares a ZoneList of CharacterRange objects with a special character class represented as an array of integers. Used to check for inverse ranges, i.e., ranges representing the complement of a standard character set.\"\n    },\n    {\n      \"name\": \"CompareRanges\",\n      \"parameters\": [\n        \"ZoneList<CharacterRange>* ranges\",\n        \"const int* special_class\",\n        \"int length\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Compares a ZoneList of CharacterRange objects with a special character class represented as an array of integers. Used to check if the ranges represent a standard character set.\"\n    },\n    {\n      \"name\": \"ToCanonicalZoneList\",\n      \"parameters\": [\n        \"const UnicodeRangeSplitter::CharacterRangeVector* v\",\n        \"Zone* zone\"\n      ],\n      \"return_type\": \"ZoneList<CharacterRange>*\",\n      \"logic\": \"Translates between new and old V8-isms (SmallVector, ZoneList) and convert small vector to canonical zone list by canonicalizing.\"\n    },\n    {\n      \"name\": \"AddBmpCharacters\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"ChoiceNode* result\",\n        \"RegExpNode* on_success\",\n        \"UnicodeRangeSplitter* splitter\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Creates a TextNode for the BMP characters in the splitter and adds it as an alternative to the ChoiceNode.\"\n    },\n    {\n      \"name\": \"ToUC16Range\",\n      \"parameters\": [\n        \"base::uc16 from\",\n        \"base::uc16 to\"\n      ],\n      \"return_type\": \"UC16Range\",\n      \"logic\": \"Packs 2 UTF16 code points into an unit32_t.\"\n    },\n    {\n      \"name\": \"ExtractFrom\",\n      \"parameters\": [\n        \"UC16Range r\"\n      ],\n      \"return_type\": \"base::uc16\",\n      \"logic\": \"Extracts the first UTF16 code point (from) from a packed unit32_t.\"\n    },\n    {\n      \"name\": \"ExtractTo\",\n      \"parameters\": [\n        \"UC16Range r\"\n      ],\n      \"return_type\": \"base::uc16\",\n      \"logic\": \"Extracts the second UTF16 code point (to) from a packed unit32_t.\"\n    },\n    {\n      \"name\": \"AddNonBmpSurrogatePairs\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"ChoiceNode* result\",\n        \"RegExpNode* on_success\",\n        \"UnicodeRangeSplitter* splitter\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Creates TextNodes for surrogate pairs from non-BMP characters and adds them as alternatives to the ChoiceNode. Translates 32-bit code points to 16-bit surrogate pairs and creates text nodes.\"\n    },\n    {\n      \"name\": \"NegativeLookaroundAgainstReadDirectionAndMatch\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"ZoneList<CharacterRange>* lookbehind\",\n        \"ZoneList<CharacterRange>* match\",\n        \"RegExpNode* on_success\",\n        \"bool read_backward\"\n      ],\n      \"return_type\": \"RegExpNode*\",\n      \"logic\": \"Creates a negative lookaround assertion, where it asserts that reading backwards, there should be no lookbehind characters, and then match the characters in match. Handles the correct direction.\"\n    },\n    {\n      \"name\": \"MatchAndNegativeLookaroundInReadDirection\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"ZoneList<CharacterRange>* match\",\n        \"ZoneList<CharacterRange>* lookahead\",\n        \"RegExpNode* on_success\",\n        \"bool read_backward\"\n      ],\n      \"return_type\": \"RegExpNode*\",\n      \"logic\": \"Match given character, and then creates a negative lookaround to look ahead or behind. It asserts that reading forwards, there should be no lookahead characters. Handles the correct direction.\"\n    },\n    {\n      \"name\": \"AddLoneLeadSurrogates\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"ChoiceNode* result\",\n        \"RegExpNode* on_success\",\n        \"UnicodeRangeSplitter* splitter\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Creates TextNodes for lone lead surrogates, adds negative lookahead assertion, and adds them as alternatives to the ChoiceNode.\"\n    },\n    {\n      \"name\": \"AddLoneTrailSurrogates\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"ChoiceNode* result\",\n        \"RegExpNode* on_success\",\n        \"UnicodeRangeSplitter* splitter\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Creates TextNodes for lone trail surrogates, adds negative lookbehind assertion, and adds them as alternatives to the ChoiceNode.\"\n    },\n    {\n      \"name\": \"UnanchoredAdvance\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"RegExpNode* on_success\"\n      ],\n      \"return_type\": \"RegExpNode*\",\n      \"logic\": \"Implements ES2015 21.2.5.2.3, AdvanceStringIndex. It create TextNode with range 0 to max uft16 code unit.\"\n    },\n    {\n      \"name\": \"CharacterRange::AddUnicodeCaseEquivalents\",\n      \"parameters\": [\n        \"ZoneList<CharacterRange>* ranges\",\n        \"Zone* zone\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Uses ICU to compute the case fold closure over the ranges when V8_INTL_SUPPORT is enabled.\"\n    },\n    {\n      \"name\": \"BoundaryAssertionAsLookaround\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"RegExpNode* on_success\",\n        \"RegExpAssertion::Type type\"\n      ],\n      \"return_type\": \"RegExpNode*\",\n      \"logic\": \"Desugar \\\\b to (?<=\\\\w)(?=\\\\W)|(?<=\\\\W)(?=\\\\w) and \\\\B to (?<=\\\\w)(?=\\\\w)|(?<=\\\\W)(?=\\\\W)\"\n    },\n    {\n      \"name\": \"CompareFirstChar\",\n      \"parameters\": [\n        \"RegExpTree* const* a\",\n        \"RegExpTree* const* b\"\n      ],\n      \"return_type\": \"int\",\n      \"logic\": \"Compare the first character of two regular expression atoms. Returns -1 if a < b, 1 if a > b, and 0 if a == b. Used for sorting.\"\n    },\n    {\n      \"name\": \"CompareCaseInsensitive\",\n      \"parameters\": [\n        \"const icu::UnicodeString& a\",\n        \"const icu::UnicodeString& b\"\n      ],\n      \"return_type\": \"int\",\n      \"logic\": \"Compare two unicode strings for case insensitive check.\"\n    },\n    {\n      \"name\": \"CompareFirstCharCaseInsensitive\",\n      \"parameters\": [\n        \"RegExpTree* const* a\",\n        \"RegExpTree* const* b\"\n      ],\n      \"return_type\": \"int\",\n      \"logic\": \"Compare the first character of two regular expression atoms with case-insensitive comparison. Used for sorting case-insensitive regular expressions. (ICU version)\"\n    },\n    {\n      \"name\": \"Equals\",\n      \"parameters\": [\n        \"bool ignore_case\",\n        \"const icu::UnicodeString& a\",\n        \"const icu::UnicodeString& b\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Checks if two ICU unicode strings are equal. If ignore_case is true then it returns the case-insensitive check using CompareCaseInsensitive.\"\n    },\n    {\n      \"name\": \"CharAtEquals\",\n      \"parameters\": [\n        \"bool ignore_case\",\n        \"int index\",\n        \"const RegExpAtom* a\",\n        \"const RegExpAtom* b\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Checks if the characters at a specific index in two RegExpAtom are equal, handling case-insensitive comparisons.  Uses Equals to perform the case-insensitive check. (ICU version)\"\n    },\n    {\n      \"name\": \"Canonical\",\n      \"parameters\": [\n        \"unibrow::Mapping<unibrow::Ecma262Canonicalize>* canonicalize\",\n        \"unibrow::uchar c\"\n      ],\n      \"return_type\": \"unibrow::uchar\",\n      \"logic\": \"Canonicalizes a unicode character (non-ICU version). Returns the character itself if already in canonical form.\"\n    },\n    {\n      \"name\": \"CompareCaseInsensitive\",\n      \"parameters\": [\n        \"unibrow::Mapping<unibrow::Ecma262Canonicalize>* canonicalize\",\n        \"unibrow::uchar a\",\n        \"unibrow::uchar b\"\n      ],\n      \"return_type\": \"int\",\n      \"logic\": \"Compare two unicode chars case-insensitive (non-ICU version).\"\n    },\n    {\n      \"name\": \"CompareFirstCharCaseInsensitive\",\n      \"parameters\": [\n        \"unibrow::Mapping<unibrow::Ecma262Canonicalize>* canonicalize\",\n        \"RegExpTree* const* a\",\n        \"RegExpTree* const* b\"\n      ],\n      \"return_type\": \"int\",\n      \"logic\": \"Compare the first character of two regular expression atoms with case-insensitive comparison. Used for sorting case-insensitive regular expressions. (non-ICU version)\"\n    },\n    {\n      \"name\": \"Equals\",\n      \"parameters\": [\n        \"bool ignore_case\",\n        \"unibrow::Mapping<unibrow::Ecma262Canonicalize>* canonicalize\",\n        \"unibrow::uchar a\",\n        \"unibrow::uchar b\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Check if two Unicode chars are equals (case-sensitive or case-insensitive)  (non-ICU version).\"\n    },\n    {\n      \"name\": \"CharAtEquals\",\n      \"parameters\": [\n        \"bool ignore_case\",\n        \"unibrow::Mapping<unibrow::Ecma262Canonicalize>* canonicalize\",\n        \"int index\",\n        \"const RegExpAtom* a\",\n        \"const RegExpAtom* b\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Checks if the characters at a specific index in two RegExpAtom are equal, handling case-insensitive comparisons. Uses Equals to perform the case-insensitive check (non-ICU version).\"\n    },\n    {\n      \"name\": \"AddClass\",\n      \"parameters\": [\n        \"const int* elmv\",\n        \"int elmc\",\n        \"ZoneList<CharacterRange>* ranges\",\n        \"Zone* zone\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Adds character ranges from an integer array representation of a character class to a ZoneList of CharacterRange objects.\"\n    },\n    {\n      \"name\": \"AddClassNegated\",\n      \"parameters\": [\n        \"const int* elmv\",\n        \"int elmc\",\n        \"ZoneList<CharacterRange>* ranges\",\n        \"Zone* zone\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Adds the negated character ranges from an integer array representation of a character class to a ZoneList of CharacterRange objects.\"\n    },\n    {\n      \"name\": \"CharacterRange::AddClassEscape\",\n      \"parameters\": [\n        \"StandardCharacterSet standard_character_set\",\n        \"ZoneList<CharacterRange>* ranges\",\n        \"bool add_unicode_case_equivalents\",\n        \"Zone* zone\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Adds predefined character ranges associated with a standard character set"
}