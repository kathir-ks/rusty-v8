{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/wasm/wasm-module.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n    \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/wasm/wasm-module.h\",\n    \"imports\": [\n        \"<map>\",\n        \"<memory>\",\n        \"<optional>\",\n        \"src/base/platform/mutex.h\",\n        \"src/base/vector.h\",\n        \"src/codegen/signature.h\",\n        \"src/common/globals.h\",\n        \"src/handles/handles.h\",\n        \"src/trap-handler/trap-handler.h\",\n        \"src/wasm/branch-hint-map.h\",\n        \"src/wasm/constant-expression.h\",\n        \"src/wasm/struct-types.h\",\n        \"src/wasm/wasm-constants.h\",\n        \"src/wasm/wasm-init-expr.h\",\n        \"src/wasm/wasm-limits.h\",\n        \"src/wasm/well-known-imports.h\"\n    ],\n    \"classes\": [\n        {\n            \"name\": \"WireBytesRef\",\n            \"properties\": [\n                \"offset_\",\n                \"length_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"WireBytesRef\",\n                    \"parameters\": [],\n                    \"return_type\": \"WireBytesRef\",\n                    \"logic\": \"Default constructor initializing offset_ and length_ to 0.\"\n                },\n                {\n                    \"name\": \"WireBytesRef\",\n                    \"parameters\": [\n                        \"uint32_t offset\",\n                        \"uint32_t length\"\n                    ],\n                    \"return_type\": \"WireBytesRef\",\n                    \"logic\": \"Constructor initializing offset_ and length_ with given values and asserting some conditions.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the offset.\"\n                },\n                {\n                    \"name\": \"length\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the length.\"\n                },\n                {\n                    \"name\": \"end_offset\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the sum of offset and length.\"\n                },\n                {\n                    \"name\": \"is_empty\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the length is 0.\"\n                },\n                {\n                    \"name\": \"is_set\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the offset is not 0.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"AdaptiveMap\",\n            \"properties\": [\n                \"mode_\",\n                \"vector_\",\n                \"map_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"AdaptiveMap\",\n                    \"parameters\": [],\n                    \"return_type\": \"AdaptiveMap\",\n                    \"logic\": \"Constructor that initializes with a map.\"\n                },\n                {\n                    \"name\": \"FinishInitialization\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Transforms from kInitializing to either kDense or kSparse mode based on the map's size.\"\n                },\n                {\n                    \"name\": \"is_set\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the mode is not kInitializing.\"\n                },\n                {\n                    \"name\": \"Put\",\n                    \"parameters\": [\n                        \"uint32_t key\",\n                        \"const Value& value\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Inserts a key-value pair into the map during the initialization phase.\"\n                },\n                {\n                    \"name\": \"Put\",\n                    \"parameters\": [\n                        \"uint32_t key\",\n                        \"Value&& value\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Inserts a key-value pair into the map during the initialization phase (using move semantics).\"\n                },\n                {\n                    \"name\": \"Get\",\n                    \"parameters\": [\"uint32_t key\"],\n                    \"return_type\": \"const Value*\",\n                    \"logic\": \"Retrieves the value associated with the given key.\"\n                },\n                {\n                    \"name\": \"Has\",\n                    \"parameters\": [\"uint32_t key\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks whether the map contains the given key.\"\n                },\n                {\n                    \"name\": \"EstimateCurrentMemoryConsumption\",\n                    \"parameters\": [],\n                    \"return_type\": \"size_t\",\n                    \"logic\": \"Estimates the memory consumption of the AdaptiveMap.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"LazilyGeneratedNames\",\n            \"properties\": [\n                \"mutex_\",\n                \"has_functions_\",\n                \"function_names_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"LookupFunctionName\",\n                    \"parameters\": [\n                        \"ModuleWireBytes wire_bytes\",\n                        \"uint32_t function_index\"\n                    ],\n                    \"return_type\": \"WireBytesRef\",\n                    \"logic\": \"Looks up the function name for a given function index from the wire bytes.\"\n                },\n                {\n                    \"name\": \"AddForTesting\",\n                    \"parameters\": [\n                        \"int function_index\",\n                        \"WireBytesRef name\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Adds function names for testing purposes.\"\n                },\n                {\n                    \"name\": \"Has\",\n                    \"parameters\": [\"uint32_t function_index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if there is a name for given function_index.\"\n                },\n                {\n                    \"name\": \"EstimateCurrentMemoryConsumption\",\n                    \"parameters\": [],\n                    \"return_type\": \"size_t\",\n                    \"logic\": \"Estimates the memory consumption of the object.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"AsmJsOffsetInformation\",\n            \"properties\": [\n                \"mutex_\",\n                \"encoded_offsets_\",\n                \"decoded_offsets_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"AsmJsOffsetInformation\",\n                    \"parameters\": [\"base::Vector<const uint8_t> encoded_offsets\"],\n                    \"return_type\": \"AsmJsOffsetInformation\",\n                    \"logic\": \"Constructor that initializes with encoded offsets.\"\n                },\n                {\n                    \"name\": \"~AsmJsOffsetInformation\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Destructor to clean up the decoded offsets.\"\n                },\n                {\n                    \"name\": \"GetSourcePosition\",\n                    \"parameters\": [\n                        \"int func_index\",\n                        \"int byte_offset\",\n                        \"bool is_at_number_conversion\"\n                    ],\n                    \"return_type\": \"int\",\n                    \"logic\": \"Retrieves source position from function index and byte offset.\"\n                },\n                {\n                    \"name\": \"GetFunctionOffsets\",\n                    \"parameters\": [\"int func_index\"],\n                    \"return_type\": \"std::pair<int, int>\",\n                    \"logic\": \"Retrieves start and end offsets for the given function.\"\n                },\n                {\n                    \"name\": \"EnsureDecodedOffsets\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Decodes the offset information if it is not decoded already.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"CallSiteFeedback\",\n            \"properties\": [\n              \"index_or_count_\",\n              \"has_non_inlineable_targets_\",\n              \"is_megamorphic_\",\n              \"frequency_or_ool_\"\n            ],\n            \"methods\": [\n              {\n                \"name\": \"CreateMegamorphic\",\n                \"parameters\": [],\n                \"return_type\": \"CallSiteFeedback\",\n                \"logic\": \"Creates a megamorphic feedback.\"\n              },\n              {\n                \"name\": \"CallSiteFeedback\",\n                \"parameters\": [],\n                \"return_type\": \"CallSiteFeedback\",\n                \"logic\": \"Default constructor.\"\n              },\n              {\n                \"name\": \"CallSiteFeedback\",\n                \"parameters\": [\n                  \"int function_index\",\n                  \"int call_count\"\n                ],\n                \"return_type\": \"CallSiteFeedback\",\n                \"logic\": \"Constructor that initializes with a function index and a call count.\"\n              },\n              {\n                \"name\": \"CallSiteFeedback\",\n                \"parameters\": [\n                  \"PolymorphicCase* polymorphic_cases\",\n                  \"int num_cases\"\n                ],\n                \"return_type\": \"CallSiteFeedback\",\n                \"logic\": \"Constructor that initializes with polymorphic cases.\"\n              },\n              {\n                \"name\": \"~CallSiteFeedback\",\n                \"parameters\": [],\n                \"return_type\": \"void\",\n                \"logic\": \"Destructor that cleans up the polymorphic storage if necessary.\"\n              },\n              {\n                \"name\": \"num_cases\",\n                \"parameters\": [],\n                \"return_type\": \"int\",\n                \"logic\": \"Returns number of polymorphic cases.\"\n              },\n              {\n                \"name\": \"function_index\",\n                \"parameters\": [\"int i\"],\n                \"return_type\": \"int\",\n                \"logic\": \"Returns the function index of a specific polymorphic case.\"\n              },\n              {\n                \"name\": \"call_count\",\n                \"parameters\": [\"int i\"],\n                \"return_type\": \"int\",\n                \"logic\": \"Returns the call count of a specific polymorphic case.\"\n              },\n              {\n                \"name\": \"has_non_inlineable_targets\",\n                \"parameters\": [],\n                \"return_type\": \"bool\",\n                \"logic\": \"Checks if non-inlineable targets are present.\"\n              },\n              {\n                \"name\": \"set_has_non_inlineable_targets\",\n                \"parameters\": [\"bool has_non_inlineable_targets\"],\n                \"return_type\": \"void\",\n                \"logic\": \"Sets the presence of non-inlineable targets.\"\n              },\n              {\n                \"name\": \"is_megamorphic\",\n                \"parameters\": [],\n                \"return_type\": \"bool\",\n                \"logic\": \"Checks if feedback is megamorphic.\"\n              }\n            ]\n          },\n        {\n          \"name\": \"TypeFeedbackStorage\",\n          \"properties\": [\n            \"feedback_for_function\",\n            \"deopt_count_for_function\",\n            \"mutex\",\n            \"well_known_imports\"\n          ],\n          \"methods\": [],\n          \"logic\": \"Storage for type feedback data\"\n        },\n        {\n            \"name\": \"WasmModule\",\n            \"properties\": [\n                \"signature_zone\",\n                \"start_function_index\",\n                \"untagged_globals_buffer_size\",\n                \"tagged_globals_buffer_size\",\n                \"num_imported_globals\",\n                \"num_imported_mutable_globals\",\n                \"num_imported_functions\",\n                \"num_imported_tables\",\n                \"num_imported_tags\",\n                \"num_declared_functions\",\n                \"num_small_functions\",\n                \"num_exported_functions\",\n                \"num_declared_data_segments\",\n                \"code\",\n                \"name\",\n                \"name_section\",\n                \"canonical_typenames_decoded\",\n                \"is_wasm_gc\",\n                \"has_shared_part\",\n                \"types\",\n                \"isorecursive_canonical_type_ids\",\n                \"functions\",\n                \"globals\",\n                \"data_segments\",\n                \"tables\",\n                \"memories\",\n                \"import_table\",\n                \"export_table\",\n                \"tags\",\n                \"stringref_literals\",\n                \"elem_segments\",\n                \"compilation_hints\",\n                \"branch_hints\",\n                \"inst_traces\",\n                \"type_feedback\",\n                \"origin\",\n                \"lazily_generated_names\",\n                \"debug_symbols\",\n                \"build_id\",\n                \"asm_js_offset_information\",\n                \"validated_functions\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"WasmModule\",\n                    \"parameters\": [\"ModuleOrigin\"],\n                    \"return_type\": \"WasmModule\",\n                    \"logic\": \"Constructor for WasmModule.\"\n                },\n                {\n                    \"name\": \"AddTypeForTesting\",\n                    \"parameters\": [\"TypeDefinition type\"],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Adds a type for testing purposes.\"\n                },\n                {\n                    \"name\": \"AddSignatureForTesting\",\n                    \"parameters\": [\n                        \"const FunctionSig* sig\",\n                        \"ModuleTypeIndex supertype\",\n                        \"bool is_final\",\n                        \"bool is_shared\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Adds a signature for testing purposes.\"\n                },\n                {\n                    \"name\": \"AddStructTypeForTesting\",\n                    \"parameters\": [\n                      \"const StructType* type\",\n                      \"ModuleTypeIndex supertype\",\n                      \"bool is_final\",\n                      \"bool is_shared\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Adds a struct type for testing purposes.\"\n                  },\n                  {\n                    \"name\": \"AddArrayTypeForTesting\",\n                    \"parameters\": [\n                      \"const ArrayType* type\",\n                      \"ModuleTypeIndex supertype\",\n                      \"bool is_final\",\n                      \"bool is_shared\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Adds an array type for testing purposes.\"\n                  },\n                  {\n                    \"name\": \"AddContTypeForTesting\",\n                    \"parameters\": [\n                      \"const ContType* type\",\n                      \"ModuleTypeIndex supertype\",\n                      \"bool is_final\",\n                      \"bool is_shared\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Adds a cont type for testing purposes.\"\n                  },\n                {\n                    \"name\": \"has_type\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if a type exists at a specific index.\"\n                },\n                {\n                    \"name\": \"type\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"const TypeDefinition&\",\n                    \"logic\": \"Returns the TypeDefinition at a specific index.\"\n                },\n                {\n                    \"name\": \"heap_type\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"HeapType\",\n                    \"logic\": \"Returns the HeapType at a specific index.\"\n                },\n                {\n                    \"name\": \"canonical_type_id\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"CanonicalTypeIndex\",\n                    \"logic\": \"Returns the CanonicalTypeIndex at a specific index.\"\n                },\n                {\n                    \"name\": \"canonical_type\",\n                    \"parameters\": [\"ValueType type\"],\n                    \"return_type\": \"CanonicalValueType\",\n                    \"logic\": \"Returns the CanonicalValueType for a given ValueType.\"\n                },\n                {\n                    \"name\": \"has_signature\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if a signature exists at a specific index.\"\n                },\n                {\n                    \"name\": \"signature\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"const FunctionSig*\",\n                    \"logic\": \"Returns the FunctionSig at a specific index.\"\n                },\n                {\n                    \"name\": \"has_conttype\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if a continuation type exists at a specific index.\"\n                },\n                {\n                    \"name\": \"canonical_sig_id\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"CanonicalTypeIndex\",\n                    \"logic\": \"Returns the CanonicalTypeIndex for given signature.\"\n                },\n                {\n                    \"name\": \"signature_hash\",\n                    \"parameters\": [\n                        \"TypeCanonicalizer*\",\n                        \"uint32_t function_index\"\n                    ],\n                    \"return_type\": \"uint64_t\",\n                    \"logic\": \"Computes the hash of the signature.\"\n                },\n                {\n                    \"name\": \"has_struct\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if a struct exists at a specific index.\"\n                },\n                {\n                    \"name\": \"struct_type\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"const StructType*\",\n                    \"logic\": \"Returns the StructType at a specific index.\"\n                },\n                {\n                    \"name\": \"has_array\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if an array type exists at a specific index.\"\n                },\n                {\n                    \"name\": \"array_type\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"const ArrayType*\",\n                    \"logic\": \"Returns the ArrayType at a specific index.\"\n                },\n                {\n                    \"name\": \"supertype\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"ModuleTypeIndex\",\n                    \"logic\": \"Returns the ModuleTypeIndex of the supertype.\"\n                },\n                {\n                    \"name\": \"has_supertype\",\n                    \"parameters\": [\"ModuleTypeIndex index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if a type has a supertype.\"\n                },\n                {\n                    \"name\": \"MaxCanonicalTypeIndex\",\n                    \"parameters\": [],\n                    \"return_type\": \"CanonicalTypeIndex\",\n                    \"logic\": \"Linear search. Returns the maximum canonical type index.\"\n                },\n                {\n                    \"name\": \"function_is_shared\",\n                    \"parameters\": [\"int func_index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the function is shared.\"\n                },\n                {\n                    \"name\": \"function_was_validated\",\n                    \"parameters\": [\"int func_index\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the function was validated.\"\n                },\n                {\n                    \"name\": \"set_function_validated\",\n                    \"parameters\": [\"int func_index\"],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets the function as validated.\"\n                },\n                {\n                    \"name\": \"set_all_functions_validated\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets all functions as validated.\"\n                },\n                {\n                  \"name\": \"declared_functions\",\n                  \"parameters\": [],\n                  \"return_type\": \"base::Vector<const WasmFunction>\",\n                  \"logic\": \"Gets the list of declared functions, excluding imports.\"\n                },\n                {\n#if V8_ENABLE_DRUMBRAKE\n                    \"name\": \"SetWasmInterpreter\",\n                    \"parameters\": [\"std::shared_ptr<WasmInterpreterRuntime> interpreter\"],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Set interpreter\"\n#endif\n                },\n                {\n                    \"name\": \"EstimateStoredSize\",\n                    \"parameters\": [],\n                    \"return_type\": \"size_t\",\n                    \"logic\": \"Estimates the size when storing the module.\"\n                },\n                {\n                    \"name\": \"EstimateCurrentMemoryConsumption\",\n                    \"parameters\": [],\n                    \"return_type\": \"size_t\",\n                    \"logic\": \"Estimates the current memory usage.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"ModuleWireBytes\",\n            \"properties\": [\n                \"module_bytes_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"ModuleWireBytes\",\n                    \"parameters\": [\"base::Vector<const uint8_t> module_bytes\"],\n                    \"return_type\": \"ModuleWireBytes\",\n                    \"logic\": \"Constructor for ModuleWireBytes from a vector of bytes.\"\n                },\n                {\n                    \"name\": \"ModuleWireBytes\",\n                    \"parameters\": [\"const uint8_t* start\", \"const uint8_t* end\"],\n                    \"return_type\": \"ModuleWireBytes\",\n                    \"logic\": \"Constructor from raw byte array (start, end).\"\n                },\n                {\n                    \"name\": \"GetNameOrNull\",\n                    \"parameters\": [\"WireBytesRef ref\"],\n                    \"return_type\": \"WasmName\",\n                    \"logic\": \"Gets the name from the wire bytes or returns null if it doesn't exist.\"\n                },\n                {\n                    \"name\": \"GetNameOrNull\",\n                    \"parameters\": [\n                      \"int func_index\",\n                      \"const WasmModule* module\"\n                    ],\n                    \"return_type\": \"WasmName\",\n                    \"logic\": \"Gets the name from the wire bytes for given function index.\"\n                },\n                {\n                    \"name\": \"BoundsCheck\",\n                    \"parameters\": [\"WireBytesRef ref\"],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the reference is within the module's boundaries.\"\n                },\n                {\n                    \"name\": \"GetFunctionBytes\",\n                    \"parameters\": [\"const WasmFunction* function\"],\n                    \"return_type\": \"base::Vector<const uint8_t>\",\n                    \"logic\": \"Gets the bytes for the specified function.\"\n                },\n                {\n                    \"name\": \"module_bytes\",\n                    \"parameters\": [],\n                    \"return_type\": \"base::Vector<const uint8_t>\",\n                    \"logic\": \"Returns the module bytes.\"\n                },\n                {\n                    \"name\": \"start\",\n                    \"parameters\": [],\n                    \"return_type\": \"const uint8_t*\",\n                    \"logic\": \"Returns a pointer to the start of the module bytes.\"\n                },\n                {\n                    \"name\": \"end\",\n                    \"parameters\": [],\n                    \"return_type\": \"const uint8_t*\",\n                    \"logic\": \"Returns a pointer to the end of the module bytes.\"\n                },\n                {\n                    \"name\": \"length\",\n                    \"parameters\": [],\n                    \"return_type\": \"size_t\",\n                    \"logic\": \"Returns the length of the module bytes.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"WasmFunctionName\",\n            \"properties\": [\n                \"func_index_\",\n                \"name_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"WasmFunctionName\",\n                    \"parameters\": [\n                        \"int func_index\",\n                        \"WasmName name\"\n                    ],\n                    \"return_type\": \"WasmFunctionName\",\n                    \"logic\": \"Constructor for WasmFunctionName.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"TruncatedUserString\",\n            \"properties\": [\n                \"start_\",\n                \"length_\",\n                \"buffer_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"TruncatedUserString\",\n                    \"parameters\": [\"base::Vector<T> name\"],\n                    \"return_type\": \"TruncatedUserString\",\n                    \"logic\": \"Constructor for TruncatedUserString.\"\n                },\n                {\n                    \"name\": \"TruncatedUserString\",\n                    \"parameters\": [\"const uint8_t* start\", \"size_t len\"],\n                    \"return_type\": \"TruncatedUserString\",\n                    \"logic\": \"Constructor for TruncatedUserString from const uint8_t pointer and length.\"\n                },\n                {\n                    \"name\": \"TruncatedUserString\",\n                    \"parameters\": [\"const char* start\", \"size_t len\"],\n                    \"return_type\": \"TruncatedUserString\",\n                    \"logic\": \"Constructor for TruncatedUserString from const char pointer and length.\"\n                },\n                {\n                    \"name\": \"start\",\n                    \"parameters\": [],\n                    \"return_type\": \"const char*\",\n                    \"logic\": \"Returns a pointer to the start of the truncated string.\"\n                },\n                {\n                    \"name\": \"length\",\n                    \"parameters\": [],\n                    \"return_type\": \"int\",\n                    \"logic\": \"Returns the length of the truncated string.\"\n                }\n            ]\n        }\n    ],\n    \"functions\": [\n        {\n            \"name\": \"AddressTypeToStr\",\n            \"parameters\": [\"AddressType address_type\"],\n            \"return_type\": \"const char*\",\n            \"logic\": \"Returns string representation of AddressType enum.\"\n        },\n        {\n            \"name\": \"operator<<\",\n            \"parameters\": [\n                \"std::ostream& os\",\n                \"AddressType address_type\"\n            ],\n            \"return_type\": \"std::ostream&\",\n            \"logic\": \"Overloads the << operator for AddressType enum to allow printing it.\"\n        },\n        {\n            \"name\": \"UpdateComputedInformation\",\n            \"parameters\": [\n                \"WasmMemory* memory\",\n                \"ModuleOrigin origin\"\n            ],\n            \"return_type\": \"void\",\n            \"logic\": \"Updates computed information of wasm memory like min and max memory size, bounds checks etc.\"\n        },\n        {\n            \"name\": \"SELECT_WASM_COUNTER\",\n            \"parameters\": [],\n            \"return_type\": \"N/A\",\n            \"logic\": \"Macro used to select a wasm counter based on origin.\"\n        },\n        {\n            \"name\": \"is_asmjs_module\",\n            \"parameters\": [\"const WasmModule* module\"],\n            \"return_type\": \"bool\",\n            \"logic\": \"Checks if a WasmModule is from asm.js origin.\"\n        },\n        {\n            \"name\": \"GetWasmFunctionOffset\",\n            \"parameters\": [\n                \"const WasmModule* module\",\n                \"uint32_t func_index\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Retrieves byte offset of the wasm function.\"\n        },\n        {\n            \"name\": \"GetContainingWasmFunction\",\n            \"parameters\": [\n                \"const WasmModule* module\",\n                \"uint32_t byte_offset\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Returns function containing the given byte offset.\"\n        },\n        {\n            \"name\": \"GetNearestWasmFunction\",\n            \"parameters\": [\n                \"const WasmModule* module\",\n                \"uint32_t byte_offset\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Returns nearest function containing the given byte offset. Returns the previous function if the byte_offset is not contained within any function.\"\n        },\n        {\n            \"name\": \"GetSubtypingDepth\",\n            \"parameters\": [\n                \"const WasmModule* module\",\n                \"ModuleTypeIndex type_index\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Gets the explicit subtyping depth for the given type.\"\n        },\n        {\n            \"name\": \"GetNameOrNull\",\n            \"parameters\": [\n              \"WireBytesRef ref\"\n            ],\n            \"return_type\": \"WasmName\",\n            \"logic\": \"Get a string stored in the module bytes representing a name\"\n        },\n        {\n            \"name\": \"operator<<\",\n            \"parameters\": [\n                \"std::ostream& os\",\n                \"const WasmFunctionName& name\"\n            ],\n            \"return_type\": \"std::ostream&\",\n            \"logic\": \"Overloads the << operator to allow printing WasmFunctionName struct.\"\n        },\n        {\n            \"name\": \"IsWasmCodegenAllowed\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"DirectHandle<NativeContext> context\"\n            ],\n            \"return_type\": \"bool\",\n            \"logic\": \"Checks if wasm codegen is allowed for the provided isolate and context.\"\n        },\n        {\n            \"name\": \"ErrorStringForCodegen\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"DirectHandle<Context> context\"\n            ],\n            \"return_type\": \"DirectHandle<String>\",\n            \"logic\": \"Returns an error string if codegen is not allowed.\"\n        },\n        {\n            \"name\": \"GetTypeForFunction\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"const FunctionSig* sig\",\n                \"bool for_exception\"\n            ],\n            \"return_type\": \"DirectHandle<JSObject>\",\n            \"logic\": \"Gets the JS type (JSObject) for a function signature.\"\n        },\n        {\n            \"name\": \"GetTypeForGlobal\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"bool is_mutable\",\n                \"ValueType type\"\n            ],\n            \"return_type\": \"DirectHandle<JSObject>\",\n            \"logic\": \"Gets the JS type (JSObject) for a global variable.\"\n        },\n        {\n            \"name\": \"GetTypeForMemory\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"uint32_t min_size\",\n                \"std::optional<uint64_t> max_size\",\n                \"bool shared\",\n                \"AddressType address_type\"\n            ],\n            \"return_type\": \"DirectHandle<JSObject>\",\n            \"logic\": \"Gets the JS type (JSObject) for a memory.\"\n        },\n        {\n            \"name\": \"GetTypeForTable\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"ValueType type\",\n                \"uint32_t min_size\",\n                \"std::optional<uint64_t> max_size\",\n                \"AddressType address_type\"\n            ],\n            \"return_type\": \"DirectHandle<JSObject>\",\n            \"logic\": \"Gets the JS type (JSObject) for a table.\"\n        },\n        {\n            \"name\": \"GetImports\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"DirectHandle<WasmModuleObject> module\"\n            ],\n            \"return_type\": \"DirectHandle<JSArray>\",\n            \"logic\": \"Gets the imports for a wasm module.\"\n        },\n        {\n            \"name\": \"GetExports\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"DirectHandle<WasmModuleObject> module\"\n            ],\n            \"return_type\": \"DirectHandle<JSArray>\",\n            \"logic\": \"Gets the exports for a wasm module.\"\n        },\n        {\n            \"name\": \"GetCustomSections\",\n            \"parameters\": [\n                \"Isolate* isolate\",\n                \"DirectHandle<WasmModuleObject> module\",\n                \"DirectHandle<String> name\",\n                \"ErrorThrower* thrower\"\n            ],\n            \"return_type\": \"DirectHandle<JSArray>\",\n            \"logic\": \"Gets custom sections from a WASM module\"\n        },\n        {\n            \"name\": \"GetSourcePosition\",\n            \"parameters\": [\n                \"const WasmModule*\",\n                \"uint32_t func_index\",\n                \"uint32_t byte_offset\",\n                \"bool is_at_number_conversion\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Get the source position from a given function index and byte offset, for either asm.js or pure Wasm modules.\"\n        },\n        {\n            \"name\": \"declared_function_index\",\n            \"parameters\": [\n                \"const WasmModule* module\",\n                \"int func_index\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Translate function index to the index relative to the first declared function.\"\n        },\n        {\n            \"name\": \"JumpTableOffset\",\n            \"parameters\": [\n                \"const WasmModule* module\",\n                \"int func_index\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Translate from function index to jump table offset.\"\n        },\n        {\n            \"name\": \"PrintSignature\",\n            \"parameters\": [\n                \"base::Vector<char> buffer\",\n                \"const CanonicalSig* sig\",\n                \"char delimiter\"\n            ],\n            \"return_type\": \"size_t\",\n            \"logic\": \"Print the signature into the given {buffer}, using {delimiter} as separator between parameter types and return types.\"\n        },\n        {\n            \"name\": \"GetWireBytesHash\",\n            \"parameters\": [\n                \"base::Vector<const uint8_t> wire_bytes\"\n            ],\n            \"return_type\": \"size_t\",\n            \"logic\": \"Calculates the hash of wire bytes.\"\n        },\n        {\n            \"name\": \"NumFeedbackSlots\",\n            \"parameters\": [\n              \"const WasmModule* module\",\n              \"int func_index\"\n            ],\n            \"return_type\": \"int\",\n            \"logic\": \"Get the required number of feedback slots for a function.\"\n          }\n    ]\n}\n```"
}