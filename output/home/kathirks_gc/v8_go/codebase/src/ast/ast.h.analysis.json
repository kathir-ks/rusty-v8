{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/ast/ast.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/ast/ast.h\",\n  \"imports\": [\n    \"<memory>\",\n    \"src/ast/ast-value-factory.h\",\n    \"src/ast/modules.h\",\n    \"src/ast/variables.h\",\n    \"src/base/pointer-with-payload.h\",\n    \"src/base/threaded-list.h\",\n    \"src/codegen/bailout-reason.h\",\n    \"src/codegen/handler-table.h\",\n    \"src/codegen/label.h\",\n    \"src/common/globals.h\",\n    \"src/heap/factory.h\",\n    \"src/objects/elements-kind.h\",\n    \"src/objects/function-syntax-kind.h\",\n    \"src/objects/literal-objects.h\",\n    \"src/objects/shared-function-info.h\",\n    \"src/objects/smi.h\",\n    \"src/parsing/token.h\",\n    \"src/runtime/runtime.h\",\n    \"src/zone/zone-list.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"AstNode\",\n      \"properties\": [\n        \"position_\",\n        \"bit_field_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"node_type\",\n          \"parameters\": [],\n          \"return_type\": \"NodeType\",\n          \"logic\": \"Returns the node type of the AST node.\"\n        },\n        {\n          \"name\": \"position\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the source code position of the AST node.\"\n        },\n        {\n          \"name\": \"Print\",\n          \"parameters\": [\n            \"Isolate* isolate\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints the AST node for debugging purposes (DEBUG mode only).\"\n        },\n        {\n          \"name\": \"Is##type\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Type check for specific AstNode subclass\"\n        },\n        {\n          \"name\": \"As##type\",\n          \"parameters\": [],\n          \"return_type\": \"type*\",\n          \"logic\": \"Casts to specific AstNode subclass, returns nullptr if it's not that type\"\n        },\n        {\n          \"name\": \"AsIterationStatement\",\n          \"parameters\": [],\n          \"return_type\": \"IterationStatement*\",\n          \"logic\": \"Casts to IterationStatement, returns nullptr if not that type.\"\n        },\n        {\n          \"name\": \"AsMaterializedLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"MaterializedLiteral*\",\n          \"logic\": \"Casts to MaterializedLiteral, returns nullptr if not that type.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Statement\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"Expression\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"IsValidReferenceExpression\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a valid reference expression (e.g., can be assigned to).\"\n        },\n        {\n          \"name\": \"IsPrivateName\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a private name.\"\n        },\n        {\n          \"name\": \"ToBooleanIsTrue\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Helpers for ToBoolean conversion, returning true if the expression is statically known to be truthy.\"\n        },\n        {\n          \"name\": \"ToBooleanIsFalse\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Helpers for ToBoolean conversion, returning true if the expression is statically known to be falsy.\"\n        },\n        {\n          \"name\": \"IsPropertyName\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a property name (cannot be parsed as array index).\"\n        },\n        {\n          \"name\": \"IsAnonymousFunctionDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is an anonymous function expression.\"\n        },\n        {\n          \"name\": \"IsConciseMethodDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a concise method definition.\"\n        },\n        {\n          \"name\": \"IsAccessorFunctionDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is an accessor function definition.\"\n        },\n        {\n          \"name\": \"IsSmiLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a literal represented as a smi.\"\n        },\n        {\n          \"name\": \"IsNumberLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a literal represented as a number.\"\n        },\n        {\n          \"name\": \"IsStringLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a string literal.\"\n        },\n        {\n          \"name\": \"IsConsStringLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a cons string literal.\"\n        },\n        {\n          \"name\": \"IsNullLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is the null literal.\"\n        },\n        {\n          \"name\": \"IsBooleanLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a boolean literal.\"\n        },\n        {\n          \"name\": \"IsTheHoleLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is the hole literal.\"\n        },\n        {\n          \"name\": \"IsUndefinedLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is the undefined literal.\"\n        },\n        {\n          \"name\": \"IsNullOrUndefinedLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is either null or undefined literal.\"\n        },\n        {\n          \"name\": \"IsLiteralButNotNullOrUndefined\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a literal and not null or undefined.\"\n        },\n        {\n          \"name\": \"IsCompileTimeValue\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is a compile time value.\"\n        },\n        {\n          \"name\": \"IsPattern\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the expression is an object or array literal, i.e., used as a pattern.\"\n        },\n        {\n          \"name\": \"is_parenthesized\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Indicates if the expression is parenthesized.\"\n        },\n        {\n          \"name\": \"mark_parenthesized\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks the expression as parenthesized.\"\n        },\n        {\n          \"name\": \"clear_parenthesized\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Clears the parenthesized flag.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"FailureExpression\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"BreakableStatement\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"Block\",\n      \"properties\": [\n        \"statements_\",\n        \"scope_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"statements\",\n          \"parameters\": [],\n          \"return_type\": \"ZonePtrList<Statement>*\",\n          \"logic\": \"Returns the list of statements in the block.\"\n        },\n        {\n          \"name\": \"ignore_completion_value\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether the block's completion value should be ignored.\"\n        },\n        {\n          \"name\": \"is_breakable\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether the block is breakable.\"\n        },\n        {\n          \"name\": \"is_initialization_block_for_parameters\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Return whether this block is an initialization block for parameters\"\n        },\n        {\n          \"name\": \"scope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the scope associated with the block.\"\n        },\n        {\n          \"name\": \"set_scope\",\n          \"parameters\": [\n            \"Scope* scope\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the scope associated with the block.\"\n        },\n        {\n          \"name\": \"InitializeStatements\",\n          \"parameters\": [\n            \"const ScopedPtrList<Statement>& statements\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes the statements in the block from a ScopedPtrList.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Declaration\",\n      \"properties\": [\n        \"var_\",\n        \"next_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"var\",\n          \"parameters\": [],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Returns the Variable associated with the declaration.\"\n        },\n        {\n          \"name\": \"set_var\",\n          \"parameters\": [\n            \"Variable* var\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the Variable associated with the declaration.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"VariableDeclaration\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"AsNested\",\n          \"parameters\": [],\n          \"return_type\": \"NestedVariableDeclaration*\",\n          \"logic\": \"Returns NestedVariableDeclaration if this is nested, otherwise nullptr.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"NestedVariableDeclaration\",\n      \"properties\": [\n        \"scope_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"scope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the scope in which the nested variable is declared.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"FunctionDeclaration\",\n      \"properties\": [\n        \"fun_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"fun\",\n          \"parameters\": [],\n          \"return_type\": \"FunctionLiteral*\",\n          \"logic\": \"Returns the FunctionLiteral associated with the declaration.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"IterationStatement\",\n      \"properties\": [\n        \"body_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"body\",\n          \"parameters\": [],\n          \"return_type\": \"Statement*\",\n          \"logic\": \"Returns the body statement of the iteration.\"\n        },\n        {\n          \"name\": \"set_body\",\n          \"parameters\": [\n            \"Statement* s\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the body statement of the iteration.\"\n        },\n        {\n          \"name\": \"Initialize\",\n          \"parameters\": [\n            \"Statement* body\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes the body statement of the iteration.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DoWhileStatement\",\n      \"properties\": [\n        \"cond_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Initialize\",\n          \"parameters\": [\n            \"Expression* cond\",\n            \"Statement* body\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes the condition and body of the do-while statement.\"\n        },\n        {\n          \"name\": \"cond\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the condition expression of the do-while statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"WhileStatement\",\n      \"properties\": [\n        \"cond_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Initialize\",\n          \"parameters\": [\n            \"Expression* cond\",\n            \"Statement* body\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes the condition and body of the while statement.\"\n        },\n        {\n          \"name\": \"cond\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the condition expression of the while statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ForStatement\",\n      \"properties\": [\n        \"init_\",\n        \"cond_\",\n        \"next_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Initialize\",\n          \"parameters\": [\n            \"Statement* init\",\n            \"Expression* cond\",\n            \"Statement* next\",\n            \"Statement* body\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes the init, condition, next, and body of the for statement.\"\n        },\n        {\n          \"name\": \"init\",\n          \"parameters\": [],\n          \"return_type\": \"Statement*\",\n          \"logic\": \"Returns the initialization statement of the for statement.\"\n        },\n        {\n          \"name\": \"cond\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the condition expression of the for statement.\"\n        },\n        {\n          \"name\": \"next\",\n          \"parameters\": [],\n          \"return_type\": \"Statement*\",\n          \"logic\": \"Returns the next statement of the for statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ForEachStatement\",\n      \"properties\": [\n        \"each_\",\n        \"subject_\",\n        \"subject_scope_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"VisitModeString\",\n          \"parameters\": [\n            \"VisitMode mode\"\n          ],\n          \"return_type\": \"const char*\",\n          \"logic\": \"Returns a string representation of the VisitMode.\"\n        },\n        {\n          \"name\": \"Initialize\",\n          \"parameters\": [\n            \"Expression* each\",\n            \"Expression* subject\",\n            \"Statement* body\",\n            \"Scope* subject_scope\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Initializes the each, subject, body, and scope of the for-in or for-of statement.\"\n        },\n        {\n          \"name\": \"each\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the 'each' expression of the for-in or for-of statement.\"\n        },\n        {\n          \"name\": \"subject\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the 'subject' expression of the for-in or for-of statement.\"\n        },\n        {\n          \"name\": \"subject_scope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the subject scope of the for-in or for-of statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ForInStatement\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"ForOfStatement\",\n      \"properties\": [\n        \"type_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"type\",\n          \"parameters\": [],\n          \"return_type\": \"IteratorType\",\n          \"logic\": \"Returns the iterator type (normal or async) of the for-of statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ExpressionStatement\",\n      \"properties\": [\n        \"expression_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"set_expression\",\n          \"parameters\": [\n            \"Expression* e\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the expression of the expression statement.\"\n        },\n        {\n          \"name\": \"expression\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the expression of the expression statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"JumpStatement\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"ContinueStatement\",\n      \"properties\": [\n        \"target_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"target\",\n          \"parameters\": [],\n          \"return_type\": \"IterationStatement*\",\n          \"logic\": \"Returns the target iteration statement of the continue statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BreakStatement\",\n      \"properties\": [\n        \"target_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"target\",\n          \"parameters\": [],\n          \"return_type\": \"BreakableStatement*\",\n          \"logic\": \"Returns the target breakable statement of the break statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ReturnStatement\",\n      \"properties\": [\n        \"expression_\",\n        \"end_position_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"expression\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the expression being returned.\"\n        },\n        {\n          \"name\": \"type\",\n          \"parameters\": [],\n          \"return_type\": \"Type\",\n          \"logic\": \"Return the type of return.\"\n        },\n        {\n          \"name\": \"is_async_return\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if it's a regular or async return.\"\n        },\n         {\n          \"name\": \"is_synthetic_async_return\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if it's a synthetic async return.\"\n        },\n        {\n          \"name\": \"end_position\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the end position of the return statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"WithStatement\",\n      \"properties\": [\n        \"scope_\",\n        \"expression_\",\n        \"statement_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"scope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the scope of the with statement.\"\n        },\n        {\n          \"name\": \"expression\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the expression of the with statement.\"\n        },\n        {\n          \"name\": \"statement\",\n          \"parameters\": [],\n          \"return_type\": \"Statement*\",\n          \"logic\": \"Returns the statement of the with statement.\"\n        },\n        {\n          \"name\": \"set_statement\",\n          \"parameters\": [\n            \"Statement* s\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the statement of the with statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CaseClause\",\n      \"properties\": [\n        \"label_\",\n        \"statements_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"is_default\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the case clause is the default clause.\"\n        },\n        {\n          \"name\": \"label\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the label expression of the case clause.\"\n        },\n        {\n          \"name\": \"statements\",\n          \"parameters\": [],\n          \"return_type\": \"ZonePtrList<Statement>*\",\n          \"logic\": \"Returns the list of statements in the case clause.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"SwitchStatement\",\n      \"properties\": [\n        \"tag_\",\n        \"cases_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"tag\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the tag expression of the switch statement.\"\n        },\n        {\n          \"name\": \"set_tag\",\n          \"parameters\": [\n            \"Expression* t\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the tag expression of the switch statement.\"\n        },\n        {\n          \"name\": \"cases\",\n          \"parameters\": [],\n          \"return_type\": \"ZonePtrList<CaseClause>*\",\n          \"logic\": \"Returns the list of case clauses in the switch statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"IfStatement\",\n      \"properties\": [\n        \"condition_\",\n        \"then_statement_\",\n        \"else_statement_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"HasThenStatement\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the if statement has a non-empty then statement.\"\n        },\n        {\n          \"name\": \"HasElseStatement\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the if statement has a non-empty else statement.\"\n        },\n        {\n          \"name\": \"condition\",\n          \"parameters\": [],\n          \"return_type\": \"Expression*\",\n          \"logic\": \"Returns the condition expression of the if statement.\"\n        },\n        {\n          \"name\": \"then_statement\",\n          \"parameters\": [],\n          \"return_type\": \"Statement*\",\n          \"logic\": \"Returns the then statement of the if statement.\"\n        },\n        {\n          \"name\": \"else_statement\",\n          \"parameters\": [],\n          \"return_type\": \"Statement*\",\n          \"logic\": \"Returns the else statement of the if statement.\"\n        },\n        {\n          \"name\": \"set_then_statement\",\n          \"parameters\": [\n            \"Statement* s\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the then statement of the if statement.\"\n        },\n        {\n          \"name\": \"set_else_statement\",\n          \"parameters\": [\n            \"Statement* s\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the else statement of the if statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"TryStatement\",\n      \"properties\": [\n        \"try_block_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"try_block\",\n          \"parameters\": [],\n          \"return_type\": \"Block*\",\n          \"logic\": \"Returns the try block of the try statement.\"\n        },\n        {\n          \"name\": \"set_try_block\",\n          \"parameters\": [\n            \"Block* b\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the try block of the try statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"TryCatchStatement\",\n      \"properties\": [\n        \"scope_\",\n        \"catch_block_\",\n        \"catch_prediction_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"scope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the scope of the catch block.\"\n        },\n        {\n          \"name\": \"catch_block\",\n          \"parameters\": [],\n          \"return_type\": \"Block*\",\n          \"logic\": \"Returns the catch block of the try-catch statement.\"\n        },\n        {\n          \"name\": \"set_catch_block\",\n          \"parameters\": [\n            \"Block* b\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the catch block of the try-catch statement.\"\n        },\n        {\n          \"name\": \"GetCatchPrediction\",\n          \"parameters\": [\n            \"HandlerTable::CatchPrediction outer_catch_prediction\"\n          ],\n          \"return_type\": \"HandlerTable::CatchPrediction\",\n          \"logic\": \"Returns the predicted catch behavior of this try block.\"\n        },\n        {\n          \"name\": \"ShouldClearException\",\n          \"parameters\": [\n            \"HandlerTable::CatchPrediction outer_catch_prediction\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Indicates whether the pending exception should be cleared before executing the catch block.\"\n        },\n        {\n          \"name\": \"is_try_catch_for_async\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Indicates whether the try/catch statement is for async function\"\n        }\n      ]\n    },\n    {\n      \"name\": \"TryFinallyStatement\",\n      \"properties\": [\n        \"finally_block_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"finally_block\",\n          \"parameters\": [],\n          \"return_type\": \"Block*\",\n          \"logic\": \"Returns the finally block of the try-finally statement.\"\n        },\n        {\n          \"name\": \"set_finally_block\",\n          \"parameters\": [\n            \"Block* b\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the finally block of the try-finally statement.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DebuggerStatement\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"EmptyStatement\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"SloppyBlockFunctionStatement\",\n      \"properties\": [\n        \"var_\",\n        \"statement_\",\n        \"next_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"statement\",\n          \"parameters\": [],\n          \"return_type\": \"Statement*\",\n          \"logic\": \"Returns the statement this delegates to.\"\n        },\n        {\n          \"name\": \"set_statement\",\n          \"parameters\": [\n            \"Statement* statement\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the statement.\"\n        },\n        {\n          \"name\": \"scope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the scope.\"\n        },\n        {\n          \"name\": \"var\",\n          \"parameters\": [],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Returns the variable associated with the function.\"\n        },\n        {\n          \"name\": \"init\",\n          \"parameters\": [],\n          \"return_type\": \"Token::Value\",\n          \"logic\": \"Returns the token value used for initialization.\"\n        },\n        {\n          \"name\": \"name\",\n          \"parameters\": [],\n          \"return_type\": \"const AstRawString*\",\n          \"logic\": \"Returns the name.\"\n        },\n        {\n          \"name\": \"next\",\n          \"parameters\": [],\n          \"return_type\": \"SloppyBlockFunctionStatement**\",\n          \"logic\": \"Returns the next statement in the chain.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Literal\",\n      \"properties\": [\n        \"string_\",\n        \"cons_string_\",\n        \"smi_\",\n        \"number_\",\n        \"bigint_\",\n        \"boolean_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"type\",\n          \"parameters\": [],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of the literal.\"\n        },\n        {\n          \"name\": \"IsPropertyName\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if literal represents a property name\"\n        },\n        {\n          \"name\": \"AsArrayIndex\",\n          \"parameters\": [\n            \"uint32_t* index\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if literal represents an array index\"\n        },\n        {\n          \"name\": \"AsRawPropertyName\",\n          \"parameters\": [],\n          \"return_type\": \"const AstRawString*\",\n          \"logic\": \"Returns literal's string value.\"\n        },\n        {\n          \"name\": \"AsSmiLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"Tagged<Smi>\",\n          \"logic\": \"Returns literal's smi value.\"\n        },\n        {\n          \"name\": \"AsBooleanLiteral\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns literal's boolean value.\"\n        },\n        {\n          \"name\": \"IsNumber\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the literal is a number.\"\n        },\n        {\n          \"name\": \"AsNumber\",\n          \"parameters\": [],\n          \"return_type\": \"double\",\n          \"logic\": \"Returns literal's number value.\"\n        },\n        {\n          \"name\": \"AsBigInt\",\n          \"parameters\": [],\n          \"return_type\": \"AstBigInt\",\n          \"logic\": \"Returns literal's bigint value.\"\n        },\n        {\n          \"name\": \"IsRawString\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the literal is a raw string.\"\n        },\n        {\n          \"name\": \"AsRawString\",\n          \"parameters\": [],\n          \"return_type\": \"const AstRawString*\",\n          \"logic\": \"Returns literal's raw string value.\"\n        },\n        {\n          \"name\": \"IsConsString\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the literal is a cons string.\"\n        },\n        {\n          \"name\": \"AsConsString\",\n          \"parameters\": [],\n          \"return_type\": \"AstConsString*\",\n          \"logic\": \"Returns literal's cons string value.\"\n        },\n        {\n          \"name\": \"ToBooleanIsTrue\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether the literal is true in a boolean context\"\n        },\n        {\n          \"name\": \"ToBooleanIsFalse\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether the literal is false in a boolean context\"\n        },\n        {\n          \"name\": \"ToUint32\",\n          \"parameters\": [\n            \"uint32_t* value\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Converts the literal to a uint32_t value, if possible.\"\n        },\n        {\n          \"name\": \"BuildValue\",\n          \"parameters\": [\n            \"IsolateT* isolate\"\n          ],\n          \"return_type\": \"DirectHandle<Object>\",\n          \"logic\": \"Builds an Object representing this literal\"\n        },\n        {\n          \"name\": \"Hash\",\n          \"parameters\": [],\n          \"return_type\": \"uint32_t\",\n          \"logic\": \"Support for using Literal as a HashMap key\"\n        },\n        {\n          \"name\": \"Match\",\n          \"parameters\": [\n            \"void* literal1\",\n            \"void* literal2\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Support for using Literal as a HashMap key\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MaterializedLiteral\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"IsSimple\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the materialized literal is simple (consisting of constants and simple object/array literals).\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpLiteral\",\n      \"properties\": [\n        \"flags_\",\n        \"pattern_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"pattern\",\n          \"parameters\": [],\n          \"return_type\": \"DirectHandle<String>\",\n          \"logic\": \"Returns the pattern string of the RegExp literal.\"\n        },\n        {\n          \"name\": \"raw_pattern\",\n          \"parameters\": [],\n          \"return_type\": \"const AstRawString*\",\n          \"logic\": \"Returns the raw pattern string of the RegExp literal.\"\n        },\n        {\n          \"name\": \"flags\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the flags of the RegExp literal.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AggregateLiteral\",\n      \"properties\": [],\n      \"methods\": []\n    },\n    {\n      \"name\": \"LiteralBoilerplateBuilder\",\n      \"properties\": [\n        \"bit_field_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"is_initialized\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if the literal builder is initialized.\"\n        },\n        {\n          \"name\":"
}