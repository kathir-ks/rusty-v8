{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/execution/arm/simulator-arm.cc",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/execution/arm/simulator-arm.cc\",\n  \"imports\": [\n    \"src/execution/arm/simulator-arm.h\",\n    \"src/base/logging.h\",\n    \"<stdarg.h>\",\n    \"<stdlib.h>\",\n    \"<cmath>\",\n    \"src/base/bits.h\",\n    \"src/base/lazy-instance.h\",\n    \"src/base/memory.h\",\n    \"src/base/overflowing-math.h\",\n    \"src/base/platform/memory.h\",\n    \"src/base/platform/platform.h\",\n    \"src/base/vector.h\",\n    \"src/codegen/arm/constants-arm.h\",\n    \"src/codegen/assembler-inl.h\",\n    \"src/codegen/macro-assembler.h\",\n    \"src/diagnostics/disasm.h\",\n    \"src/heap/base/stack.h\",\n    \"src/heap/combined-heap.h\",\n    \"src/heap/heap-inl.h\",\n    \"src/objects/objects-inl.h\",\n    \"src/runtime/runtime-utils.h\",\n    \"src/utils/ostreams.h\",\n    \"src/utils/utils.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"ArmDebugger\",\n      \"properties\": [\n        \"sim_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ArmDebugger\",\n          \"parameters\": [\n            \"Simulator* sim\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for the ArmDebugger class, initializes the sim_ pointer.\"\n        },\n        {\n          \"name\": \"Debug\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Main debugging loop, disassembles instructions, takes debugger commands and executes them.\"\n        },\n        {\n          \"name\": \"ExecDebugCommand\",\n          \"parameters\": [\n            \"ArrayUniquePtr<char> line_ptr\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Parses and executes a debugger command entered by the user. Returns true if the debugger should exit.\"\n        },\n        {\n          \"name\": \"GetRegisterValue\",\n          \"parameters\": [\n            \"int regnum\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Gets the value of a specified ARM register from the simulator state.\"\n        },\n        {\n          \"name\": \"GetRegisterPairDoubleValue\",\n          \"parameters\": [\n            \"int regnum\"\n          ],\n          \"return_type\": \"double\",\n          \"logic\": \"Gets a double value from a pair of ARM registers.\"\n        },\n        {\n          \"name\": \"GetVFPDoubleRegisterValue\",\n          \"parameters\": [\n            \"int regnum\"\n          ],\n          \"return_type\": \"double\",\n          \"logic\": \"Gets a double value from a specified VFP double register from the simulator state.\"\n        },\n        {\n          \"name\": \"GetValue\",\n          \"parameters\": [\n            \"const char* desc\",\n            \"int32_t* value\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Parses a string description (register name or hex/decimal number) and stores the resulting integer value.\"\n        },\n        {\n          \"name\": \"GetVFPSingleValue\",\n          \"parameters\": [\n            \"const char* desc\",\n            \"float* value\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Parses a string description (VFP register name) and stores the resulting float value.\"\n        },\n        {\n          \"name\": \"GetVFPDoubleValue\",\n          \"parameters\": [\n            \"const char* desc\",\n            \"double* value\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Parses a string description (VFP register name) and stores the resulting double value.\"\n        },\n        {\n          \"name\": \"SetBreakpoint\",\n          \"parameters\": [\n            \"Instruction* breakpc\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Sets a breakpoint at the given instruction address. Returns false if breakpoint already exists.\"\n        },\n        {\n          \"name\": \"DeleteBreakpoint\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Deletes the currently set breakpoint.\"\n        },\n        {\n          \"name\": \"UndoBreakpoint\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Removes the breakpoint instruction from the code, restoring the original instruction.\"\n        },\n        {\n          \"name\": \"RedoBreakpoint\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Reinstalls the breakpoint instruction in the code.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Simulator\",\n      \"properties\": [\n        \"isolate_\",\n        \"stack_\",\n        \"pc_modified_\",\n        \"icount_\",\n        \"break_pc_\",\n        \"break_instr_\",\n        \"registers_\",\n        \"n_flag_\",\n        \"z_flag_\",\n        \"c_flag_\",\n        \"v_flag_\",\n        \"vfp_registers_\",\n        \"n_flag_FPSCR_\",\n        \"z_flag_FPSCR_\",\n        \"c_flag_FPSCR_\",\n        \"v_flag_FPSCR_\",\n        \"FPSCR_rounding_mode_\",\n        \"FPSCR_default_NaN_mode_\",\n        \"inv_op_vfp_flag_\",\n        \"div_zero_vfp_flag_\",\n        \"overflow_vfp_flag_\",\n        \"underflow_vfp_flag_\",\n        \"inexact_vfp_flag_\",\n        \"last_debugger_input_\",\n        \"global_monitor_\",\n        \"global_monitor_processor_\",\n        \"instruction_tracing_\",\n        \"watched_stops_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Simulator\",\n          \"parameters\": [\n            \"Isolate* isolate\"\n          ],\n          \"return_type\": null,\n          \"logic\": \"Constructor for the Simulator class. Initializes the simulator state, including registers, flags, and memory.\"\n        },\n        {\n          \"name\": \"~Simulator\",\n          \"parameters\": [],\n          \"return_type\": null,\n          \"logic\": \"Destructor for the Simulator class. Frees allocated memory.\"\n        },\n        {\n          \"name\": \"current\",\n          \"parameters\": [\n            \"Isolate* isolate\"\n          ],\n          \"return_type\": \"Simulator*\",\n          \"logic\": \"Returns the active Simulator for the current thread/Isolate. Creates a new simulator if none exists.\"\n        },\n        {\n          \"name\": \"set_register\",\n          \"parameters\": [\n            \"int reg\",\n            \"int32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the value of a specified ARM register in the simulator state. Updates PC if needed.\"\n        },\n        {\n          \"name\": \"get_register\",\n          \"parameters\": [\n            \"int reg\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Gets the value of a specified ARM register from the simulator state. Adjusts the PC value for instruction fetching.\"\n        },\n        {\n          \"name\": \"get_double_from_register_pair\",\n          \"parameters\": [\n            \"int reg\"\n          ],\n          \"return_type\": \"double\",\n          \"logic\": \"Gets a double value from a pair of consecutive ARM registers.\"\n        },\n        {\n          \"name\": \"set_register_pair_from_double\",\n          \"parameters\": [\n            \"int reg\",\n            \"double* value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a pair of consecutive ARM registers from a double value.\"\n        },\n        {\n          \"name\": \"set_dw_register\",\n          \"parameters\": [\n            \"int dreg\",\n            \"const int* dbl\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a pair of ARM registers(double word) with given integer array values\"\n        },\n        {\n          \"name\": \"get_d_register\",\n          \"parameters\": [\n            \"int dreg\",\n            \"uint64_t* value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Gets a double register value\"\n        },\n        {\n          \"name\": \"set_d_register\",\n          \"parameters\": [\n            \"int dreg\",\n            \"const uint64_t* value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a double register value\"\n        },\n        {\n          \"name\": \"get_d_register\",\n          \"parameters\": [\n            \"int dreg\",\n            \"uint32_t* value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Gets a double register value\"\n        },\n        {\n          \"name\": \"set_d_register\",\n          \"parameters\": [\n            \"int dreg\",\n            \"const uint32_t* value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a double register value\"\n        },\n        {\n          \"name\": \"get_neon_register\",\n          \"parameters\": [\n            \"int reg\",\n            \"T (&value)[SIZE / sizeof(T)]\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Gets a NEON register value.\"\n        },\n        {\n          \"name\": \"set_neon_register\",\n          \"parameters\": [\n            \"int reg\",\n            \"const T (&value)[SIZE / sizeof(T)]\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a NEON register value.\"\n        },\n        {\n          \"name\": \"set_pc\",\n          \"parameters\": [\n            \"int32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the program counter (PC) register. Updates internal state.\"\n        },\n        {\n          \"name\": \"has_bad_pc\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the PC register has an invalid or known bad value.\"\n        },\n        {\n          \"name\": \"get_pc\",\n          \"parameters\": [],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Gets the raw value of the program counter (PC) register without any adjustments.\"\n        },\n        {\n          \"name\": \"set_s_register\",\n          \"parameters\": [\n            \"int sreg\",\n            \"unsigned int value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a single-precision VFP register value.\"\n        },\n        {\n          \"name\": \"get_s_register\",\n          \"parameters\": [\n            \"int sreg\"\n          ],\n          \"return_type\": \"unsigned int\",\n          \"logic\": \"Gets a single-precision VFP register value.\"\n        },\n        {\n          \"name\": \"SetVFPRegister\",\n          \"parameters\": [\n            \"int reg_index\",\n            \"const InputType& value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a VFP register with given value\"\n        },\n        {\n          \"name\": \"GetFromVFPRegister\",\n          \"parameters\": [\n            \"int reg_index\"\n          ],\n          \"return_type\": \"ReturnType\",\n          \"logic\": \"Gets a value from VFP register\"\n        },\n        {\n          \"name\": \"SetSpecialRegister\",\n          \"parameters\": [\n            \"SRegisterFieldMask reg_and_mask\",\n            \"uint32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a special register (e.g., CPSR) based on the provided mask and value.\"\n        },\n        {\n          \"name\": \"GetFromSpecialRegister\",\n          \"parameters\": [\n            \"SRegister reg\"\n          ],\n          \"return_type\": \"uint32_t\",\n          \"logic\": \"Gets the value from a special register (e.g., CPSR).\"\n        },\n        {\n          \"name\": \"GetFpArgs\",\n          \"parameters\": [\n            \"double* x\",\n            \"double* y\",\n            \"int32_t* z\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Retrieves floating-point arguments from registers (r0-r3 or d0, d1 and r0) for runtime calls.\"\n        },\n        {\n          \"name\": \"SetFpResult\",\n          \"parameters\": [\n            \"const double& result\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the floating-point result into registers (r0/r1 or d0) after runtime calls.\"\n        },\n        {\n          \"name\": \"TrashCallerSaveRegisters\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Overwrites the caller-saved registers with garbage values to detect incorrect usage of registers across runtime calls.\"\n        },\n        {\n          \"name\": \"ReadW\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Reads a word (32-bit) from simulated memory at the given address.\"\n        },\n        {\n          \"name\": \"ReadExW\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Read word exclusive. Reads a word from memory and marks it for exclusive access.\"\n        },\n        {\n          \"name\": \"WriteW\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"int value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes a word (32-bit) to simulated memory at the given address.\"\n        },\n        {\n          \"name\": \"WriteExW\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"int value\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Write word exclusive. Writes a word to memory, succeeding only if the address is marked for exclusive access.\"\n        },\n        {\n          \"name\": \"ReadHU\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"uint16_t\",\n          \"logic\": \"Reads an unsigned halfword (16-bit) from simulated memory at the given address.\"\n        },\n        {\n          \"name\": \"ReadH\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"int16_t\",\n          \"logic\": \"Reads a signed halfword (16-bit) from simulated memory at the given address.\"\n        },\n                {\n          \"name\": \"ReadExHU\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"uint16_t\",\n          \"logic\": \"Reads an unsigned halfword exclusively\"\n        },\n        {\n          \"name\": \"WriteH\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"uint16_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes an unsigned halfword to memory.\"\n        },\n        {\n          \"name\": \"WriteH\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"int16_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes a signed halfword to memory.\"\n        },\n        {\n          \"name\": \"WriteExH\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"uint16_t value\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Write halfword exclusive\"\n        },\n        {\n          \"name\": \"ReadBU\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"uint8_t\",\n          \"logic\": \"Reads an unsigned byte from simulated memory at the given address.\"\n        },\n        {\n          \"name\": \"ReadB\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"int8_t\",\n          \"logic\": \"Reads a signed byte from simulated memory at the given address.\"\n        },\n                {\n          \"name\": \"ReadExBU\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"uint8_t\",\n          \"logic\": \"Reads an unsigned byte exclusively.\"\n        },\n        {\n          \"name\": \"WriteB\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"uint8_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes an unsigned byte to simulated memory at the given address.\"\n        },\n        {\n          \"name\": \"WriteB\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"int8_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes a signed byte to simulated memory at the given address.\"\n        },\n                {\n          \"name\": \"WriteExB\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"uint8_t value\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Write a byte exclusive.\"\n        },\n        {\n          \"name\": \"ReadDW\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"int32_t*\",\n          \"logic\": \"Reads a double word (two 32-bit words) from simulated memory at the given address. Returns a pointer to the memory location.\"\n        },\n        {\n          \"name\": \"ReadExDW\",\n          \"parameters\": [\n            \"int32_t addr\"\n          ],\n          \"return_type\": \"int32_t*\",\n          \"logic\": \"Read double word exclusively.\"\n        },\n        {\n          \"name\": \"WriteDW\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"int32_t value1\",\n            \"int32_t value2\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes a double word (two 32-bit words) to simulated memory at the given address.\"\n        },\n        {\n          \"name\": \"WriteExDW\",\n          \"parameters\": [\n            \"int32_t addr\",\n            \"int32_t value1\",\n            \"int32_t value2\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Write double word exclusively\"\n        },\n        {\n          \"name\": \"StackLimit\",\n          \"parameters\": [\n            \"uintptr_t c_limit\"\n          ],\n          \"return_type\": \"uintptr_t\",\n          \"logic\": \"Returns the stack limit based on the current stack pointer and the C stack limit.\"\n        },\n        {\n          \"name\": \"StackBase\",\n          \"parameters\": [],\n          \"return_type\": \"uintptr_t\",\n          \"logic\": \"Returns the base address of the simulated stack.\"\n        },\n        {\n          \"name\": \"GetCentralStackView\",\n          \"parameters\": [],\n          \"return_type\": \"base::Vector<uint8_t>\",\n          \"logic\": \"Returns a view of the central stack memory.\"\n        },\n        {\n          \"name\": \"IterateRegistersAndStack\",\n          \"parameters\": [\n            \"::heap::base::StackVisitor* visitor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates through the registers and stack, calling the visitor function for each pointer found.\"\n        },\n        {\n          \"name\": \"Format\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"const char* format\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Handles unsupported instructions by printing an error message and halting execution.\"\n        },\n        {\n          \"name\": \"ConditionallyExecute\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines whether to execute an instruction based on its condition code and the current flag values.\"\n        },\n        {\n          \"name\": \"SetNZFlags\",\n          \"parameters\": [\n            \"int32_t val\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the Negative and Zero flags based on the given value.\"\n        },\n        {\n          \"name\": \"SetCFlag\",\n          \"parameters\": [\n            \"bool val\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the Carry flag.\"\n        },\n        {\n          \"name\": \"SetVFlag\",\n          \"parameters\": [\n            \"bool val\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the Overflow flag.\"\n        },\n        {\n          \"name\": \"CarryFrom\",\n          \"parameters\": [\n            \"int32_t left\",\n            \"int32_t right\",\n            \"int32_t carry\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Calculates the Carry flag value for additions.\"\n        },\n        {\n          \"name\": \"BorrowFrom\",\n          \"parameters\": [\n            \"int32_t left\",\n            \"int32_t right\",\n            \"int32_t carry\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Calculates the Carry/Borrow flag value for subtractions.\"\n        },\n        {\n          \"name\": \"OverflowFrom\",\n          \"parameters\": [\n            \"int32_t alu_out\",\n            \"int32_t left\",\n            \"int32_t right\",\n            \"bool addition\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Calculates the Overflow flag value for additions and subtractions.\"\n        },\n        {\n          \"name\": \"Compute_FPSCR_Flags\",\n          \"parameters\": [\n            \"float val1\",\n            \"float val2\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Computes the FPSCR flags based on the result of a floating-point comparison.\"\n        },\n        {\n          \"name\": \"Compute_FPSCR_Flags\",\n          \"parameters\": [\n            \"double val1\",\n            \"double val2\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Computes the FPSCR flags based on the result of a floating-point comparison.\"\n        },\n        {\n          \"name\": \"Copy_FPSCR_to_APSR\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Copies the FPSCR flags (N, Z, C, V) to the APSR flags.\"\n        },\n        {\n          \"name\": \"GetShiftRm\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"bool* carry_out\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Gets the value of a register operand after applying a shift operation.\"\n        },\n        {\n          \"name\": \"GetImm\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"bool* carry_out\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Gets the immediate value after applying a rotation operation.\"\n        },\n        {\n          \"name\": \"ProcessPU\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"int num_regs\",\n            \"int reg_size\",\n            \"intptr_t* start_address\",\n            \"intptr_t* end_address\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Processes the pre/post increment and update mode for load/store multiple instructions.\"\n        },\n        {\n          \"name\": \"HandleRList\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"bool load\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Handles Load and Store Multiple instructions for integer registers.\"\n        },\n        {\n          \"name\": \"HandleVList\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Handles Load and Store Multiple instructions for VFP registers.\"\n        },\n        {\n          \"name\": \"SoftwareInterrupt\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Handles software interrupt instructions, which are used to call into the V8 runtime.\"\n        },\n        {\n          \"name\": \"canonicalizeNaN\",\n          \"parameters\": [\n            \"float value\"\n          ],\n          \"return_type\": \"float\",\n          \"logic\": \"Canonicalizes a NaN value according to the ARM specification if the default NaN mode is enabled.\"\n        },\n        {\n          \"name\": \"canonicalizeNaN\",\n          \"parameters\": [\n            \"Float32 value\"\n          ],\n          \"return_type\": \"Float32\",\n          \"logic\": \"Canonicalizes a NaN value according to the ARM specification if the default NaN mode is enabled.\"\n        },\n        {\n          \"name\": \"canonicalizeNaN\",\n          \"parameters\": [\n            \"double value\"\n          ],\n          \"return_type\": \"double\",\n          \"logic\": \"Canonicalizes a NaN value according to the ARM specification if the default NaN mode is enabled.\"\n        },\n        {\n          \"name\": \"canonicalizeNaN\",\n          \"parameters\": [\n            \"Float64 value\"\n          ],\n          \"return_type\": \"Float64\",\n          \"logic\": \"Canonicalizes a NaN value according to the ARM specification if the default NaN mode is enabled.\"\n        },\n        {\n          \"name\": \"isWatchedStop\",\n          \"parameters\": [\n            \"uint32_t code\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the given stop code is watched.\"\n        },\n        {\n          \"name\": \"isEnabledStop\",\n          \"parameters\": [\n            \"uint32_t code\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the given stop code is enabled.\"\n        },\n        {\n          \"name\": \"EnableStop\",\n          \"parameters\": [\n            \"uint32_t code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Enables the specified stop code.\"\n        },\n        {\n          \"name\": \"DisableStop\",\n          \"parameters\": [\n            \"uint32_t code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Disables the specified stop code.\"\n        },\n        {\n          \"name\": \"IncreaseStopCounter\",\n          \"parameters\": [\n            \"uint32_t code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Increases the counter for the specified stop code.\"\n        },\n        {\n          \"name\": \"PrintStopInfo\",\n          \"parameters\": [\n            \"uint32_t code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints information about the specified stop code.\"\n        },\n        {\n          \"name\": \"DecodeType01\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Decodes instructions of type 0 and 1.\"\n        },\n        {\n          \"name\": \"DecodeType2\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Decodes instructions of type 2.\"\n        },\n        {\n          \"name\": \"DecodeType3\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Decodes instructions of type 3.\"\n        },\n        {\n            \"name\": \"DebugAtNextPC\",\n            \"parameters\": [],\n            \"return_type\": \"void\",\n            \"logic\": \"Sets up the debugger to start debugging at the next program counter.\"\n        },\n                {\n            \"name\": \"AdvancedSIMDElementOrStructureLoadStoreWriteback\",\n            \"parameters\": [\n                \"int Rn\",\n                \"int Rm\",\n                \"int ebytes\"\n            ],\n            \"return_type\": \"void\",\n            \"logic\": \"Implements writeback functionality for Advanced SIMD load/store operations, incrementing the base register by either ebytes or the value in register Rm.\"\n        },\n        {\n            \"name\": \"SetRedirectInstruction\",\n            \"parameters\": [\n                \"Instruction* instruction\"\n            ],\n            \"return_type\": \"void\",\n            \"logic\": \"Sets an instruction to be a redirection instruction, typically used for calling runtime functions.\"\n        },\n        {\n            \"name\": \"FlushICache\",\n            \"parameters\": [\n                \"base::CustomMatcherHashMap* i_cache\",\n                \"void* start_addr\",\n                \"size_t size\"\n            ],\n            \"return_type\": \"void\",\n            \"logic\": \"Flushes the instruction cache for a given address range to ensure that the simulator executes the latest code.\"\n        },\n        {\n            \"name\": \"ICacheMatch\",\n            \"parameters\": [\n                \"void* one\",\n                \"void* two\"\n            ],\n            \"return_type\": \"bool\",\n            \"logic\": \"Determines whether cache pages are identical.\"\n        },\n        {\n            \"name\": \"ToggleInstructionTracing\",\n            \"parameters\": [],\n            \"return_type\": \"void\",\n            \"logic\": \"Toggles instruction tracing.\"\n        },\n        {\n            \"name\": \"InstructionTracingEnabled\",\n            \"parameters\": [],\n            \"return_type\": \"bool\",\n            \"logic\": \"Checks if instruction tracing is enabled.\"\n        },\n        {\n            \"name\": \"FlushOnePage\",\n            \"parameters\": [\n                \"base::CustomMatcherHashMap* i_cache\",\n                \"intptr_t start\",\n                \"int size\"\n            ],\n            \"return_type\": \"void\",\n            \"logic\": \"Flushes a single page in the instruction cache.\"\n        },\n        {\n            \"name\": \"GetCachePage\",\n            \"parameters\": [\n                \"base::CustomMatcherHashMap* i_cache\",\n                \"void* page\"\n            ],\n            \"return_type\": \"CachePage*\",\n            \"logic\": \"Gets the CachePage from the I-cache hash map.\"\n        },\n        {\n            \"name\": \"CheckICache\",\n            \"parameters\": [\n                \"base::CustomMatcherHashMap* i_cache\",\n                \"Instruction* instr\"\n            ],\n            \"return_type\": \"void\",\n            \"logic\": \"Checks whether the instruction cache is valid for a given instruction and loads the instruction into the cache if not.\"\n        },\n        {\n            \"name\": \"InstructionDecode\",\n            \"parameters\": [\n                \"Instruction* instr\"\n            ],\n            \"return_type\": \"void\",\n            \"logic\": \"Decodes an instruction and performs the corresponding operation in the simulator.\"\n        }\n      ]\n    }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"SetInstructionBitsInCodeSpace\",\n      \"parameters\": [\n        \"Instruction* instr\",\n        \"Instr value\",\n        \"Heap* heap\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Sets the instruction bits in the code space, allowing modification of code at runtime (used for breakpoints). This is only available in simulator builds.\"\n    },\n    {\n      \"name\": \"ICacheHash\",\n      \"parameters\": [\n        \"void* key\"\n      ],\n      \"return_type\": \"uint32_t\",\n      \"logic\": \"Hashes the address of cache entry.\"\n    },\n    {\n      \"name\": \"AllOnOnePage\",\n      \"parameters\": [\n        \"uintptr_t start\",\n        \"int size\"\n      ],\n      \"return_type\": \"static bool\",\n      \"logic\": \"Determines if a memory region lies within a single cache page.\"\n    },\n    {\n      \"name\": \"count_bits\",\n      \"parameters\": [\n        \"int bit_vector\"\n      ],\n      \"return_type\": \"int\",\n      \"logic\": \"Counts number of bits.\"\n    },\n    {\n        \"name\": \"UnsafeGenericFunctionCall\",\n        \"parameters\": [\n            \"intptr_t function\",\n            \"int32_t arg0\",\n            \"int32_t arg1\",\n            \"int32_t arg2\",\n            \"int32_t arg3\",\n            \"int32_t arg4\",\n            \"int32_t arg5\",\n            \"int32_t arg6\",\n            \"int32_t arg7\",\n            \"int32_t arg8\",\n            \"int32_t arg9\",\n            \"int32_t arg10\",\n            \"int32_t arg11\",\n            \"int32_t arg12\",\n            \"int32_t arg13\",\n            \"int32_t arg14\",\n            \"int32_t arg15\",\n            \"int32_t arg16\",\n            \"int32_t arg17\",\n            \"int32_t arg18\",\n            \"int32_t arg19\"\n        ],\n        \"return_type\": \"int64_t\",\n        \"logic\": \"Calls a C++ function with a variable number of"
}