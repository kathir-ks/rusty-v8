// Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Definition and semantics of the EXPERIMENTAL bytecode.
// Background:
// - Russ Cox's blog post series on regular expression matching, in particular
//   https://swtch.com/~rsc/regexp/regexp2.html
// - The re2 regular regexp library: https://github.com/google/re2
//
// This comment describes the bytecode used by the experimental regexp engine
// and its abstract semantics in terms of a VM.  An implementation of the
// semantics that avoids exponential runtime can be found in `NfaInterpreter`.
//
// The experimental bytecode describes a non-deterministic finite automaton. It
// runs on a multithreaded virtual machine (VM), i.e. in several threads
// concurrently.  (These "threads" don't need to be actual operating system
// threads.)  Apart from a list of threads, the VM maintains an immutable
// shared input string which threads can read from.  Each thread is given by a
// program counter (PC, index of the current instruction), a fixed number of
// registers of indices into the input string, and a monotonically increasing
// index which represents the current position within the input string.
//
// For the precise encoding of the instruction set, see the definition `struct
// RegExpInstruction` below.  Currently we support the following instructions:
// - CONSUME_RANGE: Check whether the codepoint of the current character is
//   contained in a non-empty closed interval [min, max] specified in the
//   instruction payload.  If false, advance to the next CONSUME_RANGE in the
//   current list, or abort this thread if this was the last range.  If true,
//   advance to the next instruction after the current list of ranges.
// - RANGE_COUNT: Check that the current character can be accepted by any of the
//   next n CONSUME_RANGE instructions, where n is specified in the instruction
//   payload.  Abort this thread if none of these ranges match.  Otherwise,
//   advance the input position by 1 and continue with the next instruction
//   after the n ranges.
// - ACCEPT: Stop this thread and signify the end of a match at the current
//   input position.
// - FORK: If executed by a thread t, spawn a new thread t0 whose register
//   values and input position agree with those of t, but whose PC value is set
//   to the value specified in the instruction payload.  The register values of
//   t and t0 agree directly after the FORK, but they can diverge.  Thread t
//   continues with the instruction directly after the current FORK
//   instruction.
// - JMP: Instead of incrementing the PC value after execution of this
//   instruction by 1, set PC of this thread to the value specified in the
//   instruction payload and continue there.
// - SET_REGISTER_TO_CP: Set a register specified in the payload to the current
//   position (CP) within the input, then continue with the next instruction.
// - CLEAR_REGISTER: Clear the register specified in the payload by resetting
//   it to the initial value -1.
//
// Special care must be exercised with respect to thread priority.  It is
// possible that more than one thread executes an ACCEPT statement.  The output
// of the program is given by the contents of the matching thread's registers,
// so this is ambiguous in case of multiple matches.  To resolve the ambiguity,
// every implementation of the VM  must output the match that a backtracking
// implementation would output (i.e. behave the same as Irregexp).
//
// A backtracking implementation of the VM maintains a stack of postponed
// threads.  Upon encountering a FORK statement, this VM will create a copy of
// the current thread, set the copy's PC value according to the instruction
// payload, and push it to the stack of postponed threads.  The VM will then
// continue execution of the current thread.
//
// If at some point a thread t executes a MATCH statement, the VM stops and
// outputs the registers of t.  Postponed threads are discarded.  On the other
// hand, if a thread t is aborted because some input character didn't pass a
// check, then the VM pops the topmost postponed thread and continues execution
// with this thread.  If there are no postponed threads, then the VM outputs
// failure, i.e. no matches.
//
// Equivalently, we can describe the behavior of the backtracking VM in terms
// of priority: Threads are linearly ordered by priority, and matches generated
// by threads with high priority must be preferred over matches generated by
// threads with low priority, regardless of the chronological order in which
// matches were found.  If a thread t executes a FORK statement and spawns a
// thread t0, then the priority of t0 is such that the following holds:
// * t0 < t, i.e. t0 has lower priority than t.
// * For all threads u such that u != t and u != t0, we have t0 < u iff t < u,
//   i.e. the t0 compares to other threads the same as t.
// For example, if there are currently 3 threads s, t, u such that s < t < u,
// then after t executes a fork, the thread priorities will be s < t0 < t < u.

pub mod regexp {
    pub mod experimental {
        use std::fmt;
        use std::fmt::{Display, Formatter};

        pub mod experimental_bytecode {
            use super::*;

            // Bytecode format.
            // Currently very simple fixed-size: The opcode is encoded in the first 4
            // bytes, the payload takes another 4 bytes.
            #[derive(Debug, Clone, Copy)]
            #[repr(C)]
            pub struct RegExpInstruction {
                pub opcode: Opcode,
                pub payload: Payload,
            }

            #[derive(Debug, Clone, Copy)]
            pub enum Opcode {
                ACCEPT,
                ASSERTION,
                CLEAR_REGISTER,
                CONSUME_RANGE,
                RANGE_COUNT,
                FORK,
                JMP,
                SET_REGISTER_TO_CP,
                SET_QUANTIFIER_TO_CLOCK,
                FILTER_QUANTIFIER,
                FILTER_GROUP,
                FILTER_LOOKAROUND,
                FILTER_CHILD,
                BEGIN_LOOP,
                END_LOOP,
                START_LOOKAROUND,
                END_LOOKAROUND,
                WRITE_LOOKAROUND_TABLE,
                READ_LOOKAROUND_TABLE,
            }

            #[derive(Debug, Copy, Clone)]
            #[repr(C)]
            pub struct Uc16Range {
                pub min: u16, // Inclusive.
                pub max: u16, // Inclusive.
            }

            #[derive(Debug, Copy, Clone)]
            #[repr(C)]
            pub struct LookaroundPayload {
                payload_: u32,
            }

            impl LookaroundPayload {
                pub fn new() -> Self {
                    LookaroundPayload { payload_: 0 }
                }

                pub fn new_with_params(
                    lookaround_index: u32,
                    is_positive: bool,
                    type_: RegExpLookaroundType,
                ) -> Self {
                    let mut payload: u32 = LookaroundIndex::encode(lookaround_index);
                    payload = IsPositive::update(payload, is_positive);
                    payload = Type::update(payload, type_ as u32);

                    LookaroundPayload { payload_: payload }
                }

                pub fn index(&self) -> u32 {
                    LookaroundIndex::decode(self.payload_)
                }
                pub fn is_positive(&self) -> bool {
                    IsPositive::decode(self.payload_)
                }
                pub fn type_(&self) -> RegExpLookaroundType {
                    match Type::decode(self.payload_) {
                        0 => RegExpLookaroundType::Positive,
                        1 => RegExpLookaroundType::Negative,
                        _ => panic!("Invalid RegExpLookaroundType"),
                    }
                }
            }

            #[derive(Debug, Copy, Clone)]
            struct IsPositive;
            impl IsPositive {
                const OFFSET: u32 = 0;
                const MASK: u32 = 1 << Self::OFFSET;

                fn update(value: u32, bit: bool) -> u32 {
                    if bit {
                        value | Self::MASK
                    } else {
                        value & !Self::MASK
                    }
                }
                fn decode(value: u32) -> bool {
                    (value & Self::MASK) != 0
                }
            }

            #[derive(Debug, Copy, Clone)]
            struct Type;
            impl Type {
                const OFFSET: u32 = IsPositive::OFFSET + 1;
                const MASK: u32 = 1 << Self::OFFSET;

                fn update(value: u32, type_: u32) -> u32 {
                    (value & !Self::MASK) | ((type_ << Self::OFFSET) & Self::MASK)
                }
                fn decode(value: u32) -> u32 {
                    (value >> Self::OFFSET) & 1
                }
            }

            #[derive(Debug, Copy, Clone)]
            struct LookaroundIndex;
            impl LookaroundIndex {
                const OFFSET: u32 = Type::OFFSET + 1;
                const MASK: u32 = (1 << 30) - 1 << Self::OFFSET;

                fn encode(index: u32) -> u32 {
                    index << Self::OFFSET
                }
                fn decode(value: u32) -> u32 {
                    (value >> Self::OFFSET) & ((1 << 30) - 1)
                }
            }

            #[derive(Debug, Clone, Copy)]
            #[repr(C)]
            pub union Payload {
                pub consume_range: Uc16Range,
                pub num_ranges: i32,
                pub pc: i32,
                pub register_index: i32,
                pub assertion_type: RegExpAssertionType,
                pub quantifier_id: i32,
                pub group_id: i32,
                pub lookaround_id: i32,
                pub lookaround: LookaroundPayload,
            }

            impl Default for Payload {
                fn default() -> Self {
                    Payload { pc: 0 } // Initialize with a default value
                }
            }

            impl RegExpInstruction {
                pub fn consume_range(min: u16, max: u16) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::CONSUME_RANGE,
                        payload: Payload {
                            consume_range: Uc16Range { min, max },
                        },
                    }
                }

                pub fn consume_any_char() -> Self {
                    RegExpInstruction::consume_range(0x0000, 0xFFFF)
                }

                pub fn fail() -> Self {
                    RegExpInstruction::consume_range(0xFFFF, 0x0000)
                }

                pub fn range_count(num_ranges: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::RANGE_COUNT,
                        payload: Payload { num_ranges },
                    }
                }

                pub fn fork(alt_index: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::FORK,
                        payload: Payload { pc: alt_index },
                    }
                }

                pub fn jmp(alt_index: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::JMP,
                        payload: Payload { pc: alt_index },
                    }
                }

                pub fn accept() -> Self {
                    RegExpInstruction {
                        opcode: Opcode::ACCEPT,
                        payload: Payload::default(),
                    }
                }

                pub fn set_register_to_cp(register_index: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::SET_REGISTER_TO_CP,
                        payload: Payload { register_index },
                    }
                }

                pub fn assertion(t: RegExpAssertionType) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::ASSERTION,
                        payload: Payload { assertion_type: t },
                    }
                }

                pub fn clear_register(register_index: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::CLEAR_REGISTER,
                        payload: Payload { register_index },
                    }
                }

                pub fn set_quantifier_to_clock(quantifier_id: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::SET_QUANTIFIER_TO_CLOCK,
                        payload: Payload { quantifier_id },
                    }
                }

                pub fn filter_quantifier(quantifier_id: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::FILTER_QUANTIFIER,
                        payload: Payload { quantifier_id },
                    }
                }

                pub fn filter_group(group_id: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::FILTER_GROUP,
                        payload: Payload { group_id },
                    }
                }

                pub fn filter_lookaround(lookaround_id: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::FILTER_LOOKAROUND,
                        payload: Payload { lookaround_id },
                    }
                }

                pub fn filter_child(pc: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::FILTER_CHILD,
                        payload: Payload { pc },
                    }
                }

                pub fn begin_loop() -> Self {
                    RegExpInstruction {
                        opcode: Opcode::BEGIN_LOOP,
                        payload: Payload::default(),
                    }
                }

                pub fn end_loop() -> Self {
                    RegExpInstruction {
                        opcode: Opcode::END_LOOP,
                        payload: Payload::default(),
                    }
                }

                pub fn start_lookaround(
                    lookaround_index: i32,
                    is_positive: bool,
                    type_: RegExpLookaroundType,
                ) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::START_LOOKAROUND,
                        payload: Payload {
                            lookaround: LookaroundPayload::new_with_params(
                                lookaround_index as u32,
                                is_positive,
                                type_,
                            ),
                        },
                    }
                }

                pub fn end_lookaround() -> Self {
                    RegExpInstruction {
                        opcode: Opcode::END_LOOKAROUND,
                        payload: Payload::default(),
                    }
                }

                pub fn write_look_table(index: i32) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::WRITE_LOOKAROUND_TABLE,
                        payload: Payload { lookaround_id: index },
                    }
                }

                pub fn read_look_table(
                    index: i32,
                    is_positive: bool,
                    type_: RegExpLookaroundType,
                ) -> Self {
                    RegExpInstruction {
                        opcode: Opcode::READ_LOOKAROUND_TABLE,
                        payload: Payload {
                            lookaround: LookaroundPayload::new_with_params(
                                index as u32,
                                is_positive,
                                type_,
                            ),
                        },
                    }
                }

                // Returns whether an instruction is `FILTER_GROUP`, `FILTER_QUANTIFIER` or
                // `FILTER_CHILD`.
                pub fn is_filter(instruction: &RegExpInstruction) -> bool {
                    matches!(
                        instruction.opcode,
                        Opcode::FILTER_GROUP | Opcode::FILTER_QUANTIFIER | Opcode::FILTER_CHILD
                    )
                }
            }
            impl Display for RegExpInstruction {
                fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
                    write!(f, "{:?}", self)
                }
            }
        }
    }
}

pub mod regexp_ast {
    #[derive(Debug, Copy, Clone)]
    #[repr(C)]
    pub enum RegExpAssertionType {
        BeginningOfLine,
        EndOfLine,
        BeginningOfText,
        EndOfText,
        WordBoundary,
        NotWordBoundary,
    }

    #[derive(Debug, Copy, Clone)]
    #[repr(C)]
    pub enum RegExpLookaroundType {
        Positive,
        Negative,
    }
}

use regexp_ast::*;
// use std::fmt;
// use std::fmt::{Display, Formatter};
use regexp::experimental::experimental_bytecode::*;

// Implement the missing std::ostream& operator<<(std::ostream& os, const RegExpInstruction& inst)
// and similar functions here.  Since Rust does not have operator overloading
// in the same way as C++, we will use the Display trait to achieve similar functionality.
//
// Implement the missing std::ostream& operator<<(std::ostream& os, base::Vector<const RegExpInstruction> insts)
//
// The base::Vector type from C++ is similar to Vec in Rust.  Since Rust does not have operator overloading
// in the same way as C++, we will use a custom function to achieve similar functionality.
impl Display for Uc16Range {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "Uc16Range {{ min: {}, max: {} }}", self.min, self.max)
    }
}
impl Display for Payload {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
        // Safely access the union members based on the context.
        // Since it's a union, only one field is valid at a time.
        unsafe {
            match self {
                Payload { consume_range } => write!(f, "{}", consume_range),
                Payload { num_ranges } => write!(f, "num_ranges: {}", num_ranges),
                Payload { pc } => write!(f, "pc: {}", pc),
                Payload { register_index } => write!(f, "register_index: {}", register_index),
                Payload { assertion_type } => write!(f, "assertion_type: {:?}", assertion_type),
                Payload { quantifier_id } => write!(f, "quantifier_id: {}", quantifier_id),
                Payload { group_id } => write!(f, "group_id: {}", group_id),
                Payload { lookaround_id } => write!(f, "lookaround_id: {}", lookaround_id),
                Payload { lookaround } => write!(f, "{}", lookaround),
            }
        }
    }
}

impl Display for LookaroundPayload {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
        write!(
            f,
            "LookaroundPayload {{ index: {}, is_positive: {}, type: {:?} }}",
            self.index(),
            self.is_positive(),
            self.type_()
        )
    }
}

pub fn display_instructions(instructions: &Vec<RegExpInstruction>) -> String {
    let mut result = String::new();
    for instruction in instructions {
        result.push_str(&format!("{}\n", instruction));
    }
    result
}