// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is automatically generated by gen-keywords-gen-h.py and should not
// be modified manually.

pub mod keywords_gen {
    use crate::parsing::token::Token;

    // TODO: Implement the functionality of base::IsInRange
    // For now, we'll use a simple range check
    fn is_in_range<T: PartialOrd>(value: T, min: T, max: T) -> bool {
        value >= min && value <= max
    }
    // TODO: Implement the functionality of base::IsInRange

    const TOTAL_KEYWORDS: usize = 52;
    const MIN_WORD_LENGTH: usize = 2;
    const MAX_WORD_LENGTH: usize = 10;
    const MIN_HASH_VALUE: usize = 3;
    const MAX_HASH_VALUE: usize = 64;

    struct PerfectKeywordHashTableEntry {
        name: &'static str,
        value: Token,
    }

    struct PerfectKeywordHash;

    impl PerfectKeywordHash {
        #[inline]
        fn hash(str_: &str, len: usize) -> u32 {
            debug_assert!(str_.as_bytes()[1] as u32 + 1 < 129);
            debug_assert!(str_.as_bytes()[0] as u32 < 129);

            const ASSO_VALUES: [u8; 129] = [
                65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
                65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
                65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
                65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
                65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
                65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 33, 0, 24, 18, 17,
                0, 31, 65, 15, 33, 65, 0, 25, 24, 14, 1, 65, 0, 10, 3, 36, 4,
                23, 26, 13, 1, 65, 65, 65, 65, 65, 65,
            ];

            len as u32 + ASSO_VALUES[str_.as_bytes()[1] as usize + 1] as u32 + ASSO_VALUES[str_.as_bytes()[0] as usize] as u32
        }

        #[inline]
        pub fn get_token(str_: &str) -> Token {
            let len = str_.len();
            if is_in_range(len, MIN_WORD_LENGTH, MAX_WORD_LENGTH) {
                let key = Self::hash(str_, len) & 0x7f;

                const KEYWORD_LENGTH_TABLE: [u8; 128] = [
                    0, 0, 0, 3, 3, 5, 6, 3, 7, 4, 6, 6, 8, 3, 0, 5, 3, 4, 7, 5, 9, 2,
                    4, 5, 6, 7, 8, 3, 4, 5, 5, 2, 4, 8, 3, 4, 6, 7, 9, 10, 7, 5, 6, 5,
                    5, 6, 4, 2, 2, 10, 0, 5, 6, 0, 5, 0, 0, 0, 0, 8, 4, 0, 0, 0, 5, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                ];

                const KEYWORD_HASH_TABLE: [PerfectKeywordHashTableEntry; 128] = [
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "let", value: Token::Let },
                    PerfectKeywordHashTableEntry { name: "for", value: Token::For },
                    PerfectKeywordHashTableEntry { name: "false", value: Token::FalseLiteral },
                    PerfectKeywordHashTableEntry { name: "return", value: Token::Return },
                    PerfectKeywordHashTableEntry { name: "var", value: Token::Var },
                    PerfectKeywordHashTableEntry { name: "package", value: Token::FutureStrictReservedWord },
                    PerfectKeywordHashTableEntry { name: "void", value: Token::Void },
                    PerfectKeywordHashTableEntry { name: "typeof", value: Token::TypeOf },
                    PerfectKeywordHashTableEntry { name: "public", value: Token::FutureStrictReservedWord },
                    PerfectKeywordHashTableEntry { name: "function", value: Token::Function },
                    PerfectKeywordHashTableEntry { name: "set", value: Token::Set },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "break", value: Token::Break },
                    PerfectKeywordHashTableEntry { name: "try", value: Token::Try },
                    PerfectKeywordHashTableEntry { name: "true", value: Token::TrueLiteral },
                    PerfectKeywordHashTableEntry { name: "private", value: Token::FutureStrictReservedWord },
                    PerfectKeywordHashTableEntry { name: "super", value: Token::Super },
                    PerfectKeywordHashTableEntry { name: "protected", value: Token::FutureStrictReservedWord },
                    PerfectKeywordHashTableEntry { name: "do", value: Token::Do },
                    PerfectKeywordHashTableEntry { name: "this", value: Token::This },
                    PerfectKeywordHashTableEntry { name: "throw", value: Token::Throw },
                    PerfectKeywordHashTableEntry { name: "delete", value: Token::Delete },
                    PerfectKeywordHashTableEntry { name: "default", value: Token::Default },
                    PerfectKeywordHashTableEntry { name: "debugger", value: Token::Debugger },
                    PerfectKeywordHashTableEntry { name: "new", value: Token::New },
                    PerfectKeywordHashTableEntry { name: "case", value: Token::Case },
                    PerfectKeywordHashTableEntry { name: "catch", value: Token::Catch },
                    PerfectKeywordHashTableEntry { name: "const", value: Token::Const },
                    PerfectKeywordHashTableEntry { name: "in", value: Token::In },
                    PerfectKeywordHashTableEntry { name: "null", value: Token::NullLiteral },
                    PerfectKeywordHashTableEntry { name: "continue", value: Token::Continue },
                    PerfectKeywordHashTableEntry { name: "get", value: Token::Get },
                    PerfectKeywordHashTableEntry { name: "enum", value: Token::Enum },
                    PerfectKeywordHashTableEntry { name: "export", value: Token::Export },
                    PerfectKeywordHashTableEntry { name: "extends", value: Token::Extends },
                    PerfectKeywordHashTableEntry { name: "interface", value: Token::FutureStrictReservedWord },
                    PerfectKeywordHashTableEntry { name: "instanceof", value: Token::InstanceOf },
                    PerfectKeywordHashTableEntry { name: "finally", value: Token::Finally },
                    PerfectKeywordHashTableEntry { name: "async", value: Token::Async },
                    PerfectKeywordHashTableEntry { name: "switch", value: Token::Switch },
                    PerfectKeywordHashTableEntry { name: "while", value: Token::While },
                    PerfectKeywordHashTableEntry { name: "using", value: Token::Using },
                    PerfectKeywordHashTableEntry { name: "import", value: Token::Import },
                    PerfectKeywordHashTableEntry { name: "else", value: Token::Else },
                    PerfectKeywordHashTableEntry { name: "of", value: Token::Of },
                    PerfectKeywordHashTableEntry { name: "if", value: Token::If },
                    PerfectKeywordHashTableEntry { name: "implements", value: Token::FutureStrictReservedWord },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "yield", value: Token::Yield },
                    PerfectKeywordHashTableEntry { name: "static", value: Token::Static },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "class", value: Token::Class },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "accessor", value: Token::Accessor },
                    PerfectKeywordHashTableEntry { name: "with", value: Token::With },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "await", value: Token::Await },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                    PerfectKeywordHashTableEntry { name: "", value: Token::Identifier },
                ];

                debug_assert!(key < KEYWORD_LENGTH_TABLE.len() as u32);
                debug_assert!(key < KEYWORD_HASH_TABLE.len() as u32);

                if len == KEYWORD_LENGTH_TABLE[key as usize] as usize {
                    let s = KEYWORD_HASH_TABLE[key as usize].name;
                    let mut s_chars = s.chars();
                    let mut str_chars = str_.chars();
                    loop {
                        match (s_chars.next(), str_chars.next()) {
                            (Some(s_char), Some(str_char)) => {
                                if s_char != str_char {
                                    return Token::Identifier;
                                }
                            }
                            (None, _) => {
                                return KEYWORD_HASH_TABLE[key as usize].value;
                            }
                            (Some(_), None) => return Token::Identifier,
                        }
                    }
                }
            }
            Token::Identifier
        }
    }
}
